{
  "Doc": "\nThe torch package contains data structures for multi-dimensional\ntensors and defines mathematical operations over these tensors.\nAdditionally, it provides many utilities for efficient serializing of\nTensors and arbitrary types, and other useful utilities.\n\nIt has a CUDA counterpart, that enables you to run your tensor computations\non an NVIDIA GPU with compute capability >= 3.0.\n",
  "Classes": {
    "BFloat16Tensor": {
      "Doc": null
    },
    "BoolTensor": {
      "Doc": null
    },
    "ByteTensor": {
      "Doc": null
    },
    "CharTensor": {
      "Doc": null
    },
    "DoubleTensor": {
      "Doc": null
    },
    "FloatTensor": {
      "Doc": null
    },
    "HalfTensor": {
      "Doc": null
    },
    "IntTensor": {
      "Doc": null
    },
    "LongTensor": {
      "Doc": null
    },
    "ShortTensor": {
      "Doc": null
    },
    "Tensor": {
      "Doc": null,
      "Functions": {
        "align_to": {
          "Doc": "Permutes the dimensions of the :attr:`self` tensor to match the order\n        specified in :attr:`names`, adding size-one dims for any new names.\n\n        All of the dims of :attr:`self` must be named in order to use this method.\n        The resulting tensor is a view on the original tensor.\n\n        All dimension names of :attr:`self` must be present in :attr:`names`.\n        :attr:`names` may contain additional names that are not in ``self.names``;\n        the output tensor has a size-one dimension for each of those new names.\n\n        :attr:`names` may contain up to one Ellipsis (``...``).\n        The Ellipsis is expanded to be equal to all dimension names of :attr:`self`\n        that are not mentioned in :attr:`names`, in the order that they appear\n        in :attr:`self`.\n\n        Python 2 does not support Ellipsis but one may use a string literal\n        instead (``'...'``).\n\n        Args:\n            names (iterable of str): The desired dimension ordering of the\n                output tensor. May contain up to one Ellipsis that is expanded\n                to all unmentioned dim names of :attr:`self`.\n\n        Examples::\n\n            >>> tensor = torch.randn(2, 2, 2, 2, 2, 2)\n            >>> named_tensor = tensor.refine_names('A', 'B', 'C', 'D', 'E', 'F')\n\n            # Move the F and E dims to the front while keeping the rest in order\n            >>> named_tensor.align_to('F', 'E', ...)\n\n        .. warning::\n            The named tensor API is experimental and subject to change.\n\n        ",
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            },
            "*names": {
              "Type": null,
              "Default": null
            }
          }
        },
        "backward": {
          "Doc": "Computes the gradient of current tensor w.r.t. graph leaves.\n\n        The graph is differentiated using the chain rule. If the tensor is\n        non-scalar (i.e. its data has more than one element) and requires\n        gradient, the function additionally requires specifying ``gradient``.\n        It should be a tensor of matching type and location, that contains\n        the gradient of the differentiated function w.r.t. ``self``.\n\n        This function accumulates gradients in the leaves - you might need to zero\n        ``.grad`` attributes or set them to ``None`` before calling it.\n        See :ref:`Default gradient layouts<default-grad-layouts>`\n        for details on the memory layout of accumulated gradients.\n\n        .. note::\n\n            If you run any forward ops, create ``gradient``, and/or call ``backward``\n            in a user-specified CUDA stream context, see\n            :ref:`Stream semantics of backward passes<bwd-cuda-stream-semantics>`.\n\n        .. note::\n\n            When ``inputs`` are provided and a given input is not a leaf,\n            the current implementation will call its grad_fn (though it is not strictly needed to get this gradients).\n            It is an implementation detail on which the user should not rely.\n            See https://github.com/pytorch/pytorch/pull/60521#issuecomment-867061780 for more details.\n\n        Args:\n            gradient (Tensor or None): Gradient w.r.t. the\n                tensor. If it is a tensor, it will be automatically converted\n                to a Tensor that does not require grad unless ``create_graph`` is True.\n                None values can be specified for scalar Tensors or ones that\n                don't require grad. If a None value would be acceptable then\n                this argument is optional.\n            retain_graph (bool, optional): If ``False``, the graph used to compute\n                the grads will be freed. Note that in nearly all cases setting\n                this option to True is not needed and often can be worked around\n                in a much more efficient way. Defaults to the value of\n                ``create_graph``.\n            create_graph (bool, optional): If ``True``, graph of the derivative will\n                be constructed, allowing to compute higher order derivative\n                products. Defaults to ``False``.\n            inputs (sequence of Tensor): Inputs w.r.t. which the gradient will be\n                accumulated into ``.grad``. All other Tensors will be ignored. If not\n                provided, the gradient is accumulated into all the leaf Tensors that were\n                used to compute the attr::tensors.\n        ",
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            },
            "gradient": {
              "Type": null,
              "Default": "None"
            },
            "retain_graph": {
              "Type": null,
              "Default": "None"
            },
            "create_graph": {
              "Type": null,
              "Default": "False"
            },
            "inputs": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "eig": {
          "Doc": null,
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            },
            "eigenvectors": {
              "Type": null,
              "Default": "False"
            }
          }
        },
        "is_shared": {
          "Doc": "Checks if tensor is in shared memory.\n\n        This is always ``True`` for CUDA tensors.\n        ",
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            }
          }
        },
        "istft": {
          "Doc": "See :func:`torch.istft`",
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            },
            "n_fft": {
              "Type": "<class 'int'>",
              "Default": null
            },
            "hop_length": {
              "Type": "typing.Optional[int]",
              "Default": "None"
            },
            "win_length": {
              "Type": "typing.Optional[int]",
              "Default": "None"
            },
            "window": {
              "Type": "Optional[Tensor]",
              "Default": "None"
            },
            "center": {
              "Type": "<class 'bool'>",
              "Default": "True"
            },
            "normalized": {
              "Type": "<class 'bool'>",
              "Default": "False"
            },
            "onesided": {
              "Type": "typing.Optional[bool]",
              "Default": "None"
            },
            "length": {
              "Type": "typing.Optional[int]",
              "Default": "None"
            },
            "return_complex": {
              "Type": "<class 'bool'>",
              "Default": "False"
            }
          }
        },
        "lstsq": {
          "Doc": null,
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            },
            "other": {
              "Type": null,
              "Default": null
            }
          }
        },
        "lu": {
          "Doc": "See :func:`torch.lu`",
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            },
            "pivot": {
              "Type": null,
              "Default": "True"
            },
            "get_infos": {
              "Type": null,
              "Default": "False"
            }
          }
        },
        "norm": {
          "Doc": "See :func:`torch.norm`",
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            },
            "p": {
              "Type": null,
              "Default": "fro"
            },
            "dim": {
              "Type": null,
              "Default": "None"
            },
            "keepdim": {
              "Type": null,
              "Default": "False"
            },
            "dtype": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "refine_names": {
          "Doc": "Refines the dimension names of :attr:`self` according to :attr:`names`.\n\n        Refining is a special case of renaming that \"lifts\" unnamed dimensions.\n        A ``None`` dim can be refined to have any name; a named dim can only be\n        refined to have the same name.\n\n        Because named tensors can coexist with unnamed tensors, refining names\n        gives a nice way to write named-tensor-aware code that works with both\n        named and unnamed tensors.\n\n        :attr:`names` may contain up to one Ellipsis (``...``).\n        The Ellipsis is expanded greedily; it is expanded in-place to fill\n        :attr:`names` to the same length as ``self.dim()`` using names from the\n        corresponding indices of ``self.names``.\n\n        Python 2 does not support Ellipsis but one may use a string literal\n        instead (``'...'``).\n\n        Args:\n            names (iterable of str): The desired names of the output tensor. May\n                contain up to one Ellipsis.\n\n        Examples::\n\n            >>> imgs = torch.randn(32, 3, 128, 128)\n            >>> named_imgs = imgs.refine_names('N', 'C', 'H', 'W')\n            >>> named_imgs.names\n            ('N', 'C', 'H', 'W')\n\n            >>> tensor = torch.randn(2, 3, 5, 7, 11)\n            >>> tensor = tensor.refine_names('A', ..., 'B', 'C')\n            >>> tensor.names\n            ('A', None, None, 'B', 'C')\n\n        .. warning::\n            The named tensor API is experimental and subject to change.\n\n        ",
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            },
            "*names": {
              "Type": null,
              "Default": null
            }
          }
        },
        "register_hook": {
          "Doc": "Registers a backward hook.\n\n        The hook will be called every time a gradient with respect to the\n        Tensor is computed. The hook should have the following signature::\n\n            hook(grad) -> Tensor or None\n\n\n        The hook should not modify its argument, but it can optionally return\n        a new gradient which will be used in place of :attr:`grad`.\n\n        This function returns a handle with a method ``handle.remove()``\n        that removes the hook from the module.\n\n        Example::\n\n            >>> v = torch.tensor([0., 0., 0.], requires_grad=True)\n            >>> h = v.register_hook(lambda grad: grad * 2)  # double the gradient\n            >>> v.backward(torch.tensor([1., 2., 3.]))\n            >>> v.grad\n\n             2\n             4\n             6\n            [torch.FloatTensor of size (3,)]\n\n            >>> h.remove()  # removes the hook\n        ",
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            },
            "hook": {
              "Type": null,
              "Default": null
            }
          }
        },
        "reinforce": {
          "Doc": null,
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            },
            "reward": {
              "Type": null,
              "Default": null
            }
          }
        },
        "rename": {
          "Doc": "Renames dimension names of :attr:`self`.\n\n        There are two main usages:\n\n        ``self.rename(**rename_map)`` returns a view on tensor that has dims\n        renamed as specified in the mapping :attr:`rename_map`.\n\n        ``self.rename(*names)`` returns a view on tensor, renaming all\n        dimensions positionally using :attr:`names`.\n        Use ``self.rename(None)`` to drop names on a tensor.\n\n        One cannot specify both positional args :attr:`names` and keyword args\n        :attr:`rename_map`.\n\n        Examples::\n\n            >>> imgs = torch.rand(2, 3, 5, 7, names=('N', 'C', 'H', 'W'))\n            >>> renamed_imgs = imgs.rename(N='batch', C='channels')\n            >>> renamed_imgs.names\n            ('batch', 'channels', 'H', 'W')\n\n            >>> renamed_imgs = imgs.rename(None)\n            >>> renamed_imgs.names\n            (None, None, None, None)\n\n            >>> renamed_imgs = imgs.rename('batch', 'channel', 'height', 'width')\n            >>> renamed_imgs.names\n            ('batch', 'channel', 'height', 'width')\n\n        .. warning::\n            The named tensor API is experimental and subject to change.\n\n        ",
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            },
            "*names": {
              "Type": null,
              "Default": null
            },
            "**rename_map": {
              "Type": null,
              "Default": null
            }
          }
        },
        "resize": {
          "Doc": null,
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            },
            "*sizes": {
              "Type": null,
              "Default": null
            }
          }
        },
        "resize_as": {
          "Doc": null,
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            },
            "tensor": {
              "Type": null,
              "Default": null
            }
          }
        },
        "solve": {
          "Doc": null,
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            },
            "other": {
              "Type": null,
              "Default": null
            }
          }
        },
        "split": {
          "Doc": "See :func:`torch.split`",
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            },
            "split_size": {
              "Type": null,
              "Default": null
            },
            "dim": {
              "Type": null,
              "Default": "0"
            }
          }
        },
        "stft": {
          "Doc": "See :func:`torch.stft`\n\n        .. warning::\n          This function changed signature at version 0.4.1. Calling with\n          the previous signature may cause error or return incorrect result.\n        ",
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            },
            "n_fft": {
              "Type": "<class 'int'>",
              "Default": null
            },
            "hop_length": {
              "Type": "typing.Optional[int]",
              "Default": "None"
            },
            "win_length": {
              "Type": "typing.Optional[int]",
              "Default": "None"
            },
            "window": {
              "Type": "Optional[Tensor]",
              "Default": "None"
            },
            "center": {
              "Type": "<class 'bool'>",
              "Default": "True"
            },
            "pad_mode": {
              "Type": "<class 'str'>",
              "Default": "reflect"
            },
            "normalized": {
              "Type": "<class 'bool'>",
              "Default": "False"
            },
            "onesided": {
              "Type": "typing.Optional[bool]",
              "Default": "None"
            },
            "return_complex": {
              "Type": "typing.Optional[bool]",
              "Default": "None"
            }
          }
        },
        "storage": {
          "Doc": "\n        storage() -> torch.Storage\n\n        Returns the underlying storage.\n        ",
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            }
          }
        },
        "storage_type": {
          "Doc": "storage_type() -> type\n\n        Returns the type of the underlying storage.\n\n        ",
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            }
          }
        },
        "to_sparse_coo": {
          "Doc": "Convert a tensor to :ref:`coordinate format <sparse-coo-docs>`.\n\n        Examples::\n\n             >>> dense = torch.randn(5, 5)\n             >>> sparse = dense.to_sparse_coo()\n             >>> sparse._nnz()\n             25\n\n        ",
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            }
          }
        },
        "unflatten": {
          "Doc": "\n        unflatten(dim, sizes) -> Tensor\n\n        See :func:`torch.unflatten`.\n\n        ",
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            },
            "dim": {
              "Type": null,
              "Default": null
            },
            "sizes": {
              "Type": null,
              "Default": null
            }
          }
        },
        "unique": {
          "Doc": "Returns the unique elements of the input tensor.\n\n        See :func:`torch.unique`\n        ",
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            },
            "sorted": {
              "Type": null,
              "Default": "True"
            },
            "return_inverse": {
              "Type": null,
              "Default": "False"
            },
            "return_counts": {
              "Type": null,
              "Default": "False"
            },
            "dim": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "unique_consecutive": {
          "Doc": "Eliminates all but the first element from every consecutive group of equivalent elements.\n\n        See :func:`torch.unique_consecutive`\n        ",
          "Args": {
            "self": {
              "Type": null,
              "Default": null
            },
            "return_inverse": {
              "Type": null,
              "Default": "False"
            },
            "return_counts": {
              "Type": null,
              "Default": "False"
            },
            "dim": {
              "Type": null,
              "Default": "None"
            }
          }
        }
      }
    },
    "TensorType": {
      "Doc": null
    }
  },
  "Functions": {
    "abs": {
      "Doc": "\nabs(input, *, out=None) -> Tensor\n\nComputes the absolute value of each element in :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = |\\text{input}_{i}|\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> torch.abs(torch.tensor([-1, -2, 3]))\n    tensor([ 1,  2,  3])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "absolute": {
      "Doc": "\nabsolute(input, *, out=None) -> Tensor\n\nAlias for :func:`torch.abs`\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "acos": {
      "Doc": "\nacos(input, *, out=None) -> Tensor\n\nComputes the inverse cosine of each element in :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\cos^{-1}(\\text{input}_{i})\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 0.3348, -0.5889,  0.2005, -0.1584])\n    >>> torch.acos(a)\n    tensor([ 1.2294,  2.2004,  1.3690,  1.7298])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "acosh": {
      "Doc": "\nacosh(input, *, out=None) -> Tensor\n\nReturns a new tensor with the inverse hyperbolic cosine of the elements of :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\cosh^{-1}(\\text{input}_{i})\n\nNote:\n    The domain of the inverse hyperbolic cosine is `[1, inf)` and values outside this range\n    will be mapped to ``NaN``, except for `+ INF` for which the output is mapped to `+ INF`.\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword arguments:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4).uniform_(1, 2)\n    >>> a\n    tensor([ 1.3192, 1.9915, 1.9674, 1.7151 ])\n    >>> torch.acosh(a)\n    tensor([ 0.7791, 1.3120, 1.2979, 1.1341 ])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "adaptive_avg_pool1d": {
      "Doc": "\nadaptive_avg_pool1d(input, output_size) -> Tensor\n\nApplies a 1D adaptive average pooling over an input signal composed of\nseveral input planes.\n\nSee :class:`~torch.nn.AdaptiveAvgPool1d` for details and output shape.\n\nArgs:\n    output_size: the target output size (single integer)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "output_size": {
          "Type": null,
          "Default": null
        }
      }
    },
    "adaptive_max_pool1d": {
      "Doc": null,
      "Args": null
    },
    "add": {
      "Doc": "\nadd(input, other, *, alpha=1, out=None) -> Tensor\n\nAdds :attr:`other`, scaled by :attr:`alpha`, to :attr:`input`.\n\n.. math::\n    \\text{{out}}_i = \\text{{input}}_i + \\text{{alpha}} \\times \\text{{other}}_i\n\n\nSupports :ref:`broadcasting to a common shape <broadcasting-semantics>`,\n:ref:`type promotion <type-promotion-doc>`, and integer, float, and complex inputs.\n\nArgs:\n    input (Tensor): the input tensor.\n    other (Tensor or Number): the tensor or number to add to input.\n\nKeyword arguments:\n    alpha (Number): the multiplier for :attr:`other`.\n    out (Tensor, optional): the output tensor.\n\nExamples::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 0.0202,  1.0985,  1.3506, -0.6056])\n    >>> torch.add(a, 20)\n    tensor([ 20.0202,  21.0985,  21.3506,  19.3944])\n\n    >>> b = torch.randn(4)\n    >>> b\n    tensor([-0.9732, -0.3497,  0.6245,  0.4022])\n    >>> c = torch.randn(4, 1)\n    >>> c\n    tensor([[ 0.3743],\n            [-1.7724],\n            [-0.5811],\n            [-0.8017]])\n    >>> torch.add(b, c, alpha=10)\n    tensor([[  2.7695,   3.3930,   4.3672,   4.1450],\n            [-18.6971, -18.0736, -17.0994, -17.3216],\n            [ -6.7845,  -6.1610,  -5.1868,  -5.4090],\n            [ -8.9902,  -8.3667,  -7.3925,  -7.6147]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "alpha": {
          "Type": null,
          "Default": "1"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "addbmm": {
      "Doc": "\naddbmm(input, batch1, batch2, *, beta=1, alpha=1, out=None) -> Tensor\n\nPerforms a batch matrix-matrix product of matrices stored\nin :attr:`batch1` and :attr:`batch2`,\nwith a reduced add step (all matrix multiplications get accumulated\nalong the first dimension).\n:attr:`input` is added to the final result.\n\n:attr:`batch1` and :attr:`batch2` must be 3-D tensors each containing the\nsame number of matrices.\n\nIf :attr:`batch1` is a :math:`(b \\times n \\times m)` tensor, :attr:`batch2` is a\n:math:`(b \\times m \\times p)` tensor, :attr:`input` must be\n:ref:`broadcastable <broadcasting-semantics>` with a :math:`(n \\times p)` tensor\nand :attr:`out` will be a :math:`(n \\times p)` tensor.\n\n.. math::\n    out = \\beta\\ \\text{input} + \\alpha\\ (\\sum_{i=0}^{b-1} \\text{batch1}_i \\mathbin{@} \\text{batch2}_i)\n\nIf :attr:`beta` is 0, then :attr:`input` will be ignored, and `nan` and `inf` in\nit will not be propagated.\n\nFor inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and :attr:`alpha`\nmust be real numbers, otherwise they should be integers.\n\nThis operator supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\nOn certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.\n\nArgs:\n    batch1 (Tensor): the first batch of matrices to be multiplied\n    batch2 (Tensor): the second batch of matrices to be multiplied\n\nKeyword args:\n    beta (Number, optional): multiplier for :attr:`input` (:math:`\\beta`)\n    input (Tensor): matrix to be added\n    alpha (Number, optional): multiplier for `batch1 @ batch2` (:math:`\\alpha`)\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> M = torch.randn(3, 5)\n    >>> batch1 = torch.randn(10, 3, 4)\n    >>> batch2 = torch.randn(10, 4, 5)\n    >>> torch.addbmm(M, batch1, batch2)\n    tensor([[  6.6311,   0.0503,   6.9768, -12.0362,  -2.1653],\n            [ -4.8185,  -1.4255,  -6.6760,   8.9453,   2.5743],\n            [ -3.8202,   4.3691,   1.0943,  -1.1109,   5.4730]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "batch1": {
          "Type": null,
          "Default": null
        },
        "batch2": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "beta": {
          "Type": null,
          "Default": "1"
        },
        "alpha": {
          "Type": null,
          "Default": "1"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "addcdiv": {
      "Doc": "\naddcdiv(input, tensor1, tensor2, *, value=1, out=None) -> Tensor\n\nPerforms the element-wise division of :attr:`tensor1` by :attr:`tensor2`,\nmultiply the result by the scalar :attr:`value` and add it to :attr:`input`.\n\n.. warning::\n    Integer division with addcdiv is no longer supported, and in a future\n    release addcdiv will perform a true division of tensor1 and tensor2.\n    The historic addcdiv behavior can be implemented as\n    (input + value * torch.trunc(tensor1 / tensor2)).to(input.dtype)\n    for integer inputs and as (input + value * tensor1 / tensor2) for float inputs.\n    The future addcdiv behavior is just the latter implementation:\n    (input + value * tensor1 / tensor2), for all dtypes.\n\n.. math::\n    \\text{out}_i = \\text{input}_i + \\text{value} \\times \\frac{\\text{tensor1}_i}{\\text{tensor2}_i}\n\n\nThe shapes of :attr:`input`, :attr:`tensor1`, and :attr:`tensor2` must be\n:ref:`broadcastable <broadcasting-semantics>`.\n\nFor inputs of type `FloatTensor` or `DoubleTensor`, :attr:`value` must be\na real number, otherwise an integer.\n\nArgs:\n    input (Tensor): the tensor to be added\n    tensor1 (Tensor): the numerator tensor\n    tensor2 (Tensor): the denominator tensor\n\nKeyword args:\n    value (Number, optional): multiplier for :math:`\\text{tensor1} / \\text{tensor2}`\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> t = torch.randn(1, 3)\n    >>> t1 = torch.randn(3, 1)\n    >>> t2 = torch.randn(1, 3)\n    >>> torch.addcdiv(t, t1, t2, value=0.1)\n    tensor([[-0.2312, -3.6496,  0.1312],\n            [-1.0428,  3.4292, -0.1030],\n            [-0.5369, -0.9829,  0.0430]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "tensor1": {
          "Type": null,
          "Default": null
        },
        "tensor2": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "value": {
          "Type": null,
          "Default": "1"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "addcmul": {
      "Doc": "\naddcmul(input, tensor1, tensor2, *, value=1, out=None) -> Tensor\n\nPerforms the element-wise multiplication of :attr:`tensor1`\nby :attr:`tensor2`, multiply the result by the scalar :attr:`value`\nand add it to :attr:`input`.\n\n.. math::\n    \\text{out}_i = \\text{input}_i + \\text{value} \\times \\text{tensor1}_i \\times \\text{tensor2}_i\n\nThe shapes of :attr:`tensor`, :attr:`tensor1`, and :attr:`tensor2` must be\n:ref:`broadcastable <broadcasting-semantics>`.\n\nFor inputs of type `FloatTensor` or `DoubleTensor`, :attr:`value` must be\na real number, otherwise an integer.\n\nArgs:\n    input (Tensor): the tensor to be added\n    tensor1 (Tensor): the tensor to be multiplied\n    tensor2 (Tensor): the tensor to be multiplied\n\nKeyword args:\n    value (Number, optional): multiplier for :math:`tensor1 .* tensor2`\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> t = torch.randn(1, 3)\n    >>> t1 = torch.randn(3, 1)\n    >>> t2 = torch.randn(1, 3)\n    >>> torch.addcmul(t, t1, t2, value=0.1)\n    tensor([[-0.8635, -0.6391,  1.6174],\n            [-0.7617, -0.5879,  1.7388],\n            [-0.8353, -0.6249,  1.6511]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "tensor1": {
          "Type": null,
          "Default": null
        },
        "tensor2": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "value": {
          "Type": null,
          "Default": "1"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "addmm": {
      "Doc": "\naddmm(input, mat1, mat2, *, beta=1, alpha=1, out=None) -> Tensor\n\nPerforms a matrix multiplication of the matrices :attr:`mat1` and :attr:`mat2`.\nThe matrix :attr:`input` is added to the final result.\n\nIf :attr:`mat1` is a :math:`(n \\times m)` tensor, :attr:`mat2` is a\n:math:`(m \\times p)` tensor, then :attr:`input` must be\n:ref:`broadcastable <broadcasting-semantics>` with a :math:`(n \\times p)` tensor\nand :attr:`out` will be a :math:`(n \\times p)` tensor.\n\n:attr:`alpha` and :attr:`beta` are scaling factors on matrix-vector product between\n:attr:`mat1` and :attr:`mat2` and the added matrix :attr:`input` respectively.\n\n.. math::\n    \\text{out} = \\beta\\ \\text{input} + \\alpha\\ (\\text{mat1}_i \\mathbin{@} \\text{mat2}_i)\n\nIf :attr:`beta` is 0, then :attr:`input` will be ignored, and `nan` and `inf` in\nit will not be propagated.\n\nFor inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and\n:attr:`alpha` must be real numbers, otherwise they should be integers.\n\nThis operation has support for arguments with :ref:`sparse layouts<sparse-docs>`. If\n:attr:`input` is sparse the result will have the same layout and if :attr:`out`\nis provided it must have the same layout as :attr:`input`.\n\n\n.. warning::\n    Sparse support is a beta feature and some layout(s)/dtype/device combinations may not be supported,\n    or may not have autograd support. If you notice missing functionality please\n    open a feature request.\n\nThis operator supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\nOn certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.\n\nArgs:\n    input (Tensor): matrix to be added\n    mat1 (Tensor): the first matrix to be matrix multiplied\n    mat2 (Tensor): the second matrix to be matrix multiplied\n\nKeyword args:\n    beta (Number, optional): multiplier for :attr:`input` (:math:`\\beta`)\n    alpha (Number, optional): multiplier for :math:`mat1 @ mat2` (:math:`\\alpha`)\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> M = torch.randn(2, 3)\n    >>> mat1 = torch.randn(2, 3)\n    >>> mat2 = torch.randn(3, 3)\n    >>> torch.addmm(M, mat1, mat2)\n    tensor([[-4.8716,  1.4671, -1.3746],\n            [ 0.7573, -3.9555, -2.8681]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "mat1": {
          "Type": null,
          "Default": null
        },
        "mat2": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "beta": {
          "Type": null,
          "Default": "1"
        },
        "alpha": {
          "Type": null,
          "Default": "1"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "addmv": {
      "Doc": "\naddmv(input, mat, vec, *, beta=1, alpha=1, out=None) -> Tensor\n\nPerforms a matrix-vector product of the matrix :attr:`mat` and\nthe vector :attr:`vec`.\nThe vector :attr:`input` is added to the final result.\n\nIf :attr:`mat` is a :math:`(n \\times m)` tensor, :attr:`vec` is a 1-D tensor of\nsize `m`, then :attr:`input` must be\n:ref:`broadcastable <broadcasting-semantics>` with a 1-D tensor of size `n` and\n:attr:`out` will be 1-D tensor of size `n`.\n\n:attr:`alpha` and :attr:`beta` are scaling factors on matrix-vector product between\n:attr:`mat` and :attr:`vec` and the added tensor :attr:`input` respectively.\n\n.. math::\n    \\text{out} = \\beta\\ \\text{input} + \\alpha\\ (\\text{mat} \\mathbin{@} \\text{vec})\n\nIf :attr:`beta` is 0, then :attr:`input` will be ignored, and `nan` and `inf` in\nit will not be propagated.\n\nFor inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and\n:attr:`alpha` must be real numbers, otherwise they should be integers\n\nArgs:\n    input (Tensor): vector to be added\n    mat (Tensor): matrix to be matrix multiplied\n    vec (Tensor): vector to be matrix multiplied\n\nKeyword args:\n    beta (Number, optional): multiplier for :attr:`input` (:math:`\\beta`)\n    alpha (Number, optional): multiplier for :math:`mat @ vec` (:math:`\\alpha`)\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> M = torch.randn(2)\n    >>> mat = torch.randn(2, 3)\n    >>> vec = torch.randn(3)\n    >>> torch.addmv(M, mat, vec)\n    tensor([-0.3768, -5.5565])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "mat": {
          "Type": null,
          "Default": null
        },
        "vec": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "beta": {
          "Type": null,
          "Default": "1"
        },
        "alpha": {
          "Type": null,
          "Default": "1"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "addr": {
      "Doc": "\naddr(input, vec1, vec2, *, beta=1, alpha=1, out=None) -> Tensor\n\nPerforms the outer-product of vectors :attr:`vec1` and :attr:`vec2`\nand adds it to the matrix :attr:`input`.\n\nOptional values :attr:`beta` and :attr:`alpha` are scaling factors on the\nouter product between :attr:`vec1` and :attr:`vec2` and the added matrix\n:attr:`input` respectively.\n\n.. math::\n    \\text{out} = \\beta\\ \\text{input} + \\alpha\\ (\\text{vec1} \\otimes \\text{vec2})\n\nIf :attr:`beta` is 0, then :attr:`input` will be ignored, and `nan` and `inf` in\nit will not be propagated.\n\nIf :attr:`vec1` is a vector of size `n` and :attr:`vec2` is a vector\nof size `m`, then :attr:`input` must be\n:ref:`broadcastable <broadcasting-semantics>` with a matrix of size\n:math:`(n \\times m)` and :attr:`out` will be a matrix of size\n:math:`(n \\times m)`.\n\nArgs:\n    input (Tensor): matrix to be added\n    vec1 (Tensor): the first vector of the outer product\n    vec2 (Tensor): the second vector of the outer product\n\nKeyword args:\n    beta (Number, optional): multiplier for :attr:`input` (:math:`\\beta`)\n    alpha (Number, optional): multiplier for :math:`\\text{vec1} \\otimes \\text{vec2}` (:math:`\\alpha`)\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> vec1 = torch.arange(1., 4.)\n    >>> vec2 = torch.arange(1., 3.)\n    >>> M = torch.zeros(3, 2)\n    >>> torch.addr(M, vec1, vec2)\n    tensor([[ 1.,  2.],\n            [ 2.,  4.],\n            [ 3.,  6.]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "vec1": {
          "Type": null,
          "Default": null
        },
        "vec2": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "beta": {
          "Type": null,
          "Default": "1"
        },
        "alpha": {
          "Type": null,
          "Default": "1"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "adjoint": {
      "Doc": "\nadjoint(Tensor) -> Tensor\nReturns a view of the tensor conjugated and with the last two dimensions transposed.\n\n``x.adjoint()`` is equivalent to ``x.transpose(-2, -1).conj()`` for complex tensors and\nto ``x.transpose(-2, -1)`` for real tensors.\n\nExample::\n    >>> x = torch.arange(4, dtype=torch.float)\n    >>> A = torch.complex(x, x).reshape(2, 2)\n    >>> A\n    tensor([[0.+0.j, 1.+1.j],\n            [2.+2.j, 3.+3.j]])\n    >>> A.adjoint()\n    tensor([[0.-0.j, 2.-2.j],\n            [1.-1.j, 3.-3.j]])\n    >>> (A.adjoint() == A.mH).all()\n    tensor(True)\n",
      "Args": {
        "Tensor": {
          "Type": null,
          "Default": null
        }
      }
    },
    "affine_grid_generator": {
      "Doc": null,
      "Args": null
    },
    "alias_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.alias`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "align_tensors": {
      "Doc": null,
      "Args": {
        "*tensors": {
          "Type": null,
          "Default": null
        }
      }
    },
    "all": {
      "Doc": "\nall(input) -> Tensor\n\nTests if all elements in :attr:`input` evaluate to `True`.\n\n.. note:: This function matches the behaviour of NumPy in returning\n          output of dtype `bool` for all supported dtypes except `uint8`.\n          For `uint8` the dtype of output is `uint8` itself.\n\nExample::\n\n    >>> a = torch.rand(1, 2).bool()\n    >>> a\n    tensor([[False, True]], dtype=torch.bool)\n    >>> torch.all(a)\n    tensor(False, dtype=torch.bool)\n    >>> a = torch.arange(0, 3)\n    >>> a\n    tensor([0, 1, 2])\n    >>> torch.all(a)\n    tensor(False)\n\n.. function:: all(input, dim, keepdim=False, *, out=None) -> Tensor\n   :noindex:\n\nFor each row of :attr:`input` in the given dimension :attr:`dim`,\nreturns `True` if all elements in the row evaluate to `True` and `False` otherwise.\n\nIf :attr:`keepdim` is ``True``, the output tensor is of the same size\nas :attr:`input` except in the dimension :attr:`dim` where it is of size 1.\nOtherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in\nthe output tensor having 1 fewer dimension than :attr:`input`.\n\nArgs:\n    input (Tensor): the input tensor.\n    dim (int): the dimension to reduce.\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.rand(4, 2).bool()\n    >>> a\n    tensor([[True, True],\n            [True, False],\n            [True, True],\n            [True, True]], dtype=torch.bool)\n    >>> torch.all(a, dim=1)\n    tensor([ True, False,  True,  True], dtype=torch.bool)\n    >>> torch.all(a, dim=0)\n    tensor([ True, False], dtype=torch.bool)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "allclose": {
      "Doc": "\nallclose(input, other, rtol=1e-05, atol=1e-08, equal_nan=False) -> bool\n\nThis function checks if all :attr:`input` and :attr:`other` satisfy the condition:\n\n.. math::\n    \\lvert \\text{input} - \\text{other} \\rvert \\leq \\texttt{atol} + \\texttt{rtol} \\times \\lvert \\text{other} \\rvert\n\nelementwise, for all elements of :attr:`input` and :attr:`other`. The behaviour of this function is analogous to\n`numpy.allclose <https://docs.scipy.org/doc/numpy/reference/generated/numpy.allclose.html>`_\n\nArgs:\n    input (Tensor): first tensor to compare\n    other (Tensor): second tensor to compare\n    atol (float, optional): absolute tolerance. Default: 1e-08\n    rtol (float, optional): relative tolerance. Default: 1e-05\n    equal_nan (bool, optional): if ``True``, then two ``NaN`` s will be considered equal. Default: ``False``\n\nExample::\n\n    >>> torch.allclose(torch.tensor([10000., 1e-07]), torch.tensor([10000.1, 1e-08]))\n    False\n    >>> torch.allclose(torch.tensor([10000., 1e-08]), torch.tensor([10000.1, 1e-09]))\n    True\n    >>> torch.allclose(torch.tensor([1.0, float('nan')]), torch.tensor([1.0, float('nan')]))\n    False\n    >>> torch.allclose(torch.tensor([1.0, float('nan')]), torch.tensor([1.0, float('nan')]), equal_nan=True)\n    True\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "rtol": {
          "Type": null,
          "Default": "1e-05"
        },
        "atol": {
          "Type": null,
          "Default": "1e-08"
        },
        "equal_nan": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "alpha_dropout": {
      "Doc": null,
      "Args": null
    },
    "amax": {
      "Doc": "\namax(input, dim, keepdim=False, *, out=None) -> Tensor\n\nReturns the maximum value of each slice of the :attr:`input` tensor in the given\ndimension(s) :attr:`dim`.\n\n.. note::\n    The difference between ``max``/``min`` and ``amax``/``amin`` is:\n        - ``amax``/``amin`` supports reducing on multiple dimensions,\n        - ``amax``/``amin`` does not return indices,\n        - ``amax``/``amin`` evenly distributes gradient between equal values,\n          while ``max(dim)``/``min(dim)`` propagates gradient only to a single\n          index in the source tensor.\n\n\nIf :attr:`keepdim` is ``True``, the output tensor is of the same size\nas :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.\nOtherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the\noutput tensor having 1 (or ``len(dim)``) fewer dimension(s).\n\n\nArgs:\n    input (Tensor): the input tensor.\n    dim (int or tuple of ints): the dimension or dimensions to reduce.\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not.\n\nKeyword args:\n  out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[ 0.8177,  1.4878, -0.2491,  0.9130],\n            [-0.7158,  1.1775,  2.0992,  0.4817],\n            [-0.0053,  0.0164, -1.3738, -0.0507],\n            [ 1.9700,  1.1106, -1.0318, -1.0816]])\n    >>> torch.amax(a, 1)\n    tensor([1.4878, 2.0992, 0.0164, 1.9700])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "keepdim": {
          "Type": null,
          "Default": "False"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "amin": {
      "Doc": "\namin(input, dim, keepdim=False, *, out=None) -> Tensor\n\nReturns the minimum value of each slice of the :attr:`input` tensor in the given\ndimension(s) :attr:`dim`.\n\n.. note::\n    The difference between ``max``/``min`` and ``amax``/``amin`` is:\n        - ``amax``/``amin`` supports reducing on multiple dimensions,\n        - ``amax``/``amin`` does not return indices,\n        - ``amax``/``amin`` evenly distributes gradient between equal values,\n          while ``max(dim)``/``min(dim)`` propagates gradient only to a single\n          index in the source tensor.\n\n\nIf :attr:`keepdim` is ``True``, the output tensor is of the same size\nas :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.\nOtherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the\noutput tensor having 1 (or ``len(dim)``) fewer dimension(s).\n\n\nArgs:\n    input (Tensor): the input tensor.\n    dim (int or tuple of ints): the dimension or dimensions to reduce.\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not.\n\nKeyword args:\n  out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[ 0.6451, -0.4866,  0.2987, -1.3312],\n            [-0.5744,  1.2980,  1.8397, -0.2713],\n            [ 0.9128,  0.9214, -1.7268, -0.2995],\n            [ 0.9023,  0.4853,  0.9075, -1.6165]])\n    >>> torch.amin(a, 1)\n    tensor([-1.3312, -0.5744, -1.7268, -1.6165])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "keepdim": {
          "Type": null,
          "Default": "False"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "aminmax": {
      "Doc": "\naminmax(input, *, dim=None, keepdim=False, out=None) -> (Tensor min, Tensor max)\n\nComputes the minimum and maximum values of the :attr:`input` tensor.\n\nArgs:\n    input (Tensor):\n        The input tensor\n\nKeyword Args:\n    dim (Optional[int]):\n        The dimension along which to compute the values. If `None`,\n        computes the values over the entire :attr:`input` tensor.\n        Default is `None`.\n    keepdim (bool):\n        If `True`, the reduced dimensions will be kept in the output\n        tensor as dimensions with size 1 for broadcasting, otherwise\n        they will be removed, as if calling (:func:`torch.squeeze`).\n        Default is `False`.\n    out (Optional[Tuple[Tensor, Tensor]]):\n        Optional tensors on which to write the result. Must have the same\n        shape and dtype as the expected output.\n        Default is `None`.\n\nReturns:\n    A named tuple `(min, max)` containing the minimum and maximum values.\n\nRaises:\n    RuntimeError\n        If any of the dimensions to compute the values over has size 0.\n\n.. note::\n    NaN values are propagated to the output if at least one value is NaN.\n\n.. seealso::\n    :func:`torch.amin` computes just the minimum value\n    :func:`torch.amax` computes just the maximum value\n\nExample::\n\n    >>> torch.aminmax(torch.tensor([1, -3, 5]))\n    torch.return_types.aminmax(\n    min=tensor(-3),\n    max=tensor(5))\n\n    >>> # aminmax propagates NaNs\n    >>> torch.aminmax(torch.tensor([1, -3, 5, torch.nan]))\n    torch.return_types.aminmax(\n    min=tensor(nan),\n    max=tensor(nan))\n\n    >>> t = torch.arange(10).view(2, 5)\n    >>> t\n    tensor([[0, 1, 2, 3, 4],\n            [5, 6, 7, 8, 9]])\n    >>> t.aminmax(dim=0, keepdim=True)\n    torch.return_types.aminmax(\n    min=tensor([[0, 1, 2, 3, 4]]),\n    max=tensor([[5, 6, 7, 8, 9]]))\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "None"
        },
        "keepdim": {
          "Type": null,
          "Default": "False"
        },
        "out": {
          "Type": null,
          "Default": "None) -> (Tensor min"
        },
        "Tensor max": {
          "Type": null,
          "Default": null
        }
      }
    },
    "angle": {
      "Doc": "\nangle(input, *, out=None) -> Tensor\n\nComputes the element-wise angle (in radians) of the given :attr:`input` tensor.\n\n.. math::\n    \\text{out}_{i} = angle(\\text{input}_{i})\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\n.. note:: Starting in PyTorch 1.8, angle returns pi for negative real numbers,\n          zero for non-negative real numbers, and propagates NaNs. Previously\n          the function would return zero for all real numbers and not propagate\n          floating-point NaNs.\n\nExample::\n\n    >>> torch.angle(torch.tensor([-1 + 1j, -2 + 2j, 3 - 3j]))*180/3.14159\n    tensor([ 135.,  135,  -45])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "any": {
      "Doc": "\nany(input) -> Tensor\n\nTests if any element in :attr:`input` evaluates to `True`.\n\n.. note:: This function matches the behaviour of NumPy in returning\n          output of dtype `bool` for all supported dtypes except `uint8`.\n          For `uint8` the dtype of output is `uint8` itself.\n\nExample::\n\n    >>> a = torch.rand(1, 2).bool()\n    >>> a\n    tensor([[False, True]], dtype=torch.bool)\n    >>> torch.any(a)\n    tensor(True, dtype=torch.bool)\n    >>> a = torch.arange(0, 3)\n    >>> a\n    tensor([0, 1, 2])\n    >>> torch.any(a)\n    tensor(True)\n\n.. function:: any(input, dim, keepdim=False, *, out=None) -> Tensor\n   :noindex:\n\nFor each row of :attr:`input` in the given dimension :attr:`dim`,\nreturns `True` if any element in the row evaluate to `True` and `False` otherwise.\n\nIf :attr:`keepdim` is ``True``, the output tensor is of the same size\nas :attr:`input` except in the dimension :attr:`dim` where it is of size 1.\nOtherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in\nthe output tensor having 1 fewer dimension than :attr:`input`.\n\nArgs:\n    input (Tensor): the input tensor.\n    dim (int): the dimension to reduce.\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4, 2) < 0\n    >>> a\n    tensor([[ True,  True],\n            [False,  True],\n            [ True,  True],\n            [False, False]])\n    >>> torch.any(a, 1)\n    tensor([ True,  True,  True, False])\n    >>> torch.any(a, 0)\n    tensor([True, True])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "arange": {
      "Doc": "\narange(start=0, end, step=1, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nReturns a 1-D tensor of size :math:`\\left\\lceil \\frac{\\text{end} - \\text{start}}{\\text{step}} \\right\\rceil`\nwith values from the interval ``[start, end)`` taken with common difference\n:attr:`step` beginning from `start`.\n\nNote that non-integer :attr:`step` is subject to floating point rounding errors when\ncomparing against :attr:`end`; to avoid inconsistency, we advise adding a small epsilon to :attr:`end`\nin such cases.\n\n.. math::\n    \\text{out}_{{i+1}} = \\text{out}_{i} + \\text{step}\n\nArgs:\n    start (Number): the starting value for the set of points. Default: ``0``.\n    end (Number): the ending value for the set of points\n    step (Number): the gap between each pair of adjacent points. Default: ``1``.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`). If `dtype` is not given, infer the data type from the other input\n        arguments. If any of `start`, `end`, or `stop` are floating-point, the\n        `dtype` is inferred to be the default dtype, see\n        :meth:`~torch.get_default_dtype`. Otherwise, the `dtype` is inferred to\n        be `torch.int64`.\n    layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.\n        Default: ``torch.strided``.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n\nExample::\n\n    >>> torch.arange(5)\n    tensor([ 0,  1,  2,  3,  4])\n    >>> torch.arange(1, 4)\n    tensor([ 1,  2,  3])\n    >>> torch.arange(1, 2.5, 0.5)\n    tensor([ 1.0000,  1.5000,  2.0000])\n",
      "Args": {
        "start": {
          "Type": null,
          "Default": "0"
        },
        "end": {
          "Type": null,
          "Default": null
        },
        "step": {
          "Type": null,
          "Default": "1"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "torch.strided"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "arccos": {
      "Doc": "\narccos(input, *, out=None) -> Tensor\n\nAlias for :func:`torch.acos`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "arccosh": {
      "Doc": "\narccosh(input, *, out=None) -> Tensor\n\nAlias for :func:`torch.acosh`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "arcsin": {
      "Doc": "\narcsin(input, *, out=None) -> Tensor\n\nAlias for :func:`torch.asin`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "arcsinh": {
      "Doc": "\narcsinh(input, *, out=None) -> Tensor\n\nAlias for :func:`torch.asinh`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "arctan": {
      "Doc": "\narctan(input, *, out=None) -> Tensor\n\nAlias for :func:`torch.atan`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "arctan2": {
      "Doc": "\narctan2(input, other, *, out=None) -> Tensor\nAlias for :func:`torch.atan2`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "arctanh": {
      "Doc": "\narctanh(input, *, out=None) -> Tensor\n\nAlias for :func:`torch.atanh`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "are_deterministic_algorithms_enabled": {
      "Doc": "Returns True if the global deterministic flag is turned on. Refer to\n    :func:`torch.use_deterministic_algorithms` documentation for more details.\n    ",
      "Args": {}
    },
    "argmax": {
      "Doc": "\nargmax(input) -> LongTensor\n\nReturns the indices of the maximum value of all elements in the :attr:`input` tensor.\n\nThis is the second value returned by :meth:`torch.max`. See its\ndocumentation for the exact semantics of this method.\n\n.. note:: If there are multiple maximal values then the indices of the first maximal value are returned.\n\nArgs:\n    input (Tensor): the input tensor.\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[ 1.3398,  0.2663, -0.2686,  0.2450],\n            [-0.7401, -0.8805, -0.3402, -1.1936],\n            [ 0.4907, -1.3948, -1.0691, -0.3132],\n            [-1.6092,  0.5419, -0.2993,  0.3195]])\n    >>> torch.argmax(a)\n    tensor(0)\n\n.. function:: argmax(input, dim, keepdim=False) -> LongTensor\n   :noindex:\n\nReturns the indices of the maximum values of a tensor across a dimension.\n\nThis is the second value returned by :meth:`torch.max`. See its\ndocumentation for the exact semantics of this method.\n\nArgs:\n    input (Tensor): the input tensor.\n    dim (int): the dimension to reduce. If ``None``, the argmax of the flattened input is returned.\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not. Ignored if ``dim=None``.\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[ 1.3398,  0.2663, -0.2686,  0.2450],\n            [-0.7401, -0.8805, -0.3402, -1.1936],\n            [ 0.4907, -1.3948, -1.0691, -0.3132],\n            [-1.6092,  0.5419, -0.2993,  0.3195]])\n    >>> torch.argmax(a, dim=1)\n    tensor([ 0,  2,  0,  1])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "argmin": {
      "Doc": "\nargmin(input, dim=None, keepdim=False) -> LongTensor\n\nReturns the indices of the minimum value(s) of the flattened tensor or along a dimension\n\nThis is the second value returned by :meth:`torch.min`. See its\ndocumentation for the exact semantics of this method.\n\n.. note:: If there are multiple minimal values then the indices of the first minimal value are returned.\n\nArgs:\n    input (Tensor): the input tensor.\n    dim (int): the dimension to reduce. If ``None``, the argmin of the flattened input is returned.\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not..\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[ 0.1139,  0.2254, -0.1381,  0.3687],\n            [ 1.0100, -1.1975, -0.0102, -0.4732],\n            [-0.9240,  0.1207, -0.7506, -1.0213],\n            [ 1.7809, -1.2960,  0.9384,  0.1438]])\n    >>> torch.argmin(a)\n    tensor(13)\n    >>> torch.argmin(a, dim=1)\n    tensor([ 2,  1,  3,  1])\n    >>> torch.argmin(a, dim=1, keepdim=True)\n    tensor([[2],\n            [1],\n            [3],\n            [1]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "None"
        },
        "keepdim": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "argsort": {
      "Doc": "\nargsort(input, dim=-1, descending=False, stable=False) -> Tensor\n\nReturns the indices that sort a tensor along a given dimension in ascending\norder by value.\n\nThis is the second value returned by :meth:`torch.sort`.  See its documentation\nfor the exact semantics of this method.\n\nIf :attr:`stable` is ``True`` then the sorting routine becomes stable, preserving\nthe order of equivalent elements. If ``False``, the relative order of values\nwhich compare equal is not guaranteed. ``True`` is slower.\n\nArgs:\n    input (Tensor): the input tensor.\n    dim (int, optional): the dimension to sort along\n    descending (bool, optional): controls the sorting order (ascending or descending)\n    stable (bool, optional): controls the relative order of equivalent elements\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[ 0.0785,  1.5267, -0.8521,  0.4065],\n            [ 0.1598,  0.0788, -0.0745, -1.2700],\n            [ 1.2208,  1.0722, -0.7064,  1.2564],\n            [ 0.0669, -0.2318, -0.8229, -0.9280]])\n\n\n    >>> torch.argsort(a, dim=1)\n    tensor([[2, 0, 3, 1],\n            [3, 2, 1, 0],\n            [2, 1, 0, 3],\n            [3, 2, 1, 0]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "-1"
        },
        "descending": {
          "Type": null,
          "Default": "False"
        },
        "stable": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "argwhere": {
      "Doc": "\nargwhere(input) -> Tensor\n\nReturns a tensor containing the indices of all non-zero elements of\n:attr:`input`.  Each row in the result contains the indices of a non-zero\nelement in :attr:`input`. The result is sorted lexicographically, with\nthe last index changing the fastest (C-style).\n\nIf :attr:`input` has :math:`n` dimensions, then the resulting indices tensor\n:attr:`out` is of size :math:`(z \\times n)`, where :math:`z` is the total number of\nnon-zero elements in the :attr:`input` tensor.\n\n.. note::\n    This function is similar to NumPy's `argwhere`.\n\n    When :attr:`input` is on CUDA, this function causes host-device synchronization.\n\nArgs:\n    {input}\n\nExample::\n\n    >>> t = torch.tensor([1, 0, 1])\n    >>> torch.argwhere(t)\n    tensor([[0],\n            [2]])\n    >>> t = torch.tensor([[1, 0, 1], [0, 1, 1]])\n    >>> torch.argwhere(t)\n    tensor([[0, 0],\n            [0, 2],\n            [1, 1],\n            [1, 2]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "as_strided": {
      "Doc": "\nas_strided(input, size, stride, storage_offset=None) -> Tensor\n\nCreate a view of an existing `torch.Tensor` :attr:`input` with specified\n:attr:`size`, :attr:`stride` and :attr:`storage_offset`.\n\n.. warning::\n    Prefer using other view functions, like :meth:`torch.Tensor.expand`,\n    to setting a view's strides manually with `as_strided`, as this\n    function's behavior depends on the implementation of a tensor's storage.\n    The constructed view of the storage must only refer to elements within\n    the storage or a runtime error will be thrown, and if the view is\n    \"overlapped\" (with multiple indices referring to the same element in\n    memory) its behavior is undefined.\n\nArgs:\n    input (Tensor): the input tensor.\n    size (tuple or ints): the shape of the output tensor\n    stride (tuple or ints): the stride of the output tensor\n    storage_offset (int, optional): the offset in the underlying storage of the output tensor.\n    If ``None``, the storage_offset of the output tensor will match the input tensor.\n\nExample::\n\n    >>> x = torch.randn(3, 3)\n    >>> x\n    tensor([[ 0.9039,  0.6291,  1.0795],\n            [ 0.1586,  2.1939, -0.4900],\n            [-0.1909, -0.7503,  1.9355]])\n    >>> t = torch.as_strided(x, (2, 2), (1, 2))\n    >>> t\n    tensor([[0.9039, 1.0795],\n            [0.6291, 0.1586]])\n    >>> t = torch.as_strided(x, (2, 2), (1, 2), 1)\n    tensor([[0.6291, 0.1586],\n            [1.0795, 2.1939]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "size": {
          "Type": null,
          "Default": null
        },
        "stride": {
          "Type": null,
          "Default": null
        },
        "storage_offset": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "as_strided_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.as_strided`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "as_strided_scatter": {
      "Doc": "\nas_strided_scatter(input, src, size, stride, storage_offset=0) -> Tensor\n\nEmbeds the values of the :attr:`src` tensor into :attr:`input` along\nthe elements corresponding to the result of calling\ninput.as_strided(size, stride, storage_offset).\n\nThis function returns a tensor with fresh storage; it does not\nreturn a view.\n\nArgs:\n    input (Tensor): the input tensor.\n    size (tuple or ints): the shape of the output tensor\n    stride (tuple or ints): the stride of the output tensor\n    storage_offset (int, optional): the offset in the underlying storage of the output tensor\n\n.. note::\n\n    :attr:`src` must be of the proper size in order to be embedded\n    into :attr:`input`. Specifically, it should have the same shape as\n    `torch.as_strided(input, size, stride, storage_offset)`\n\nExample::\n\n    >>> a = torch.arange(4).reshape(2, 2) + 1\n    >>> a\n    tensor([[1, 2],\n            [3, 4]])\n    >>> b = torch.zeros(3, 3)\n    >>> b\n    tensor([[0., 0., 0.],\n            [0., 0., 0.],\n            [0., 0., 0.]])\n    >>> torch.as_strided_scatter(b, a, (2, 2), (1, 2))\n    tensor([[1., 3., 2.],\n            [4., 0., 0.],\n            [0., 0., 0.]])\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "src": {
          "Type": null,
          "Default": null
        },
        "size": {
          "Type": null,
          "Default": null
        },
        "stride": {
          "Type": null,
          "Default": null
        },
        "storage_offset": {
          "Type": null,
          "Default": "0"
        }
      }
    },
    "as_tensor": {
      "Doc": "\nas_tensor(data, dtype=None, device=None) -> Tensor\n\nConverts data into a tensor, sharing data and preserving autograd\nhistory if possible.\n\nIf data is already a tensor with the requested dtype and device\nthen data itself is returned, but if data is a\ntensor with a different dtype or device then it's copied as if using\n`data.to(dtype=dtype, device=device)`.\n\nIf data is a NumPy array (an ndarray) with the same dtype and device then a\ntensor is constructed using :func:`torch.from_numpy`.\n\n.. seealso::\n\n    :func:`torch.tensor` never shares its data and creates a new \"leaf tensor\" (see :doc:`/notes/autograd`).\n\n\nArgs:\n    data (array_like): Initial data for the tensor. Can be a list, tuple,\n        NumPy ``ndarray``, scalar, and other types.\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, infers data type from :attr:`data`.\n    device (:class:`torch.device`, optional): the device of the constructed tensor. If None and data is a tensor\n        then the device of data is used. If None and data is not a tensor then\n        the result tensor is constructed on the CPU.\n\n\nExample::\n\n    >>> a = numpy.array([1, 2, 3])\n    >>> t = torch.as_tensor(a)\n    >>> t\n    tensor([ 1,  2,  3])\n    >>> t[0] = -1\n    >>> a\n    array([-1,  2,  3])\n\n    >>> a = numpy.array([1, 2, 3])\n    >>> t = torch.as_tensor(a, device=torch.device('cuda'))\n    >>> t\n    tensor([ 1,  2,  3])\n    >>> t[0] = -1\n    >>> a\n    array([1,  2,  3])\n",
      "Args": {
        "data": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "device": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "asarray": {
      "Doc": "\nasarray(obj, *, dtype=None, device=None, copy=None, requires_grad=False) -> Tensor\n\nConverts :attr:`obj` to a tensor.\n\n:attr:`obj` can be one of:\n\n1. a tensor\n2. a NumPy array\n3. a DLPack capsule\n4. an object that implements Python's buffer protocol\n5. a scalar\n6. a sequence of scalars\n\nWhen :attr:`obj` is a tensor, NumPy array, or DLPack capsule the returned tensor will,\nby default, not require a gradient, have the same datatype as :attr:`obj`, be on the\nsame device, and share memory with it. These properties can be controlled with the\n:attr:`dtype`, :attr:`device`, :attr:`copy`, and :attr:`requires_grad` keyword arguments.\nIf the returned tensor is of a different datatype, on a different device, or a copy is\nrequested then it will not share its memory with :attr:`obj`. If :attr:`requires_grad`\nis ``True`` then the returned tensor will require a gradient, and if :attr:`obj` is\nalso a tensor with an autograd history then the returned tensor will have the same history.\n\nWhen :attr:`obj` is not a tensor, NumPy Array, or DLPack capsule but implements Python's\nbuffer protocol then the buffer is interpreted as an array of bytes grouped according to\nthe size of the datatype passed to the :attr:`dtype` keyword argument. (If no datatype is\npassed then the default floating point datatype is used, instead.) The returned tensor\nwill have the specified datatype (or default floating point datatype if none is specified)\nand, by default, be on the CPU device and share memory with the buffer.\n\nWhen :attr:`obj` is none of the above but a scalar or sequence of scalars then the\nreturned tensor will, by default, infer its datatype from the scalar values, be on the\nCPU device, and not share its memory.\n\n.. seealso::\n\n    :func:`torch.tensor` creates a tensor that always copies the data from the input object.\n    :func:`torch.from_numpy` creates a tensor that always shares memory from NumPy arrays.\n    :func:`torch.frombuffer` creates a tensor that always shares memory from objects that\n    implement the buffer protocol.\n    :func:`torch.from_dlpack` creates a tensor that always shares memory from\n    DLPack capsules.\n\nArgs:\n    obj (object): a tensor, NumPy array, DLPack Capsule, object that implements Python's\n           buffer protocol, scalar, or sequence of scalars.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the datatype of the returned tensor.\n           Default: ``None``, which causes the datatype of the returned tensor to be\n           inferred from :attr:`obj`.\n    copy (bool, optional): controls whether the returned tensor shares memory with :attr:`obj`.\n           Default: ``None``, which causes the returned tensor to share memory with :attr:`obj`\n           whenever possible. If ``True`` then the returned tensor does not share its memory.\n           If ``False`` then the returned tensor shares its memory with :attr:`obj` and an\n           error is thrown if it cannot.\n    device (:class:`torch.device`, optional): the device of the returned tensor.\n           Default: ``None``, which causes the device of :attr:`obj` to be used.\n    requires_grad (bool, optional): whether the returned tensor requires grad.\n           Default: ``False``, which causes the returned tensor not to require a gradient.\n           If ``True``, then the returned tensor will require a gradient, and if :attr:`obj`\n           is also a tensor with an autograd history then the returned tensor will have\n           the same history.\n\nExample::\n\n    >>> a = torch.tensor([1, 2, 3])\n    >>> # Shares memory with tensor 'a'\n    >>> b = torch.asarray(a)\n    >>> a.data_ptr() == b.data_ptr()\n    True\n    >>> # Forces memory copy\n    >>> c = torch.asarray(a, copy=True)\n    >>> a.data_ptr() == c.data_ptr()\n    False\n\n    >>> a = torch.tensor([1, 2, 3], requires_grad=True).float()\n    >>> b = a + 2\n    >>> b\n    tensor([1., 2., 3.], grad_fn=<AddBackward0>)\n    >>> # Shares memory with tensor 'b', with no grad\n    >>> c = torch.asarray(b)\n    >>> c\n    tensor([1., 2., 3.])\n    >>> # Shares memory with tensor 'b', retaining autograd history\n    >>> d = torch.asarray(b, requires_grad=True)\n    >>> d\n    tensor([1., 2., 3.], grad_fn=<AddBackward0>)\n\n    >>> array = numpy.array([1, 2, 3])\n    >>> # Shares memory with array 'array'\n    >>> t1 = torch.asarray(array)\n    >>> array.__array_interface__['data'][0] == t1.data_ptr()\n    True\n    >>> # Copies memory due to dtype mismatch\n    >>> t2 = torch.asarray(array, dtype=torch.float32)\n    >>> array.__array_interface__['data'][0] == t1.data_ptr()\n    False\n",
      "Args": {
        "obj": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "copy": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "asin": {
      "Doc": "\nasin(input, *, out=None) -> Tensor\n\nReturns a new tensor with the arcsine  of the elements of :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\sin^{-1}(\\text{input}_{i})\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([-0.5962,  1.4985, -0.4396,  1.4525])\n    >>> torch.asin(a)\n    tensor([-0.6387,     nan, -0.4552,     nan])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "asinh": {
      "Doc": "\nasinh(input, *, out=None) -> Tensor\n\nReturns a new tensor with the inverse hyperbolic sine of the elements of :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\sinh^{-1}(\\text{input}_{i})\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword arguments:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 0.1606, -1.4267, -1.0899, -1.0250 ])\n    >>> torch.asinh(a)\n    tensor([ 0.1599, -1.1534, -0.9435, -0.8990 ])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "atan": {
      "Doc": "\natan(input, *, out=None) -> Tensor\n\nReturns a new tensor with the arctangent  of the elements of :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\tan^{-1}(\\text{input}_{i})\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 0.2341,  0.2539, -0.6256, -0.6448])\n    >>> torch.atan(a)\n    tensor([ 0.2299,  0.2487, -0.5591, -0.5727])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "atan2": {
      "Doc": "\natan2(input, other, *, out=None) -> Tensor\n\nElement-wise arctangent of :math:`\\text{input}_{i} / \\text{other}_{i}`\nwith consideration of the quadrant. Returns a new tensor with the signed angles\nin radians between vector :math:`(\\text{other}_{i}, \\text{input}_{i})`\nand vector :math:`(1, 0)`. (Note that :math:`\\text{other}_{i}`, the second\nparameter, is the x-coordinate, while :math:`\\text{input}_{i}`, the first\nparameter, is the y-coordinate.)\n\nThe shapes of ``input`` and ``other`` must be\n:ref:`broadcastable <broadcasting-semantics>`.\n\nArgs:\n    input (Tensor): the first input tensor\n    other (Tensor): the second input tensor\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 0.9041,  0.0196, -0.3108, -2.4423])\n    >>> torch.atan2(a, torch.randn(4))\n    tensor([ 0.9833,  0.0811, -1.9743, -1.4151])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "atanh": {
      "Doc": "\natanh(input, *, out=None) -> Tensor\n\nReturns a new tensor with the inverse hyperbolic tangent of the elements of :attr:`input`.\n\nNote:\n    The domain of the inverse hyperbolic tangent is `(-1, 1)` and values outside this range\n    will be mapped to ``NaN``, except for the values `1` and `-1` for which the output is\n    mapped to `+/-INF` respectively.\n\n.. math::\n    \\text{out}_{i} = \\tanh^{-1}(\\text{input}_{i})\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword arguments:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4).uniform_(-1, 1)\n    >>> a\n    tensor([ -0.9385, 0.2968, -0.8591, -0.1871 ])\n    >>> torch.atanh(a)\n    tensor([ -1.7253, 0.3060, -1.2899, -0.1893 ])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "atleast_1d": {
      "Doc": "\n    Returns a 1-dimensional view of each input tensor with zero dimensions.\n    Input tensors with one or more dimensions are returned as-is.\n\n    Args:\n        input (Tensor or list of Tensors)\n\n    Returns:\n        output (Tensor or tuple of Tensors)\n\n    Example::\n\n        >>> x = torch.arange(2)\n        >>> x\n        tensor([0, 1])\n        >>> torch.atleast_1d(x)\n        tensor([0, 1])\n        >>> x = torch.tensor(1.)\n        >>> x\n        tensor(1.)\n        >>> torch.atleast_1d(x)\n        tensor([1.])\n        >>> x = torch.tensor(0.5)\n        >>> y = torch.tensor(1.)\n        >>> torch.atleast_1d((x,y))\n        (tensor([0.5000]), tensor([1.]))\n    ",
      "Args": {
        "*tensors": {
          "Type": null,
          "Default": null
        }
      }
    },
    "atleast_2d": {
      "Doc": "\n    Returns a 2-dimensional view of each input tensor with zero dimensions.\n    Input tensors with two or more dimensions are returned as-is.\n\n    Args:\n        input (Tensor or list of Tensors)\n\n    Returns:\n        output (Tensor or tuple of Tensors)\n\n    Example::\n\n        >>> x = torch.tensor(1.)\n        >>> x\n        tensor(1.)\n        >>> torch.atleast_2d(x)\n        tensor([[1.]])\n        >>> x = torch.arange(4).view(2,2)\n        >>> x\n        tensor([[0, 1],\n                [2, 3]])\n        >>> torch.atleast_2d(x)\n        tensor([[0, 1],\n                [2, 3]])\n        >>> x = torch.tensor(0.5)\n        >>> y = torch.tensor(1.)\n        >>> torch.atleast_2d((x,y))\n        (tensor([[0.5000]]), tensor([[1.]]))\n    ",
      "Args": {
        "*tensors": {
          "Type": null,
          "Default": null
        }
      }
    },
    "atleast_3d": {
      "Doc": "\n    Returns a 3-dimensional view of each input tensor with zero dimensions.\n    Input tensors with three or more dimensions are returned as-is.\n\n    Args:\n        input (Tensor or list of Tensors)\n\n    Returns:\n        output (Tensor or tuple of Tensors)\n\n    Example:\n\n        >>> x = torch.tensor(0.5)\n        >>> x\n        tensor(0.5000)\n        >>> torch.atleast_3d(x)\n        tensor([[[0.5000]]])\n        >>> y = torch.arange(4).view(2,2)\n        >>> y\n        tensor([[0, 1],\n                [2, 3]])\n        >>> torch.atleast_3d(y)\n        tensor([[[0],\n                 [1]],\n                <BLANKLINE>\n                [[2],\n                 [3]]])\n        >>> x = torch.tensor(1).view(1, 1, 1)\n        >>> x\n        tensor([[[1]]])\n        >>> torch.atleast_3d(x)\n        tensor([[[1]]])\n        >>> x = torch.tensor(0.5)\n        >>> y = torch.tensor(1.)\n        >>> torch.atleast_3d((x,y))\n        (tensor([[[0.5000]]]), tensor([[[1.]]]))\n    ",
      "Args": {
        "*tensors": {
          "Type": null,
          "Default": null
        }
      }
    },
    "autocast_decrement_nesting": {
      "Doc": null,
      "Args": null
    },
    "autocast_increment_nesting": {
      "Doc": null,
      "Args": null
    },
    "avg_pool1d": {
      "Doc": "\navg_pool1d(input, kernel_size, stride=None, padding=0, ceil_mode=False, count_include_pad=True) -> Tensor\n\nApplies a 1D average pooling over an input signal composed of several\ninput planes.\n\nSee :class:`~torch.nn.AvgPool1d` for details and output shape.\n\nArgs:\n    input: input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iW)`\n    kernel_size: the size of the window. Can be a single number or a\n      tuple `(kW,)`\n    stride: the stride of the window. Can be a single number or a tuple\n      `(sW,)`. Default: :attr:`kernel_size`\n    padding: implicit zero paddings on both sides of the input. Can be a\n      single number or a tuple `(padW,)`. Default: 0\n    ceil_mode: when True, will use `ceil` instead of `floor` to compute the\n        output shape. Default: ``False``\n    count_include_pad: when True, will include the zero-padding in the\n        averaging calculation. Default: ``True``\n\nExamples::\n\n    >>> # pool of square window of size=3, stride=2\n    >>> input = torch.tensor([[[1, 2, 3, 4, 5, 6, 7]]], dtype=torch.float32)\n    >>> F.avg_pool1d(input, kernel_size=3, stride=2)\n    tensor([[[ 2.,  4.,  6.]]])\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "kernel_size": {
          "Type": null,
          "Default": null
        },
        "stride": {
          "Type": null,
          "Default": "None"
        },
        "padding": {
          "Type": null,
          "Default": "0"
        },
        "ceil_mode": {
          "Type": null,
          "Default": "False"
        },
        "count_include_pad": {
          "Type": null,
          "Default": "True"
        }
      }
    },
    "baddbmm": {
      "Doc": "\nbaddbmm(input, batch1, batch2, *, beta=1, alpha=1, out=None) -> Tensor\n\nPerforms a batch matrix-matrix product of matrices in :attr:`batch1`\nand :attr:`batch2`.\n:attr:`input` is added to the final result.\n\n:attr:`batch1` and :attr:`batch2` must be 3-D tensors each containing the same\nnumber of matrices.\n\nIf :attr:`batch1` is a :math:`(b \\times n \\times m)` tensor, :attr:`batch2` is a\n:math:`(b \\times m \\times p)` tensor, then :attr:`input` must be\n:ref:`broadcastable <broadcasting-semantics>` with a\n:math:`(b \\times n \\times p)` tensor and :attr:`out` will be a\n:math:`(b \\times n \\times p)` tensor. Both :attr:`alpha` and :attr:`beta` mean the\nsame as the scaling factors used in :meth:`torch.addbmm`.\n\n.. math::\n    \\text{out}_i = \\beta\\ \\text{input}_i + \\alpha\\ (\\text{batch1}_i \\mathbin{@} \\text{batch2}_i)\n\nIf :attr:`beta` is 0, then :attr:`input` will be ignored, and `nan` and `inf` in\nit will not be propagated.\n\nFor inputs of type `FloatTensor` or `DoubleTensor`, arguments :attr:`beta` and\n:attr:`alpha` must be real numbers, otherwise they should be integers.\n\nThis operator supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\nOn certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.\n\nArgs:\n    input (Tensor): the tensor to be added\n    batch1 (Tensor): the first batch of matrices to be multiplied\n    batch2 (Tensor): the second batch of matrices to be multiplied\n\nKeyword args:\n    beta (Number, optional): multiplier for :attr:`input` (:math:`\\beta`)\n    alpha (Number, optional): multiplier for :math:`\\text{batch1} \\mathbin{@} \\text{batch2}` (:math:`\\alpha`)\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> M = torch.randn(10, 3, 5)\n    >>> batch1 = torch.randn(10, 3, 4)\n    >>> batch2 = torch.randn(10, 4, 5)\n    >>> torch.baddbmm(M, batch1, batch2).size()\n    torch.Size([10, 3, 5])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "batch1": {
          "Type": null,
          "Default": null
        },
        "batch2": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "beta": {
          "Type": null,
          "Default": "1"
        },
        "alpha": {
          "Type": null,
          "Default": "1"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "bartlett_window": {
      "Doc": "\nbartlett_window(window_length, periodic=True, *, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nBartlett window function.\n\n.. math::\n    w[n] = 1 - \\left| \\frac{2n}{N-1} - 1 \\right| = \\begin{cases}\n        \\frac{2n}{N - 1} & \\text{if } 0 \\leq n \\leq \\frac{N - 1}{2} \\\\\n        2 - \\frac{2n}{N - 1} & \\text{if } \\frac{N - 1}{2} < n < N \\\\\n    \\end{cases},\n\nwhere :math:`N` is the full window size.\n\nThe input :attr:`window_length` is a positive integer controlling the\nreturned window size. :attr:`periodic` flag determines whether the returned\nwindow trims off the last duplicate value from the symmetric window and is\nready to be used as a periodic window with functions like\n:meth:`torch.stft`. Therefore, if :attr:`periodic` is true, the :math:`N` in\nabove formula is in fact :math:`\\text{window\\_length} + 1`. Also, we always have\n``torch.bartlett_window(L, periodic=True)`` equal to\n``torch.bartlett_window(L + 1, periodic=False)[:-1])``.\n\n.. note::\n    If :attr:`window_length` :math:`=1`, the returned window contains a single value 1.\n\nArguments:\n    window_length (int): the size of returned window\n    periodic (bool, optional): If True, returns a window to be used as periodic\n        function. If False, return a symmetric window.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`). Only floating point types are supported.\n    layout (:class:`torch.layout`, optional): the desired layout of returned window tensor. Only\n          ``torch.strided`` (dense layout) is supported.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n\nReturns:\n    Tensor: A 1-D tensor of size :math:`(\\text{window\\_length},)` containing the window\n\n",
      "Args": {
        "window_length": {
          "Type": null,
          "Default": null
        },
        "periodic": {
          "Type": null,
          "Default": "True"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "torch.strided"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "batch_norm": {
      "Doc": null,
      "Args": null
    },
    "batch_norm_backward_elemt": {
      "Doc": null,
      "Args": null
    },
    "batch_norm_backward_reduce": {
      "Doc": null,
      "Args": null
    },
    "batch_norm_elemt": {
      "Doc": null,
      "Args": null
    },
    "batch_norm_gather_stats": {
      "Doc": null,
      "Args": null
    },
    "batch_norm_gather_stats_with_counts": {
      "Doc": null,
      "Args": null
    },
    "batch_norm_stats": {
      "Doc": null,
      "Args": null
    },
    "batch_norm_update_stats": {
      "Doc": null,
      "Args": null
    },
    "bernoulli": {
      "Doc": "\nbernoulli(input, *, generator=None, out=None) -> Tensor\n\nDraws binary random numbers (0 or 1) from a Bernoulli distribution.\n\nThe :attr:`input` tensor should be a tensor containing probabilities\nto be used for drawing the binary random number.\nHence, all values in :attr:`input` have to be in the range:\n:math:`0 \\leq \\text{input}_i \\leq 1`.\n\nThe :math:`\\text{i}^{th}` element of the output tensor will draw a\nvalue :math:`1` according to the :math:`\\text{i}^{th}` probability value given\nin :attr:`input`.\n\n.. math::\n    \\text{out}_{i} \\sim \\mathrm{Bernoulli}(p = \\text{input}_{i})\n\nThe returned :attr:`out` tensor only has values 0 or 1 and is of the same\nshape as :attr:`input`.\n\n:attr:`out` can have integral ``dtype``, but :attr:`input` must have floating\npoint ``dtype``.\n\nArgs:\n    input (Tensor): the input tensor of probability values for the Bernoulli distribution\n\nKeyword args:\n    generator (:class:`torch.Generator`, optional): a pseudorandom number generator for sampling\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.empty(3, 3).uniform_(0, 1)  # generate a uniform random matrix with range [0, 1]\n    >>> a\n    tensor([[ 0.1737,  0.0950,  0.3609],\n            [ 0.7148,  0.0289,  0.2676],\n            [ 0.9456,  0.8937,  0.7202]])\n    >>> torch.bernoulli(a)\n    tensor([[ 1.,  0.,  0.],\n            [ 0.,  0.,  0.],\n            [ 1.,  1.,  1.]])\n\n    >>> a = torch.ones(3, 3) # probability of drawing \"1\" is 1\n    >>> torch.bernoulli(a)\n    tensor([[ 1.,  1.,  1.],\n            [ 1.,  1.,  1.],\n            [ 1.,  1.,  1.]])\n    >>> a = torch.zeros(3, 3) # probability of drawing \"1\" is 0\n    >>> torch.bernoulli(a)\n    tensor([[ 0.,  0.,  0.],\n            [ 0.,  0.,  0.],\n            [ 0.,  0.,  0.]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "generator": {
          "Type": null,
          "Default": "None"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "bilinear": {
      "Doc": "\nbilinear(input1, input2, weight, bias=None) -> Tensor\n\nApplies a bilinear transformation to the incoming data:\n:math:`y = x_1^T A x_2 + b`\n\nShape:\n\n    - input1: :math:`(N, *, H_{in1})` where :math:`H_{in1}=\\text{in1\\_features}`\n      and :math:`*` means any number of additional dimensions.\n      All but the last dimension of the inputs should be the same.\n    - input2: :math:`(N, *, H_{in2})` where :math:`H_{in2}=\\text{in2\\_features}`\n    - weight: :math:`(\\text{out\\_features}, \\text{in1\\_features},\n      \\text{in2\\_features})`\n    - bias: :math:`(\\text{out\\_features})`\n    - output: :math:`(N, *, H_{out})` where :math:`H_{out}=\\text{out\\_features}`\n      and all but the last dimension are the same shape as the input.\n",
      "Args": {
        "input1": {
          "Type": null,
          "Default": null
        },
        "input2": {
          "Type": null,
          "Default": null
        },
        "weight": {
          "Type": null,
          "Default": null
        },
        "bias": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "binary_cross_entropy_with_logits": {
      "Doc": null,
      "Args": null
    },
    "bincount": {
      "Doc": "\nbincount(input, weights=None, minlength=0) -> Tensor\n\nCount the frequency of each value in an array of non-negative ints.\n\nThe number of bins (size 1) is one larger than the largest value in\n:attr:`input` unless :attr:`input` is empty, in which case the result is a\ntensor of size 0. If :attr:`minlength` is specified, the number of bins is at least\n:attr:`minlength` and if :attr:`input` is empty, then the result is tensor of size\n:attr:`minlength` filled with zeros. If ``n`` is the value at position ``i``,\n``out[n] += weights[i]`` if :attr:`weights` is specified else\n``out[n] += 1``.\n\nNote:\n    This operation may produce nondeterministic gradients when given tensors on a CUDA device. See :doc:`/notes/randomness` for more information.\n\nArguments:\n    input (Tensor): 1-d int tensor\n    weights (Tensor): optional, weight for each value in the input tensor.\n        Should be of same size as input tensor.\n    minlength (int): optional, minimum number of bins. Should be non-negative.\n\nReturns:\n    output (Tensor): a tensor of shape ``Size([max(input) + 1])`` if\n    :attr:`input` is non-empty, else ``Size(0)``\n\nExample::\n\n    >>> input = torch.randint(0, 8, (5,), dtype=torch.int64)\n    >>> weights = torch.linspace(0, 1, steps=5)\n    >>> input, weights\n    (tensor([4, 3, 6, 3, 4]),\n     tensor([ 0.0000,  0.2500,  0.5000,  0.7500,  1.0000])\n\n    >>> torch.bincount(input)\n    tensor([0, 0, 0, 2, 2, 0, 1])\n\n    >>> input.bincount(weights)\n    tensor([0.0000, 0.0000, 0.0000, 1.0000, 1.0000, 0.0000, 0.5000])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "weights": {
          "Type": null,
          "Default": "None"
        },
        "minlength": {
          "Type": null,
          "Default": "0"
        }
      }
    },
    "binomial": {
      "Doc": null,
      "Args": null
    },
    "bitwise_and": {
      "Doc": "\nbitwise_and(input, other, *, out=None) -> Tensor\n\nComputes the bitwise AND of :attr:`input` and :attr:`other`. The input tensor must be of\nintegral or Boolean types. For bool tensors, it computes the logical AND.\n\nArgs:\n    input: the first input tensor\n    other: the second input tensor\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample:\n\n    >>> torch.bitwise_and(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))\n    tensor([1, 0,  3], dtype=torch.int8)\n    >>> torch.bitwise_and(torch.tensor([True, True, False]), torch.tensor([False, True, False]))\n    tensor([ False, True, False])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "bitwise_left_shift": {
      "Doc": "\nbitwise_left_shift(input, other, *, out=None) -> Tensor\n\nComputes the left arithmetic shift of :attr:`input` by :attr:`other` bits.\nThe input tensor must be of integral type. This operator supports\n:ref:`broadcasting to a common shape <broadcasting-semantics>` and\n:ref:`type promotion <type-promotion-doc>`.\n\nThe operation applied is:\n\n.. math::\n    \\text{out}_i = \\text{input}_i << \\text{other}_i\n\nArgs:\n    input (Tensor or Scalar): the first input tensor\n    other (Tensor or Scalar): the second input tensor\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample:\n\n    >>> torch.bitwise_left_shift(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))\n    tensor([-2, -2, 24], dtype=torch.int8)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "bitwise_not": {
      "Doc": "\nbitwise_not(input, *, out=None) -> Tensor\n\nComputes the bitwise NOT of the given input tensor. The input tensor must be of\nintegral or Boolean types. For bool tensors, it computes the logical NOT.\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample:\n\n    >>> torch.bitwise_not(torch.tensor([-1, -2, 3], dtype=torch.int8))\n    tensor([ 0,  1, -4], dtype=torch.int8)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "bitwise_or": {
      "Doc": "\nbitwise_or(input, other, *, out=None) -> Tensor\n\nComputes the bitwise OR of :attr:`input` and :attr:`other`. The input tensor must be of\nintegral or Boolean types. For bool tensors, it computes the logical OR.\n\nArgs:\n    input: the first input tensor\n    other: the second input tensor\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample:\n\n    >>> torch.bitwise_or(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))\n    tensor([-1, -2,  3], dtype=torch.int8)\n    >>> torch.bitwise_or(torch.tensor([True, True, False]), torch.tensor([False, True, False]))\n    tensor([ True, True, False])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "bitwise_right_shift": {
      "Doc": "\nbitwise_right_shift(input, other, *, out=None) -> Tensor\n\nComputes the right arithmetic shift of :attr:`input` by :attr:`other` bits.\nThe input tensor must be of integral type. This operator supports\n:ref:`broadcasting to a common shape <broadcasting-semantics>` and\n:ref:`type promotion <type-promotion-doc>`.\n\nThe operation applied is:\n\n.. math::\n    \\text{out}_i = \\text{input}_i >> \\text{other}_i\n\nArgs:\n    input (Tensor or Scalar): the first input tensor\n    other (Tensor or Scalar): the second input tensor\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample:\n\n    >>> torch.bitwise_right_shift(torch.tensor([-2, -7, 31], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))\n    tensor([-1, -7,  3], dtype=torch.int8)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "bitwise_xor": {
      "Doc": "\nbitwise_xor(input, other, *, out=None) -> Tensor\n\nComputes the bitwise XOR of :attr:`input` and :attr:`other`. The input tensor must be of\nintegral or Boolean types. For bool tensors, it computes the logical XOR.\n\nArgs:\n    input: the first input tensor\n    other: the second input tensor\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample:\n\n    >>> torch.bitwise_xor(torch.tensor([-1, -2, 3], dtype=torch.int8), torch.tensor([1, 0, 3], dtype=torch.int8))\n    tensor([-2, -2,  0], dtype=torch.int8)\n    >>> torch.bitwise_xor(torch.tensor([True, True, False]), torch.tensor([False, True, False]))\n    tensor([ True, False, False])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "blackman_window": {
      "Doc": "\nblackman_window(window_length, periodic=True, *, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nBlackman window function.\n\n.. math::\n    w[n] = 0.42 - 0.5 \\cos \\left( \\frac{2 \\pi n}{N - 1} \\right) + 0.08 \\cos \\left( \\frac{4 \\pi n}{N - 1} \\right)\n\nwhere :math:`N` is the full window size.\n\nThe input :attr:`window_length` is a positive integer controlling the\nreturned window size. :attr:`periodic` flag determines whether the returned\nwindow trims off the last duplicate value from the symmetric window and is\nready to be used as a periodic window with functions like\n:meth:`torch.stft`. Therefore, if :attr:`periodic` is true, the :math:`N` in\nabove formula is in fact :math:`\\text{window\\_length} + 1`. Also, we always have\n``torch.blackman_window(L, periodic=True)`` equal to\n``torch.blackman_window(L + 1, periodic=False)[:-1])``.\n\n.. note::\n    If :attr:`window_length` :math:`=1`, the returned window contains a single value 1.\n\nArguments:\n    window_length (int): the size of returned window\n    periodic (bool, optional): If True, returns a window to be used as periodic\n        function. If False, return a symmetric window.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`). Only floating point types are supported.\n    layout (:class:`torch.layout`, optional): the desired layout of returned window tensor. Only\n          ``torch.strided`` (dense layout) is supported.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n\nReturns:\n    Tensor: A 1-D tensor of size :math:`(\\text{window\\_length},)` containing the window\n\n",
      "Args": {
        "window_length": {
          "Type": null,
          "Default": null
        },
        "periodic": {
          "Type": null,
          "Default": "True"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "torch.strided"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "block_diag": {
      "Doc": "Create a block diagonal matrix from provided tensors.\n\n    Args:\n        *tensors: One or more tensors with 0, 1, or 2 dimensions.\n\n    Returns:\n        Tensor: A 2 dimensional tensor with all the input tensors arranged in\n        order such that their upper left and lower right corners are\n        diagonally adjacent. All other elements are set to 0.\n\n    Example::\n\n        >>> import torch\n        >>> A = torch.tensor([[0, 1], [1, 0]])\n        >>> B = torch.tensor([[3, 4, 5], [6, 7, 8]])\n        >>> C = torch.tensor(7)\n        >>> D = torch.tensor([1, 2, 3])\n        >>> E = torch.tensor([[4], [5], [6]])\n        >>> torch.block_diag(A, B, C, D, E)\n        tensor([[0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                [0, 0, 3, 4, 5, 0, 0, 0, 0, 0],\n                [0, 0, 6, 7, 8, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 7, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 0, 1, 2, 3, 0],\n                [0, 0, 0, 0, 0, 0, 0, 0, 0, 4],\n                [0, 0, 0, 0, 0, 0, 0, 0, 0, 5],\n                [0, 0, 0, 0, 0, 0, 0, 0, 0, 6]])\n    ",
      "Args": {
        "*tensors": {
          "Type": null,
          "Default": null
        }
      }
    },
    "bmm": {
      "Doc": "\nbmm(input, mat2, *, out=None) -> Tensor\n\nPerforms a batch matrix-matrix product of matrices stored in :attr:`input`\nand :attr:`mat2`.\n\n:attr:`input` and :attr:`mat2` must be 3-D tensors each containing\nthe same number of matrices.\n\nIf :attr:`input` is a :math:`(b \\times n \\times m)` tensor, :attr:`mat2` is a\n:math:`(b \\times m \\times p)` tensor, :attr:`out` will be a\n:math:`(b \\times n \\times p)` tensor.\n\n.. math::\n    \\text{out}_i = \\text{input}_i \\mathbin{@} \\text{mat2}_i\n\nThis operator supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\nOn certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.\n\n.. note:: This function does not :ref:`broadcast <broadcasting-semantics>`.\n          For broadcasting matrix products, see :func:`torch.matmul`.\n\nArgs:\n    input (Tensor): the first batch of matrices to be multiplied\n    mat2 (Tensor): the second batch of matrices to be multiplied\n\nKeyword Args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> input = torch.randn(10, 3, 4)\n    >>> mat2 = torch.randn(10, 4, 5)\n    >>> res = torch.bmm(input, mat2)\n    >>> res.size()\n    torch.Size([10, 3, 5])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "mat2": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "broadcast_shapes": {
      "Doc": "broadcast_shapes(*shapes) -> Size\n\n    Similar to :func:`broadcast_tensors` but for shapes.\n\n    This is equivalent to\n    ``torch.broadcast_tensors(*map(torch.empty, shapes))[0].shape``\n    but avoids the need create to intermediate tensors. This is useful for\n    broadcasting tensors of common batch shape but different rightmost shape,\n    e.g. to broadcast mean vectors with covariance matrices.\n\n    Example::\n\n        >>> torch.broadcast_shapes((2,), (3, 1), (1, 1, 1))\n        torch.Size([1, 3, 2])\n\n    Args:\n        \\*shapes (torch.Size): Shapes of tensors.\n\n    Returns:\n        shape (torch.Size): A shape compatible with all input shapes.\n\n    Raises:\n        RuntimeError: If shapes are incompatible.\n    ",
      "Args": {
        "*shapes": {
          "Type": null,
          "Default": null
        }
      }
    },
    "broadcast_tensors": {
      "Doc": "broadcast_tensors(*tensors) -> List of Tensors\n\n    Broadcasts the given tensors according to :ref:`broadcasting-semantics`.\n\n    Args:\n        *tensors: any number of tensors of the same type\n\n    .. warning::\n\n        More than one element of a broadcasted tensor may refer to a single\n        memory location. As a result, in-place operations (especially ones that\n        are vectorized) may result in incorrect behavior. If you need to write\n        to the tensors, please clone them first.\n\n    Example::\n\n        >>> x = torch.arange(3).view(1, 3)\n        >>> y = torch.arange(2).view(2, 1)\n        >>> a, b = torch.broadcast_tensors(x, y)\n        >>> a.size()\n        torch.Size([2, 3])\n        >>> a\n        tensor([[0, 1, 2],\n                [0, 1, 2]])\n    ",
      "Args": {
        "*tensors": {
          "Type": null,
          "Default": null
        }
      }
    },
    "broadcast_to": {
      "Doc": "\nbroadcast_to(input, shape) -> Tensor\n\nBroadcasts :attr:`input` to the shape :attr:`\\shape`.\nEquivalent to calling ``input.expand(shape)``. See :meth:`~Tensor.expand` for details.\n\nArgs:\n    input (Tensor): the input tensor.\n    shape (list, tuple, or :class:`torch.Size`): the new shape.\n\nExample::\n\n    >>> x = torch.tensor([1, 2, 3])\n    >>> torch.broadcast_to(x, (3, 3))\n    tensor([[1, 2, 3],\n            [1, 2, 3],\n            [1, 2, 3]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "shape": {
          "Type": null,
          "Default": null
        }
      }
    },
    "bucketize": {
      "Doc": "\nbucketize(input, boundaries, *, out_int32=False, right=False, out=None) -> Tensor\n\nReturns the indices of the buckets to which each value in the :attr:`input` belongs, where the\nboundaries of the buckets are set by :attr:`boundaries`. Return a new tensor with the same size\nas :attr:`input`. If :attr:`right` is False (default), then the left boundary is closed. More\nformally, the returned index satisfies the following rules:\n\n.. list-table::\n   :widths: 15 85\n   :header-rows: 1\n\n   * - :attr:`right`\n     - *returned index satisfies*\n   * - False\n     - ``boundaries[i-1] < input[m][n]...[l][x] <= boundaries[i]``\n   * - True\n     - ``boundaries[i-1] <= input[m][n]...[l][x] < boundaries[i]``\n\nArgs:\n    input (Tensor or Scalar): N-D tensor or a Scalar containing the search value(s).\n    boundaries (Tensor): 1-D tensor, must contain a monotonically increasing sequence.\n\nKeyword args:\n    out_int32 (bool, optional): indicate the output data type. torch.int32 if True, torch.int64 otherwise.\n                                Default value is False, i.e. default output data type is torch.int64.\n    right (bool, optional): if False, return the first suitable location that is found. If True, return the\n                            last such index. If no suitable index found, return 0 for non-numerical value\n                            (eg. nan, inf) or the size of :attr:`boundaries` (one pass the last index).\n                            In other words, if False, gets the lower bound index for each value in :attr:`input`\n                            from :attr:`boundaries`. If True, gets the upper bound index instead.\n                            Default value is False.\n    out (Tensor, optional): the output tensor, must be the same size as :attr:`input` if provided.\n\n\nExample::\n\n    >>> boundaries = torch.tensor([1, 3, 5, 7, 9])\n    >>> boundaries\n    tensor([1, 3, 5, 7, 9])\n    >>> v = torch.tensor([[3, 6, 9], [3, 6, 9]])\n    >>> v\n    tensor([[3, 6, 9],\n            [3, 6, 9]])\n    >>> torch.bucketize(v, boundaries)\n    tensor([[1, 3, 4],\n            [1, 3, 4]])\n    >>> torch.bucketize(v, boundaries, right=True)\n    tensor([[2, 3, 5],\n            [2, 3, 5]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "boundaries": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out_int32": {
          "Type": null,
          "Default": "False"
        },
        "right": {
          "Type": null,
          "Default": "False"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "can_cast": {
      "Doc": "\ncan_cast(from, to) -> bool\n\nDetermines if a type conversion is allowed under PyTorch casting rules\ndescribed in the type promotion :ref:`documentation <type-promotion-doc>`.\n\nArgs:\n    from (dtype): The original :class:`torch.dtype`.\n    to (dtype): The target :class:`torch.dtype`.\n\nExample::\n\n    >>> torch.can_cast(torch.double, torch.float)\n    True\n    >>> torch.can_cast(torch.float, torch.int)\n    False\n",
      "Args": {
        "from": {
          "Type": null,
          "Default": null
        },
        "to": {
          "Type": null,
          "Default": null
        }
      }
    },
    "candidate": {
      "Doc": "wait(arg0: torch._C.Future) -> object\n",
      "Args": {
        "arg0": {
          "Type": "torch._C.Future",
          "Default": null
        }
      }
    },
    "cartesian_prod": {
      "Doc": "Do cartesian product of the given sequence of tensors. The behavior is similar to\n    python's `itertools.product`.\n\n    Args:\n        *tensors: any number of 1 dimensional tensors.\n\n    Returns:\n        Tensor: A tensor equivalent to converting all the input tensors into lists,\n        do `itertools.product` on these lists, and finally convert the resulting list\n        into tensor.\n\n    Example::\n\n        >>> import itertools\n        >>> a = [1, 2, 3]\n        >>> b = [4, 5]\n        >>> list(itertools.product(a, b))\n        [(1, 4), (1, 5), (2, 4), (2, 5), (3, 4), (3, 5)]\n        >>> tensor_a = torch.tensor(a)\n        >>> tensor_b = torch.tensor(b)\n        >>> torch.cartesian_prod(tensor_a, tensor_b)\n        tensor([[1, 4],\n                [1, 5],\n                [2, 4],\n                [2, 5],\n                [3, 4],\n                [3, 5]])\n    ",
      "Args": {
        "*tensors": {
          "Type": null,
          "Default": null
        }
      }
    },
    "cat": {
      "Doc": "\ncat(tensors, dim=0, *, out=None) -> Tensor\n\nConcatenates the given sequence of :attr:`seq` tensors in the given dimension.\nAll tensors must either have the same shape (except in the concatenating\ndimension) or be empty.\n\n:func:`torch.cat` can be seen as an inverse operation for :func:`torch.split`\nand :func:`torch.chunk`.\n\n:func:`torch.cat` can be best understood via examples.\n\nArgs:\n    tensors (sequence of Tensors): any python sequence of tensors of the same type.\n        Non-empty tensors provided must have the same shape, except in the\n        cat dimension.\n    dim (int, optional): the dimension over which the tensors are concatenated\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> x = torch.randn(2, 3)\n    >>> x\n    tensor([[ 0.6580, -1.0969, -0.4614],\n            [-0.1034, -0.5790,  0.1497]])\n    >>> torch.cat((x, x, x), 0)\n    tensor([[ 0.6580, -1.0969, -0.4614],\n            [-0.1034, -0.5790,  0.1497],\n            [ 0.6580, -1.0969, -0.4614],\n            [-0.1034, -0.5790,  0.1497],\n            [ 0.6580, -1.0969, -0.4614],\n            [-0.1034, -0.5790,  0.1497]])\n    >>> torch.cat((x, x, x), 1)\n    tensor([[ 0.6580, -1.0969, -0.4614,  0.6580, -1.0969, -0.4614,  0.6580,\n             -1.0969, -0.4614],\n            [-0.1034, -0.5790,  0.1497, -0.1034, -0.5790,  0.1497, -0.1034,\n             -0.5790,  0.1497]])\n",
      "Args": {
        "tensors": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "0"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "ccol_indices_copy": {
      "Doc": null,
      "Args": null
    },
    "cdist": {
      "Doc": "Computes batched the p-norm distance between each pair of the two collections of row vectors.\n\n    Args:\n        x1 (Tensor): input tensor of shape :math:`B \\times P \\times M`.\n        x2 (Tensor): input tensor of shape :math:`B \\times R \\times M`.\n        p: p value for the p-norm distance to calculate between each vector pair\n            :math:`\\in [0, \\infty]`.\n        compute_mode:\n            'use_mm_for_euclid_dist_if_necessary' - will use matrix multiplication approach to calculate\n            euclidean distance (p = 2) if P > 25 or R > 25\n            'use_mm_for_euclid_dist' - will always use matrix multiplication approach to calculate\n            euclidean distance (p = 2)\n            'donot_use_mm_for_euclid_dist' - will never use matrix multiplication approach to calculate\n            euclidean distance (p = 2)\n            Default: use_mm_for_euclid_dist_if_necessary.\n\n    If x1 has shape :math:`B \\times P \\times M` and x2 has shape :math:`B \\times R \\times M` then the\n    output will have shape :math:`B \\times P \\times R`.\n\n    This function is equivalent to `scipy.spatial.distance.cdist(input,'minkowski', p=p)`\n    if :math:`p \\in (0, \\infty)`. When :math:`p = 0` it is equivalent to\n    `scipy.spatial.distance.cdist(input, 'hamming') * M`. When :math:`p = \\infty`, the closest\n    scipy function is `scipy.spatial.distance.cdist(xn, lambda x, y: np.abs(x - y).max())`.\n\n    Example:\n\n        >>> a = torch.tensor([[0.9041,  0.0196], [-0.3108, -2.4423], [-0.4821,  1.059]])\n        >>> a\n        tensor([[ 0.9041,  0.0196],\n                [-0.3108, -2.4423],\n                [-0.4821,  1.0590]])\n        >>> b = torch.tensor([[-2.1763, -0.4713], [-0.6986,  1.3702]])\n        >>> b\n        tensor([[-2.1763, -0.4713],\n                [-0.6986,  1.3702]])\n        >>> torch.cdist(a, b, p=2)\n        tensor([[3.1193, 2.0959],\n                [2.7138, 3.8322],\n                [2.2830, 0.3791]])\n    ",
      "Args": {
        "x1": {
          "Type": null,
          "Default": null
        },
        "x2": {
          "Type": null,
          "Default": null
        },
        "p": {
          "Type": null,
          "Default": "2.0"
        },
        "compute_mode": {
          "Type": null,
          "Default": "use_mm_for_euclid_dist_if_necessary"
        }
      }
    },
    "ceil": {
      "Doc": "\nceil(input, *, out=None) -> Tensor\n\nReturns a new tensor with the ceil of the elements of :attr:`input`,\nthe smallest integer greater than or equal to each element.\n\nFor integer inputs, follows the array-api convention of returning a\ncopy of the input tensor.\n\n.. math::\n    \\text{out}_{i} = \\left\\lceil \\text{input}_{i} \\right\\rceil\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([-0.6341, -1.4208, -1.0900,  0.5826])\n    >>> torch.ceil(a)\n    tensor([-0., -1., -1.,  1.])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "celu": {
      "Doc": null,
      "Args": null
    },
    "chain_matmul": {
      "Doc": "Returns the matrix product of the :math:`N` 2-D tensors. This product is efficiently computed\n    using the matrix chain order algorithm which selects the order in which incurs the lowest cost in terms\n    of arithmetic operations (`[CLRS]`_). Note that since this is a function to compute the product, :math:`N`\n    needs to be greater than or equal to 2; if equal to 2 then a trivial matrix-matrix product is returned.\n    If :math:`N` is 1, then this is a no-op - the original matrix is returned as is.\n\n    .. warning::\n\n        :func:`torch.chain_matmul` is deprecated and will be removed in a future PyTorch release.\n        Use :func:`torch.linalg.multi_dot` instead, which accepts a list of two or more tensors\n        rather than multiple arguments.\n\n    Args:\n        matrices (Tensors...): a sequence of 2 or more 2-D tensors whose product is to be determined.\n        out (Tensor, optional): the output tensor. Ignored if :attr:`out` = ``None``.\n\n    Returns:\n        Tensor: if the :math:`i^{th}` tensor was of dimensions :math:`p_{i} \\times p_{i + 1}`, then the product\n        would be of dimensions :math:`p_{1} \\times p_{N + 1}`.\n\n    Example::\n\n        >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\")\n        >>> a = torch.randn(3, 4)\n        >>> b = torch.randn(4, 5)\n        >>> c = torch.randn(5, 6)\n        >>> d = torch.randn(6, 7)\n        >>> # will raise a deprecation warning\n        >>> torch.chain_matmul(a, b, c, d)\n        tensor([[ -2.3375,  -3.9790,  -4.1119,  -6.6577,   9.5609, -11.5095,  -3.2614],\n                [ 21.4038,   3.3378,  -8.4982,  -5.2457, -10.2561,  -2.4684,   2.7163],\n                [ -0.9647,  -5.8917,  -2.3213,  -5.2284,  12.8615, -12.2816,  -2.5095]])\n\n    .. _`[CLRS]`: https://mitpress.mit.edu/books/introduction-algorithms-third-edition\n    ",
      "Args": {
        "*matrices": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "channel_shuffle": {
      "Doc": "\nchannel_shuffle(input, groups) -> Tensor\n\nDivide the channels in a tensor of shape :math:`(*, C , H, W)`\ninto g groups and rearrange them as :math:`(*, C \\frac g, g, H, W)`,\nwhile keeping the original tensor shape.\n\nSee :class:`~torch.nn.ChannelShuffle` for details.\n\nArgs:\n    input (Tensor): the input tensor\n    groups (int): number of groups to divide channels in and rearrange.\n\nExamples::\n\n    >>> input = torch.randn(1, 4, 2, 2)\n    >>> print(input)\n    [[[[1, 2],\n       [3, 4]],\n      [[5, 6],\n       [7, 8]],\n      [[9, 10],\n       [11, 12]],\n      [[13, 14],\n       [15, 16]],\n     ]]\n    >>> output = torch.nn.functional.channel_shuffle(input, 2)\n    >>> print(output)\n    [[[[1, 2],\n       [3, 4]],\n      [[9, 10],\n       [11, 12]],\n      [[5, 6],\n       [7, 8]],\n      [[13, 14],\n       [15, 16]],\n     ]]\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "groups": {
          "Type": null,
          "Default": null
        }
      }
    },
    "cholesky": {
      "Doc": "\ncholesky(input, upper=False, *, out=None) -> Tensor\n\nComputes the Cholesky decomposition of a symmetric positive-definite\nmatrix :math:`A` or for batches of symmetric positive-definite matrices.\n\nIf :attr:`upper` is ``True``, the returned matrix ``U`` is upper-triangular, and\nthe decomposition has the form:\n\n.. math::\n\n  A = U^TU\n\nIf :attr:`upper` is ``False``, the returned matrix ``L`` is lower-triangular, and\nthe decomposition has the form:\n\n.. math::\n\n    A = LL^T\n\nIf :attr:`upper` is ``True``, and :math:`A` is a batch of symmetric positive-definite\nmatrices, then the returned tensor will be composed of upper-triangular Cholesky factors\nof each of the individual matrices. Similarly, when :attr:`upper` is ``False``, the returned\ntensor will be composed of lower-triangular Cholesky factors of each of the individual\nmatrices.\n\n.. warning::\n\n    :func:`torch.cholesky` is deprecated in favor of :func:`torch.linalg.cholesky`\n    and will be removed in a future PyTorch release.\n\n    ``L = torch.cholesky(A)`` should be replaced with\n\n    .. code:: python\n\n        L = torch.linalg.cholesky(A)\n\n    ``U = torch.cholesky(A, upper=True)`` should be replaced with\n\n    .. code:: python\n\n        U = torch.linalg.cholesky(A).mH\n\n    This transform will produce equivalent results for all valid (symmetric positive definite) inputs.\n\nArgs:\n    input (Tensor): the input tensor :math:`A` of size :math:`(*, n, n)` where `*` is zero or more\n                batch dimensions consisting of symmetric positive-definite matrices.\n    upper (bool, optional): flag that indicates whether to return a\n                            upper or lower triangular matrix. Default: ``False``\n\nKeyword args:\n    out (Tensor, optional): the output matrix\n\nExample::\n\n    >>> a = torch.randn(3, 3)\n    >>> a = a @ a.mT + 1e-3 # make symmetric positive-definite\n    >>> l = torch.cholesky(a)\n    >>> a\n    tensor([[ 2.4112, -0.7486,  1.4551],\n            [-0.7486,  1.3544,  0.1294],\n            [ 1.4551,  0.1294,  1.6724]])\n    >>> l\n    tensor([[ 1.5528,  0.0000,  0.0000],\n            [-0.4821,  1.0592,  0.0000],\n            [ 0.9371,  0.5487,  0.7023]])\n    >>> l @ l.mT\n    tensor([[ 2.4112, -0.7486,  1.4551],\n            [-0.7486,  1.3544,  0.1294],\n            [ 1.4551,  0.1294,  1.6724]])\n    >>> a = torch.randn(3, 2, 2) # Example for batched input\n    >>> a = a @ a.mT + 1e-03 # make symmetric positive-definite\n    >>> l = torch.cholesky(a)\n    >>> z = l @ l.mT\n    >>> torch.dist(z, a)\n    tensor(2.3842e-07)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "upper": {
          "Type": null,
          "Default": "False"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "cholesky_inverse": {
      "Doc": "\ncholesky_inverse(input, upper=False, *, out=None) -> Tensor\n\nComputes the inverse of a symmetric positive-definite matrix :math:`A` using its\nCholesky factor :math:`u`: returns matrix ``inv``. The inverse is computed using\nLAPACK routines ``dpotri`` and ``spotri`` (and the corresponding MAGMA routines).\n\nIf :attr:`upper` is ``False``, :math:`u` is lower triangular\nsuch that the returned tensor is\n\n.. math::\n    inv = (uu^{{T}})^{{-1}}\n\nIf :attr:`upper` is ``True`` or not provided, :math:`u` is upper\ntriangular such that the returned tensor is\n\n.. math::\n    inv = (u^T u)^{{-1}}\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :math:`A` is a batch of matrices then the output has the same batch dimensions.\n\nArgs:\n    input (Tensor): the input tensor :math:`A` of size :math:`(*, n, n)`,\n                consisting of symmetric positive-definite matrices\n                where :math:`*` is zero or more batch dimensions.\n    upper (bool, optional): flag that indicates whether to return a\n                upper or lower triangular matrix. Default: False\n\nKeyword args:\n    out (Tensor, optional): the output tensor for `inv`\n\nExample::\n\n    >>> a = torch.randn(3, 3)\n    >>> a = torch.mm(a, a.t()) + 1e-05 * torch.eye(3) # make symmetric positive definite\n    >>> u = torch.linalg.cholesky(a)\n    >>> a\n    tensor([[  0.9935,  -0.6353,   1.5806],\n            [ -0.6353,   0.8769,  -1.7183],\n            [  1.5806,  -1.7183,  10.6618]])\n    >>> torch.cholesky_inverse(u)\n    tensor([[ 1.9314,  1.2251, -0.0889],\n            [ 1.2251,  2.4439,  0.2122],\n            [-0.0889,  0.2122,  0.1412]])\n    >>> a.inverse()\n    tensor([[ 1.9314,  1.2251, -0.0889],\n            [ 1.2251,  2.4439,  0.2122],\n            [-0.0889,  0.2122,  0.1412]])\n    >>> a = torch.randn(3, 2, 2) # Example for batched input\n    >>> a = a @ a.mT + 1e-03 # make symmetric positive-definite\n    >>> l = torch.linalg.cholesky(a)\n    >>> z = l @ l.mT\n    >>> torch.dist(z, a)\n    tensor(3.5894e-07)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "upper": {
          "Type": null,
          "Default": "False"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "cholesky_solve": {
      "Doc": "\ncholesky_solve(input, input2, upper=False, *, out=None) -> Tensor\n\nSolves a linear system of equations with a positive semidefinite\nmatrix to be inverted given its Cholesky factor matrix :math:`u`.\n\nIf :attr:`upper` is ``False``, :math:`u` is and lower triangular and `c` is\nreturned such that:\n\n.. math::\n    c = (u u^T)^{{-1}} b\n\nIf :attr:`upper` is ``True`` or not provided, :math:`u` is upper triangular\nand `c` is returned such that:\n\n.. math::\n    c = (u^T u)^{{-1}} b\n\n`torch.cholesky_solve(b, u)` can take in 2D inputs `b, u` or inputs that are\nbatches of 2D matrices. If the inputs are batches, then returns\nbatched outputs `c`\n\nSupports real-valued and complex-valued inputs.\nFor the complex-valued inputs the transpose operator above is the conjugate transpose.\n\nArgs:\n    input (Tensor): input matrix :math:`b` of size :math:`(*, m, k)`,\n                where :math:`*` is zero or more batch dimensions\n    input2 (Tensor): input matrix :math:`u` of size :math:`(*, m, m)`,\n                where :math:`*` is zero of more batch dimensions composed of\n                upper or lower triangular Cholesky factor\n    upper (bool, optional): whether to consider the Cholesky factor as a\n                            lower or upper triangular matrix. Default: ``False``.\n\nKeyword args:\n    out (Tensor, optional): the output tensor for `c`\n\nExample::\n\n    >>> a = torch.randn(3, 3)\n    >>> a = torch.mm(a, a.t()) # make symmetric positive definite\n    >>> u = torch.linalg.cholesky(a)\n    >>> a\n    tensor([[ 0.7747, -1.9549,  1.3086],\n            [-1.9549,  6.7546, -5.4114],\n            [ 1.3086, -5.4114,  4.8733]])\n    >>> b = torch.randn(3, 2)\n    >>> b\n    tensor([[-0.6355,  0.9891],\n            [ 0.1974,  1.4706],\n            [-0.4115, -0.6225]])\n    >>> torch.cholesky_solve(b, u)\n    tensor([[ -8.1625,  19.6097],\n            [ -5.8398,  14.2387],\n            [ -4.3771,  10.4173]])\n    >>> torch.mm(a.inverse(), b)\n    tensor([[ -8.1626,  19.6097],\n            [ -5.8398,  14.2387],\n            [ -4.3771,  10.4173]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "input2": {
          "Type": null,
          "Default": null
        },
        "upper": {
          "Type": null,
          "Default": "False"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "choose_qparams_optimized": {
      "Doc": null,
      "Args": null
    },
    "chunk": {
      "Doc": "\nchunk(input, chunks, dim=0) -> List of Tensors\n\nAttempts to split a tensor into the specified number of chunks. Each chunk is a view of\nthe input tensor.\n\n\n.. note::\n\n    This function may return less then the specified number of chunks!\n\n.. seealso::\n\n    :func:`torch.tensor_split` a function that always returns exactly the specified number of chunks\n\nIf the tensor size along the given dimesion :attr:`dim` is divisible by :attr:`chunks`,\nall returned chunks will be the same size.\nIf the tensor size along the given dimension :attr:`dim` is not divisible by :attr:`chunks`,\nall returned chunks will be the same size, except the last one.\nIf such division is not possible, this function may return less\nthan the specified number of chunks.\n\nArguments:\n    input (Tensor): the tensor to split\n    chunks (int): number of chunks to return\n    dim (int): dimension along which to split the tensor\n\nExample::\n    >>> torch.arange(11).chunk(6)\n    (tensor([0, 1]),\n     tensor([2, 3]),\n     tensor([4, 5]),\n     tensor([6, 7]),\n     tensor([8, 9]),\n     tensor([10]))\n    >>> torch.arange(12).chunk(6)\n    (tensor([0, 1]),\n     tensor([2, 3]),\n     tensor([4, 5]),\n     tensor([6, 7]),\n     tensor([8, 9]),\n     tensor([10, 11]))\n    >>> torch.arange(13).chunk(6)\n    (tensor([0, 1, 2]),\n     tensor([3, 4, 5]),\n     tensor([6, 7, 8]),\n     tensor([ 9, 10, 11]),\n     tensor([12]))\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "chunks": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "0"
        }
      }
    },
    "clamp": {
      "Doc": "\nclamp(input, min=None, max=None, *, out=None) -> Tensor\n\nClamps all elements in :attr:`input` into the range `[` :attr:`min`, :attr:`max` `]`.\nLetting min_value and max_value be :attr:`min` and :attr:`max`, respectively, this returns:\n\n.. math::\n    y_i = \\min(\\max(x_i, \\text{min\\_value}_i), \\text{max\\_value}_i)\n\nIf :attr:`min` is ``None``, there is no lower bound.\nOr, if :attr:`max` is ``None`` there is no upper bound.\n\n\n.. note::\n    If :attr:`min` is greater than :attr:`max` :func:`torch.clamp(..., min, max) <torch.clamp>`\n    sets all elements in :attr:`input` to the value of :attr:`max`.\n\nArgs:\n    input (Tensor): the input tensor.\n    min (Number or Tensor, optional): lower-bound of the range to be clamped to\n    max (Number or Tensor, optional): upper-bound of the range to be clamped to\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([-1.7120,  0.1734, -0.0478, -0.0922])\n    >>> torch.clamp(a, min=-0.5, max=0.5)\n    tensor([-0.5000,  0.1734, -0.0478, -0.0922])\n\n    >>> min = torch.linspace(-1, 1, steps=4)\n    >>> torch.clamp(a, min=min)\n    tensor([-1.0000,  0.1734,  0.3333,  1.0000])\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "min": {
          "Type": null,
          "Default": "None"
        },
        "max": {
          "Type": null,
          "Default": "None"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "clamp_max": {
      "Doc": null,
      "Args": null
    },
    "clamp_min": {
      "Doc": null,
      "Args": null
    },
    "classproperty": {
      "Doc": null,
      "Args": {
        "func": {
          "Type": null,
          "Default": null
        }
      }
    },
    "clear_autocast_cache": {
      "Doc": null,
      "Args": null
    },
    "clip": {
      "Doc": "\nclip(input, min=None, max=None, *, out=None) -> Tensor\n\nAlias for :func:`torch.clamp`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "min": {
          "Type": null,
          "Default": "None"
        },
        "max": {
          "Type": null,
          "Default": "None"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "clone": {
      "Doc": "\nclone(input, *, memory_format=torch.preserve_format) -> Tensor\n\nReturns a copy of :attr:`input`.\n\n.. note::\n\n    This function is differentiable, so gradients will flow back from the\n    result of this operation to :attr:`input`. To create a tensor without an\n    autograd relationship to :attr:`input` see :meth:`~Tensor.detach`.\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    memory_format (:class:`torch.memory_format`, optional): the desired memory format of\n        returned tensor. Default: ``torch.preserve_format``.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "memory_format": {
          "Type": null,
          "Default": "torch.preserve_format"
        }
      }
    },
    "col_indices_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.col_indices`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "column_stack": {
      "Doc": "\ncolumn_stack(tensors, *, out=None) -> Tensor\n\nCreates a new tensor by horizontally stacking the tensors in :attr:`tensors`.\n\nEquivalent to ``torch.hstack(tensors)``, except each zero or one dimensional tensor ``t``\nin :attr:`tensors` is first reshaped into a ``(t.numel(), 1)`` column before being stacked horizontally.\n\nArgs:\n    tensors (sequence of Tensors): sequence of tensors to concatenate\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.tensor([1, 2, 3])\n    >>> b = torch.tensor([4, 5, 6])\n    >>> torch.column_stack((a, b))\n    tensor([[1, 4],\n        [2, 5],\n        [3, 6]])\n    >>> a = torch.arange(5)\n    >>> b = torch.arange(10).reshape(5, 2)\n    >>> torch.column_stack((a, b, b))\n    tensor([[0, 0, 1, 0, 1],\n            [1, 2, 3, 2, 3],\n            [2, 4, 5, 4, 5],\n            [3, 6, 7, 6, 7],\n            [4, 8, 9, 8, 9]])\n\n",
      "Args": {
        "tensors": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "combinations": {
      "Doc": "\ncombinations(input, r=2, with_replacement=False) -> seq\n\nCompute combinations of length :math:`r` of the given tensor. The behavior is similar to\npython's `itertools.combinations` when `with_replacement` is set to `False`, and\n`itertools.combinations_with_replacement` when `with_replacement` is set to `True`.\n\nArguments:\n    input (Tensor): 1D vector.\n    r (int, optional): number of elements to combine\n    with_replacement (bool, optional): whether to allow duplication in combination\n\nReturns:\n    Tensor: A tensor equivalent to converting all the input tensors into lists, do\n    `itertools.combinations` or `itertools.combinations_with_replacement` on these\n    lists, and finally convert the resulting list into tensor.\n\nExample::\n\n    >>> a = [1, 2, 3]\n    >>> list(itertools.combinations(a, r=2))\n    [(1, 2), (1, 3), (2, 3)]\n    >>> list(itertools.combinations(a, r=3))\n    [(1, 2, 3)]\n    >>> list(itertools.combinations_with_replacement(a, r=2))\n    [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]\n    >>> tensor_a = torch.tensor(a)\n    >>> torch.combinations(tensor_a)\n    tensor([[1, 2],\n            [1, 3],\n            [2, 3]])\n    >>> torch.combinations(tensor_a, r=3)\n    tensor([[1, 2, 3]])\n    >>> torch.combinations(tensor_a, with_replacement=True)\n    tensor([[1, 1],\n            [1, 2],\n            [1, 3],\n            [2, 2],\n            [2, 3],\n            [3, 3]])\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "r": {
          "Type": null,
          "Default": "2"
        },
        "with_replacement": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "compiled_with_cxx11_abi": {
      "Doc": "Returns whether PyTorch was built with _GLIBCXX_USE_CXX11_ABI=1",
      "Args": {}
    },
    "complex": {
      "Doc": "\ncomplex(real, imag, *, out=None) -> Tensor\n\nConstructs a complex tensor with its real part equal to :attr:`real` and its\nimaginary part equal to :attr:`imag`.\n\nArgs:\n    real (Tensor): The real part of the complex tensor. Must be float or double.\n    imag (Tensor): The imaginary part of the complex tensor. Must be same dtype\n        as :attr:`real`.\n\nKeyword args:\n    out (Tensor): If the inputs are ``torch.float32``, must be\n        ``torch.complex64``. If the inputs are ``torch.float64``, must be\n        ``torch.complex128``.\n\nExample::\n\n    >>> real = torch.tensor([1, 2], dtype=torch.float32)\n    >>> imag = torch.tensor([3, 4], dtype=torch.float32)\n    >>> z = torch.complex(real, imag)\n    >>> z\n    tensor([(1.+3.j), (2.+4.j)])\n    >>> z.dtype\n    torch.complex64\n\n",
      "Args": {
        "real": {
          "Type": null,
          "Default": null
        },
        "imag": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "concat": {
      "Doc": "\nconcat(tensors, dim=0, *, out=None) -> Tensor\n\nAlias of :func:`torch.cat`.\n",
      "Args": {
        "tensors": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "0"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "concatenate": {
      "Doc": "\nconcatenate(tensors, axis=0, out=None) -> Tensor\n\nAlias of :func:`torch.cat`.\n",
      "Args": {
        "tensors": {
          "Type": null,
          "Default": null
        },
        "axis": {
          "Type": null,
          "Default": "0"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "conj": {
      "Doc": "\nconj(input) -> Tensor\n\nReturns a view of :attr:`input` with a flipped conjugate bit. If :attr:`input` has a non-complex dtype,\nthis function just returns :attr:`input`.\n\n.. note::\n    :func:`torch.conj` performs a lazy conjugation, but the actual conjugated tensor can be materialized\n    at any time using :func:`torch.resolve_conj`.\n\n.. warning:: In the future, :func:`torch.conj` may return a non-writeable view for an :attr:`input` of\n             non-complex dtype. It's recommended that programs not modify the tensor returned by :func:`torch.conj_physical`\n             when :attr:`input` is of non-complex dtype to be compatible with this change.\n\nArgs:\n    input (Tensor): the input tensor.\n\nExample::\n\n    >>> x = torch.tensor([-1 + 1j, -2 + 2j, 3 - 3j])\n    >>> x.is_conj()\n    False\n    >>> y = torch.conj(x)\n    >>> y.is_conj()\n    True\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "conj_physical": {
      "Doc": "\nconj_physical(input, *, out=None) -> Tensor\n\nComputes the element-wise conjugate of the given :attr:`input` tensor.\nIf :attr:`input` has a non-complex dtype, this function just returns :attr:`input`.\n\n.. note::\n   This performs the conjugate operation regardless of the fact conjugate bit is set or not.\n\n.. warning:: In the future, :func:`torch.conj_physical` may return a non-writeable view for an :attr:`input` of\n             non-complex dtype. It's recommended that programs not modify the tensor returned by :func:`torch.conj_physical`\n             when :attr:`input` is of non-complex dtype to be compatible with this change.\n\n.. math::\n    \\text{out}_{i} = conj(\\text{input}_{i})\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> torch.conj_physical(torch.tensor([-1 + 1j, -2 + 2j, 3 - 3j]))\n    tensor([-1 - 1j, -2 - 2j, 3 + 3j])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "constant_pad_nd": {
      "Doc": null,
      "Args": null
    },
    "conv1d": {
      "Doc": "\nconv1d(input, weight, bias=None, stride=1, padding=0, dilation=1, groups=1) -> Tensor\n\nApplies a 1D convolution over an input signal composed of several input\nplanes.\n\nThis operator supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\nSee :class:`~torch.nn.Conv1d` for details and output shape.\n\nNote:\n    In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.\n\nNote:\n    This operator supports complex data types i.e. ``complex32, complex64, complex128``.\n\n\nArgs:\n    input: input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iW)`\n    weight: filters of shape :math:`(\\text{out\\_channels} , \\frac{\\text{in\\_channels}}{\\text{groups}} , kW)`\n    bias: optional bias of shape :math:`(\\text{out\\_channels})`. Default: ``None``\n    stride: the stride of the convolving kernel. Can be a single number or\n      a one-element tuple `(sW,)`. Default: 1\n    padding: implicit paddings on both sides of the input. Can be a string {'valid', 'same'},\n      single number or a one-element tuple `(padW,)`. Default: 0\n      ``padding='valid'`` is the same as no padding. ``padding='same'`` pads\n      the input so the output has the same shape as the input. However, this mode\n      doesn't support any stride values other than 1.\n\n      .. warning::\n          For ``padding='same'``, if the ``weight`` is even-length and\n          ``dilation`` is odd in any dimension, a full :func:`pad` operation\n          may be needed internally. Lowering performance.\n    dilation: the spacing between kernel elements. Can be a single number or\n      a one-element tuple `(dW,)`. Default: 1\n    groups: split input into groups, :math:`\\text{in\\_channels}` should be divisible by\n      the number of groups. Default: 1\n\nExamples::\n\n    >>> inputs = torch.randn(33, 16, 30)\n    >>> filters = torch.randn(20, 16, 5)\n    >>> F.conv1d(inputs, filters)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "weight": {
          "Type": null,
          "Default": null
        },
        "bias": {
          "Type": null,
          "Default": "None"
        },
        "stride": {
          "Type": null,
          "Default": "1"
        },
        "padding": {
          "Type": null,
          "Default": "0"
        },
        "dilation": {
          "Type": null,
          "Default": "1"
        },
        "groups": {
          "Type": null,
          "Default": "1"
        }
      }
    },
    "conv2d": {
      "Doc": "\nconv2d(input, weight, bias=None, stride=1, padding=0, dilation=1, groups=1) -> Tensor\n\nApplies a 2D convolution over an input image composed of several input\nplanes.\n\nThis operator supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\nSee :class:`~torch.nn.Conv2d` for details and output shape.\n\nNote:\n    In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.\n\nNote:\n    This operator supports complex data types i.e. ``complex32, complex64, complex128``.\n\n\nArgs:\n    input: input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iH , iW)`\n    weight: filters of shape :math:`(\\text{out\\_channels} , \\frac{\\text{in\\_channels}}{\\text{groups}} , kH , kW)`\n    bias: optional bias tensor of shape :math:`(\\text{out\\_channels})`. Default: ``None``\n    stride: the stride of the convolving kernel. Can be a single number or a\n      tuple `(sH, sW)`. Default: 1\n    padding: implicit paddings on both sides of the input. Can be a string {'valid', 'same'},\n      single number or a tuple `(padH, padW)`. Default: 0\n      ``padding='valid'`` is the same as no padding. ``padding='same'`` pads\n      the input so the output has the same shape as the input. However, this mode\n      doesn't support any stride values other than 1.\n\n      .. warning::\n          For ``padding='same'``, if the ``weight`` is even-length and\n          ``dilation`` is odd in any dimension, a full :func:`pad` operation\n          may be needed internally. Lowering performance.\n\n    dilation: the spacing between kernel elements. Can be a single number or\n      a tuple `(dH, dW)`. Default: 1\n    groups: split input into groups, :math:`\\text{in\\_channels}` should be divisible by the\n      number of groups. Default: 1\n\nExamples::\n\n    >>> # With square kernels and equal stride\n    >>> filters = torch.randn(8, 4, 3, 3)\n    >>> inputs = torch.randn(1, 4, 5, 5)\n    >>> F.conv2d(inputs, filters, padding=1)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "weight": {
          "Type": null,
          "Default": null
        },
        "bias": {
          "Type": null,
          "Default": "None"
        },
        "stride": {
          "Type": null,
          "Default": "1"
        },
        "padding": {
          "Type": null,
          "Default": "0"
        },
        "dilation": {
          "Type": null,
          "Default": "1"
        },
        "groups": {
          "Type": null,
          "Default": "1"
        }
      }
    },
    "conv3d": {
      "Doc": "\nconv3d(input, weight, bias=None, stride=1, padding=0, dilation=1, groups=1) -> Tensor\n\nApplies a 3D convolution over an input image composed of several input\nplanes.\n\nThis operator supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\nSee :class:`~torch.nn.Conv3d` for details and output shape.\n\nNote:\n    In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.\n\nNote:\n    This operator supports complex data types i.e. ``complex32, complex64, complex128``.\n\n\nArgs:\n    input: input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iT , iH , iW)`\n    weight: filters of shape :math:`(\\text{out\\_channels} , \\frac{\\text{in\\_channels}}{\\text{groups}} , kT , kH , kW)`\n    bias: optional bias tensor of shape :math:`(\\text{out\\_channels})`. Default: None\n    stride: the stride of the convolving kernel. Can be a single number or a\n      tuple `(sT, sH, sW)`. Default: 1\n    padding: implicit paddings on both sides of the input. Can be a string {'valid', 'same'},\n      single number or a tuple `(padT, padH, padW)`. Default: 0\n      ``padding='valid'`` is the same as no padding. ``padding='same'`` pads\n      the input so the output has the same shape as the input. However, this mode\n      doesn't support any stride values other than 1.\n\n      .. warning::\n          For ``padding='same'``, if the ``weight`` is even-length and\n          ``dilation`` is odd in any dimension, a full :func:`pad` operation\n          may be needed internally. Lowering performance.\n\n    dilation: the spacing between kernel elements. Can be a single number or\n      a tuple `(dT, dH, dW)`. Default: 1\n    groups: split input into groups, :math:`\\text{in\\_channels}` should be divisible by\n      the number of groups. Default: 1\n\nExamples::\n\n    >>> filters = torch.randn(33, 16, 3, 3, 3)\n    >>> inputs = torch.randn(20, 16, 50, 10, 20)\n    >>> F.conv3d(inputs, filters)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "weight": {
          "Type": null,
          "Default": null
        },
        "bias": {
          "Type": null,
          "Default": "None"
        },
        "stride": {
          "Type": null,
          "Default": "1"
        },
        "padding": {
          "Type": null,
          "Default": "0"
        },
        "dilation": {
          "Type": null,
          "Default": "1"
        },
        "groups": {
          "Type": null,
          "Default": "1"
        }
      }
    },
    "conv_tbc": {
      "Doc": "\nApplies a 1-dimensional sequence convolution over an input sequence.\nInput and output dimensions are (Time, Batch, Channels) - hence TBC.\n\nArgs:\n    input: input tensor of shape :math:`(\\text{sequence length} \\times batch \\times \\text{in\\_channels})`\n    weight: filter of shape (:math:`\\text{kernel width} \\times \\text{in\\_channels} \\times \\text{out\\_channels}`)\n    bias: bias of shape (:math:`\\text{out\\_channels}`)\n    pad: number of timesteps to pad. Default: 0\n",
      "Args": {
        "Time": {
          "Type": null,
          "Default": null
        },
        "Batch": {
          "Type": null,
          "Default": null
        },
        "Channels": {
          "Type": null,
          "Default": null
        }
      }
    },
    "conv_transpose1d": {
      "Doc": "\nconv_transpose1d(input, weight, bias=None, stride=1, padding=0, output_padding=0, groups=1, dilation=1) -> Tensor\n\nApplies a 1D transposed convolution operator over an input signal\ncomposed of several input planes, sometimes also called \"deconvolution\".\n\nThis operator supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\nSee :class:`~torch.nn.ConvTranspose1d` for details and output shape.\n\nNote:\n    In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.\n\n\nArgs:\n    input: input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iW)`\n    weight: filters of shape :math:`(\\text{in\\_channels} , \\frac{\\text{out\\_channels}}{\\text{groups}} , kW)`\n    bias: optional bias of shape :math:`(\\text{out\\_channels})`. Default: None\n    stride: the stride of the convolving kernel. Can be a single number or a\n      tuple ``(sW,)``. Default: 1\n    padding: ``dilation * (kernel_size - 1) - padding`` zero-padding will be added to both\n      sides of each dimension in the input. Can be a single number or a tuple\n      ``(padW,)``. Default: 0\n    output_padding: additional size added to one side of each dimension in the\n      output shape. Can be a single number or a tuple ``(out_padW)``. Default: 0\n    groups: split input into groups, :math:`\\text{in\\_channels}` should be divisible by the\n      number of groups. Default: 1\n    dilation: the spacing between kernel elements. Can be a single number or\n      a tuple ``(dW,)``. Default: 1\n\nExamples::\n\n    >>> inputs = torch.randn(20, 16, 50)\n    >>> weights = torch.randn(16, 33, 5)\n    >>> F.conv_transpose1d(inputs, weights)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "weight": {
          "Type": null,
          "Default": null
        },
        "bias": {
          "Type": null,
          "Default": "None"
        },
        "stride": {
          "Type": null,
          "Default": "1"
        },
        "padding": {
          "Type": null,
          "Default": "0"
        },
        "output_padding": {
          "Type": null,
          "Default": "0"
        },
        "groups": {
          "Type": null,
          "Default": "1"
        },
        "dilation": {
          "Type": null,
          "Default": "1"
        }
      }
    },
    "conv_transpose2d": {
      "Doc": "\nconv_transpose2d(input, weight, bias=None, stride=1, padding=0, output_padding=0, groups=1, dilation=1) -> Tensor\n\nApplies a 2D transposed convolution operator over an input image\ncomposed of several input planes, sometimes also called \"deconvolution\".\n\nThis operator supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\nSee :class:`~torch.nn.ConvTranspose2d` for details and output shape.\n\nNote:\n    In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.\n\n\nArgs:\n    input: input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iH , iW)`\n    weight: filters of shape :math:`(\\text{in\\_channels} , \\frac{\\text{out\\_channels}}{\\text{groups}} , kH , kW)`\n    bias: optional bias of shape :math:`(\\text{out\\_channels})`. Default: None\n    stride: the stride of the convolving kernel. Can be a single number or a\n      tuple ``(sH, sW)``. Default: 1\n    padding: ``dilation * (kernel_size - 1) - padding`` zero-padding will be added to both\n      sides of each dimension in the input. Can be a single number or a tuple\n      ``(padH, padW)``. Default: 0\n    output_padding: additional size added to one side of each dimension in the\n      output shape. Can be a single number or a tuple ``(out_padH, out_padW)``.\n      Default: 0\n    groups: split input into groups, :math:`\\text{in\\_channels}` should be divisible by the\n      number of groups. Default: 1\n    dilation: the spacing between kernel elements. Can be a single number or\n      a tuple ``(dH, dW)``. Default: 1\n\nExamples::\n\n    >>> # With square kernels and equal stride\n    >>> inputs = torch.randn(1, 4, 5, 5)\n    >>> weights = torch.randn(4, 8, 3, 3)\n    >>> F.conv_transpose2d(inputs, weights, padding=1)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "weight": {
          "Type": null,
          "Default": null
        },
        "bias": {
          "Type": null,
          "Default": "None"
        },
        "stride": {
          "Type": null,
          "Default": "1"
        },
        "padding": {
          "Type": null,
          "Default": "0"
        },
        "output_padding": {
          "Type": null,
          "Default": "0"
        },
        "groups": {
          "Type": null,
          "Default": "1"
        },
        "dilation": {
          "Type": null,
          "Default": "1"
        }
      }
    },
    "conv_transpose3d": {
      "Doc": "\nconv_transpose3d(input, weight, bias=None, stride=1, padding=0, output_padding=0, groups=1, dilation=1) -> Tensor\n\nApplies a 3D transposed convolution operator over an input image\ncomposed of several input planes, sometimes also called \"deconvolution\"\n\nThis operator supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\nSee :class:`~torch.nn.ConvTranspose3d` for details and output shape.\n\nNote:\n    In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.\n\n\nArgs:\n    input: input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iT , iH , iW)`\n    weight: filters of shape :math:`(\\text{in\\_channels} , \\frac{\\text{out\\_channels}}{\\text{groups}} , kT , kH , kW)`\n    bias: optional bias of shape :math:`(\\text{out\\_channels})`. Default: None\n    stride: the stride of the convolving kernel. Can be a single number or a\n      tuple ``(sT, sH, sW)``. Default: 1\n    padding: ``dilation * (kernel_size - 1) - padding`` zero-padding will be added to both\n      sides of each dimension in the input. Can be a single number or a tuple\n      ``(padT, padH, padW)``. Default: 0\n    output_padding: additional size added to one side of each dimension in the\n      output shape. Can be a single number or a tuple\n      ``(out_padT, out_padH, out_padW)``. Default: 0\n    groups: split input into groups, :math:`\\text{in\\_channels}` should be divisible by the\n      number of groups. Default: 1\n    dilation: the spacing between kernel elements. Can be a single number or\n      a tuple `(dT, dH, dW)`. Default: 1\n\nExamples::\n\n    >>> inputs = torch.randn(20, 16, 50, 10, 20)\n    >>> weights = torch.randn(16, 33, 3, 3, 3)\n    >>> F.conv_transpose3d(inputs, weights)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "weight": {
          "Type": null,
          "Default": null
        },
        "bias": {
          "Type": null,
          "Default": "None"
        },
        "stride": {
          "Type": null,
          "Default": "1"
        },
        "padding": {
          "Type": null,
          "Default": "0"
        },
        "output_padding": {
          "Type": null,
          "Default": "0"
        },
        "groups": {
          "Type": null,
          "Default": "1"
        },
        "dilation": {
          "Type": null,
          "Default": "1"
        }
      }
    },
    "convolution": {
      "Doc": null,
      "Args": null
    },
    "copysign": {
      "Doc": "\ncopysign(input, other, *, out=None) -> Tensor\n\nCreate a new floating-point tensor with the magnitude of :attr:`input` and the sign of :attr:`other`, elementwise.\n\n.. math::\n    \\text{out}_{i} = \\begin{cases}\n        -|\\text{input}_{i}| & \\text{if } \\text{other}_{i} \\leq -0.0 \\\\\n         |\\text{input}_{i}| & \\text{if } \\text{other}_{i} \\geq 0.0 \\\\\n    \\end{cases}\n\n\nSupports :ref:`broadcasting to a common shape <broadcasting-semantics>`,\nand integer and float inputs.\n\nArgs:\n    input (Tensor): magnitudes.\n    other (Tensor or Number): contains value(s) whose signbit(s) are\n        applied to the magnitudes in :attr:`input`.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(5)\n    >>> a\n    tensor([-1.2557, -0.0026, -0.5387,  0.4740, -0.9244])\n    >>> torch.copysign(a, 1)\n    tensor([1.2557, 0.0026, 0.5387, 0.4740, 0.9244])\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[ 0.7079,  0.2778, -1.0249,  0.5719],\n            [-0.0059, -0.2600, -0.4475, -1.3948],\n            [ 0.3667, -0.9567, -2.5757, -0.1751],\n            [ 0.2046, -0.0742,  0.2998, -0.1054]])\n    >>> b = torch.randn(4)\n    tensor([ 0.2373,  0.3120,  0.3190, -1.1128])\n    >>> torch.copysign(a, b)\n    tensor([[ 0.7079,  0.2778,  1.0249, -0.5719],\n            [ 0.0059,  0.2600,  0.4475, -1.3948],\n            [ 0.3667,  0.9567,  2.5757, -0.1751],\n            [ 0.2046,  0.0742,  0.2998, -0.1054]])\n    >>> a = torch.tensor([1.])\n    >>> b = torch.tensor([-0.])\n    >>> torch.copysign(a, b)\n    tensor([-1.])\n\n.. note::\n    copysign handles signed zeros. If the other argument has a negative zero (-0),\n    the corresponding output value will be negative.\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "corrcoef": {
      "Doc": "\ncorrcoef(input) -> Tensor\n\nEstimates the Pearson product-moment correlation coefficient matrix of the variables given by the :attr:`input` matrix,\nwhere rows are the variables and columns are the observations.\n\n.. note::\n\n    The correlation coefficient matrix R is computed using the covariance matrix C as given by\n    :math:`R_{ij} = \\frac{ C_{ij} } { \\sqrt{ C_{ii} * C_{jj} } }`\n\n.. note::\n\n    Due to floating point rounding, the resulting array may not be Hermitian and its diagonal elements may not be 1.\n    The real and imaginary values are clipped to the interval [-1, 1] in an attempt to improve this situation.\n\nArgs:\n    input (Tensor): A 2D matrix containing multiple variables and observations, or a\n        Scalar or 1D vector representing a single variable.\n\nReturns:\n    (Tensor) The correlation coefficient matrix of the variables.\n\n.. seealso::\n\n        :func:`torch.cov` covariance matrix.\n\nExample::\n\n    >>> x = torch.tensor([[0, 1, 2], [2, 1, 0]])\n    >>> torch.corrcoef(x)\n    tensor([[ 1., -1.],\n            [-1.,  1.]])\n    >>> x = torch.randn(2, 4)\n    >>> x\n    tensor([[-0.2678, -0.0908, -0.3766,  0.2780],\n            [-0.5812,  0.1535,  0.2387,  0.2350]])\n    >>> torch.corrcoef(x)\n    tensor([[1.0000, 0.3582],\n            [0.3582, 1.0000]])\n    >>> torch.corrcoef(x[0])\n    tensor(1.)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "cos": {
      "Doc": "\ncos(input, *, out=None) -> Tensor\n\nReturns a new tensor with the cosine  of the elements of :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\cos(\\text{input}_{i})\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 1.4309,  1.2706, -0.8562,  0.9796])\n    >>> torch.cos(a)\n    tensor([ 0.1395,  0.2957,  0.6553,  0.5574])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "cosh": {
      "Doc": "\ncosh(input, *, out=None) -> Tensor\n\nReturns a new tensor with the hyperbolic cosine  of the elements of\n:attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\cosh(\\text{input}_{i})\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 0.1632,  1.1835, -0.6979, -0.7325])\n    >>> torch.cosh(a)\n    tensor([ 1.0133,  1.7860,  1.2536,  1.2805])\n\n.. note::\n   When :attr:`input` is on the CPU, the implementation of torch.cosh may use\n   the Sleef library, which rounds very large results to infinity or negative\n   infinity. See `here <https://sleef.org/purec.xhtml>`_ for details.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "cosine_embedding_loss": {
      "Doc": null,
      "Args": null
    },
    "cosine_similarity": {
      "Doc": "\ncosine_similarity(x1, x2, dim=1, eps=1e-8) -> Tensor\n\nReturns cosine similarity between ``x1`` and ``x2``, computed along dim. ``x1`` and ``x2`` must be broadcastable\nto a common shape. ``dim`` refers to the dimension in this common shape. Dimension ``dim`` of the output is\nsqueezed (see :func:`torch.squeeze`), resulting in the\noutput tensor having 1 fewer dimension.\n\n.. math ::\n    \\text{similarity} = \\dfrac{x_1 \\cdot x_2}{\\max(\\Vert x_1 \\Vert _2 \\cdot \\Vert x_2 \\Vert _2, \\epsilon)}\n\nSupports :ref:`type promotion <type-promotion-doc>`.\n\nArgs:\n    x1 (Tensor): First input.\n    x2 (Tensor): Second input.\n    dim (int, optional): Dimension along which cosine similarity is computed. Default: 1\n    eps (float, optional): Small value to avoid division by zero.\n        Default: 1e-8\n\nExample::\n\n    >>> input1 = torch.randn(100, 128)\n    >>> input2 = torch.randn(100, 128)\n    >>> output = F.cosine_similarity(input1, input2)\n    >>> print(output)\n",
      "Args": {
        "x1": {
          "Type": null,
          "Default": null
        },
        "x2": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "1"
        },
        "eps": {
          "Type": null,
          "Default": "1e-8"
        }
      }
    },
    "count_nonzero": {
      "Doc": "\ncount_nonzero(input, dim=None) -> Tensor\n\nCounts the number of non-zero values in the tensor :attr:`input` along the given :attr:`dim`.\nIf no dim is specified then all non-zeros in the tensor are counted.\n\nArgs:\n    input (Tensor): the input tensor.\n    dim (int or tuple of ints, optional): Dim or tuple of dims along which to count non-zeros.\n\nExample::\n\n    >>> x = torch.zeros(3,3)\n    >>> x[torch.randn(3,3) > 0.5] = 1\n    >>> x\n    tensor([[0., 1., 1.],\n            [0., 0., 0.],\n            [0., 0., 1.]])\n    >>> torch.count_nonzero(x)\n    tensor(3)\n    >>> torch.count_nonzero(x, dim=0)\n    tensor([0, 1, 2])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "cov": {
      "Doc": "\ncov(input, *, correction=1, fweights=None, aweights=None) -> Tensor\n\nEstimates the covariance matrix of the variables given by the :attr:`input` matrix, where rows are\nthe variables and columns are the observations.\n\nA covariance matrix is a square matrix giving the covariance of each pair of variables. The diagonal contains\nthe variance of each variable (covariance of a variable with itself). By definition, if :attr:`input` represents\na single variable (Scalar or 1D) then its variance is returned.\n\nThe unbiased sample covariance of the variables :math:`x` and :math:`y` is given by:\n\n.. math::\n    \\text{cov}_w(x,y) = \\frac{\\sum^{N}_{i = 1}(x_{i} - \\bar{x})(y_{i} - \\bar{y})}{N~-~1}\n\nwhere :math:`\\bar{x}` and :math:`\\bar{y}` are the simple means of the :math:`x` and :math:`y` respectively.\n\nIf :attr:`fweights` and/or :attr:`aweights` are provided, the unbiased weighted covariance\nis calculated, which is given by:\n\n.. math::\n    \\text{cov}_w(x,y) = \\frac{\\sum^{N}_{i = 1}w_i(x_{i} - \\mu_x^*)(y_{i} - \\mu_y^*)}{\\sum^{N}_{i = 1}w_i~-~1}\n\nwhere :math:`w` denotes :attr:`fweights` or :attr:`aweights` based on whichever is provided, or\n:math:`w = fweights \\times aweights` if both are provided, and\n:math:`\\mu_x^* = \\frac{\\sum^{N}_{i = 1}w_ix_{i} }{\\sum^{N}_{i = 1}w_i}` is the weighted mean of the variable.\n\nArgs:\n    input (Tensor): A 2D matrix containing multiple variables and observations, or a\n        Scalar or 1D vector representing a single variable.\n\nKeyword Args:\n    correction (int, optional): difference between the sample size and sample degrees of freedom.\n        Defaults to Bessel's correction, ``correction = 1`` which returns the unbiased estimate,\n        even if both :attr:`fweights` and :attr:`aweights` are specified. ``correction = 0``\n        will return the simple average. Defaults to ``1``.\n    fweights (tensor, optional): A Scalar or 1D tensor of observation vector frequencies representing the number of\n        times each observation should be repeated. Its numel must equal the number of columns of :attr:`input`.\n        Must have integral dtype. Ignored if ``None``. `Defaults to ``None``.\n    aweights (tensor, optional): A Scalar or 1D array of observation vector weights.\n        These relative weights are typically large for observations considered \u201cimportant\u201d and smaller for\n        observations considered less \u201cimportant\u201d. Its numel must equal the number of columns of :attr:`input`.\n        Must have floating point dtype. Ignored if ``None``. `Defaults to ``None``.\n\nReturns:\n    (Tensor) The covariance matrix of the variables.\n\n.. seealso::\n\n        :func:`torch.corrcoef` normalized covariance matrix.\n\nExample::\n    >>> x = torch.tensor([[0, 2], [1, 1], [2, 0]]).T\n    >>> x\n    tensor([[0, 1, 2],\n            [2, 1, 0]])\n    >>> torch.cov(x)\n    tensor([[ 1., -1.],\n            [-1.,  1.]])\n    >>> torch.cov(x, correction=0)\n    tensor([[ 0.6667, -0.6667],\n            [-0.6667,  0.6667]])\n    >>> fw = torch.randint(1, 10, (3,))\n    >>> fw\n    tensor([1, 6, 9])\n    >>> aw = torch.rand(3)\n    >>> aw\n    tensor([0.4282, 0.0255, 0.4144])\n    >>> torch.cov(x, fweights=fw, aweights=aw)\n    tensor([[ 0.4169, -0.4169],\n            [-0.4169,  0.4169]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "correction": {
          "Type": null,
          "Default": "1"
        },
        "fweights": {
          "Type": null,
          "Default": "None"
        },
        "aweights": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "cross": {
      "Doc": "\ncross(input, other, dim=None, *, out=None) -> Tensor\n\n\nReturns the cross product of vectors in dimension :attr:`dim` of :attr:`input`\nand :attr:`other`.\n\nSupports input of float, double, cfloat and cdouble dtypes. Also supports batches\nof vectors, for which it computes the product along the dimension :attr:`dim`.\nIn this case, the output has the same batch dimensions as the inputs.\n\nIf :attr:`dim` is not given, it defaults to the first dimension found with the\nsize 3. Note that this might be unexpected.\n\n.. seealso::\n        :func:`torch.linalg.cross` which requires specifying dim (defaulting to -1).\n\n.. warning:: This function may change in a future PyTorch release to match\n        the default behaviour in :func:`torch.linalg.cross`. We recommend using\n        :func:`torch.linalg.cross`.\n\nArgs:\n    input (Tensor): the input tensor.\n    other (Tensor): the second input tensor\n    dim  (int, optional): the dimension to take the cross-product in.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4, 3)\n    >>> a\n    tensor([[-0.3956,  1.1455,  1.6895],\n            [-0.5849,  1.3672,  0.3599],\n            [-1.1626,  0.7180, -0.0521],\n            [-0.1339,  0.9902, -2.0225]])\n    >>> b = torch.randn(4, 3)\n    >>> b\n    tensor([[-0.0257, -1.4725, -1.2251],\n            [-1.1479, -0.7005, -1.9757],\n            [-1.3904,  0.3726, -1.1836],\n            [-0.9688, -0.7153,  0.2159]])\n    >>> torch.cross(a, b, dim=1)\n    tensor([[ 1.0844, -0.5281,  0.6120],\n            [-2.4490, -1.5687,  1.9792],\n            [-0.8304, -1.3037,  0.5650],\n            [-1.2329,  1.9883,  1.0551]])\n    >>> torch.cross(a, b)\n    tensor([[ 1.0844, -0.5281,  0.6120],\n            [-2.4490, -1.5687,  1.9792],\n            [-0.8304, -1.3037,  0.5650],\n            [-1.2329,  1.9883,  1.0551]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "None"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "crow_indices_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.crow_indices`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "ctc_loss": {
      "Doc": null,
      "Args": null
    },
    "cudnn_affine_grid_generator": {
      "Doc": null,
      "Args": null
    },
    "cudnn_batch_norm": {
      "Doc": null,
      "Args": null
    },
    "cudnn_convolution": {
      "Doc": null,
      "Args": null
    },
    "cudnn_convolution_add_relu": {
      "Doc": null,
      "Args": null
    },
    "cudnn_convolution_relu": {
      "Doc": null,
      "Args": null
    },
    "cudnn_convolution_transpose": {
      "Doc": null,
      "Args": null
    },
    "cudnn_grid_sampler": {
      "Doc": null,
      "Args": null
    },
    "cudnn_is_acceptable": {
      "Doc": null,
      "Args": null
    },
    "cummax": {
      "Doc": "\ncummax(input, dim, *, out=None) -> (Tensor, LongTensor)\nReturns a namedtuple ``(values, indices)`` where ``values`` is the cumulative maximum of\nelements of :attr:`input` in the dimension :attr:`dim`. And ``indices`` is the index\nlocation of each maximum value found in the dimension :attr:`dim`.\n\n.. math::\n    y_i = max(x_1, x_2, x_3, \\dots, x_i)\n\nArgs:\n    input (Tensor): the input tensor.\n    dim  (int): the dimension to do the operation over\n\nKeyword args:\n    out (tuple, optional): the result tuple of two output tensors (values, indices)\n\nExample::\n\n    >>> a = torch.randn(10)\n    >>> a\n    tensor([-0.3449, -1.5447,  0.0685, -1.5104, -1.1706,  0.2259,  1.4696, -1.3284,\n         1.9946, -0.8209])\n    >>> torch.cummax(a, dim=0)\n    torch.return_types.cummax(\n        values=tensor([-0.3449, -0.3449,  0.0685,  0.0685,  0.0685,  0.2259,  1.4696,  1.4696,\n         1.9946,  1.9946]),\n        indices=tensor([0, 0, 2, 2, 2, 5, 6, 6, 8, 8]))\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None) -> (Tensor"
        },
        "LongTensor": {
          "Type": null,
          "Default": null
        }
      }
    },
    "cummin": {
      "Doc": "\ncummin(input, dim, *, out=None) -> (Tensor, LongTensor)\nReturns a namedtuple ``(values, indices)`` where ``values`` is the cumulative minimum of\nelements of :attr:`input` in the dimension :attr:`dim`. And ``indices`` is the index\nlocation of each maximum value found in the dimension :attr:`dim`.\n\n.. math::\n    y_i = min(x_1, x_2, x_3, \\dots, x_i)\n\nArgs:\n    input (Tensor): the input tensor.\n    dim  (int): the dimension to do the operation over\n\nKeyword args:\n    out (tuple, optional): the result tuple of two output tensors (values, indices)\n\nExample::\n\n    >>> a = torch.randn(10)\n    >>> a\n    tensor([-0.2284, -0.6628,  0.0975,  0.2680, -1.3298, -0.4220, -0.3885,  1.1762,\n         0.9165,  1.6684])\n    >>> torch.cummin(a, dim=0)\n    torch.return_types.cummin(\n        values=tensor([-0.2284, -0.6628, -0.6628, -0.6628, -1.3298, -1.3298, -1.3298, -1.3298,\n        -1.3298, -1.3298]),\n        indices=tensor([0, 1, 1, 1, 4, 4, 4, 4, 4, 4]))\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None) -> (Tensor"
        },
        "LongTensor": {
          "Type": null,
          "Default": null
        }
      }
    },
    "cumprod": {
      "Doc": "\ncumprod(input, dim, *, dtype=None, out=None) -> Tensor\n\nReturns the cumulative product of elements of :attr:`input` in the dimension\n:attr:`dim`.\n\nFor example, if :attr:`input` is a vector of size N, the result will also be\na vector of size N, with elements.\n\n.. math::\n    y_i = x_1 \\times x_2\\times x_3\\times \\dots \\times x_i\n\nArgs:\n    input (Tensor): the input tensor.\n    dim  (int): the dimension to do the operation over\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        If specified, the input tensor is casted to :attr:`dtype` before the operation\n        is performed. This is useful for preventing data type overflows. Default: None.\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(10)\n    >>> a\n    tensor([ 0.6001,  0.2069, -0.1919,  0.9792,  0.6727,  1.0062,  0.4126,\n            -0.2129, -0.4206,  0.1968])\n    >>> torch.cumprod(a, dim=0)\n    tensor([ 0.6001,  0.1241, -0.0238, -0.0233, -0.0157, -0.0158, -0.0065,\n             0.0014, -0.0006, -0.0001])\n\n    >>> a[5] = 0.0\n    >>> torch.cumprod(a, dim=0)\n    tensor([ 0.6001,  0.1241, -0.0238, -0.0233, -0.0157, -0.0000, -0.0000,\n             0.0000, -0.0000, -0.0000])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "cumsum": {
      "Doc": "\ncumsum(input, dim, *, dtype=None, out=None) -> Tensor\n\nReturns the cumulative sum of elements of :attr:`input` in the dimension\n:attr:`dim`.\n\nFor example, if :attr:`input` is a vector of size N, the result will also be\na vector of size N, with elements.\n\n.. math::\n    y_i = x_1 + x_2 + x_3 + \\dots + x_i\n\nArgs:\n    input (Tensor): the input tensor.\n    dim  (int): the dimension to do the operation over\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        If specified, the input tensor is casted to :attr:`dtype` before the operation\n        is performed. This is useful for preventing data type overflows. Default: None.\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(10)\n    >>> a\n    tensor([-0.8286, -0.4890,  0.5155,  0.8443,  0.1865, -0.1752, -2.0595,\n             0.1850, -1.1571, -0.4243])\n    >>> torch.cumsum(a, dim=0)\n    tensor([-0.8286, -1.3175, -0.8020,  0.0423,  0.2289,  0.0537, -2.0058,\n            -1.8209, -2.9780, -3.4022])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "cumulative_trapezoid": {
      "Doc": "\ncumulative_trapezoid(y, x=None, *, dx=None, dim=-1) -> Tensor\n\nCumulatively computes the `trapezoidal rule <https://en.wikipedia.org/wiki/Trapezoidal_rule>`_\nalong :attr:`dim`. By default the spacing between elements is assumed to be 1, but\n:attr:`dx` can be used to specify a different constant spacing, and :attr:`x` can be\nused to specify arbitrary spacing along :attr:`dim`.\n\nFor more details, please read :func:`torch.trapezoid`. The difference between :func:`torch.trapezoid`\nand this function is that, :func:`torch.trapezoid` returns a value for each integration,\nwhere as this function returns a cumulative value for every spacing within the integration. This\nis analogous to how `.sum` returns a value and `.cumsum` returns a cumulative sum.\n\nArguments:\n    y (Tensor): Values to use when computing the trapezoidal rule.\n    x (Tensor): If specified, defines spacing between values as specified above.\n\nKeyword arguments:\n    dx (float): constant spacing between values. If neither :attr:`x` or :attr:`dx`\n        are specified then this defaults to 1. Effectively multiplies the result by its value.\n    dim (int): The dimension along which to compute the trapezoidal rule.\n        The last (inner-most) dimension by default.\n\nExamples::\n\n    >>> # Cumulatively computes the trapezoidal rule in 1D, spacing is implicitly 1.\n    >>> y = torch.tensor([1, 5, 10])\n    >>> torch.cumulative_trapezoid(y)\n    tensor([3., 10.5])\n\n    >>> # Computes the same trapezoidal rule directly up to each element to verify\n    >>> (1 + 5) / 2\n    3.0\n    >>> (1 + 10 + 10) / 2\n    10.5\n\n    >>> # Cumulatively computes the trapezoidal rule in 1D with constant spacing of 2\n    >>> # NOTE: the result is the same as before, but multiplied by 2\n    >>> torch.cumulative_trapezoid(y, dx=2)\n    tensor([6., 21.])\n\n    >>> # Cumulatively computes the trapezoidal rule in 1D with arbitrary spacing\n    >>> x = torch.tensor([1, 3, 6])\n    >>> torch.cumulative_trapezoid(y, x)\n    tensor([6., 28.5])\n\n    >>> # Computes the same trapezoidal rule directly up to each element to verify\n    >>> ((3 - 1) * (1 + 5)) / 2\n    6.0\n    >>> ((3 - 1) * (1 + 5) + (6 - 3) * (5 + 10)) / 2\n    28.5\n\n    >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 matrix\n    >>> y = torch.arange(9).reshape(3, 3)\n    tensor([[0, 1, 2],\n            [3, 4, 5],\n            [6, 7, 8]])\n    >>> torch.cumulative_trapezoid(y)\n    tensor([[ 0.5,  2.],\n            [ 3.5,  8.],\n            [ 6.5, 14.]])\n\n    >>> # Cumulatively computes the trapezoidal rule for each column of the matrix\n    >>> torch.cumulative_trapezoid(y, dim=0)\n    tensor([[ 1.5,  2.5,  3.5],\n            [ 6.0,  8.0, 10.0]])\n\n    >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 ones matrix\n    >>> #   with the same arbitrary spacing\n    >>> y = torch.ones(3, 3)\n    >>> x = torch.tensor([1, 3, 6])\n    >>> torch.cumulative_trapezoid(y, x)\n    tensor([[2., 5.],\n            [2., 5.],\n            [2., 5.]])\n\n    >>> # Cumulatively computes the trapezoidal rule for each row of a 3x3 ones matrix\n    >>> #   with different arbitrary spacing per row\n    >>> y = torch.ones(3, 3)\n    >>> x = torch.tensor([[1, 2, 3], [1, 3, 5], [1, 4, 7]])\n    >>> torch.cumulative_trapezoid(y, x)\n    tensor([[1., 2.],\n            [2., 4.],\n            [3., 6.]])\n",
      "Args": {
        "y": {
          "Type": null,
          "Default": null
        },
        "x": {
          "Type": null,
          "Default": "None"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dx": {
          "Type": null,
          "Default": "None"
        },
        "dim": {
          "Type": null,
          "Default": "-1"
        }
      }
    },
    "deg2rad": {
      "Doc": "\ndeg2rad(input, *, out=None) -> Tensor\n\nReturns a new tensor with each of the elements of :attr:`input`\nconverted from angles in degrees to radians.\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword arguments:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.tensor([[180.0, -180.0], [360.0, -360.0], [90.0, -90.0]])\n    >>> torch.deg2rad(a)\n    tensor([[ 3.1416, -3.1416],\n            [ 6.2832, -6.2832],\n            [ 1.5708, -1.5708]])\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "dequantize": {
      "Doc": "\ndequantize(tensor) -> Tensor\n\nReturns an fp32 Tensor by dequantizing a quantized Tensor\n\nArgs:\n    tensor (Tensor): A quantized Tensor\n\n.. function:: dequantize(tensors) -> sequence of Tensors\n   :noindex:\n\nGiven a list of quantized Tensors, dequantize them and return a list of fp32 Tensors\n\nArgs:\n     tensors (sequence of Tensors): A list of quantized Tensors\n",
      "Args": {
        "tensor": {
          "Type": null,
          "Default": null
        }
      }
    },
    "det": {
      "Doc": "\ndet(input) -> Tensor\n\nAlias for :func:`torch.linalg.det`\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "detach": {
      "Doc": null,
      "Args": null
    },
    "detach_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.detach`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "diag": {
      "Doc": "\ndiag(input, diagonal=0, *, out=None) -> Tensor\n\n- If :attr:`input` is a vector (1-D tensor), then returns a 2-D square tensor\n  with the elements of :attr:`input` as the diagonal.\n- If :attr:`input` is a matrix (2-D tensor), then returns a 1-D tensor with\n  the diagonal elements of :attr:`input`.\n\nThe argument :attr:`diagonal` controls which diagonal to consider:\n\n- If :attr:`diagonal` = 0, it is the main diagonal.\n- If :attr:`diagonal` > 0, it is above the main diagonal.\n- If :attr:`diagonal` < 0, it is below the main diagonal.\n\nArgs:\n    input (Tensor): the input tensor.\n    diagonal (int, optional): the diagonal to consider\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\n.. seealso::\n\n        :func:`torch.diagonal` always returns the diagonal of its input.\n\n        :func:`torch.diagflat` always constructs a tensor with diagonal elements\n        specified by the input.\n\nExamples:\n\nGet the square matrix where the input vector is the diagonal::\n\n    >>> a = torch.randn(3)\n    >>> a\n    tensor([ 0.5950,-0.0872, 2.3298])\n    >>> torch.diag(a)\n    tensor([[ 0.5950, 0.0000, 0.0000],\n            [ 0.0000,-0.0872, 0.0000],\n            [ 0.0000, 0.0000, 2.3298]])\n    >>> torch.diag(a, 1)\n    tensor([[ 0.0000, 0.5950, 0.0000, 0.0000],\n            [ 0.0000, 0.0000,-0.0872, 0.0000],\n            [ 0.0000, 0.0000, 0.0000, 2.3298],\n            [ 0.0000, 0.0000, 0.0000, 0.0000]])\n\nGet the k-th diagonal of a given matrix::\n\n    >>> a = torch.randn(3, 3)\n    >>> a\n    tensor([[-0.4264, 0.0255,-0.1064],\n            [ 0.8795,-0.2429, 0.1374],\n            [ 0.1029,-0.6482,-1.6300]])\n    >>> torch.diag(a, 0)\n    tensor([-0.4264,-0.2429,-1.6300])\n    >>> torch.diag(a, 1)\n    tensor([ 0.0255, 0.1374])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "diagonal": {
          "Type": null,
          "Default": "0"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "diag_embed": {
      "Doc": "\ndiag_embed(input, offset=0, dim1=-2, dim2=-1) -> Tensor\n\nCreates a tensor whose diagonals of certain 2D planes (specified by\n:attr:`dim1` and :attr:`dim2`) are filled by :attr:`input`.\nTo facilitate creating batched diagonal matrices, the 2D planes formed by\nthe last two dimensions of the returned tensor are chosen by default.\n\nThe argument :attr:`offset` controls which diagonal to consider:\n\n- If :attr:`offset` = 0, it is the main diagonal.\n- If :attr:`offset` > 0, it is above the main diagonal.\n- If :attr:`offset` < 0, it is below the main diagonal.\n\nThe size of the new matrix will be calculated to make the specified diagonal\nof the size of the last input dimension.\nNote that for :attr:`offset` other than :math:`0`, the order of :attr:`dim1`\nand :attr:`dim2` matters. Exchanging them is equivalent to changing the\nsign of :attr:`offset`.\n\nApplying :meth:`torch.diagonal` to the output of this function with\nthe same arguments yields a matrix identical to input. However,\n:meth:`torch.diagonal` has different default dimensions, so those\nneed to be explicitly specified.\n\nArgs:\n    input (Tensor): the input tensor. Must be at least 1-dimensional.\n    offset (int, optional): which diagonal to consider. Default: 0\n        (main diagonal).\n    dim1 (int, optional): first dimension with respect to which to\n        take diagonal. Default: -2.\n    dim2 (int, optional): second dimension with respect to which to\n        take diagonal. Default: -1.\n\nExample::\n\n    >>> a = torch.randn(2, 3)\n    >>> torch.diag_embed(a)\n    tensor([[[ 1.5410,  0.0000,  0.0000],\n             [ 0.0000, -0.2934,  0.0000],\n             [ 0.0000,  0.0000, -2.1788]],\n\n            [[ 0.5684,  0.0000,  0.0000],\n             [ 0.0000, -1.0845,  0.0000],\n             [ 0.0000,  0.0000, -1.3986]]])\n\n    >>> torch.diag_embed(a, offset=1, dim1=0, dim2=2)\n    tensor([[[ 0.0000,  1.5410,  0.0000,  0.0000],\n             [ 0.0000,  0.5684,  0.0000,  0.0000]],\n\n            [[ 0.0000,  0.0000, -0.2934,  0.0000],\n             [ 0.0000,  0.0000, -1.0845,  0.0000]],\n\n            [[ 0.0000,  0.0000,  0.0000, -2.1788],\n             [ 0.0000,  0.0000,  0.0000, -1.3986]],\n\n            [[ 0.0000,  0.0000,  0.0000,  0.0000],\n             [ 0.0000,  0.0000,  0.0000,  0.0000]]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "offset": {
          "Type": null,
          "Default": "0"
        },
        "dim1": {
          "Type": null,
          "Default": "-2"
        },
        "dim2": {
          "Type": null,
          "Default": "-1"
        }
      }
    },
    "diagflat": {
      "Doc": "\ndiagflat(input, offset=0) -> Tensor\n\n- If :attr:`input` is a vector (1-D tensor), then returns a 2-D square tensor\n  with the elements of :attr:`input` as the diagonal.\n- If :attr:`input` is a tensor with more than one dimension, then returns a\n  2-D tensor with diagonal elements equal to a flattened :attr:`input`.\n\nThe argument :attr:`offset` controls which diagonal to consider:\n\n- If :attr:`offset` = 0, it is the main diagonal.\n- If :attr:`offset` > 0, it is above the main diagonal.\n- If :attr:`offset` < 0, it is below the main diagonal.\n\nArgs:\n    input (Tensor): the input tensor.\n    offset (int, optional): the diagonal to consider. Default: 0 (main\n        diagonal).\n\nExamples::\n\n    >>> a = torch.randn(3)\n    >>> a\n    tensor([-0.2956, -0.9068,  0.1695])\n    >>> torch.diagflat(a)\n    tensor([[-0.2956,  0.0000,  0.0000],\n            [ 0.0000, -0.9068,  0.0000],\n            [ 0.0000,  0.0000,  0.1695]])\n    >>> torch.diagflat(a, 1)\n    tensor([[ 0.0000, -0.2956,  0.0000,  0.0000],\n            [ 0.0000,  0.0000, -0.9068,  0.0000],\n            [ 0.0000,  0.0000,  0.0000,  0.1695],\n            [ 0.0000,  0.0000,  0.0000,  0.0000]])\n\n    >>> a = torch.randn(2, 2)\n    >>> a\n    tensor([[ 0.2094, -0.3018],\n            [-0.1516,  1.9342]])\n    >>> torch.diagflat(a)\n    tensor([[ 0.2094,  0.0000,  0.0000,  0.0000],\n            [ 0.0000, -0.3018,  0.0000,  0.0000],\n            [ 0.0000,  0.0000, -0.1516,  0.0000],\n            [ 0.0000,  0.0000,  0.0000,  1.9342]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "offset": {
          "Type": null,
          "Default": "0"
        }
      }
    },
    "diagonal": {
      "Doc": "\ndiagonal(input, offset=0, dim1=0, dim2=1) -> Tensor\n\nReturns a partial view of :attr:`input` with the its diagonal elements\nwith respect to :attr:`dim1` and :attr:`dim2` appended as a dimension\nat the end of the shape.\n\nThe argument :attr:`offset` controls which diagonal to consider:\n\n- If :attr:`offset` = 0, it is the main diagonal.\n- If :attr:`offset` > 0, it is above the main diagonal.\n- If :attr:`offset` < 0, it is below the main diagonal.\n\nApplying :meth:`torch.diag_embed` to the output of this function with\nthe same arguments yields a diagonal matrix with the diagonal entries\nof the input. However, :meth:`torch.diag_embed` has different default\ndimensions, so those need to be explicitly specified.\n\nArgs:\n    input (Tensor): the input tensor. Must be at least 2-dimensional.\n    offset (int, optional): which diagonal to consider. Default: 0\n        (main diagonal).\n    dim1 (int, optional): first dimension with respect to which to\n        take diagonal. Default: 0.\n    dim2 (int, optional): second dimension with respect to which to\n        take diagonal. Default: 1.\n\n.. note::  To take a batch diagonal, pass in dim1=-2, dim2=-1.\n\nExamples::\n\n    >>> a = torch.randn(3, 3)\n    >>> a\n    tensor([[-1.0854,  1.1431, -0.1752],\n            [ 0.8536, -0.0905,  0.0360],\n            [ 0.6927, -0.3735, -0.4945]])\n\n\n    >>> torch.diagonal(a, 0)\n    tensor([-1.0854, -0.0905, -0.4945])\n\n\n    >>> torch.diagonal(a, 1)\n    tensor([ 1.1431,  0.0360])\n\n\n    >>> x = torch.randn(2, 5, 4, 2)\n    >>> torch.diagonal(x, offset=-1, dim1=1, dim2=2)\n    tensor([[[-1.2631,  0.3755, -1.5977, -1.8172],\n             [-1.1065,  1.0401, -0.2235, -0.7938]],\n\n            [[-1.7325, -0.3081,  0.6166,  0.2335],\n             [ 1.0500,  0.7336, -0.3836, -1.1015]]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "offset": {
          "Type": null,
          "Default": "0"
        },
        "dim1": {
          "Type": null,
          "Default": "0"
        },
        "dim2": {
          "Type": null,
          "Default": "1"
        }
      }
    },
    "diagonal_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.diagonal`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "diagonal_scatter": {
      "Doc": "\ndiagonal_scatter(input, src, offset=0, dim1=0, dim2=1) -> Tensor\n\nEmbeds the values of the :attr:`src` tensor into :attr:`input` along\nthe diagonal elements of :attr:`input`, with respect to :attr:`dim1`\nand :attr:`dim2`.\n\nThis function returns a tensor with fresh storage; it does not\nreturn a view.\n\nThe argument :attr:`offset` controls which diagonal to consider:\n\n- If :attr:`offset` = 0, it is the main diagonal.\n- If :attr:`offset` > 0, it is above the main diagonal.\n- If :attr:`offset` < 0, it is below the main diagonal.\n\nArgs:\n    input (Tensor): the input tensor. Must be at least 2-dimensional.\n    src (Tensor): the tensor to embed into :attr:`input`.\n    offset (int, optional): which diagonal to consider. Default: 0\n        (main diagonal).\n    dim1 (int, optional): first dimension with respect to which to\n        take diagonal. Default: 0.\n    dim2 (int, optional): second dimension with respect to which to\n        take diagonal. Default: 1.\n\n.. note::\n\n    :attr:`src` must be of the proper size in order to be embedded\n    into :attr:`input`. Specifically, it should have the same shape as\n    ``torch.diagonal(input, offset, dim1, dim2)``\n\nExamples::\n\n    >>> a = torch.zeros(3, 3)\n    >>> a\n    tensor([[0., 0., 0.],\n            [0., 0., 0.],\n            [0., 0., 0.]])\n\n    >>> torch.diagonal_scatter(a, torch.ones(3), 0)\n    tensor([[1., 0., 0.],\n            [0., 1., 0.],\n            [0., 0., 1.]])\n\n    >>> torch.diagonal_scatter(a, torch.ones(2), 1)\n    tensor([[0., 1., 0.],\n            [0., 0., 1.],\n            [0., 0., 0.]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "src": {
          "Type": null,
          "Default": null
        },
        "offset": {
          "Type": null,
          "Default": "0"
        },
        "dim1": {
          "Type": null,
          "Default": "0"
        },
        "dim2": {
          "Type": null,
          "Default": "1"
        }
      }
    },
    "diff": {
      "Doc": "\ndiff(input, n=1, dim=-1, prepend=None, append=None) -> Tensor\n\nComputes the n-th forward difference along the given dimension.\n\nThe first-order differences are given by `out[i] = input[i + 1] - input[i]`. Higher-order\ndifferences are calculated by using :func:`torch.diff` recursively.\n\nArgs:\n    input (Tensor): the tensor to compute the differences on\n    n (int, optional): the number of times to recursively compute the difference\n    dim (int, optional): the dimension to compute the difference along.\n        Default is the last dimension.\n    prepend, append (Tensor, optional): values to prepend or append to\n        :attr:`input` along :attr:`dim` before computing the difference.\n        Their dimensions must be equivalent to that of input, and their shapes\n        must match input's shape except on :attr:`dim`.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.tensor([1, 3, 2])\n    >>> torch.diff(a)\n    tensor([ 2, -1])\n    >>> b = torch.tensor([4, 5])\n    >>> torch.diff(a, append=b)\n    tensor([ 2, -1,  2,  1])\n    >>> c = torch.tensor([[1, 2, 3], [3, 4, 5]])\n    >>> torch.diff(c, dim=0)\n    tensor([[2, 2, 2]])\n    >>> torch.diff(c, dim=1)\n    tensor([[1, 1],\n            [1, 1]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "n": {
          "Type": null,
          "Default": "1"
        },
        "dim": {
          "Type": null,
          "Default": "-1"
        },
        "prepend": {
          "Type": null,
          "Default": "None"
        },
        "append": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "digamma": {
      "Doc": "\ndigamma(input, *, out=None) -> Tensor\n\nAlias for :func:`torch.special.digamma`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "dist": {
      "Doc": "\ndist(input, other, p=2) -> Tensor\n\nReturns the p-norm of (:attr:`input` - :attr:`other`)\n\nThe shapes of :attr:`input` and :attr:`other` must be\n:ref:`broadcastable <broadcasting-semantics>`.\n\nArgs:\n    input (Tensor): the input tensor.\n    other (Tensor): the Right-hand-side input tensor\n    p (float, optional): the norm to be computed\n\nExample::\n\n    >>> x = torch.randn(4)\n    >>> x\n    tensor([-1.5393, -0.8675,  0.5916,  1.6321])\n    >>> y = torch.randn(4)\n    >>> y\n    tensor([ 0.0967, -1.0511,  0.6295,  0.8360])\n    >>> torch.dist(x, y, 3.5)\n    tensor(1.6727)\n    >>> torch.dist(x, y, 3)\n    tensor(1.6973)\n    >>> torch.dist(x, y, 0)\n    tensor(4.)\n    >>> torch.dist(x, y, 1)\n    tensor(2.6537)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "p": {
          "Type": null,
          "Default": "2"
        }
      }
    },
    "div": {
      "Doc": "\ndiv(input, other, *, rounding_mode=None, out=None) -> Tensor\n\nDivides each element of the input ``input`` by the corresponding element of\n:attr:`other`.\n\n.. math::\n    \\text{out}_i = \\frac{\\text{input}_i}{\\text{other}_i}\n\n.. note::\n    By default, this performs a \"true\" division like Python 3.\n    See the :attr:`rounding_mode` argument for floor division.\n\nSupports :ref:`broadcasting to a common shape <broadcasting-semantics>`,\n:ref:`type promotion <type-promotion-doc>`, and integer, float, and complex inputs.\nAlways promotes integer types to the default scalar type.\n\nArgs:\n    input (Tensor): the dividend\n    other (Tensor or Number): the divisor\n\nKeyword args:\n    rounding_mode (str, optional): Type of rounding applied to the result:\n\n        * None - default behavior. Performs no rounding and, if both :attr:`input` and\n          :attr:`other` are integer types, promotes the inputs to the default scalar type.\n          Equivalent to true division in Python (the ``/`` operator) and NumPy's ``np.true_divide``.\n        * ``\"trunc\"`` - rounds the results of the division towards zero.\n          Equivalent to C-style integer division.\n        * ``\"floor\"`` - rounds the results of the division down.\n          Equivalent to floor division in Python (the ``//`` operator) and NumPy's ``np.floor_divide``.\n\n    out (Tensor, optional): the output tensor.\n\nExamples::\n\n    >>> x = torch.tensor([ 0.3810,  1.2774, -0.2972, -0.3719,  0.4637])\n    >>> torch.div(x, 0.5)\n    tensor([ 0.7620,  2.5548, -0.5944, -0.7438,  0.9274])\n\n    >>> a = torch.tensor([[-0.3711, -1.9353, -0.4605, -0.2917],\n    ...                   [ 0.1815, -1.0111,  0.9805, -1.5923],\n    ...                   [ 0.1062,  1.4581,  0.7759, -1.2344],\n    ...                   [-0.1830, -0.0313,  1.1908, -1.4757]])\n    >>> b = torch.tensor([ 0.8032,  0.2930, -0.8113, -0.2308])\n    >>> torch.div(a, b)\n    tensor([[-0.4620, -6.6051,  0.5676,  1.2639],\n            [ 0.2260, -3.4509, -1.2086,  6.8990],\n            [ 0.1322,  4.9764, -0.9564,  5.3484],\n            [-0.2278, -0.1068, -1.4678,  6.3938]])\n\n    >>> torch.div(a, b, rounding_mode='trunc')\n    tensor([[-0., -6.,  0.,  1.],\n            [ 0., -3., -1.,  6.],\n            [ 0.,  4., -0.,  5.],\n            [-0., -0., -1.,  6.]])\n\n    >>> torch.div(a, b, rounding_mode='floor')\n    tensor([[-1., -7.,  0.,  1.],\n            [ 0., -4., -2.,  6.],\n            [ 0.,  4., -1.,  5.],\n            [-1., -1., -2.,  6.]])\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "rounding_mode": {
          "Type": null,
          "Default": "None"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "divide": {
      "Doc": "\ndivide(input, other, *, rounding_mode=None, out=None) -> Tensor\n\nAlias for :func:`torch.div`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "rounding_mode": {
          "Type": null,
          "Default": "None"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "dot": {
      "Doc": "\ndot(input, other, *, out=None) -> Tensor\n\nComputes the dot product of two 1D tensors.\n\n.. note::\n\n    Unlike NumPy's dot, torch.dot intentionally only supports computing the dot product\n    of two 1D tensors with the same number of elements.\n\nArgs:\n    input (Tensor): first tensor in the dot product, must be 1D.\n    other (Tensor): second tensor in the dot product, must be 1D.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> torch.dot(torch.tensor([2, 3]), torch.tensor([2, 1]))\n    tensor(7)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "dropout": {
      "Doc": null,
      "Args": null
    },
    "dsmm": {
      "Doc": null,
      "Args": null
    },
    "dsplit": {
      "Doc": "\ndsplit(input, indices_or_sections) -> List of Tensors\n\nSplits :attr:`input`, a tensor with three or more dimensions, into multiple tensors\ndepthwise according to :attr:`indices_or_sections`. Each split is a view of\n:attr:`input`.\n\nThis is equivalent to calling torch.tensor_split(input, indices_or_sections, dim=2)\n(the split dimension is 2), except that if :attr:`indices_or_sections` is an integer\nit must evenly divide the split dimension or a runtime error will be thrown.\n\nThis function is based on NumPy's :func:`numpy.dsplit`.\n\nArgs:\n    input (Tensor): tensor to split.\n    indices_or_sections (int or list or tuple of ints): See argument in :func:`torch.tensor_split`.\n\nExample::\n    >>> t = torch.arange(16.0).reshape(2, 2, 4)\n    >>> t\n    tensor([[[ 0.,  1.,  2.,  3.],\n             [ 4.,  5.,  6.,  7.]],\n            [[ 8.,  9., 10., 11.],\n             [12., 13., 14., 15.]]])\n    >>> torch.dsplit(t, 2)\n    (tensor([[[ 0.,  1.],\n            [ 4.,  5.]],\n           [[ 8.,  9.],\n            [12., 13.]]]),\n     tensor([[[ 2.,  3.],\n              [ 6.,  7.]],\n             [[10., 11.],\n              [14., 15.]]]))\n\n    >>> torch.dsplit(t, [3, 6])\n    (tensor([[[ 0.,  1.,  2.],\n              [ 4.,  5.,  6.]],\n             [[ 8.,  9., 10.],\n              [12., 13., 14.]]]),\n     tensor([[[ 3.],\n              [ 7.]],\n             [[11.],\n              [15.]]]),\n     tensor([], size=(2, 2, 0)))\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "indices_or_sections": {
          "Type": null,
          "Default": null
        }
      }
    },
    "dstack": {
      "Doc": "\ndstack(tensors, *, out=None) -> Tensor\n\nStack tensors in sequence depthwise (along third axis).\n\nThis is equivalent to concatenation along the third axis after 1-D and 2-D tensors have been reshaped by :func:`torch.atleast_3d`.\n\nArgs:\n    tensors (sequence of Tensors): sequence of tensors to concatenate\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.tensor([1, 2, 3])\n    >>> b = torch.tensor([4, 5, 6])\n    >>> torch.dstack((a,b))\n    tensor([[[1, 4],\n             [2, 5],\n             [3, 6]]])\n    >>> a = torch.tensor([[1],[2],[3]])\n    >>> b = torch.tensor([[4],[5],[6]])\n    >>> torch.dstack((a,b))\n    tensor([[[1, 4]],\n            [[2, 5]],\n            [[3, 6]]])\n\n\n",
      "Args": {
        "tensors": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "eig": {
      "Doc": null,
      "Args": {
        "self": {
          "Type": "<class 'torch.Tensor'>",
          "Default": null
        },
        "eigenvectors": {
          "Type": "<class 'bool'>",
          "Default": "False"
        },
        "e": {
          "Type": null,
          "Default": "None"
        },
        "v": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "einsum": {
      "Doc": "einsum(equation, *operands) -> Tensor\n\n    Sums the product of the elements of the input :attr:`operands` along dimensions specified using a notation\n    based on the Einstein summation convention.\n\n    Einsum allows computing many common multi-dimensional linear algebraic array operations by representing them\n    in a short-hand format based on the Einstein summation convention, given by :attr:`equation`. The details of\n    this format are described below, but the general idea is to label every dimension of the input :attr:`operands`\n    with some subscript and define which subscripts are part of the output. The output is then computed by summing\n    the product of the elements of the :attr:`operands` along the dimensions whose subscripts are not part of the\n    output. For example, matrix multiplication can be computed using einsum as `torch.einsum(\"ij,jk->ik\", A, B)`.\n    Here, j is the summation subscript and i and k the output subscripts (see section below for more details on why).\n\n    Equation:\n\n        The :attr:`equation` string specifies the subscripts (letters in `[a-zA-Z]`) for each dimension of\n        the input :attr:`operands` in the same order as the dimensions, separating subcripts for each operand by a\n        comma (','), e.g. `'ij,jk'` specify subscripts for two 2D operands. The dimensions labeled with the same subscript\n        must be broadcastable, that is, their size must either match or be `1`. The exception is if a subscript is\n        repeated for the same input operand, in which case the dimensions labeled with this subscript for this operand\n        must match in size and the operand will be replaced by its diagonal along these dimensions. The subscripts that\n        appear exactly once in the :attr:`equation` will be part of the output, sorted in increasing alphabetical order.\n        The output is computed by multiplying the input :attr:`operands` element-wise, with their dimensions aligned based\n        on the subscripts, and then summing out the dimensions whose subscripts are not part of the output.\n\n        Optionally, the output subscripts can be explicitly defined by adding an arrow ('->') at the end of the equation\n        followed by the subscripts for the output. For instance, the following equation computes the transpose of a\n        matrix multiplication: 'ij,jk->ki'. The output subscripts must appear at least once for some input operand and\n        at most once for the output.\n\n        Ellipsis ('...') can be used in place of subscripts to broadcast the dimensions covered by the ellipsis.\n        Each input operand may contain at most one ellipsis which will cover the dimensions not covered by subscripts,\n        e.g. for an input operand with 5 dimensions, the ellipsis in the equation `'ab...c'` cover the third and fourth\n        dimensions. The ellipsis does not need to cover the same number of dimensions across the :attr:`operands` but the\n        'shape' of the ellipsis (the size of the dimensions covered by them) must broadcast together. If the output is not\n        explicitly defined with the arrow ('->') notation, the ellipsis will come first in the output (left-most dimensions),\n        before the subscript labels that appear exactly once for the input operands. e.g. the following equation implements\n        batch matrix multiplication `'...ij,...jk'`.\n\n        A few final notes: the equation may contain whitespaces between the different elements (subscripts, ellipsis,\n        arrow and comma) but something like `'. . .'` is not valid. An empty string `''` is valid for scalar operands.\n\n    .. note::\n\n        ``torch.einsum`` handles ellipsis ('...') differently from NumPy in that it allows dimensions\n        covered by the ellipsis to be summed over, that is, ellipsis are not required to be part of the output.\n\n    .. note::\n\n        This function uses opt_einsum (https://optimized-einsum.readthedocs.io/en/stable/) to speed up computation or to\n        consume less memory by optimizing contraction order. This optimization occurs when there are at least three\n        inputs, since the order does not matter otherwise. Note that finding _the_ optimal path is an NP-hard problem,\n        thus, opt_einsum relies on different heuristics to achieve near-optimal results. If opt_einsum is not available,\n        the default order is to contract from left to right.\n\n        To bypass this default behavior, add the following line to disable the usage of opt_einsum and skip path\n        calculation: `torch.backends.opt_einsum.enabled = False`\n\n        To specify which strategy you'd like for opt_einsum to compute the contraction path, add the following line:\n        `torch.backends.opt_einsum.strategy = 'auto'`. The default strategy is 'auto', and we also support 'greedy' and\n        'optimal'. Disclaimer that the runtime of 'optimal' is factorial in the number of inputs! See more details in\n        the opt_einsum documentation (https://optimized-einsum.readthedocs.io/en/stable/path_finding.html).\n\n    .. note::\n\n        As of PyTorch 1.10 :func:`torch.einsum` also supports the sublist format (see examples below). In this format,\n        subscripts for each operand are specified by sublists, list of integers in the range [0, 52). These sublists\n        follow their operands, and an extra sublist can appear at the end of the input to specify the output's\n        subscripts., e.g. `torch.einsum(op1, sublist1, op2, sublist2, ..., [subslist_out])`. Python's `Ellipsis` object\n        may be provided in a sublist to enable broadcasting as described in the Equation section above.\n\n    Args:\n        equation (str): The subscripts for the Einstein summation.\n        operands (List[Tensor]): The tensors to compute the Einstein summation of.\n\n    Examples::\n\n        >>> # trace\n        >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\")\n        >>> torch.einsum('ii', torch.randn(4, 4))\n        tensor(-1.2104)\n\n        >>> # diagonal\n        >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\")\n        >>> torch.einsum('ii->i', torch.randn(4, 4))\n        tensor([-0.1034,  0.7952, -0.2433,  0.4545])\n\n        >>> # outer product\n        >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\")\n        >>> x = torch.randn(5)\n        >>> y = torch.randn(4)\n        >>> torch.einsum('i,j->ij', x, y)\n        tensor([[ 0.1156, -0.2897, -0.3918,  0.4963],\n                [-0.3744,  0.9381,  1.2685, -1.6070],\n                [ 0.7208, -1.8058, -2.4419,  3.0936],\n                [ 0.1713, -0.4291, -0.5802,  0.7350],\n                [ 0.5704, -1.4290, -1.9323,  2.4480]])\n\n        >>> # batch matrix multiplication\n        >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\")\n        >>> As = torch.randn(3,2,5)\n        >>> Bs = torch.randn(3,5,4)\n        >>> torch.einsum('bij,bjk->bik', As, Bs)\n        tensor([[[-1.0564, -1.5904,  3.2023,  3.1271],\n                [-1.6706, -0.8097, -0.8025, -2.1183]],\n\n                [[ 4.2239,  0.3107, -0.5756, -0.2354],\n                [-1.4558, -0.3460,  1.5087, -0.8530]],\n\n                [[ 2.8153,  1.8787, -4.3839, -1.2112],\n                [ 0.3728, -2.1131,  0.0921,  0.8305]]])\n\n        >>> # with sublist format and ellipsis\n        >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\")\n        >>> torch.einsum(As, [..., 0, 1], Bs, [..., 1, 2], [..., 0, 2])\n        tensor([[[-1.0564, -1.5904,  3.2023,  3.1271],\n                [-1.6706, -0.8097, -0.8025, -2.1183]],\n\n                [[ 4.2239,  0.3107, -0.5756, -0.2354],\n                [-1.4558, -0.3460,  1.5087, -0.8530]],\n\n                [[ 2.8153,  1.8787, -4.3839, -1.2112],\n                [ 0.3728, -2.1131,  0.0921,  0.8305]]])\n\n        >>> # batch permute\n        >>> A = torch.randn(2, 3, 4, 5)\n        >>> torch.einsum('...ij->...ji', A).shape\n        torch.Size([2, 3, 5, 4])\n\n        >>> # equivalent to torch.nn.functional.bilinear\n        >>> A = torch.randn(3,5,4)\n        >>> l = torch.randn(2,5)\n        >>> r = torch.randn(2,4)\n        >>> torch.einsum('bn,anm,bm->ba', l, A, r)\n        tensor([[-0.3430, -5.2405,  0.4494],\n                [ 0.3311,  5.5201, -3.0356]])\n    ",
      "Args": {
        "*args": {
          "Type": null,
          "Default": null
        }
      }
    },
    "embedding": {
      "Doc": null,
      "Args": null
    },
    "embedding_bag": {
      "Doc": null,
      "Args": null
    },
    "empty": {
      "Doc": "\nempty(*size, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False, pin_memory=False, memory_format=torch.contiguous_format) -> Tensor\n\nReturns a tensor filled with uninitialized data. The shape of the tensor is\ndefined by the variable argument :attr:`size`.\n\nArgs:\n    size (int...): a sequence of integers defining the shape of the output tensor.\n        Can be a variable number of arguments or a collection like a list or tuple.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).\n    layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.\n        Default: ``torch.strided``.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n    pin_memory (bool, optional): If set, returned tensor would be allocated in\n        the pinned memory. Works only for CPU tensors. Default: ``False``.\n    memory_format (:class:`torch.memory_format`, optional): the desired memory format of\n        returned Tensor. Default: ``torch.contiguous_format``.\n\nExample::\n\n    >>> torch.empty((2,3), dtype=torch.int64)\n    tensor([[ 9.4064e+13,  2.8000e+01,  9.3493e+13],\n            [ 7.5751e+18,  7.1428e+18,  7.5955e+18]])\n",
      "Args": {
        "*size": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "torch.strided"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        },
        "pin_memory": {
          "Type": null,
          "Default": "False"
        },
        "memory_format": {
          "Type": null,
          "Default": "torch.contiguous_format"
        }
      }
    },
    "empty_like": {
      "Doc": "\nempty_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor\n\nReturns an uninitialized tensor with the same size as :attr:`input`.\n``torch.empty_like(input)`` is equivalent to\n``torch.empty(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.\n\nArgs:\n    input (Tensor): the size of :attr:`input` will determine size of the output tensor.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.\n        Default: if ``None``, defaults to the dtype of :attr:`input`.\n    layout (:class:`torch.layout`, optional): the desired layout of returned tensor.\n        Default: if ``None``, defaults to the layout of :attr:`input`.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, defaults to the device of :attr:`input`.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n    memory_format (:class:`torch.memory_format`, optional): the desired memory format of\n        returned Tensor. Default: ``torch.preserve_format``.\n\nExample::\n\n    >>> a=torch.empty((2,3), dtype=torch.int32, device = 'cuda')\n    >>> torch.empty_like(a)\n    tensor([[0, 0, 0],\n            [0, 0, 0]], device='cuda:0', dtype=torch.int32)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "None"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        },
        "memory_format": {
          "Type": null,
          "Default": "torch.preserve_format"
        }
      }
    },
    "empty_quantized": {
      "Doc": null,
      "Args": null
    },
    "empty_strided": {
      "Doc": "\nempty_strided(size, stride, *, dtype=None, layout=None, device=None, requires_grad=False, pin_memory=False) -> Tensor\n\nCreates a tensor with the specified :attr:`size` and :attr:`stride` and filled with undefined data.\n\n.. warning::\n    If the constructed tensor is \"overlapped\" (with multiple indices referring to the same element\n    in memory) its behavior is undefined.\n\nArgs:\n    size (tuple of int): the shape of the output tensor\n    stride (tuple of int): the strides of the output tensor\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).\n    layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.\n        Default: ``torch.strided``.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n    pin_memory (bool, optional): If set, returned tensor would be allocated in\n        the pinned memory. Works only for CPU tensors. Default: ``False``.\n\nExample::\n\n    >>> a = torch.empty_strided((2, 3), (1, 2))\n    >>> a\n    tensor([[8.9683e-44, 4.4842e-44, 5.1239e+07],\n            [0.0000e+00, 0.0000e+00, 3.0705e-41]])\n    >>> a.stride()\n    (1, 2)\n    >>> a.size()\n    torch.Size([2, 3])\n",
      "Args": {
        "size": {
          "Type": null,
          "Default": null
        },
        "stride": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "None"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        },
        "pin_memory": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "eq": {
      "Doc": "\neq(input, other, *, out=None) -> Tensor\n\nComputes element-wise equality\n\nThe second argument can be a number or a tensor whose shape is\n:ref:`broadcastable <broadcasting-semantics>` with the first argument.\n\nArgs:\n    input (Tensor): the tensor to compare\n    other (Tensor or float): the tensor or value to compare\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nReturns:\n    A boolean tensor that is True where :attr:`input` is equal to :attr:`other` and False elsewhere\n\nExample::\n\n    >>> torch.eq(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))\n    tensor([[ True, False],\n            [False, True]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "equal": {
      "Doc": "\nequal(input, other) -> bool\n\n``True`` if two tensors have the same size and elements, ``False`` otherwise.\n\nExample::\n\n    >>> torch.equal(torch.tensor([1, 2]), torch.tensor([1, 2]))\n    True\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        }
      }
    },
    "erf": {
      "Doc": "\nerf(input, *, out=None) -> Tensor\n\nAlias for :func:`torch.special.erf`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "erfc": {
      "Doc": "\nerfc(input, *, out=None) -> Tensor\n\nAlias for :func:`torch.special.erfc`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "erfinv": {
      "Doc": "\nerfinv(input, *, out=None) -> Tensor\n\nAlias for :func:`torch.special.erfinv`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "exp": {
      "Doc": "\nexp(input, *, out=None) -> Tensor\n\nReturns a new tensor with the exponential of the elements\nof the input tensor :attr:`input`.\n\n.. math::\n    y_{i} = e^{x_{i}}\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> torch.exp(torch.tensor([0, math.log(2.)]))\n    tensor([ 1.,  2.])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "exp2": {
      "Doc": "\nexp2(input, *, out=None) -> Tensor\n\nAlias for :func:`torch.special.exp2`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "expand_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.expand`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "expm1": {
      "Doc": "\nexpm1(input, *, out=None) -> Tensor\n\nAlias for :func:`torch.special.expm1`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "eye": {
      "Doc": "\neye(n, m=None, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nReturns a 2-D tensor with ones on the diagonal and zeros elsewhere.\n\nArgs:\n    n (int): the number of rows\n    m (int, optional): the number of columns with default being :attr:`n`\n\nKeyword arguments:\n    out (Tensor, optional): the output tensor.\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).\n    layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.\n        Default: ``torch.strided``.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n\nReturns:\n    Tensor: A 2-D tensor with ones on the diagonal and zeros elsewhere\n\nExample::\n\n    >>> torch.eye(3)\n    tensor([[ 1.,  0.,  0.],\n            [ 0.,  1.,  0.],\n            [ 0.,  0.,  1.]])\n",
      "Args": {
        "n": {
          "Type": null,
          "Default": null
        },
        "m": {
          "Type": null,
          "Default": "None"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "torch.strided"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "fake_quantize_per_channel_affine": {
      "Doc": "\nfake_quantize_per_channel_affine(input, scale, zero_point, quant_min, quant_max) -> Tensor\n\nReturns a new tensor with the data in :attr:`input` fake quantized per channel using :attr:`scale`,\n:attr:`zero_point`, :attr:`quant_min` and :attr:`quant_max`, across the channel specified by :attr:`axis`.\n\n.. math::\n    \\text{output} = min(\n        \\text{quant\\_max},\n        max(\n            \\text{quant\\_min},\n            \\text{std::nearby\\_int}(\\text{input} / \\text{scale}) + \\text{zero\\_point}\n        )\n    )\n\nArgs:\n    input (Tensor): the input value(s), in ``torch.float32``\n    scale (Tensor): quantization scale, per channel in ``torch.float32``\n    zero_point (Tensor): quantization zero_point, per channel in ``torch.int32`` or ``torch.half`` or ``torch.float32``\n    axis (int32): channel axis\n    quant_min (int64): lower bound of the quantized domain\n    quant_max (int64): upper bound of the quantized domain\n\nReturns:\n    Tensor: A newly fake_quantized per channel ``torch.float32`` tensor\n\nExample::\n\n    >>> x = torch.randn(2, 2, 2)\n    >>> x\n    tensor([[[-0.2525, -0.0466],\n             [ 0.3491, -0.2168]],\n\n            [[-0.5906,  1.6258],\n             [ 0.6444, -0.0542]]])\n    >>> scales = (torch.randn(2) + 1) * 0.05\n    >>> scales\n    tensor([0.0475, 0.0486])\n    >>> zero_points = torch.zeros(2).to(torch.int32)\n    >>> zero_points\n    tensor([0, 0])\n    >>> torch.fake_quantize_per_channel_affine(x, scales, zero_points, 1, 0, 255)\n    tensor([[[0.0000, 0.0000],\n             [0.3405, 0.0000]],\n\n            [[0.0000, 1.6134],\n            [0.6323, 0.0000]]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "scale": {
          "Type": null,
          "Default": null
        },
        "zero_point": {
          "Type": null,
          "Default": null
        },
        "quant_min": {
          "Type": null,
          "Default": null
        },
        "quant_max": {
          "Type": null,
          "Default": null
        }
      }
    },
    "fake_quantize_per_tensor_affine": {
      "Doc": "\nfake_quantize_per_tensor_affine(input, scale, zero_point, quant_min, quant_max) -> Tensor\n\nReturns a new tensor with the data in :attr:`input` fake quantized using :attr:`scale`,\n:attr:`zero_point`, :attr:`quant_min` and :attr:`quant_max`.\n\n.. math::\n    \\text{output} = min(\n        \\text{quant\\_max},\n        max(\n            \\text{quant\\_min},\n            \\text{std::nearby\\_int}(\\text{input} / \\text{scale}) + \\text{zero\\_point}\n        )\n    )\n\nArgs:\n    input (Tensor): the input value(s), ``torch.float32`` tensor\n    scale (double scalar or ``float32`` Tensor): quantization scale\n    zero_point (int64 scalar or ``int32`` Tensor): quantization zero_point\n    quant_min (int64): lower bound of the quantized domain\n    quant_max (int64): upper bound of the quantized domain\n\nReturns:\n    Tensor: A newly fake_quantized ``torch.float32`` tensor\n\nExample::\n\n    >>> x = torch.randn(4)\n    >>> x\n    tensor([ 0.0552,  0.9730,  0.3973, -1.0780])\n    >>> torch.fake_quantize_per_tensor_affine(x, 0.1, 0, 0, 255)\n    tensor([0.1000, 1.0000, 0.4000, 0.0000])\n    >>> torch.fake_quantize_per_tensor_affine(x, torch.tensor(0.1), torch.tensor(0), 0, 255)\n    tensor([0.6000, 0.4000, 0.0000, 0.0000])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "scale": {
          "Type": null,
          "Default": null
        },
        "zero_point": {
          "Type": null,
          "Default": null
        },
        "quant_min": {
          "Type": null,
          "Default": null
        },
        "quant_max": {
          "Type": null,
          "Default": null
        }
      }
    },
    "fbgemm_linear_fp16_weight": {
      "Doc": null,
      "Args": null
    },
    "fbgemm_linear_fp16_weight_fp32_activation": {
      "Doc": null,
      "Args": null
    },
    "fbgemm_linear_int8_weight": {
      "Doc": null,
      "Args": null
    },
    "fbgemm_linear_int8_weight_fp32_activation": {
      "Doc": null,
      "Args": null
    },
    "fbgemm_linear_quantize_weight": {
      "Doc": null,
      "Args": null
    },
    "fbgemm_pack_gemm_matrix_fp16": {
      "Doc": null,
      "Args": null
    },
    "fbgemm_pack_quantized_matrix": {
      "Doc": null,
      "Args": null
    },
    "feature_alpha_dropout": {
      "Doc": null,
      "Args": null
    },
    "feature_dropout": {
      "Doc": null,
      "Args": null
    },
    "fill": {
      "Doc": null,
      "Args": null
    },
    "fix": {
      "Doc": "\nfix(input, *, out=None) -> Tensor\n\nAlias for :func:`torch.trunc`\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "flatten": {
      "Doc": "\nflatten(input, start_dim=0, end_dim=-1) -> Tensor\n\nFlattens :attr:`input` by reshaping it into a one-dimensional tensor. If :attr:`start_dim` or :attr:`end_dim`\nare passed, only dimensions starting with :attr:`start_dim` and ending with :attr:`end_dim` are flattened.\nThe order of elements in :attr:`input` is unchanged.\n\nUnlike NumPy's flatten, which always copies input's data, this function may return the original object, a view,\nor copy. If no dimensions are flattened, then the original object :attr:`input` is returned. Otherwise, if input can\nbe viewed as the flattened shape, then that view is returned. Finally, only if the input cannot be viewed as the\nflattened shape is input's data copied. See :meth:`torch.Tensor.view` for details on when a view will be returned.\n\n.. note::\n    Flattening a zero-dimensional tensor will return a one-dimensional view.\n\nArgs:\n    input (Tensor): the input tensor.\n    start_dim (int): the first dim to flatten\n    end_dim (int): the last dim to flatten\n\nExample::\n\n    >>> t = torch.tensor([[[1, 2],\n    ...                    [3, 4]],\n    ...                   [[5, 6],\n    ...                    [7, 8]]])\n    >>> torch.flatten(t)\n    tensor([1, 2, 3, 4, 5, 6, 7, 8])\n    >>> torch.flatten(t, start_dim=1)\n    tensor([[1, 2, 3, 4],\n            [5, 6, 7, 8]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "start_dim": {
          "Type": null,
          "Default": "0"
        },
        "end_dim": {
          "Type": null,
          "Default": "-1"
        }
      }
    },
    "flip": {
      "Doc": "\nflip(input, dims) -> Tensor\n\nReverse the order of a n-D tensor along given axis in dims.\n\n.. note::\n    `torch.flip` makes a copy of :attr:`input`'s data. This is different from NumPy's `np.flip`,\n    which returns a view in constant time. Since copying a tensor's data is more work than viewing that data,\n    `torch.flip` is expected to be slower than `np.flip`.\n\nArgs:\n    input (Tensor): the input tensor.\n    dims (a list or tuple): axis to flip on\n\nExample::\n\n    >>> x = torch.arange(8).view(2, 2, 2)\n    >>> x\n    tensor([[[ 0,  1],\n             [ 2,  3]],\n\n            [[ 4,  5],\n             [ 6,  7]]])\n    >>> torch.flip(x, [0, 1])\n    tensor([[[ 6,  7],\n             [ 4,  5]],\n\n            [[ 2,  3],\n             [ 0,  1]]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dims": {
          "Type": null,
          "Default": null
        }
      }
    },
    "fliplr": {
      "Doc": "\nfliplr(input) -> Tensor\n\nFlip tensor in the left/right direction, returning a new tensor.\n\nFlip the entries in each row in the left/right direction.\nColumns are preserved, but appear in a different order than before.\n\nNote:\n    Requires the tensor to be at least 2-D.\n\n.. note::\n    `torch.fliplr` makes a copy of :attr:`input`'s data. This is different from NumPy's `np.fliplr`,\n    which returns a view in constant time. Since copying a tensor's data is more work than viewing that data,\n    `torch.fliplr` is expected to be slower than `np.fliplr`.\n\nArgs:\n    input (Tensor): Must be at least 2-dimensional.\n\nExample::\n\n    >>> x = torch.arange(4).view(2, 2)\n    >>> x\n    tensor([[0, 1],\n            [2, 3]])\n    >>> torch.fliplr(x)\n    tensor([[1, 0],\n            [3, 2]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "flipud": {
      "Doc": "\nflipud(input) -> Tensor\n\nFlip tensor in the up/down direction, returning a new tensor.\n\nFlip the entries in each column in the up/down direction.\nRows are preserved, but appear in a different order than before.\n\nNote:\n    Requires the tensor to be at least 1-D.\n\n.. note::\n    `torch.flipud` makes a copy of :attr:`input`'s data. This is different from NumPy's `np.flipud`,\n    which returns a view in constant time. Since copying a tensor's data is more work than viewing that data,\n    `torch.flipud` is expected to be slower than `np.flipud`.\n\nArgs:\n    input (Tensor): Must be at least 1-dimensional.\n\nExample::\n\n    >>> x = torch.arange(4).view(2, 2)\n    >>> x\n    tensor([[0, 1],\n            [2, 3]])\n    >>> torch.flipud(x)\n    tensor([[2, 3],\n            [0, 1]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "float_power": {
      "Doc": "\nfloat_power(input, exponent, *, out=None) -> Tensor\n\nRaises :attr:`input` to the power of :attr:`exponent`, elementwise, in double precision.\nIf neither input is complex returns a ``torch.float64`` tensor,\nand if one or more inputs is complex returns a ``torch.complex128`` tensor.\n\n.. note::\n    This function always computes in double precision, unlike :func:`torch.pow`,\n    which implements more typical :ref:`type promotion <type-promotion-doc>`.\n    This is useful when the computation needs to be performed in a wider or more precise dtype,\n    or the results of the computation may contain fractional values not representable in the input dtypes,\n    like when an integer base is raised to a negative integer exponent.\n\nArgs:\n    input (Tensor or Number): the base value(s)\n    exponent (Tensor or Number): the exponent value(s)\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randint(10, (4,))\n    >>> a\n    tensor([6, 4, 7, 1])\n    >>> torch.float_power(a, 2)\n    tensor([36., 16., 49.,  1.], dtype=torch.float64)\n\n    >>> a = torch.arange(1, 5)\n    >>> a\n    tensor([ 1,  2,  3,  4])\n    >>> exp = torch.tensor([2, -3, 4, -5])\n    >>> exp\n    tensor([ 2, -3,  4, -5])\n    >>> torch.float_power(a, exp)\n    tensor([1.0000e+00, 1.2500e-01, 8.1000e+01, 9.7656e-04], dtype=torch.float64)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "exponent": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "floor": {
      "Doc": "\nfloor(input, *, out=None) -> Tensor\n\nReturns a new tensor with the floor of the elements of :attr:`input`,\nthe largest integer less than or equal to each element.\n\nFor integer inputs, follows the array-api convention of returning a\ncopy of the input tensor.\n\n.. math::\n    \\text{out}_{i} = \\left\\lfloor \\text{input}_{i} \\right\\rfloor\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([-0.8166,  1.5308, -0.2530, -0.2091])\n    >>> torch.floor(a)\n    tensor([-1.,  1., -1., -1.])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "floor_divide": {
      "Doc": "\nfloor_divide(input, other, *, out=None) -> Tensor\n\n.. note::\n\n    Before PyTorch 1.13 :func:`torch.floor_divide` incorrectly performed\n    truncation division. To restore the previous behavior use\n    :func:`torch.div` with ``rounding_mode='trunc'``.\n\nComputes :attr:`input` divided by :attr:`other`, elementwise, and floors\nthe result.\n\n.. math::\n    \\text{{out}}_i = \\text{floor} \\left( \\frac{{\\text{{input}}_i}}{{\\text{{other}}_i}} \\right)\n\n\n\nSupports broadcasting to a common shape, type promotion, and integer and float inputs.\n\nArgs:\n    input (Tensor or Number): the dividend\n    other (Tensor or Number): the divisor\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.tensor([4.0, 3.0])\n    >>> b = torch.tensor([2.0, 2.0])\n    >>> torch.floor_divide(a, b)\n    tensor([2.0, 1.0])\n    >>> torch.floor_divide(a, 1.4)\n    tensor([2.0, 2.0])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "fmax": {
      "Doc": "\nfmax(input, other, *, out=None) -> Tensor\n\nComputes the element-wise maximum of :attr:`input` and :attr:`other`.\n\nThis is like :func:`torch.maximum` except it handles NaNs differently:\nif exactly one of the two elements being compared is a NaN then the non-NaN element is taken as the maximum.\nOnly if both elements are NaN is NaN propagated.\n\nThis function is a wrapper around C++'s ``std::fmax`` and is similar to NumPy's ``fmax`` function.\n\nSupports :ref:`broadcasting to a common shape <broadcasting-semantics>`,\n:ref:`type promotion <type-promotion-doc>`, and integer and floating-point inputs.\n\nArgs:\n    input (Tensor): the input tensor.\n    other (Tensor): the second input tensor\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.tensor([9.7, float('nan'), 3.1, float('nan')])\n    >>> b = torch.tensor([-2.2, 0.5, float('nan'), float('nan')])\n    >>> torch.fmax(a, b)\n    tensor([9.7000, 0.5000, 3.1000,    nan])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "fmin": {
      "Doc": "\nfmin(input, other, *, out=None) -> Tensor\n\nComputes the element-wise minimum of :attr:`input` and :attr:`other`.\n\nThis is like :func:`torch.minimum` except it handles NaNs differently:\nif exactly one of the two elements being compared is a NaN then the non-NaN element is taken as the minimum.\nOnly if both elements are NaN is NaN propagated.\n\nThis function is a wrapper around C++'s ``std::fmin`` and is similar to NumPy's ``fmin`` function.\n\nSupports :ref:`broadcasting to a common shape <broadcasting-semantics>`,\n:ref:`type promotion <type-promotion-doc>`, and integer and floating-point inputs.\n\nArgs:\n    input (Tensor): the input tensor.\n    other (Tensor): the second input tensor\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.tensor([2.2, float('nan'), 2.1, float('nan')])\n    >>> b = torch.tensor([-9.3, 0.1, float('nan'), float('nan')])\n    >>> torch.fmin(a, b)\n    tensor([-9.3000, 0.1000, 2.1000,    nan])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "fmod": {
      "Doc": "\nfmod(input, other, *, out=None) -> Tensor\n\nApplies C++'s `std::fmod <https://en.cppreference.com/w/cpp/numeric/math/fmod>`_ entrywise.\nThe result has the same sign as the dividend :attr:`input` and its absolute value\nis less than that of :attr:`other`.\n\nThis function may be defined in terms of :func:`torch.div` as\n\n.. code:: python\n\n    torch.fmod(a, b) == a - a.div(b, rounding_mode=\"trunc\") * b\n\nSupports :ref:`broadcasting to a common shape <broadcasting-semantics>`,\n:ref:`type promotion <type-promotion-doc>`, and integer and float inputs.\n\n.. note::\n\n    When the divisor is zero, returns ``NaN`` for floating point dtypes\n    on both CPU and GPU; raises ``RuntimeError`` for integer division by\n    zero on CPU; Integer division by zero on GPU may return any value.\n\n.. note::\n\n   Complex inputs are not supported. In some cases, it is not mathematically\n   possible to satisfy the definition of a modulo operation with complex numbers.\n\n.. seealso::\n\n    :func:`torch.remainder` which implements Python's modulus operator.\n    This one is defined using division rounding down the result.\n\nArgs:\n    input (Tensor): the dividend\n    other (Tensor or Scalar): the divisor\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> torch.fmod(torch.tensor([-3., -2, -1, 1, 2, 3]), 2)\n    tensor([-1., -0., -1.,  1.,  0.,  1.])\n    >>> torch.fmod(torch.tensor([1, 2, 3, 4, 5]), -1.5)\n    tensor([1.0000, 0.5000, 0.0000, 1.0000, 0.5000])\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "fork": {
      "Doc": "fork(*args, **kwargs) -> torch._C.Future\n",
      "Args": {
        "*args": {
          "Type": null,
          "Default": null
        },
        "**kwargs": {
          "Type": null,
          "Default": null
        }
      }
    },
    "frac": {
      "Doc": "\nfrac(input, *, out=None) -> Tensor\n\nComputes the fractional portion of each element in :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\text{input}_{i} - \\left\\lfloor |\\text{input}_{i}| \\right\\rfloor * \\operatorname{sgn}(\\text{input}_{i})\n\nExample::\n\n    >>> torch.frac(torch.tensor([1, 2.5, -3.2]))\n    tensor([ 0.0000,  0.5000, -0.2000])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "frexp": {
      "Doc": "\nfrexp(input, *, out=None) -> (Tensor mantissa, Tensor exponent)\n\nDecomposes :attr:`input` into mantissa and exponent tensors\nsuch that :math:`\\text{input} = \\text{mantissa} \\times 2^{\\text{exponent}}`.\n\nThe range of mantissa is the open interval (-1, 1).\n\nSupports float inputs.\n\nArgs:\n    input (Tensor): the input tensor\n\n\nKeyword args:\n    out (tuple, optional): the output tensors\n\nExample::\n\n    >>> x = torch.arange(9.)\n    >>> mantissa, exponent = torch.frexp(x)\n    >>> mantissa\n    tensor([0.0000, 0.5000, 0.5000, 0.7500, 0.5000, 0.6250, 0.7500, 0.8750, 0.5000])\n    >>> exponent\n    tensor([0, 1, 2, 2, 3, 3, 3, 3, 4], dtype=torch.int32)\n    >>> torch.ldexp(mantissa, exponent)\n    tensor([0., 1., 2., 3., 4., 5., 6., 7., 8.])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None) -> (Tensor mantissa"
        },
        "Tensor exponent": {
          "Type": null,
          "Default": null
        }
      }
    },
    "frobenius_norm": {
      "Doc": null,
      "Args": null
    },
    "from_dlpack": {
      "Doc": "from_dlpack(ext_tensor) -> Tensor\n\n    Converts a tensor from an external library into a ``torch.Tensor``.\n\n    The returned PyTorch tensor will share the memory with the input tensor\n    (which may have come from another library). Note that in-place operations\n    will therefore also affect the data of the input tensor. This may lead to\n    unexpected issues (e.g., other libraries may have read-only flags or\n    immutable data structures), so the user should only do this if they know\n    for sure that this is fine.\n\n    Args:\n        ext_tensor (object with ``__dlpack__`` attribute, or a DLPack capsule):\n            The tensor or DLPack capsule to convert.\n\n            If ``ext_tensor`` is a tensor (or ndarray) object, it must support\n            the ``__dlpack__`` protocol (i.e., have a ``ext_tensor.__dlpack__``\n            method). Otherwise ``ext_tensor`` may be a DLPack capsule, which is\n            an opaque ``PyCapsule`` instance, typically produced by a\n            ``to_dlpack`` function or method.\n\n    Examples::\n\n        >>> import torch.utils.dlpack\n        >>> t = torch.arange(4)\n\n        # Convert a tensor directly (supported in PyTorch >= 1.10)\n        >>> t2 = torch.from_dlpack(t)\n        >>> t2[:2] = -1  # show that memory is shared\n        >>> t2\n        tensor([-1, -1,  2,  3])\n        >>> t\n        tensor([-1, -1,  2,  3])\n\n        # The old-style DLPack usage, with an intermediate capsule object\n        >>> capsule = torch.utils.dlpack.to_dlpack(t)\n        >>> capsule\n        <capsule object \"dltensor\" at ...>\n        >>> t3 = torch.from_dlpack(capsule)\n        >>> t3\n        tensor([-1, -1,  2,  3])\n        >>> t3[0] = -9  # now we're sharing memory between 3 tensors\n        >>> t3\n        tensor([-9, -1,  2,  3])\n        >>> t2\n        tensor([-9, -1,  2,  3])\n        >>> t\n        tensor([-9, -1,  2,  3])\n\n    ",
      "Args": {
        "ext_tensor": {
          "Type": "typing.Any",
          "Default": null
        }
      }
    },
    "from_file": {
      "Doc": null,
      "Args": null
    },
    "from_numpy": {
      "Doc": "\nfrom_numpy(ndarray) -> Tensor\n\nCreates a :class:`Tensor` from a :class:`numpy.ndarray`.\n\nThe returned tensor and :attr:`ndarray` share the same memory. Modifications to\nthe tensor will be reflected in the :attr:`ndarray` and vice versa. The returned\ntensor is not resizable.\n\nIt currently accepts :attr:`ndarray` with dtypes of ``numpy.float64``,\n``numpy.float32``, ``numpy.float16``, ``numpy.complex64``, ``numpy.complex128``,\n``numpy.int64``, ``numpy.int32``, ``numpy.int16``, ``numpy.int8``, ``numpy.uint8``,\nand ``numpy.bool``.\n\n.. warning::\n    Writing to a tensor created from a read-only NumPy array is not supported and will result in undefined behavior.\n\nExample::\n\n    >>> a = numpy.array([1, 2, 3])\n    >>> t = torch.from_numpy(a)\n    >>> t\n    tensor([ 1,  2,  3])\n    >>> t[0] = -1\n    >>> a\n    array([-1,  2,  3])\n",
      "Args": {
        "ndarray": {
          "Type": null,
          "Default": null
        }
      }
    },
    "frombuffer": {
      "Doc": "\nfrombuffer(buffer, *, dtype, count=-1, offset=0, requires_grad=False) -> Tensor\n\nCreates a 1-dimensional :class:`Tensor` from an object that implements\nthe Python buffer protocol.\n\nSkips the first :attr:`offset` bytes in the buffer, and interprets the rest of\nthe raw bytes as a 1-dimensional tensor of type :attr:`dtype` with :attr:`count`\nelements.\n\nNote that either of the following must be true:\n\n1. :attr:`count` is a positive non-zero number, and the total number of bytes\nin the buffer is less than :attr:`offset` plus :attr:`count` times the size\n(in bytes) of :attr:`dtype`.\n\n2. :attr:`count` is negative, and the length (number of bytes) of the buffer\nsubtracted by the :attr:`offset` is a multiple of the size (in bytes) of\n:attr:`dtype`.\n\nThe returned tensor and buffer share the same memory. Modifications to\nthe tensor will be reflected in the buffer and vice versa. The returned\ntensor is not resizable.\n\n.. note::\n    This function increments the reference count for the object that\n    owns the shared memory. Therefore, such memory will not be deallocated\n    before the returned tensor goes out of scope.\n\n.. warning::\n    This function's behavior is undefined when passed an object implementing\n    the buffer protocol whose data is not on the CPU. Doing so is likely to\n    cause a segmentation fault.\n\n.. warning::\n    This function does not try to infer the :attr:`dtype` (hence, it is not\n    optional). Passing a different :attr:`dtype` than its source may result\n    in unexpected behavior.\n\nArgs:\n    buffer (object): a Python object that exposes the buffer interface.\n\nKeyword args:\n    dtype (:class:`torch.dtype`): the desired data type of returned tensor.\n    count (int, optional): the number of desired elements to be read.\n        If negative, all the elements (until the end of the buffer) will be\n        read. Default: -1.\n    offset (int, optional): the number of bytes to skip at the start of\n        the buffer. Default: 0.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n\nExample::\n\n    >>> import array\n    >>> a = array.array('i', [1, 2, 3])\n    >>> t = torch.frombuffer(a, dtype=torch.int32)\n    >>> t\n    tensor([ 1,  2,  3])\n    >>> t[0] = -1\n    >>> a\n    array([-1,  2,  3])\n\n    >>> # Interprets the signed char bytes as 32-bit integers.\n    >>> # Each 4 signed char elements will be interpreted as\n    >>> # 1 signed 32-bit integer.\n    >>> import array\n    >>> a = array.array('b', [-1, 0, 0, 0])\n    >>> torch.frombuffer(a, dtype=torch.int32)\n    tensor([255], dtype=torch.int32)\n",
      "Args": {
        "buffer": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": null
        },
        "count": {
          "Type": null,
          "Default": "-1"
        },
        "offset": {
          "Type": null,
          "Default": "0"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "full": {
      "Doc": "\nfull(size, fill_value, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nCreates a tensor of size :attr:`size` filled with :attr:`fill_value`. The\ntensor's dtype is inferred from :attr:`fill_value`.\n\nArgs:\n    size (int...): a list, tuple, or :class:`torch.Size` of integers defining the\n        shape of the output tensor.\n    fill_value (Scalar): the value to fill the output tensor with.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).\n    layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.\n        Default: ``torch.strided``.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n\nExample::\n\n    >>> torch.full((2, 3), 3.141592)\n    tensor([[ 3.1416,  3.1416,  3.1416],\n            [ 3.1416,  3.1416,  3.1416]])\n",
      "Args": {
        "size": {
          "Type": null,
          "Default": null
        },
        "fill_value": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "torch.strided"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "full_like": {
      "Doc": "\nfull_like(input, fill_value, \\*, dtype=None, layout=torch.strided, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor\n\nReturns a tensor with the same size as :attr:`input` filled with :attr:`fill_value`.\n``torch.full_like(input, fill_value)`` is equivalent to\n``torch.full(input.size(), fill_value, dtype=input.dtype, layout=input.layout, device=input.device)``.\n\nArgs:\n    input (Tensor): the size of :attr:`input` will determine size of the output tensor.\n    fill_value: the number to fill the output tensor with.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.\n        Default: if ``None``, defaults to the dtype of :attr:`input`.\n    layout (:class:`torch.layout`, optional): the desired layout of returned tensor.\n        Default: if ``None``, defaults to the layout of :attr:`input`.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, defaults to the device of :attr:`input`.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n    memory_format (:class:`torch.memory_format`, optional): the desired memory format of\n        returned Tensor. Default: ``torch.preserve_format``.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "fill_value": {
          "Type": null,
          "Default": null
        },
        "\\*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "torch.strided"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        },
        "memory_format": {
          "Type": null,
          "Default": "torch.preserve_format"
        }
      }
    },
    "fused_moving_avg_obs_fake_quant": {
      "Doc": null,
      "Args": null
    },
    "gather": {
      "Doc": "\ngather(input, dim, index, *, sparse_grad=False, out=None) -> Tensor\n\nGathers values along an axis specified by `dim`.\n\nFor a 3-D tensor the output is specified by::\n\n    out[i][j][k] = input[index[i][j][k]][j][k]  # if dim == 0\n    out[i][j][k] = input[i][index[i][j][k]][k]  # if dim == 1\n    out[i][j][k] = input[i][j][index[i][j][k]]  # if dim == 2\n\n:attr:`input` and :attr:`index` must have the same number of dimensions.\nIt is also required that ``index.size(d) <= input.size(d)`` for all\ndimensions ``d != dim``.  :attr:`out` will have the same shape as :attr:`index`.\nNote that ``input`` and ``index`` do not broadcast against each other.\n\nArgs:\n    input (Tensor): the source tensor\n    dim (int): the axis along which to index\n    index (LongTensor): the indices of elements to gather\n\nKeyword arguments:\n    sparse_grad (bool, optional): If ``True``, gradient w.r.t. :attr:`input` will be a sparse tensor.\n    out (Tensor, optional): the destination tensor\n\nExample::\n\n    >>> t = torch.tensor([[1, 2], [3, 4]])\n    >>> torch.gather(t, 1, torch.tensor([[0, 0], [1, 0]]))\n    tensor([[ 1,  1],\n            [ 4,  3]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "index": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "sparse_grad": {
          "Type": null,
          "Default": "False"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "gcd": {
      "Doc": "\ngcd(input, other, *, out=None) -> Tensor\n\nComputes the element-wise greatest common divisor (GCD) of :attr:`input` and :attr:`other`.\n\nBoth :attr:`input` and :attr:`other` must have integer types.\n\n.. note::\n    This defines :math:`gcd(0, 0) = 0`.\n\nArgs:\n    input (Tensor): the input tensor.\n    other (Tensor): the second input tensor\n\nKeyword arguments:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.tensor([5, 10, 15])\n    >>> b = torch.tensor([3, 4, 5])\n    >>> torch.gcd(a, b)\n    tensor([1, 2, 5])\n    >>> c = torch.tensor([3])\n    >>> torch.gcd(a, c)\n    tensor([1, 1, 3])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "ge": {
      "Doc": "\nge(input, other, *, out=None) -> Tensor\n\nComputes :math:`\\text{input} \\geq \\text{other}` element-wise.\n\n\nThe second argument can be a number or a tensor whose shape is\n:ref:`broadcastable <broadcasting-semantics>` with the first argument.\n\nArgs:\n    input (Tensor): the tensor to compare\n    other (Tensor or float): the tensor or value to compare\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nReturns:\n    A boolean tensor that is True where :attr:`input` is greater than or equal to :attr:`other` and False elsewhere\n\nExample::\n\n    >>> torch.ge(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))\n    tensor([[True, True], [False, True]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "geqrf": {
      "Doc": "\ngeqrf(input, *, out=None) -> (Tensor, Tensor)\n\nThis is a low-level function for calling LAPACK's geqrf directly. This function\nreturns a namedtuple (a, tau) as defined in `LAPACK documentation for geqrf`_ .\n\nComputes a QR decomposition of :attr:`input`.\nBoth `Q` and `R` matrices are stored in the same output tensor `a`.\nThe elements of `R` are stored on and above the diagonal.\nElementary reflectors (or Householder vectors) implicitly defining matrix `Q`\nare stored below the diagonal.\nThe results of this function can be used together with :func:`torch.linalg.householder_product`\nto obtain the `Q` matrix or\nwith :func:`torch.ormqr`, which uses an implicit representation of the `Q` matrix,\nfor an efficient matrix-matrix multiplication.\n\nSee `LAPACK documentation for geqrf`_ for further details.\n\n.. note::\n    See also :func:`torch.linalg.qr`, which computes Q and R matrices, and :func:`torch.linalg.lstsq`\n    with the ``driver=\"gels\"`` option for a function that can solve matrix equations using a QR decomposition.\n\nArgs:\n    input (Tensor): the input matrix\n\nKeyword args:\n    out (tuple, optional): the output tuple of (Tensor, Tensor). Ignored if `None`. Default: `None`.\n\n.. _LAPACK documentation for geqrf:\n    http://www.netlib.org/lapack/explore-html/df/dc5/group__variants_g_ecomputational_ga3766ea903391b5cf9008132f7440ec7b.html\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None) -> (Tensor"
        },
        "Tensor": {
          "Type": null,
          "Default": null
        }
      }
    },
    "ger": {
      "Doc": "\nger(input, vec2, *, out=None) -> Tensor\n\nAlias of :func:`torch.outer`.\n\n.. warning::\n    This function is deprecated and will be removed in a future PyTorch release.\n    Use :func:`torch.outer` instead.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "vec2": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "get_autocast_cpu_dtype": {
      "Doc": null,
      "Args": null
    },
    "get_autocast_gpu_dtype": {
      "Doc": null,
      "Args": null
    },
    "get_default_dtype": {
      "Doc": "\nget_default_dtype() -> torch.dtype\n\nGet the current default floating point :class:`torch.dtype`.\n\nExample::\n\n    >>> torch.get_default_dtype()  # initial default for floating point is torch.float32\n    torch.float32\n    >>> torch.set_default_dtype(torch.float64)\n    >>> torch.get_default_dtype()  # default is now changed to torch.float64\n    torch.float64\n    >>> torch.set_default_tensor_type(torch.FloatTensor)  # setting tensor type also affects this\n    >>> torch.get_default_dtype()  # changed to torch.float32, the dtype for torch.FloatTensor\n    torch.float32\n\n",
      "Args": {
        "torch.float64": {
          "Type": null,
          "Default": null
        }
      }
    },
    "get_deterministic_debug_mode": {
      "Doc": "Returns the current value of the debug mode for deterministic\n    operations. Refer to :func:`torch.set_deterministic_debug_mode`\n    documentation for more details.\n    ",
      "Args": {}
    },
    "get_device": {
      "Doc": null,
      "Args": null
    },
    "get_file_path": {
      "Doc": null,
      "Args": {
        "*path_components": {
          "Type": null,
          "Default": null
        }
      }
    },
    "get_float32_matmul_precision": {
      "Doc": "Returns the current value of float32 matrix multiplication precision. Refer to\n    :func:`torch.set_float32_matmul_precision` documentation for more details.\n    ",
      "Args": {}
    },
    "get_num_interop_threads": {
      "Doc": "\nget_num_interop_threads() -> int\n\nReturns the number of threads used for inter-op parallelism on CPU\n(e.g. in JIT interpreter)\n",
      "Args": {
        "e.g. in JIT interpreter": {
          "Type": null,
          "Default": null
        }
      }
    },
    "get_num_threads": {
      "Doc": "\nget_num_threads() -> int\n\nReturns the number of threads used for parallelizing CPU operations\n",
      "Args": null
    },
    "get_rng_state": {
      "Doc": "Returns the random number generator state as a `torch.ByteTensor`.",
      "Args": {}
    },
    "gradient": {
      "Doc": "\ngradient(input, *, spacing=1, dim=None, edge_order=1) -> List of Tensors\n\nEstimates the gradient of a function :math:`g : \\mathbb{R}^n \\rightarrow \\mathbb{R}` in\none or more dimensions using the `second-order accurate central differences method\n<https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_.\n\nThe gradient of :math:`g` is estimated using samples. By default, when :attr:`spacing` is not\nspecified, the samples are entirely described by :attr:`input`, and the mapping of input coordinates\nto an output is the same as the tensor's mapping of indices to values. For example, for a three-dimensional\n:attr:`input` the function described is :math:`g : \\mathbb{R}^3 \\rightarrow \\mathbb{R}`, and\n:math:`g(1, 2, 3)\\ == input[1, 2, 3]`.\n\nWhen :attr:`spacing` is specified, it modifies the relationship between :attr:`input` and input coordinates.\nThis is detailed in the \"Keyword Arguments\" section below.\n\nThe gradient is estimated by estimating each partial derivative of :math:`g` independently. This estimation is\naccurate if :math:`g` is in :math:`C^3` (it has at least 3 continuous derivatives), and the estimation can be\nimproved by providing closer samples. Mathematically, the value at each interior point of a partial derivative\nis estimated using `Taylor\u2019s theorem with remainder <https://en.wikipedia.org/wiki/Taylor%27s_theorem>`_.\nLetting :math:`x` be an interior point and  :math:`x+h_r` be point neighboring it, the partial gradient at\n:math:`f(x+h_r)` is estimated using:\n\n.. math::\n    \\begin{aligned}\n        f(x+h_r) = f(x) + h_r f'(x) + {h_r}^2  \\frac{f''(x)}{2} + {h_r}^3 \\frac{f'''(x_r)}{6} \\\\\n    \\end{aligned}\n\nwhere :math:`x_r` is a number in the interval :math:`[x, x+ h_r]`  and using the fact that :math:`f \\in C^3`\nwe derive :\n\n.. math::\n    f'(x) \\approx \\frac{ {h_l}^2 f(x+h_r) - {h_r}^2 f(x-h_l)\n          + ({h_r}^2-{h_l}^2 ) f(x) }{ {h_r} {h_l}^2 + {h_r}^2 {h_l} }\n\n.. note::\n    We estimate the gradient of functions in complex domain\n    :math:`g : \\mathbb{C}^n \\rightarrow \\mathbb{C}` in the same way.\n\nThe value of each partial derivative at the boundary points is computed differently. See edge_order below.\n\nArgs:\n    input (``Tensor``): the tensor that represents the values of the function\n\nKeyword args:\n    spacing (``scalar``, ``list of scalar``, ``list of Tensor``, optional): :attr:`spacing` can be used to modify\n        how the :attr:`input` tensor's indices relate to sample coordinates. If :attr:`spacing` is a scalar then\n        the indices are multiplied by the scalar to produce the coordinates. For example, if :attr:`spacing=2` the\n        indices (1, 2, 3) become coordinates (2, 4, 6). If :attr:`spacing` is a list of scalars then the corresponding\n        indices are multiplied. For example, if :attr:`spacing=(2, -1, 3)` the indices (1, 2, 3) become coordinates (2, -2, 9).\n        Finally, if :attr:`spacing` is a list of one-dimensional tensors then each tensor specifies the coordinates for\n        the corresponding dimension. For example, if the indices are (1, 2, 3) and the tensors are (t0, t1, t2), then\n        the coordinates are (t0[1], t1[2], t2[3])\n\n    dim (``int``, ``list of int``, optional): the dimension or dimensions to approximate the gradient over.  By default\n        the partial  gradient in every dimension is computed. Note that when :attr:`dim` is  specified the elements of\n        the :attr:`spacing` argument must correspond with the specified dims.\"\n\n    edge_order (``int``, optional): 1 or 2, for `first-order\n        <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_ or\n        `second-order <https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_\n        estimation of the boundary (\"edge\") values, respectively.\n\nExamples::\n\n    >>> # Estimates the gradient of f(x)=x^2 at points [-2, -1, 2, 4]\n    >>> coordinates = (torch.tensor([-2., -1., 1., 4.]),)\n    >>> values = torch.tensor([4., 1., 1., 16.], )\n    >>> torch.gradient(values, spacing = coordinates)\n    (tensor([-3., -2., 2., 5.]),)\n\n    >>> # Estimates the gradient of the R^2 -> R function whose samples are\n    >>> # described by the tensor t. Implicit coordinates are [0, 1] for the outermost\n    >>> # dimension and [0, 1, 2, 3] for the innermost dimension, and function estimates\n    >>> # partial derivative for both dimensions.\n    >>> t = torch.tensor([[1, 2, 4, 8], [10, 20, 40, 80]])\n    >>> torch.gradient(t)\n    (tensor([[ 9., 18., 36., 72.],\n             [ 9., 18., 36., 72.]]),\n     tensor([[ 1.0000, 1.5000, 3.0000, 4.0000],\n             [10.0000, 15.0000, 30.0000, 40.0000]]))\n\n    >>> # A scalar value for spacing modifies the relationship between tensor indices\n    >>> # and input coordinates by multiplying the indices to find the\n    >>> # coordinates. For example, below the indices of the innermost\n    >>> # 0, 1, 2, 3 translate to coordinates of [0, 2, 4, 6], and the indices of\n    >>> # the outermost dimension 0, 1 translate to coordinates of [0, 2].\n    >>> torch.gradient(t, spacing = 2.0) # dim = None (implicitly [0, 1])\n    (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],\n              [ 4.5000, 9.0000, 18.0000, 36.0000]]),\n     tensor([[ 0.5000, 0.7500, 1.5000, 2.0000],\n              [ 5.0000, 7.5000, 15.0000, 20.0000]]))\n    >>> # doubling the spacing between samples halves the estimated partial gradients.\n\n    >>>\n    >>> # Estimates only the partial derivative for dimension 1\n    >>> torch.gradient(t, dim = 1) # spacing = None (implicitly 1.)\n    (tensor([[ 1.0000, 1.5000, 3.0000, 4.0000],\n             [10.0000, 15.0000, 30.0000, 40.0000]]),)\n\n    >>> # When spacing is a list of scalars, the relationship between the tensor\n    >>> # indices and input coordinates changes based on dimension.\n    >>> # For example, below, the indices of the innermost dimension 0, 1, 2, 3 translate\n    >>> # to coordinates of [0, 3, 6, 9], and the indices of the outermost dimension\n    >>> # 0, 1 translate to coordinates of [0, 2].\n    >>> torch.gradient(t, spacing = [3., 2.])\n    (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],\n             [ 4.5000, 9.0000, 18.0000, 36.0000]]),\n     tensor([[ 0.3333, 0.5000, 1.0000, 1.3333],\n             [ 3.3333, 5.0000, 10.0000, 13.3333]]))\n\n    >>> # The following example is a replication of the previous one with explicit\n    >>> # coordinates.\n    >>> coords = (torch.tensor([0, 2]), torch.tensor([0, 3, 6, 9]))\n    >>> torch.gradient(t, spacing = coords)\n    (tensor([[ 4.5000, 9.0000, 18.0000, 36.0000],\n             [ 4.5000, 9.0000, 18.0000, 36.0000]]),\n     tensor([[ 0.3333, 0.5000, 1.0000, 1.3333],\n             [ 3.3333, 5.0000, 10.0000, 13.3333]]))\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "spacing": {
          "Type": null,
          "Default": "1"
        },
        "dim": {
          "Type": null,
          "Default": "None"
        },
        "edge_order": {
          "Type": null,
          "Default": "1"
        }
      }
    },
    "greater": {
      "Doc": "\ngreater(input, other, *, out=None) -> Tensor\n\nAlias for :func:`torch.gt`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "greater_equal": {
      "Doc": "\ngreater_equal(input, other, *, out=None) -> Tensor\n\nAlias for :func:`torch.ge`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "grid_sampler": {
      "Doc": null,
      "Args": null
    },
    "grid_sampler_2d": {
      "Doc": null,
      "Args": null
    },
    "grid_sampler_3d": {
      "Doc": null,
      "Args": null
    },
    "group_norm": {
      "Doc": null,
      "Args": null
    },
    "gru": {
      "Doc": null,
      "Args": null
    },
    "gru_cell": {
      "Doc": null,
      "Args": null
    },
    "gt": {
      "Doc": "\ngt(input, other, *, out=None) -> Tensor\n\nComputes :math:`\\text{input} > \\text{other}` element-wise.\n\n\nThe second argument can be a number or a tensor whose shape is\n:ref:`broadcastable <broadcasting-semantics>` with the first argument.\n\nArgs:\n    input (Tensor): the tensor to compare\n    other (Tensor or float): the tensor or value to compare\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nReturns:\n    A boolean tensor that is True where :attr:`input` is greater than :attr:`other` and False elsewhere\n\nExample::\n\n    >>> torch.gt(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))\n    tensor([[False, True], [False, False]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "hamming_window": {
      "Doc": "\nhamming_window(window_length, periodic=True, alpha=0.54, beta=0.46, *, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nHamming window function.\n\n.. math::\n    w[n] = \\alpha - \\beta\\ \\cos \\left( \\frac{2 \\pi n}{N - 1} \\right),\n\nwhere :math:`N` is the full window size.\n\nThe input :attr:`window_length` is a positive integer controlling the\nreturned window size. :attr:`periodic` flag determines whether the returned\nwindow trims off the last duplicate value from the symmetric window and is\nready to be used as a periodic window with functions like\n:meth:`torch.stft`. Therefore, if :attr:`periodic` is true, the :math:`N` in\nabove formula is in fact :math:`\\text{window\\_length} + 1`. Also, we always have\n``torch.hamming_window(L, periodic=True)`` equal to\n``torch.hamming_window(L + 1, periodic=False)[:-1])``.\n\n.. note::\n    If :attr:`window_length` :math:`=1`, the returned window contains a single value 1.\n\n.. note::\n    This is a generalized version of :meth:`torch.hann_window`.\n\nArguments:\n    window_length (int): the size of returned window\n    periodic (bool, optional): If True, returns a window to be used as periodic\n        function. If False, return a symmetric window.\n    alpha (float, optional): The coefficient :math:`\\alpha` in the equation above\n    beta (float, optional): The coefficient :math:`\\beta` in the equation above\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`). Only floating point types are supported.\n    layout (:class:`torch.layout`, optional): the desired layout of returned window tensor. Only\n          ``torch.strided`` (dense layout) is supported.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n\nReturns:\n    Tensor: A 1-D tensor of size :math:`(\\text{window\\_length},)` containing the window\n\n",
      "Args": {
        "window_length": {
          "Type": null,
          "Default": null
        },
        "periodic": {
          "Type": null,
          "Default": "True"
        },
        "alpha": {
          "Type": null,
          "Default": "0.54"
        },
        "beta": {
          "Type": null,
          "Default": "0.46"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "torch.strided"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "hann_window": {
      "Doc": "\nhann_window(window_length, periodic=True, *, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nHann window function.\n\n.. math::\n    w[n] = \\frac{1}{2}\\ \\left[1 - \\cos \\left( \\frac{2 \\pi n}{N - 1} \\right)\\right] =\n            \\sin^2 \\left( \\frac{\\pi n}{N - 1} \\right),\n\nwhere :math:`N` is the full window size.\n\nThe input :attr:`window_length` is a positive integer controlling the\nreturned window size. :attr:`periodic` flag determines whether the returned\nwindow trims off the last duplicate value from the symmetric window and is\nready to be used as a periodic window with functions like\n:meth:`torch.stft`. Therefore, if :attr:`periodic` is true, the :math:`N` in\nabove formula is in fact :math:`\\text{window\\_length} + 1`. Also, we always have\n``torch.hann_window(L, periodic=True)`` equal to\n``torch.hann_window(L + 1, periodic=False)[:-1])``.\n\n.. note::\n    If :attr:`window_length` :math:`=1`, the returned window contains a single value 1.\n\nArguments:\n    window_length (int): the size of returned window\n    periodic (bool, optional): If True, returns a window to be used as periodic\n        function. If False, return a symmetric window.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`). Only floating point types are supported.\n    layout (:class:`torch.layout`, optional): the desired layout of returned window tensor. Only\n          ``torch.strided`` (dense layout) is supported.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n\nReturns:\n    Tensor: A 1-D tensor of size :math:`(\\text{window\\_length},)` containing the window\n\n",
      "Args": {
        "window_length": {
          "Type": null,
          "Default": null
        },
        "periodic": {
          "Type": null,
          "Default": "True"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "torch.strided"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "hardshrink": {
      "Doc": "\nhardshrink(input, lambd=0.5) -> Tensor\n\nApplies the hard shrinkage function element-wise\n\nSee :class:`~torch.nn.Hardshrink` for more details.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "lambd": {
          "Type": null,
          "Default": "0.5"
        }
      }
    },
    "heaviside": {
      "Doc": "\nheaviside(input, values, *, out=None) -> Tensor\n\nComputes the Heaviside step function for each element in :attr:`input`.\nThe Heaviside step function is defined as:\n\n.. math::\n    \\text{{heaviside}}(input, values) = \\begin{cases}\n        0, & \\text{if input < 0}\\\\\n        values, & \\text{if input == 0}\\\\\n        1, & \\text{if input > 0}\n    \\end{cases}\n\n\nArgs:\n    input (Tensor): the input tensor.\n    values (Tensor): The values to use where :attr:`input` is zero.\n\nKeyword arguments:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> input = torch.tensor([-1.5, 0, 2.0])\n    >>> values = torch.tensor([0.5])\n    >>> torch.heaviside(input, values)\n    tensor([0.0000, 0.5000, 1.0000])\n    >>> values = torch.tensor([1.2, -2.0, 3.5])\n    >>> torch.heaviside(input, values)\n    tensor([0., -2., 1.])\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "values": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "hinge_embedding_loss": {
      "Doc": null,
      "Args": null
    },
    "histc": {
      "Doc": "\nhistc(input, bins=100, min=0, max=0, *, out=None) -> Tensor\n\nComputes the histogram of a tensor.\n\nThe elements are sorted into equal width bins between :attr:`min` and\n:attr:`max`. If :attr:`min` and :attr:`max` are both zero, the minimum and\nmaximum values of the data are used.\n\nElements lower than min and higher than max are ignored.\n\nArgs:\n    input (Tensor): the input tensor.\n    bins (int): number of histogram bins\n    min (Scalar): lower end of the range (inclusive)\n    max (Scalar): upper end of the range (inclusive)\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nReturns:\n    Tensor: Histogram represented as a tensor\n\nExample::\n\n    >>> torch.histc(torch.tensor([1., 2, 1]), bins=4, min=0, max=3)\n    tensor([ 0.,  2.,  1.,  0.])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "bins": {
          "Type": null,
          "Default": "100"
        },
        "min": {
          "Type": null,
          "Default": "0"
        },
        "max": {
          "Type": null,
          "Default": "0"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "histogram": {
      "Doc": "\nhistogram(input, bins, *, range=None, weight=None, density=False, out=None) -> (Tensor, Tensor)\n\nComputes a histogram of the values in a tensor.\n\n:attr:`bins` can be an integer or a 1D tensor.\n\nIf :attr:`bins` is an int, it specifies the number of equal-width bins.\nBy default, the lower and upper range of the bins is determined by the\nminimum and maximum elements of the input tensor. The :attr:`range`\nargument can be provided to specify a range for the bins.\n\nIf :attr:`bins` is a 1D tensor, it specifies the sequence of bin edges\nincluding the rightmost edge. It should contain at least 2 elements\nand its elements should be increasing.\n\nArgs:\n    input (Tensor): the input tensor.\n    bins: int or 1D Tensor. If int, defines the number of equal-width bins. If tensor,\n          defines the sequence of bin edges including the rightmost edge.\n\nKeyword args:\n    range (tuple of float): Defines the range of the bins.\n    weight (Tensor): If provided, weight should have the same shape as input. Each value in\n                     input contributes its associated weight towards its bin's result.\n    density (bool): If False, the result will contain the count (or total weight) in each bin.\n                    If True, the result is the value of the probability density function over the bins,\n                    normalized such that the integral over the range of the bins is 1.\n    out (Tensor, optional): the output tensor. (tuple, optional): The result tuple of two output tensors (hist, bin_edges).\n\nReturns:\n    hist (Tensor): 1D Tensor containing the values of the histogram.\n    bin_edges(Tensor): 1D Tensor containing the edges of the histogram bins.\n\nExample::\n\n    >>> torch.histogram(torch.tensor([1., 2, 1]), bins=4, range=(0., 3.), weight=torch.tensor([1., 2., 4.]))\n    (tensor([ 0.,  5.,  2.,  0.]), tensor([0., 0.75, 1.5, 2.25, 3.]))\n    >>> torch.histogram(torch.tensor([1., 2, 1]), bins=4, range=(0., 3.), weight=torch.tensor([1., 2., 4.]), density=True)\n    (tensor([ 0.,  0.9524,  0.3810,  0.]), tensor([0., 0.75, 1.5, 2.25, 3.]))\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "bins": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "range": {
          "Type": null,
          "Default": "None"
        },
        "weight": {
          "Type": null,
          "Default": "None"
        },
        "density": {
          "Type": null,
          "Default": "False"
        },
        "out": {
          "Type": null,
          "Default": "None) -> (Tensor"
        },
        "Tensor": {
          "Type": null,
          "Default": null
        }
      }
    },
    "histogramdd": {
      "Doc": "\nhistogramdd(input, bins, *, range=None, weight=None, density=False, out=None) -> (Tensor, Tensor[])\n\nComputes a multi-dimensional histogram of the values in a tensor.\n\nInterprets the elements of an input tensor whose innermost dimension has size N\nas a collection of N-dimensional points. Maps each of the points into a set of\nN-dimensional bins and returns the number of points (or total weight) in each bin.\n\n:attr:`input` must be a tensor with at least 2 dimensions.\nIf input has shape (M, N), each of its M rows defines a point in N-dimensional space.\nIf input has three or more dimensions, all but the last dimension are flattened.\n\nEach dimension is independently associated with its own strictly increasing sequence\nof bin edges. Bin edges may be specified explicitly by passing a sequence of 1D\ntensors. Alternatively, bin edges may be constructed automatically by passing a\nsequence of integers specifying the number of equal-width bins in each dimension.\n\nFor each N-dimensional point in input:\n    - Each of its coordinates is binned independently among the bin edges\n        corresponding to its dimension\n    - Binning results are combined to identify the N-dimensional bin (if any)\n        into which the point falls\n    - If the point falls into a bin, the bin's count (or total weight) is incremented\n    - Points which do not fall into any bin do not contribute to the output\n\n:attr:`bins` can be a sequence of N 1D tensors, a sequence of N ints, or a single int.\n\nIf :attr:`bins` is a sequence of N 1D tensors, it explicitly specifies the N sequences\nof bin edges. Each 1D tensor should contain a strictly increasing sequence with at\nleast one element. A sequence of K bin edges defines K-1 bins, explicitly specifying\nthe left and right edges of all bins. Every bin is exclusive of its left edge. Only\nthe rightmost bin is inclusive of its right edge.\n\nIf :attr:`bins` is a sequence of N ints, it specifies the number of equal-width bins\nin each dimension. By default, the leftmost and rightmost bin edges in each dimension\nare determined by the minimum and maximum elements of the input tensor in the\ncorresponding dimension. The :attr:`range` argument can be provided to manually\nspecify the leftmost and rightmost bin edges in each dimension.\n\nIf :attr:`bins` is an int, it specifies the number of equal-width bins for all dimensions.\n\n.. note::\n    See also :func:`torch.histogram`, which specifically computes 1D histograms.\n    While :func:`torch.histogramdd` infers the dimensionality of its bins and\n    binned values from the shape of :attr:`input`, :func:`torch.histogram`\n    accepts and flattens :attr:`input` of any shape.\n\nArgs:\n    {input}\n    bins: Tensor[], int[], or int.\n            If Tensor[], defines the sequences of bin edges.\n            If int[], defines the number of equal-width bins in each dimension.\n            If int, defines the number of equal-width bins for all dimensions.\nKeyword args:\n    range (sequence of float): Defines the leftmost and rightmost bin edges\n                                in each dimension.\n    weight (Tensor): By default, each value in the input has weight 1. If a weight\n                        tensor is passed, each N-dimensional coordinate in input\n                        contributes its associated weight towards its bin's result.\n                        The weight tensor should have the same shape as the :attr:`input`\n                        tensor excluding its innermost dimension N.\n    density (bool): If False (default), the result will contain the count (or total weight)\n                    in each bin. If True, each count (weight) is divided by the total count\n                    (total weight), then divided by the volume of its associated bin.\nReturns:\n    hist (Tensor): N-dimensional Tensor containing the values of the histogram.\n    bin_edges(Tensor[]): sequence of N 1D Tensors containing the bin edges.\n\nExample::\n    >>> torch.histogramdd(torch.tensor([[0., 1.], [1., 0.], [2., 0.], [2., 2.]]), bins=[3, 3],\n    ...                   weight=torch.tensor([1., 2., 4., 8.]))\n        torch.return_types.histogramdd(\n            hist=tensor([[0., 1., 0.],\n                         [2., 0., 0.],\n                         [4., 0., 8.]]),\n            bin_edges=(tensor([0.0000, 0.6667, 1.3333, 2.0000]),\n                       tensor([0.0000, 0.6667, 1.3333, 2.0000])))\n\n    >>> torch.histogramdd(torch.tensor([[0., 0.], [1., 1.], [2., 2.]]), bins=[2, 2],\n    ...                   range=[0., 1., 0., 1.], density=True)\n        torch.return_types.histogramdd(\n           hist=tensor([[2., 0.],\n                        [0., 2.]]),\n           bin_edges=(tensor([0.0000, 0.5000, 1.0000]),\n                      tensor([0.0000, 0.5000, 1.0000])))\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "bins": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "range": {
          "Type": null,
          "Default": "None"
        },
        "weight": {
          "Type": null,
          "Default": "None"
        },
        "density": {
          "Type": null,
          "Default": "False"
        },
        "out": {
          "Type": null,
          "Default": "None) -> (Tensor"
        },
        "Tensor[]": {
          "Type": null,
          "Default": null
        }
      }
    },
    "hsmm": {
      "Doc": null,
      "Args": null
    },
    "hsplit": {
      "Doc": "\nhsplit(input, indices_or_sections) -> List of Tensors\n\nSplits :attr:`input`, a tensor with one or more dimensions, into multiple tensors\nhorizontally according to :attr:`indices_or_sections`. Each split is a view of\n:attr:`input`.\n\nIf :attr:`input` is one dimensional this is equivalent to calling\ntorch.tensor_split(input, indices_or_sections, dim=0) (the split dimension is\nzero), and if :attr:`input` has two or more dimensions it's equivalent to calling\ntorch.tensor_split(input, indices_or_sections, dim=1) (the split dimension is 1),\nexcept that if :attr:`indices_or_sections` is an integer it must evenly divide\nthe split dimension or a runtime error will be thrown.\n\nThis function is based on NumPy's :func:`numpy.hsplit`.\n\nArgs:\n    input (Tensor): tensor to split.\n    indices_or_sections (int or list or tuple of ints): See argument in :func:`torch.tensor_split`.\n\nExample::\n    >>> t = torch.arange(16.0).reshape(4,4)\n    >>> t\n    tensor([[ 0.,  1.,  2.,  3.],\n            [ 4.,  5.,  6.,  7.],\n            [ 8.,  9., 10., 11.],\n            [12., 13., 14., 15.]])\n    >>> torch.hsplit(t, 2)\n    (tensor([[ 0.,  1.],\n             [ 4.,  5.],\n             [ 8.,  9.],\n             [12., 13.]]),\n     tensor([[ 2.,  3.],\n             [ 6.,  7.],\n             [10., 11.],\n             [14., 15.]]))\n    >>> torch.hsplit(t, [3, 6])\n    (tensor([[ 0.,  1.,  2.],\n             [ 4.,  5.,  6.],\n             [ 8.,  9., 10.],\n             [12., 13., 14.]]),\n     tensor([[ 3.],\n             [ 7.],\n             [11.],\n             [15.]]),\n     tensor([], size=(4, 0)))\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "indices_or_sections": {
          "Type": null,
          "Default": null
        }
      }
    },
    "hspmm": {
      "Doc": "\nhspmm(mat1, mat2, *, out=None) -> Tensor\n\nPerforms a matrix multiplication of a :ref:`sparse COO matrix\n<sparse-coo-docs>` :attr:`mat1` and a strided matrix :attr:`mat2`. The\nresult is a (1 + 1)-dimensional :ref:`hybrid COO matrix\n<sparse-hybrid-coo-docs>`.\n\nArgs:\n    mat1 (Tensor): the first sparse matrix to be matrix multiplied\n    mat2 (Tensor): the second strided matrix to be matrix multiplied\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n",
      "Args": {
        "mat1": {
          "Type": null,
          "Default": null
        },
        "mat2": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "hstack": {
      "Doc": "\nhstack(tensors, *, out=None) -> Tensor\n\nStack tensors in sequence horizontally (column wise).\n\nThis is equivalent to concatenation along the first axis for 1-D tensors, and along the second axis for all other tensors.\n\nArgs:\n    tensors (sequence of Tensors): sequence of tensors to concatenate\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.tensor([1, 2, 3])\n    >>> b = torch.tensor([4, 5, 6])\n    >>> torch.hstack((a,b))\n    tensor([1, 2, 3, 4, 5, 6])\n    >>> a = torch.tensor([[1],[2],[3]])\n    >>> b = torch.tensor([[4],[5],[6]])\n    >>> torch.hstack((a,b))\n    tensor([[1, 4],\n            [2, 5],\n            [3, 6]])\n\n",
      "Args": {
        "tensors": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "hypot": {
      "Doc": "\nhypot(input, other, *, out=None) -> Tensor\n\nGiven the legs of a right triangle, return its hypotenuse.\n\n.. math::\n    \\text{out}_{i} = \\sqrt{\\text{input}_{i}^{2} + \\text{other}_{i}^{2}}\n\nThe shapes of ``input`` and ``other`` must be\n:ref:`broadcastable <broadcasting-semantics>`.\n\nArgs:\n    input (Tensor): the first input tensor\n    other (Tensor): the second input tensor\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.hypot(torch.tensor([4.0]), torch.tensor([3.0, 4.0, 5.0]))\n    tensor([5.0000, 5.6569, 6.4031])\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "i0": {
      "Doc": "\ni0(input, *, out=None) -> Tensor\n\nAlias for :func:`torch.special.i0`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "igamma": {
      "Doc": "\nigamma(input, other, *, out=None) -> Tensor\n\nAlias for :func:`torch.special.gammainc`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "igammac": {
      "Doc": "\nigammac(input, other, *, out=None) -> Tensor\n\nAlias for :func:`torch.special.gammaincc`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "imag": {
      "Doc": "\nimag(input) -> Tensor\n\nReturns a new tensor containing imaginary values of the :attr:`self` tensor.\nThe returned tensor and :attr:`self` share the same underlying storage.\n\n.. warning::\n    :func:`imag` is only supported for tensors with complex dtypes.\n\nArgs:\n    input (Tensor): the input tensor.\n\nExample::\n\n    >>> x=torch.randn(4, dtype=torch.cfloat)\n    >>> x\n    tensor([(0.3100+0.3553j), (-0.5445-0.7896j), (-1.6492-0.0633j), (-0.0638-0.8119j)])\n    >>> x.imag\n    tensor([ 0.3553, -0.7896, -0.0633, -0.8119])\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "import_ir_module": {
      "Doc": "import_ir_module(arg0: torch._C.CompilationUnit, arg1: str, arg2: object, arg3: dict) -> torch._C.ScriptModule\n",
      "Args": {
        "arg0": {
          "Type": "torch._C.CompilationUnit",
          "Default": null
        },
        "arg1": {
          "Type": "str",
          "Default": null
        },
        "arg2": {
          "Type": "object",
          "Default": null
        },
        "arg3": {
          "Type": "dict",
          "Default": null
        }
      }
    },
    "import_ir_module_from_buffer": {
      "Doc": "import_ir_module_from_buffer(arg0: torch._C.CompilationUnit, arg1: str, arg2: object, arg3: dict) -> torch._C.ScriptModule\n",
      "Args": {
        "arg0": {
          "Type": "torch._C.CompilationUnit",
          "Default": null
        },
        "arg1": {
          "Type": "str",
          "Default": null
        },
        "arg2": {
          "Type": "object",
          "Default": null
        },
        "arg3": {
          "Type": "dict",
          "Default": null
        }
      }
    },
    "index_add": {
      "Doc": "\nindex_add(input, dim, index, source, *, alpha=1, out=None) -> Tensor\n\nSee :meth:`~Tensor.index_add_` for function description.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "index": {
          "Type": null,
          "Default": null
        },
        "source": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "alpha": {
          "Type": null,
          "Default": "1"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "index_copy": {
      "Doc": "\nindex_copy(input, dim, index, source, *, out=None) -> Tensor\n\nSee :meth:`~Tensor.index_add_` for function description.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "index": {
          "Type": null,
          "Default": null
        },
        "source": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "index_fill": {
      "Doc": null,
      "Args": null
    },
    "index_put": {
      "Doc": null,
      "Args": null
    },
    "index_reduce": {
      "Doc": "\nindex_reduce(input, dim, index, source, reduce, *, include_self=True, out=None) -> Tensor\n\nSee :meth:`~Tensor.index_reduce_` for function description.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "index": {
          "Type": null,
          "Default": null
        },
        "source": {
          "Type": null,
          "Default": null
        },
        "reduce": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "include_self": {
          "Type": null,
          "Default": "True"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "index_select": {
      "Doc": "\nindex_select(input, dim, index, *, out=None) -> Tensor\n\nReturns a new tensor which indexes the :attr:`input` tensor along dimension\n:attr:`dim` using the entries in :attr:`index` which is a `LongTensor`.\n\nThe returned tensor has the same number of dimensions as the original tensor\n(:attr:`input`).  The :attr:`dim`\\ th dimension has the same size as the length\nof :attr:`index`; other dimensions have the same size as in the original tensor.\n\n.. note:: The returned tensor does **not** use the same storage as the original\n          tensor.  If :attr:`out` has a different shape than expected, we\n          silently change it to the correct shape, reallocating the underlying\n          storage if necessary.\n\nArgs:\n    input (Tensor): the input tensor.\n    dim (int): the dimension in which we index\n    index (IntTensor or LongTensor): the 1-D tensor containing the indices to index\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> x = torch.randn(3, 4)\n    >>> x\n    tensor([[ 0.1427,  0.0231, -0.5414, -1.0009],\n            [-0.4664,  0.2647, -0.1228, -1.1068],\n            [-1.1734, -0.6571,  0.7230, -0.6004]])\n    >>> indices = torch.tensor([0, 2])\n    >>> torch.index_select(x, 0, indices)\n    tensor([[ 0.1427,  0.0231, -0.5414, -1.0009],\n            [-1.1734, -0.6571,  0.7230, -0.6004]])\n    >>> torch.index_select(x, 1, indices)\n    tensor([[ 0.1427, -0.5414],\n            [-0.4664, -0.1228],\n            [-1.1734,  0.7230]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "index": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "indices_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.indices`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "init_num_threads": {
      "Doc": "init_num_threads() -> None\n\n\ninit_num_threads()\n\nInitializes the number of parallel threads used on the current thread.\n\nCall this whenever a new thread is created in order to propagate values from\n:func:`torch.set_num_threads` onto the new thread.\n\n",
      "Args": null
    },
    "initial_seed": {
      "Doc": "Returns the initial seed for generating random numbers as a\n    Python `long`.\n    ",
      "Args": {}
    },
    "inner": {
      "Doc": "\ninner(input, other, *, out=None) -> Tensor\n\nComputes the dot product for 1D tensors. For higher dimensions, sums the product\nof elements from :attr:`input` and :attr:`other` along their last dimension.\n\n.. note::\n\n    If either :attr:`input` or :attr:`other` is a scalar, the result is equivalent\n    to `torch.mul(input, other)`.\n\n    If both :attr:`input` and :attr:`other` are non-scalars, the size of their last\n    dimension must match and the result is equivalent to `torch.tensordot(input,\n    other, dims=([-1], [-1]))`\n\nArgs:\n    input (Tensor): First input tensor\n    other (Tensor): Second input tensor\n\nKeyword args:\n    out (Tensor, optional): Optional output tensor to write result into. The output\n                            shape is `input.shape[:-1] + other.shape[:-1]`.\n\nExample::\n\n    # Dot product\n    >>> torch.inner(torch.tensor([1, 2, 3]), torch.tensor([0, 2, 1]))\n    tensor(7)\n\n    # Multidimensional input tensors\n    >>> a = torch.randn(2, 3)\n    >>> a\n    tensor([[0.8173, 1.0874, 1.1784],\n            [0.3279, 0.1234, 2.7894]])\n    >>> b = torch.randn(2, 4, 3)\n    >>> b\n    tensor([[[-0.4682, -0.7159,  0.1506],\n            [ 0.4034, -0.3657,  1.0387],\n            [ 0.9892, -0.6684,  0.1774],\n            [ 0.9482,  1.3261,  0.3917]],\n\n            [[ 0.4537,  0.7493,  1.1724],\n            [ 0.2291,  0.5749, -0.2267],\n            [-0.7920,  0.3607, -0.3701],\n            [ 1.3666, -0.5850, -1.7242]]])\n    >>> torch.inner(a, b)\n    tensor([[[-0.9837,  1.1560,  0.2907,  2.6785],\n            [ 2.5671,  0.5452, -0.6912, -1.5509]],\n\n            [[ 0.1782,  2.9843,  0.7366,  1.5672],\n            [ 3.5115, -0.4864, -1.2476, -4.4337]]])\n\n    # Scalar input\n    >>> torch.inner(a, torch.tensor(2))\n    tensor([[1.6347, 2.1748, 2.3567],\n            [0.6558, 0.2469, 5.5787]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "instance_norm": {
      "Doc": null,
      "Args": null
    },
    "int_repr": {
      "Doc": null,
      "Args": null
    },
    "inverse": {
      "Doc": "\ninverse(input, *, out=None) -> Tensor\n\nAlias for :func:`torch.linalg.inv`\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "is_anomaly_check_nan_enabled": {
      "Doc": null,
      "Args": null
    },
    "is_anomaly_enabled": {
      "Doc": null,
      "Args": null
    },
    "is_autocast_cache_enabled": {
      "Doc": null,
      "Args": null
    },
    "is_autocast_cpu_enabled": {
      "Doc": null,
      "Args": null
    },
    "is_autocast_enabled": {
      "Doc": null,
      "Args": null
    },
    "is_complex": {
      "Doc": "\nis_complex(input) -> (bool)\n\nReturns True if the data type of :attr:`input` is a complex data type i.e.,\none of ``torch.complex64``, and ``torch.complex128``.\n\nArgs:\n    input (Tensor): the input tensor.\n",
      "Args": {
        "input) -> (bool": {
          "Type": null,
          "Default": null
        }
      }
    },
    "is_conj": {
      "Doc": "\nis_conj(input) -> (bool)\n\nReturns True if the :attr:`input` is a conjugated tensor, i.e. its conjugate bit is set to `True`.\n\nArgs:\n    input (Tensor): the input tensor.\n",
      "Args": {
        "input) -> (bool": {
          "Type": null,
          "Default": null
        }
      }
    },
    "is_deterministic_algorithms_warn_only_enabled": {
      "Doc": "Returns True if the global deterministic flag is set to warn only.\n    Refer to :func:`torch.use_deterministic_algorithms` documentation for more\n    details.\n    ",
      "Args": {}
    },
    "is_distributed": {
      "Doc": null,
      "Args": null
    },
    "is_floating_point": {
      "Doc": "\nis_floating_point(input) -> (bool)\n\nReturns True if the data type of :attr:`input` is a floating point data type i.e.,\none of ``torch.float64``, ``torch.float32``, ``torch.float16``, and ``torch.bfloat16``.\n\nArgs:\n    input (Tensor): the input tensor.\n",
      "Args": {
        "input) -> (bool": {
          "Type": null,
          "Default": null
        }
      }
    },
    "is_grad_enabled": {
      "Doc": "\nis_grad_enabled() -> (bool)\n\nReturns True if grad mode is currently enabled.\n",
      "Args": {
        ") -> (bool": {
          "Type": null,
          "Default": null
        }
      }
    },
    "is_inference": {
      "Doc": "\nis_inference(input) -> (bool)\n\nReturns True if :attr:`input` is an inference tensor.\n\nA non-view tensor is an inference tensor if and only if it was\nallocated during inference mode. A view tensor is an inference\ntensor if and only if the tensor it is a view of is an inference tensor.\n\nFor details on inference mode please see\n`Inference Mode <https://pytorch.org/cppdocs/notes/inference_mode.html>`_.\n\nArgs:\n    input (Tensor): the input tensor.\n",
      "Args": {
        "input) -> (bool": {
          "Type": null,
          "Default": null
        }
      }
    },
    "is_inference_mode_enabled": {
      "Doc": "\nis_inference_mode_enabled() -> (bool)\n\nReturns True if inference mode is currently enabled.\n",
      "Args": {
        ") -> (bool": {
          "Type": null,
          "Default": null
        }
      }
    },
    "is_neg": {
      "Doc": null,
      "Args": null
    },
    "is_nonzero": {
      "Doc": "\nis_nonzero(input) -> (bool)\n\nReturns True if the :attr:`input` is a single element tensor which is not equal to zero\nafter type conversions.\ni.e. not equal to ``torch.tensor([0.])`` or ``torch.tensor([0])`` or\n``torch.tensor([False])``.\nThrows a ``RuntimeError`` if ``torch.numel() != 1`` (even in case\nof sparse tensors).\n\nArgs:\n    input (Tensor): the input tensor.\n\nExamples::\n\n    >>> torch.is_nonzero(torch.tensor([0.]))\n    False\n    >>> torch.is_nonzero(torch.tensor([1.5]))\n    True\n    >>> torch.is_nonzero(torch.tensor([False]))\n    False\n    >>> torch.is_nonzero(torch.tensor([3]))\n    True\n    >>> torch.is_nonzero(torch.tensor([1, 3, 5]))\n    Traceback (most recent call last):\n    ...\n    RuntimeError: bool value of Tensor with more than one value is ambiguous\n    >>> torch.is_nonzero(torch.tensor([]))\n    Traceback (most recent call last):\n    ...\n    RuntimeError: bool value of Tensor with no values is ambiguous\n",
      "Args": {
        "input) -> (bool": {
          "Type": null,
          "Default": null
        }
      }
    },
    "is_same_size": {
      "Doc": null,
      "Args": null
    },
    "is_signed": {
      "Doc": null,
      "Args": null
    },
    "is_storage": {
      "Doc": "Returns True if `obj` is a PyTorch storage object.\n\n    Args:\n        obj (Object): Object to test\n    ",
      "Args": {
        "obj": {
          "Type": null,
          "Default": null
        }
      }
    },
    "is_tensor": {
      "Doc": "Returns True if `obj` is a PyTorch tensor.\n\n    Note that this function is simply doing ``isinstance(obj, Tensor)``.\n    Using that ``isinstance`` check is better for typechecking with mypy,\n    and more explicit - so it's recommended to use that instead of\n    ``is_tensor``.\n\n    Args:\n        obj (Object): Object to test\n    Example::\n\n        >>> x=torch.tensor([1,2,3])\n        >>> torch.is_tensor(x)\n        True\n\n    ",
      "Args": {
        "obj": {
          "Type": null,
          "Default": null
        }
      }
    },
    "is_vulkan_available": {
      "Doc": null,
      "Args": null
    },
    "is_warn_always_enabled": {
      "Doc": "Returns True if the global warn_always flag is turned on. Refer to\n    :func:`torch.set_warn_always` documentation for more details.\n    ",
      "Args": {}
    },
    "isclose": {
      "Doc": "\nisclose(input, other, rtol=1e-05, atol=1e-08, equal_nan=False) -> Tensor\n\nReturns a new tensor with boolean elements representing if each element of\n:attr:`input` is \"close\" to the corresponding element of :attr:`other`.\nCloseness is defined as:\n\n.. math::\n    \\lvert \\text{input} - \\text{other} \\rvert \\leq \\texttt{atol} + \\texttt{rtol} \\times \\lvert \\text{other} \\rvert\n\n\nwhere :attr:`input` and :attr:`other` are finite. Where :attr:`input`\nand/or :attr:`other` are nonfinite they are close if and only if\nthey are equal, with NaNs being considered equal to each other when\n:attr:`equal_nan` is True.\n\nArgs:\n    input (Tensor): first tensor to compare\n    other (Tensor): second tensor to compare\n    atol (float, optional): absolute tolerance. Default: 1e-08\n    rtol (float, optional): relative tolerance. Default: 1e-05\n    equal_nan (bool, optional): if ``True``, then two ``NaN`` s will be considered equal. Default: ``False``\n\nExamples::\n\n    >>> torch.isclose(torch.tensor((1., 2, 3)), torch.tensor((1 + 1e-10, 3, 4)))\n    tensor([ True, False, False])\n    >>> torch.isclose(torch.tensor((float('inf'), 4)), torch.tensor((float('inf'), 6)), rtol=.5)\n    tensor([True, True])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "rtol": {
          "Type": null,
          "Default": "1e-05"
        },
        "atol": {
          "Type": null,
          "Default": "1e-08"
        },
        "equal_nan": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "isfinite": {
      "Doc": "\nisfinite(input) -> Tensor\n\nReturns a new tensor with boolean elements representing if each element is `finite` or not.\n\nReal values are finite when they are not NaN, negative infinity, or infinity.\nComplex values are finite when both their real and imaginary parts are finite.\n\nArgs:\n    input (Tensor): the input tensor.\n\nReturns:\n    A boolean tensor that is True where :attr:`input` is finite and False elsewhere\n\nExample::\n\n    >>> torch.isfinite(torch.tensor([1, float('inf'), 2, float('-inf'), float('nan')]))\n    tensor([True,  False,  True,  False,  False])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "isin": {
      "Doc": "\nisin(elements, test_elements, *, assume_unique=False, invert=False) -> Tensor\n\nTests if each element of :attr:`elements` is in :attr:`test_elements`. Returns\na boolean tensor of the same shape as :attr:`elements` that is True for elements\nin :attr:`test_elements` and False otherwise.\n\n.. note::\n    One of :attr:`elements` or :attr:`test_elements` can be a scalar, but not both.\n\nArgs:\n    elements (Tensor or Scalar): Input elements\n    test_elements (Tensor or Scalar): Values against which to test for each input element\n    assume_unique (bool, optional): If True, assumes both :attr:`elements` and\n        :attr:`test_elements` contain unique elements, which can speed up the\n        calculation. Default: False\n    invert (bool, optional): If True, inverts the boolean return tensor, resulting in True\n        values for elements *not* in :attr:`test_elements`. Default: False\n\nReturns:\n    A boolean tensor of the same shape as :attr:`elements` that is True for elements in\n    :attr:`test_elements` and False otherwise\n\nExample:\n    >>> torch.isin(torch.tensor([[1, 2], [3, 4]]), torch.tensor([2, 3]))\n    tensor([[False,  True],\n            [ True, False]])\n",
      "Args": {
        "elements": {
          "Type": null,
          "Default": null
        },
        "test_elements": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "assume_unique": {
          "Type": null,
          "Default": "False"
        },
        "invert": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "isinf": {
      "Doc": "\nisinf(input) -> Tensor\n\nTests if each element of :attr:`input` is infinite\n(positive or negative infinity) or not.\n\n.. note::\n    Complex values are infinite when their real or imaginary part is\n    infinite.\n\nArgs:\n    input (Tensor): the input tensor.\n\nReturns:\n    A boolean tensor that is True where :attr:`input` is infinite and False elsewhere\n\nExample::\n\n    >>> torch.isinf(torch.tensor([1, float('inf'), 2, float('-inf'), float('nan')]))\n    tensor([False,  True,  False,  True,  False])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "isnan": {
      "Doc": "\nisnan(input) -> Tensor\n\nReturns a new tensor with boolean elements representing if each element of :attr:`input`\nis NaN or not. Complex values are considered NaN when either their real\nand/or imaginary part is NaN.\n\nArguments:\n    input (Tensor): the input tensor.\n\nReturns:\n    A boolean tensor that is True where :attr:`input` is NaN and False elsewhere\n\nExample::\n\n    >>> torch.isnan(torch.tensor([1, float('nan'), 2]))\n    tensor([False, True, False])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "isneginf": {
      "Doc": "\nisneginf(input, *, out=None) -> Tensor\nTests if each element of :attr:`input` is negative infinity or not.\n\nArgs:\n  input (Tensor): the input tensor.\n\nKeyword args:\n  out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.tensor([-float('inf'), float('inf'), 1.2])\n    >>> torch.isneginf(a)\n    tensor([ True, False, False])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "isposinf": {
      "Doc": "\nisposinf(input, *, out=None) -> Tensor\nTests if each element of :attr:`input` is positive infinity or not.\n\nArgs:\n  input (Tensor): the input tensor.\n\nKeyword args:\n  out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.tensor([-float('inf'), float('inf'), 1.2])\n    >>> torch.isposinf(a)\n    tensor([False,  True, False])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "isreal": {
      "Doc": "\nisreal(input) -> Tensor\n\nReturns a new tensor with boolean elements representing if each element of :attr:`input` is real-valued or not.\nAll real-valued types are considered real. Complex values are considered real when their imaginary part is 0.\n\nArguments:\n    input (Tensor): the input tensor.\n\nReturns:\n    A boolean tensor that is True where :attr:`input` is real and False elsewhere\n\nExample::\n\n    >>> torch.isreal(torch.tensor([1, 1+1j, 2+0j]))\n    tensor([True, False, True])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "istft": {
      "Doc": "istft(input, n_fft, hop_length=None, win_length=None, window=None, center=True, normalized=False, onesided=None, length=None, return_complex=False) -> Tensor:\n\nInverse short time Fourier Transform. This is expected to be the inverse of :func:`~torch.stft`.\n\nIt has the same parameters (+ additional optional parameter of :attr:`length`) and it should return the\nleast squares estimation of the original signal. The algorithm will check using the NOLA condition (\nnonzero overlap).\n\nImportant consideration in the parameters :attr:`window` and :attr:`center` so that the envelop\ncreated by the summation of all the windows is never zero at certain point in time. Specifically,\n:math:`\\sum_{t=-\\infty}^{\\infty} |w|^2[n-t\\times hop\\_length] \\cancel{=} 0`.\n\nSince :func:`~torch.stft` discards elements at the end of the signal if they do not fit in a frame,\n``istft`` may return a shorter signal than the original signal (can occur if :attr:`center` is False\nsince the signal isn't padded). If `length` is given in the arguments and is longer than expected,\n``istft`` will pad zeros to the end of the returned signal.\n\nIf :attr:`center` is ``True``, then there will be padding e.g. ``'constant'``, ``'reflect'``, etc.\nLeft padding can be trimmed off exactly because they can be calculated but right padding cannot be\ncalculated without additional information.\n\nExample: Suppose the last window is:\n``[17, 18, 0, 0, 0]`` vs ``[18, 0, 0, 0, 0]``\n\nThe :attr:`n_fft`, :attr:`hop_length`, :attr:`win_length` are all the same which prevents the calculation\nof right padding. These additional values could be zeros or a reflection of the signal so providing\n:attr:`length` could be useful. If :attr:`length` is ``None`` then padding will be aggressively removed\n(some loss of signal).\n\n[1] D. W. Griffin and J. S. Lim, \"Signal estimation from modified short-time Fourier transform,\"\nIEEE Trans. ASSP, vol.32, no.2, pp.236-243, Apr. 1984.\n\nArgs:\n    input (Tensor): The input tensor. Expected to be output of :func:`~torch.stft`,\n        can either be complex (``channel``, ``fft_size``, ``n_frame``), or real\n        (``channel``, ``fft_size``, ``n_frame``, 2) where the ``channel``\n        dimension is optional.\n\n        .. deprecated:: 1.8.0\n            Real input is deprecated, use complex inputs as returned by\n            ``stft(..., return_complex=True)`` instead.\n    n_fft (int): Size of Fourier transform\n    hop_length (Optional[int]): The distance between neighboring sliding window frames.\n        (Default: ``n_fft // 4``)\n    win_length (Optional[int]): The size of window frame and STFT filter. (Default: ``n_fft``)\n    window (Optional[torch.Tensor]): The optional window function.\n        (Default: ``torch.ones(win_length)``)\n    center (bool): Whether :attr:`input` was padded on both sides so that the :math:`t`-th frame is\n        centered at time :math:`t \\times \\text{hop\\_length}`.\n        (Default: ``True``)\n    normalized (bool): Whether the STFT was normalized. (Default: ``False``)\n    onesided (Optional[bool]): Whether the STFT was onesided.\n        (Default: ``True`` if ``n_fft != fft_size`` in the input size)\n    length (Optional[int]): The amount to trim the signal by (i.e. the\n        original signal length). (Default: whole signal)\n    return_complex (Optional[bool]):\n        Whether the output should be complex, or if the input should be\n        assumed to derive from a real signal and window.\n        Note that this is incompatible with ``onesided=True``.\n        (Default: ``False``)\n\nReturns:\n    Tensor: Least squares estimation of the original signal of size (..., signal_length)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "n_fft": {
          "Type": null,
          "Default": null
        },
        "hop_length": {
          "Type": null,
          "Default": "None"
        },
        "win_length": {
          "Type": null,
          "Default": "None"
        },
        "window": {
          "Type": null,
          "Default": "None"
        },
        "center": {
          "Type": null,
          "Default": "True"
        },
        "normalized": {
          "Type": null,
          "Default": "False"
        },
        "onesided": {
          "Type": null,
          "Default": "None"
        },
        "length": {
          "Type": null,
          "Default": "None"
        },
        "return_complex": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "kaiser_window": {
      "Doc": "\nkaiser_window(window_length, periodic=True, beta=12.0, *, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nComputes the Kaiser window with window length :attr:`window_length` and shape parameter :attr:`beta`.\n\nLet I_0 be the zeroth order modified Bessel function of the first kind (see :func:`torch.i0`) and\n``N = L - 1`` if :attr:`periodic` is False and ``L`` if :attr:`periodic` is True,\nwhere ``L`` is the :attr:`window_length`. This function computes:\n\n.. math::\n    out_i = I_0 \\left( \\beta \\sqrt{1 - \\left( {\\frac{i - N/2}{N/2}} \\right) ^2 } \\right) / I_0( \\beta )\n\nCalling ``torch.kaiser_window(L, B, periodic=True)`` is equivalent to calling\n``torch.kaiser_window(L + 1, B, periodic=False)[:-1])``.\nThe :attr:`periodic` argument is intended as a helpful shorthand\nto produce a periodic window as input to functions like :func:`torch.stft`.\n\n.. note::\n    If :attr:`window_length` is one, then the returned window is a single element tensor containing a one.\n\n\nArgs:\n    window_length (int): length of the window.\n    periodic (bool, optional): If True, returns a periodic window suitable for use in spectral analysis.\n        If False, returns a symmetric window suitable for use in filter design.\n    beta (float, optional): shape parameter for the window.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).\n    layout (:class:`torch.layout`, optional): the desired layout of returned window tensor. Only\n          ``torch.strided`` (dense layout) is supported.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n\n",
      "Args": {
        "window_length": {
          "Type": null,
          "Default": null
        },
        "periodic": {
          "Type": null,
          "Default": "True"
        },
        "beta": {
          "Type": null,
          "Default": "12.0"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "torch.strided"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "kl_div": {
      "Doc": null,
      "Args": null
    },
    "kron": {
      "Doc": "\nkron(input, other, *, out=None) -> Tensor\n\nComputes the Kronecker product, denoted by :math:`\\otimes`, of :attr:`input` and :attr:`other`.\n\nIf :attr:`input` is a :math:`(a_0 \\times a_1 \\times \\dots \\times a_n)` tensor and :attr:`other` is a\n:math:`(b_0 \\times b_1 \\times \\dots \\times b_n)` tensor, the result will be a\n:math:`(a_0*b_0 \\times a_1*b_1 \\times \\dots \\times a_n*b_n)` tensor with the following entries:\n\n.. math::\n    (\\text{input} \\otimes \\text{other})_{k_0, k_1, \\dots, k_n} =\n        \\text{input}_{i_0, i_1, \\dots, i_n} * \\text{other}_{j_0, j_1, \\dots, j_n},\n\nwhere :math:`k_t = i_t * b_t + j_t` for :math:`0 \\leq t \\leq n`.\nIf one tensor has fewer dimensions than the other it is unsqueezed until it has the same number of dimensions.\n\nSupports real-valued and complex-valued inputs.\n\n.. note::\n    This function generalizes the typical definition of the Kronecker product for two matrices to two tensors,\n    as described above. When :attr:`input` is a :math:`(m \\times n)` matrix and :attr:`other` is a\n    :math:`(p \\times q)` matrix, the result will be a :math:`(p*m \\times q*n)` block matrix:\n\n    .. math::\n        \\mathbf{A} \\otimes \\mathbf{B}=\\begin{bmatrix}\n        a_{11} \\mathbf{B} & \\cdots & a_{1 n} \\mathbf{B} \\\\\n        \\vdots & \\ddots & \\vdots \\\\\n        a_{m 1} \\mathbf{B} & \\cdots & a_{m n} \\mathbf{B} \\end{bmatrix}\n\n    where :attr:`input` is :math:`\\mathbf{A}` and :attr:`other` is :math:`\\mathbf{B}`.\n\nArguments:\n    input (Tensor)\n    other (Tensor)\n\nKeyword args:\n    out (Tensor, optional): The output tensor. Ignored if ``None``. Default: ``None``\n\nExamples::\n\n    >>> mat1 = torch.eye(2)\n    >>> mat2 = torch.ones(2, 2)\n    >>> torch.kron(mat1, mat2)\n    tensor([[1., 1., 0., 0.],\n            [1., 1., 0., 0.],\n            [0., 0., 1., 1.],\n            [0., 0., 1., 1.]])\n\n    >>> mat1 = torch.eye(2)\n    >>> mat2 = torch.arange(1, 5).reshape(2, 2)\n    >>> torch.kron(mat1, mat2)\n    tensor([[1., 2., 0., 0.],\n            [3., 4., 0., 0.],\n            [0., 0., 1., 2.],\n            [0., 0., 3., 4.]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "kthvalue": {
      "Doc": "\nkthvalue(input, k, dim=None, keepdim=False, *, out=None) -> (Tensor, LongTensor)\n\nReturns a namedtuple ``(values, indices)`` where ``values`` is the :attr:`k` th\nsmallest element of each row of the :attr:`input` tensor in the given dimension\n:attr:`dim`. And ``indices`` is the index location of each element found.\n\nIf :attr:`dim` is not given, the last dimension of the `input` is chosen.\n\nIf :attr:`keepdim` is ``True``, both the :attr:`values` and :attr:`indices` tensors\nare the same size as :attr:`input`, except in the dimension :attr:`dim` where\nthey are of size 1. Otherwise, :attr:`dim` is squeezed\n(see :func:`torch.squeeze`), resulting in both the :attr:`values` and\n:attr:`indices` tensors having 1 fewer dimension than the :attr:`input` tensor.\n\n.. note::\n    When :attr:`input` is a CUDA tensor and there are multiple valid\n    :attr:`k` th values, this function may nondeterministically return\n    :attr:`indices` for any of them.\n\nArgs:\n    input (Tensor): the input tensor.\n    k (int): k for the k-th smallest element\n    dim (int, optional): the dimension to find the kth value along\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not.\n\nKeyword args:\n    out (tuple, optional): the output tuple of (Tensor, LongTensor)\n                           can be optionally given to be used as output buffers\n\nExample::\n\n    >>> x = torch.arange(1., 6.)\n    >>> x\n    tensor([ 1.,  2.,  3.,  4.,  5.])\n    >>> torch.kthvalue(x, 4)\n    torch.return_types.kthvalue(values=tensor(4.), indices=tensor(3))\n\n    >>> x=torch.arange(1.,7.).resize_(2,3)\n    >>> x\n    tensor([[ 1.,  2.,  3.],\n            [ 4.,  5.,  6.]])\n    >>> torch.kthvalue(x, 2, 0, True)\n    torch.return_types.kthvalue(values=tensor([[4., 5., 6.]]), indices=tensor([[1, 1, 1]]))\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "k": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "None"
        },
        "keepdim": {
          "Type": null,
          "Default": "False"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None) -> (Tensor"
        },
        "LongTensor": {
          "Type": null,
          "Default": null
        }
      }
    },
    "layer_norm": {
      "Doc": null,
      "Args": null
    },
    "lcm": {
      "Doc": "\nlcm(input, other, *, out=None) -> Tensor\n\nComputes the element-wise least common multiple (LCM) of :attr:`input` and :attr:`other`.\n\nBoth :attr:`input` and :attr:`other` must have integer types.\n\n.. note::\n    This defines :math:`lcm(0, 0) = 0` and :math:`lcm(0, a) = 0`.\n\nArgs:\n    input (Tensor): the input tensor.\n    other (Tensor): the second input tensor\n\nKeyword arguments:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.tensor([5, 10, 15])\n    >>> b = torch.tensor([3, 4, 5])\n    >>> torch.lcm(a, b)\n    tensor([15, 20, 15])\n    >>> c = torch.tensor([3])\n    >>> torch.lcm(a, c)\n    tensor([15, 30, 15])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "ldexp": {
      "Doc": "\nldexp(input, other, *, out=None) -> Tensor\n\nMultiplies :attr:`input` by 2**:attr:`other`.\n\n.. math::\n    \\text{{out}}_i = \\text{{input}}_i * 2^\\text{{other}}_i\n\n\nTypically this function is used to construct floating point numbers by multiplying\nmantissas in :attr:`input` with integral powers of two created from the exponents\nin :attr:`other`.\n\nArgs:\n    input (Tensor): the input tensor.\n    other (Tensor): a tensor of exponents, typically integers.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> torch.ldexp(torch.tensor([1.]), torch.tensor([1]))\n    tensor([2.])\n    >>> torch.ldexp(torch.tensor([1.0]), torch.tensor([1, 2, 3, 4]))\n    tensor([ 2.,  4.,  8., 16.])\n\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "le": {
      "Doc": "\nle(input, other, *, out=None) -> Tensor\n\nComputes :math:`\\text{input} \\leq \\text{other}` element-wise.\n\n\nThe second argument can be a number or a tensor whose shape is\n:ref:`broadcastable <broadcasting-semantics>` with the first argument.\n\nArgs:\n    input (Tensor): the tensor to compare\n    other (Tensor or Scalar): the tensor or value to compare\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nReturns:\n    A boolean tensor that is True where :attr:`input` is less than or equal to\n    :attr:`other` and False elsewhere\n\nExample::\n\n    >>> torch.le(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))\n    tensor([[True, False], [True, True]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "lerp": {
      "Doc": "\nlerp(input, end, weight, *, out=None)\n\nDoes a linear interpolation of two tensors :attr:`start` (given by :attr:`input`) and :attr:`end` based\non a scalar or tensor :attr:`weight` and returns the resulting :attr:`out` tensor.\n\n.. math::\n    \\text{out}_i = \\text{start}_i + \\text{weight}_i \\times (\\text{end}_i - \\text{start}_i)\n\nThe shapes of :attr:`start` and :attr:`end` must be\n:ref:`broadcastable <broadcasting-semantics>`. If :attr:`weight` is a tensor, then\nthe shapes of :attr:`weight`, :attr:`start`, and :attr:`end` must be :ref:`broadcastable <broadcasting-semantics>`.\n\nArgs:\n    input (Tensor): the tensor with the starting points\n    end (Tensor): the tensor with the ending points\n    weight (float or tensor): the weight for the interpolation formula\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> start = torch.arange(1., 5.)\n    >>> end = torch.empty(4).fill_(10)\n    >>> start\n    tensor([ 1.,  2.,  3.,  4.])\n    >>> end\n    tensor([ 10.,  10.,  10.,  10.])\n    >>> torch.lerp(start, end, 0.5)\n    tensor([ 5.5000,  6.0000,  6.5000,  7.0000])\n    >>> torch.lerp(start, end, torch.full_like(start, 0.5))\n    tensor([ 5.5000,  6.0000,  6.5000,  7.0000])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "end": {
          "Type": null,
          "Default": null
        },
        "weight": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "less": {
      "Doc": "\nless(input, other, *, out=None) -> Tensor\n\nAlias for :func:`torch.lt`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "less_equal": {
      "Doc": "\nless_equal(input, other, *, out=None) -> Tensor\n\nAlias for :func:`torch.le`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "lgamma": {
      "Doc": "\nlgamma(input, *, out=None) -> Tensor\n\nComputes the natural logarithm of the absolute value of the gamma function on :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\ln \\Gamma(|\\text{input}_{i}|)\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.arange(0.5, 2, 0.5)\n    >>> torch.lgamma(a)\n    tensor([ 0.5724,  0.0000, -0.1208])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "linspace": {
      "Doc": "\nlinspace(start, end, steps, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nCreates a one-dimensional tensor of size :attr:`steps` whose values are evenly\nspaced from :attr:`start` to :attr:`end`, inclusive. That is, the value are:\n\n.. math::\n    (\\text{start},\n    \\text{start} + \\frac{\\text{end} - \\text{start}}{\\text{steps} - 1},\n    \\ldots,\n    \\text{start} + (\\text{steps} - 2) * \\frac{\\text{end} - \\text{start}}{\\text{steps} - 1},\n    \\text{end})\n\n\nFrom PyTorch 1.11 linspace requires the steps argument. Use steps=100 to restore the previous behavior.\n\nArgs:\n    start (float): the starting value for the set of points\n    end (float): the ending value for the set of points\n    steps (int): size of the constructed tensor\n\nKeyword arguments:\n    out (Tensor, optional): the output tensor.\n    dtype (torch.dtype, optional): the data type to perform the computation in.\n        Default: if None, uses the global default dtype (see torch.get_default_dtype())\n        when both :attr:`start` and :attr:`end` are real,\n        and corresponding complex dtype when either is complex.\n    layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.\n        Default: ``torch.strided``.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n\n\nExample::\n\n    >>> torch.linspace(3, 10, steps=5)\n    tensor([  3.0000,   4.7500,   6.5000,   8.2500,  10.0000])\n    >>> torch.linspace(-10, 10, steps=5)\n    tensor([-10.,  -5.,   0.,   5.,  10.])\n    >>> torch.linspace(start=-10, end=10, steps=5)\n    tensor([-10.,  -5.,   0.,   5.,  10.])\n    >>> torch.linspace(start=-10, end=10, steps=1)\n    tensor([-10.])\n",
      "Args": {
        "start": {
          "Type": null,
          "Default": null
        },
        "end": {
          "Type": null,
          "Default": null
        },
        "steps": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "torch.strided"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "load": {
      "Doc": "load(f, map_location=None, pickle_module=pickle, *, weights_only=False, **pickle_load_args)\n\n    Loads an object saved with :func:`torch.save` from a file.\n\n    :func:`torch.load` uses Python's unpickling facilities but treats storages,\n    which underlie tensors, specially. They are first deserialized on the\n    CPU and are then moved to the device they were saved from. If this fails\n    (e.g. because the run time system doesn't have certain devices), an exception\n    is raised. However, storages can be dynamically remapped to an alternative\n    set of devices using the :attr:`map_location` argument.\n\n    If :attr:`map_location` is a callable, it will be called once for each serialized\n    storage with two arguments: storage and location. The storage argument\n    will be the initial deserialization of the storage, residing on the CPU.\n    Each serialized storage has a location tag associated with it which\n    identifies the device it was saved from, and this tag is the second\n    argument passed to :attr:`map_location`. The builtin location tags are ``'cpu'``\n    for CPU tensors and ``'cuda:device_id'`` (e.g. ``'cuda:2'``) for CUDA tensors.\n    :attr:`map_location` should return either ``None`` or a storage. If\n    :attr:`map_location` returns a storage, it will be used as the final deserialized\n    object, already moved to the right device. Otherwise, :func:`torch.load` will\n    fall back to the default behavior, as if :attr:`map_location` wasn't specified.\n\n    If :attr:`map_location` is a :class:`torch.device` object or a string containing\n    a device tag, it indicates the location where all tensors should be loaded.\n\n    Otherwise, if :attr:`map_location` is a dict, it will be used to remap location tags\n    appearing in the file (keys), to ones that specify where to put the\n    storages (values).\n\n    User extensions can register their own location tags and tagging and\n    deserialization methods using :func:`torch.serialization.register_package`.\n\n    Args:\n        f: a file-like object (has to implement :meth:`read`, :meth:`readline`, :meth:`tell`, and :meth:`seek`),\n            or a string or os.PathLike object containing a file name\n        map_location: a function, :class:`torch.device`, string or a dict specifying how to remap storage\n            locations\n        pickle_module: module used for unpickling metadata and objects (has to\n            match the :attr:`pickle_module` used to serialize file)\n        weights_only: Indicates whether unpickler should be restricted to\n            loading only tensors, primitive types and dictionaries\n        pickle_load_args: (Python 3 only) optional keyword arguments passed over to\n            :func:`pickle_module.load` and :func:`pickle_module.Unpickler`, e.g.,\n            :attr:`errors=...`.\n\n    .. warning::\n        :func:`torch.load()` unless `weights_only` parameter is set to `True`,\n        uses ``pickle`` module implicitly, which is known to be insecure.\n        It is possible to construct malicious pickle data which will execute arbitrary code\n        during unpickling. Never load data that could have come from an untrusted\n        source in an unsafe mode, or that could have been tampered with. **Only load data you trust**.\n\n    .. note::\n        When you call :func:`torch.load()` on a file which contains GPU tensors, those tensors\n        will be loaded to GPU by default. You can call ``torch.load(.., map_location='cpu')``\n        and then :meth:`load_state_dict` to avoid GPU RAM surge when loading a model checkpoint.\n\n    .. note::\n        By default, we decode byte strings as ``utf-8``.  This is to avoid a common error\n        case ``UnicodeDecodeError: 'ascii' codec can't decode byte 0x...``\n        when loading files saved by Python 2 in Python 3.  If this default\n        is incorrect, you may use an extra :attr:`encoding` keyword argument to specify how\n        these objects should be loaded, e.g., :attr:`encoding='latin1'` decodes them\n        to strings using ``latin1`` encoding, and :attr:`encoding='bytes'` keeps them\n        as byte arrays which can be decoded later with ``byte_array.decode(...)``.\n\n    Example:\n        >>> # xdoctest: +SKIP(\"undefined filepaths\")\n        >>> torch.load('tensors.pt')\n        # Load all tensors onto the CPU\n        >>> torch.load('tensors.pt', map_location=torch.device('cpu'))\n        # Load all tensors onto the CPU, using a function\n        >>> torch.load('tensors.pt', map_location=lambda storage, loc: storage)\n        # Load all tensors onto GPU 1\n        >>> torch.load('tensors.pt', map_location=lambda storage, loc: storage.cuda(1))\n        # Map tensors from GPU 1 to GPU 0\n        >>> torch.load('tensors.pt', map_location={'cuda:1':'cuda:0'})\n        # Load tensor from io.BytesIO object\n        >>> with open('tensor.pt', 'rb') as f:\n        ...     buffer = io.BytesIO(f.read())\n        >>> torch.load(buffer)\n        # Load a module with 'ascii' encoding for unpickling\n        >>> torch.load('module.pt', encoding='ascii')\n    ",
      "Args": {
        "f": {
          "Type": "typing.Union[str, os.PathLike, typing.BinaryIO, typing.IO[bytes]]",
          "Default": null
        },
        "map_location": {
          "Type": "typing.Union[typing.Callable[[torch.Tensor, str], torch.Tensor], torch.device, str, typing.Dict[str, str], NoneType]",
          "Default": "None"
        },
        "pickle_module": {
          "Type": "typing.Any",
          "Default": "None"
        },
        "**pickle_load_args": {
          "Type": null,
          "Default": null
        },
        "weights_only": {
          "Type": "<class 'bool'>",
          "Default": "False"
        }
      }
    },
    "lobpcg": {
      "Doc": "Find the k largest (or smallest) eigenvalues and the corresponding\n    eigenvectors of a symmetric positive definite generalized\n    eigenvalue problem using matrix-free LOBPCG methods.\n\n    This function is a front-end to the following LOBPCG algorithms\n    selectable via `method` argument:\n\n      `method=\"basic\"` - the LOBPCG method introduced by Andrew\n      Knyazev, see [Knyazev2001]. A less robust method, may fail when\n      Cholesky is applied to singular input.\n\n      `method=\"ortho\"` - the LOBPCG method with orthogonal basis\n      selection [StathopoulosEtal2002]. A robust method.\n\n    Supported inputs are dense, sparse, and batches of dense matrices.\n\n    .. note:: In general, the basic method spends least time per\n      iteration. However, the robust methods converge much faster and\n      are more stable. So, the usage of the basic method is generally\n      not recommended but there exist cases where the usage of the\n      basic method may be preferred.\n\n    .. warning:: The backward method does not support sparse and complex inputs.\n      It works only when `B` is not provided (i.e. `B == None`).\n      We are actively working on extensions, and the details of\n      the algorithms are going to be published promptly.\n\n    .. warning:: While it is assumed that `A` is symmetric, `A.grad` is not.\n      To make sure that `A.grad` is symmetric, so that `A - t * A.grad` is symmetric\n      in first-order optimization routines, prior to running `lobpcg`\n      we do the following symmetrization map: `A -> (A + A.t()) / 2`.\n      The map is performed only when the `A` requires gradients.\n\n    Args:\n\n      A (Tensor): the input tensor of size :math:`(*, m, m)`\n\n      B (Tensor, optional): the input tensor of size :math:`(*, m,\n                  m)`. When not specified, `B` is interpereted as\n                  identity matrix.\n\n      X (tensor, optional): the input tensor of size :math:`(*, m, n)`\n                  where `k <= n <= m`. When specified, it is used as\n                  initial approximation of eigenvectors. X must be a\n                  dense tensor.\n\n      iK (tensor, optional): the input tensor of size :math:`(*, m,\n                  m)`. When specified, it will be used as preconditioner.\n\n      k (integer, optional): the number of requested\n                  eigenpairs. Default is the number of :math:`X`\n                  columns (when specified) or `1`.\n\n      n (integer, optional): if :math:`X` is not specified then `n`\n                  specifies the size of the generated random\n                  approximation of eigenvectors. Default value for `n`\n                  is `k`. If :math:`X` is specified, the value of `n`\n                  (when specified) must be the number of :math:`X`\n                  columns.\n\n      tol (float, optional): residual tolerance for stopping\n                 criterion. Default is `feps ** 0.5` where `feps` is\n                 smallest non-zero floating-point number of the given\n                 input tensor `A` data type.\n\n      largest (bool, optional): when True, solve the eigenproblem for\n                 the largest eigenvalues. Otherwise, solve the\n                 eigenproblem for smallest eigenvalues. Default is\n                 `True`.\n\n      method (str, optional): select LOBPCG method. See the\n                 description of the function above. Default is\n                 \"ortho\".\n\n      niter (int, optional): maximum number of iterations. When\n                 reached, the iteration process is hard-stopped and\n                 the current approximation of eigenpairs is returned.\n                 For infinite iteration but until convergence criteria\n                 is met, use `-1`.\n\n      tracker (callable, optional) : a function for tracing the\n                 iteration process. When specified, it is called at\n                 each iteration step with LOBPCG instance as an\n                 argument. The LOBPCG instance holds the full state of\n                 the iteration process in the following attributes:\n\n                   `iparams`, `fparams`, `bparams` - dictionaries of\n                   integer, float, and boolean valued input\n                   parameters, respectively\n\n                   `ivars`, `fvars`, `bvars`, `tvars` - dictionaries\n                   of integer, float, boolean, and Tensor valued\n                   iteration variables, respectively.\n\n                   `A`, `B`, `iK` - input Tensor arguments.\n\n                   `E`, `X`, `S`, `R` - iteration Tensor variables.\n\n                 For instance:\n\n                   `ivars[\"istep\"]` - the current iteration step\n                   `X` - the current approximation of eigenvectors\n                   `E` - the current approximation of eigenvalues\n                   `R` - the current residual\n                   `ivars[\"converged_count\"]` - the current number of converged eigenpairs\n                   `tvars[\"rerr\"]` - the current state of convergence criteria\n\n                 Note that when `tracker` stores Tensor objects from\n                 the LOBPCG instance, it must make copies of these.\n\n                 If `tracker` sets `bvars[\"force_stop\"] = True`, the\n                 iteration process will be hard-stopped.\n\n      ortho_iparams, ortho_fparams, ortho_bparams (dict, optional):\n                 various parameters to LOBPCG algorithm when using\n                 `method=\"ortho\"`.\n\n    Returns:\n\n      E (Tensor): tensor of eigenvalues of size :math:`(*, k)`\n\n      X (Tensor): tensor of eigenvectors of size :math:`(*, m, k)`\n\n    References:\n\n      [Knyazev2001] Andrew V. Knyazev. (2001) Toward the Optimal\n      Preconditioned Eigensolver: Locally Optimal Block Preconditioned\n      Conjugate Gradient Method. SIAM J. Sci. Comput., 23(2),\n      517-541. (25 pages)\n      https://epubs.siam.org/doi/abs/10.1137/S1064827500366124\n\n      [StathopoulosEtal2002] Andreas Stathopoulos and Kesheng\n      Wu. (2002) A Block Orthogonalization Procedure with Constant\n      Synchronization Requirements. SIAM J. Sci. Comput., 23(6),\n      2165-2182. (18 pages)\n      https://epubs.siam.org/doi/10.1137/S1064827500370883\n\n      [DuerschEtal2018] Jed A. Duersch, Meiyue Shao, Chao Yang, Ming\n      Gu. (2018) A Robust and Efficient Implementation of LOBPCG.\n      SIAM J. Sci. Comput., 40(5), C655-C676. (22 pages)\n      https://epubs.siam.org/doi/abs/10.1137/17M1129830\n\n    ",
      "Args": {
        "A": {
          "Type": "<class 'torch.Tensor'>",
          "Default": null
        },
        "k": {
          "Type": "typing.Optional[int]",
          "Default": "None"
        },
        "B": {
          "Type": "typing.Optional[torch.Tensor]",
          "Default": "None"
        },
        "X": {
          "Type": "typing.Optional[torch.Tensor]",
          "Default": "None"
        },
        "n": {
          "Type": "typing.Optional[int]",
          "Default": "None"
        },
        "iK": {
          "Type": "typing.Optional[torch.Tensor]",
          "Default": "None"
        },
        "niter": {
          "Type": "typing.Optional[int]",
          "Default": "None"
        },
        "tol": {
          "Type": "typing.Optional[float]",
          "Default": "None"
        },
        "largest": {
          "Type": "typing.Optional[bool]",
          "Default": "None"
        },
        "method": {
          "Type": "typing.Optional[str]",
          "Default": "None"
        },
        "tracker": {
          "Type": "None",
          "Default": "None"
        },
        "ortho_iparams": {
          "Type": "typing.Optional[typing.Dict[str, int]]",
          "Default": "None"
        },
        "ortho_fparams": {
          "Type": "typing.Optional[typing.Dict[str, float]]",
          "Default": "None"
        },
        "ortho_bparams": {
          "Type": "typing.Optional[typing.Dict[str, bool]]",
          "Default": "None"
        }
      }
    },
    "log": {
      "Doc": "\nlog(input, *, out=None) -> Tensor\n\nReturns a new tensor with the natural logarithm of the elements\nof :attr:`input`.\n\n.. math::\n    y_{i} = \\log_{e} (x_{i})\n\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.rand(5) * 5\n    >>> a\n    tensor([4.7767, 4.3234, 1.2156, 0.2411, 4.5739])\n    >>> torch.log(a)\n    tensor([ 1.5637,  1.4640,  0.1952, -1.4226,  1.5204])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "log10": {
      "Doc": "\nlog10(input, *, out=None) -> Tensor\n\nReturns a new tensor with the logarithm to the base 10 of the elements\nof :attr:`input`.\n\n.. math::\n    y_{i} = \\log_{10} (x_{i})\n\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.rand(5)\n    >>> a\n    tensor([ 0.5224,  0.9354,  0.7257,  0.1301,  0.2251])\n\n\n    >>> torch.log10(a)\n    tensor([-0.2820, -0.0290, -0.1392, -0.8857, -0.6476])\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "log1p": {
      "Doc": "\nlog1p(input, *, out=None) -> Tensor\n\nReturns a new tensor with the natural logarithm of (1 + :attr:`input`).\n\n.. math::\n    y_i = \\log_{e} (x_i + 1)\n\n.. note:: This function is more accurate than :func:`torch.log` for small\n          values of :attr:`input`\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(5)\n    >>> a\n    tensor([-1.0090, -0.9923,  1.0249, -0.5372,  0.2492])\n    >>> torch.log1p(a)\n    tensor([    nan, -4.8653,  0.7055, -0.7705,  0.2225])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "log2": {
      "Doc": "\nlog2(input, *, out=None) -> Tensor\n\nReturns a new tensor with the logarithm to the base 2 of the elements\nof :attr:`input`.\n\n.. math::\n    y_{i} = \\log_{2} (x_{i})\n\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.rand(5)\n    >>> a\n    tensor([ 0.8419,  0.8003,  0.9971,  0.5287,  0.0490])\n\n\n    >>> torch.log2(a)\n    tensor([-0.2483, -0.3213, -0.0042, -0.9196, -4.3504])\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "log_softmax": {
      "Doc": null,
      "Args": null
    },
    "logaddexp": {
      "Doc": "\nlogaddexp(input, other, *, out=None) -> Tensor\n\nLogarithm of the sum of exponentiations of the inputs.\n\nCalculates pointwise :math:`\\log\\left(e^x + e^y\\right)`. This function is useful\nin statistics where the calculated probabilities of events may be so small as to\nexceed the range of normal floating point numbers. In such cases the logarithm\nof the calculated probability is stored. This function allows adding\nprobabilities stored in such a fashion.\n\nThis op should be disambiguated with :func:`torch.logsumexp` which performs a\nreduction on a single tensor.\n\nArgs:\n    input (Tensor): the input tensor.\n    other (Tensor): the second input tensor\n\nKeyword arguments:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> torch.logaddexp(torch.tensor([-1.0]), torch.tensor([-1.0, -2, -3]))\n    tensor([-0.3069, -0.6867, -0.8731])\n    >>> torch.logaddexp(torch.tensor([-100.0, -200, -300]), torch.tensor([-1.0, -2, -3]))\n    tensor([-1., -2., -3.])\n    >>> torch.logaddexp(torch.tensor([1.0, 2000, 30000]), torch.tensor([-1.0, -2, -3]))\n    tensor([1.1269e+00, 2.0000e+03, 3.0000e+04])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "logaddexp2": {
      "Doc": "\nlogaddexp2(input, other, *, out=None) -> Tensor\n\nLogarithm of the sum of exponentiations of the inputs in base-2.\n\nCalculates pointwise :math:`\\log_2\\left(2^x + 2^y\\right)`. See\n:func:`torch.logaddexp` for more details.\n\nArgs:\n    input (Tensor): the input tensor.\n    other (Tensor): the second input tensor\n\nKeyword arguments:\n    out (Tensor, optional): the output tensor.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "logcumsumexp": {
      "Doc": "\nlogcumsumexp(input, dim, *, out=None) -> Tensor\nReturns the logarithm of the cumulative summation of the exponentiation of\nelements of :attr:`input` in the dimension :attr:`dim`.\n\nFor summation index :math:`j` given by `dim` and other indices :math:`i`, the result is\n\n    .. math::\n        \\text{logcumsumexp}(x)_{ij} = \\log \\sum\\limits_{j=0}^{i} \\exp(x_{ij})\n\nArgs:\n    input (Tensor): the input tensor.\n    dim  (int): the dimension to do the operation over\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(10)\n    >>> torch.logcumsumexp(a, dim=0)\n    tensor([-0.42296738, -0.04462666,  0.86278635,  0.94622083,  1.05277811,\n             1.39202815,  1.83525007,  1.84492621,  2.06084887,  2.06844475]))\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "logdet": {
      "Doc": "\nlogdet(input) -> Tensor\n\nCalculates log determinant of a square matrix or batches of square matrices.\n\nIt returns ``-inf`` if the input has a determinant of zero, and ``NaN`` if it has\na negative determinant.\n\n.. note::\n    Backward through :meth:`logdet` internally uses SVD results when :attr:`input`\n    is not invertible. In this case, double backward through :meth:`logdet` will\n    be unstable in when :attr:`input` doesn't have distinct singular values. See\n    :func:`torch.linalg.svd` for details.\n\n.. seealso::\n\n        :func:`torch.linalg.slogdet` computes the sign (resp. angle) and natural logarithm of the\n        absolute value of the determinant of real-valued (resp. complex) square matrices.\n\nArguments:\n    input (Tensor): the input tensor of size ``(*, n, n)`` where ``*`` is zero or more\n                batch dimensions.\n\nExample::\n\n    >>> A = torch.randn(3, 3)\n    >>> torch.det(A)\n    tensor(0.2611)\n    >>> torch.logdet(A)\n    tensor(-1.3430)\n    >>> A\n    tensor([[[ 0.9254, -0.6213],\n             [-0.5787,  1.6843]],\n\n            [[ 0.3242, -0.9665],\n             [ 0.4539, -0.0887]],\n\n            [[ 1.1336, -0.4025],\n             [-0.7089,  0.9032]]])\n    >>> A.det()\n    tensor([1.1990, 0.4099, 0.7386])\n    >>> A.det().log()\n    tensor([ 0.1815, -0.8917, -0.3031])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "logical_and": {
      "Doc": "\nlogical_and(input, other, *, out=None) -> Tensor\n\nComputes the element-wise logical AND of the given input tensors. Zeros are treated as ``False`` and nonzeros are\ntreated as ``True``.\n\nArgs:\n    input (Tensor): the input tensor.\n    other (Tensor): the tensor to compute AND with\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> torch.logical_and(torch.tensor([True, False, True]), torch.tensor([True, False, False]))\n    tensor([ True, False, False])\n    >>> a = torch.tensor([0, 1, 10, 0], dtype=torch.int8)\n    >>> b = torch.tensor([4, 0, 1, 0], dtype=torch.int8)\n    >>> torch.logical_and(a, b)\n    tensor([False, False,  True, False])\n    >>> torch.logical_and(a.double(), b.double())\n    tensor([False, False,  True, False])\n    >>> torch.logical_and(a.double(), b)\n    tensor([False, False,  True, False])\n    >>> torch.logical_and(a, b, out=torch.empty(4, dtype=torch.bool))\n    tensor([False, False,  True, False])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "logical_not": {
      "Doc": "\nlogical_not(input, *, out=None) -> Tensor\n\nComputes the element-wise logical NOT of the given input tensor. If not specified, the output tensor will have the bool\ndtype. If the input tensor is not a bool tensor, zeros are treated as ``False`` and non-zeros are treated as ``True``.\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> torch.logical_not(torch.tensor([True, False]))\n    tensor([False,  True])\n    >>> torch.logical_not(torch.tensor([0, 1, -10], dtype=torch.int8))\n    tensor([ True, False, False])\n    >>> torch.logical_not(torch.tensor([0., 1.5, -10.], dtype=torch.double))\n    tensor([ True, False, False])\n    >>> torch.logical_not(torch.tensor([0., 1., -10.], dtype=torch.double), out=torch.empty(3, dtype=torch.int16))\n    tensor([1, 0, 0], dtype=torch.int16)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "logical_or": {
      "Doc": "\nlogical_or(input, other, *, out=None) -> Tensor\n\nComputes the element-wise logical OR of the given input tensors. Zeros are treated as ``False`` and nonzeros are\ntreated as ``True``.\n\nArgs:\n    input (Tensor): the input tensor.\n    other (Tensor): the tensor to compute OR with\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> torch.logical_or(torch.tensor([True, False, True]), torch.tensor([True, False, False]))\n    tensor([ True, False,  True])\n    >>> a = torch.tensor([0, 1, 10, 0], dtype=torch.int8)\n    >>> b = torch.tensor([4, 0, 1, 0], dtype=torch.int8)\n    >>> torch.logical_or(a, b)\n    tensor([ True,  True,  True, False])\n    >>> torch.logical_or(a.double(), b.double())\n    tensor([ True,  True,  True, False])\n    >>> torch.logical_or(a.double(), b)\n    tensor([ True,  True,  True, False])\n    >>> torch.logical_or(a, b, out=torch.empty(4, dtype=torch.bool))\n    tensor([ True,  True,  True, False])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "logical_xor": {
      "Doc": "\nlogical_xor(input, other, *, out=None) -> Tensor\n\nComputes the element-wise logical XOR of the given input tensors. Zeros are treated as ``False`` and nonzeros are\ntreated as ``True``.\n\nArgs:\n    input (Tensor): the input tensor.\n    other (Tensor): the tensor to compute XOR with\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> torch.logical_xor(torch.tensor([True, False, True]), torch.tensor([True, False, False]))\n    tensor([False, False,  True])\n    >>> a = torch.tensor([0, 1, 10, 0], dtype=torch.int8)\n    >>> b = torch.tensor([4, 0, 1, 0], dtype=torch.int8)\n    >>> torch.logical_xor(a, b)\n    tensor([ True,  True, False, False])\n    >>> torch.logical_xor(a.double(), b.double())\n    tensor([ True,  True, False, False])\n    >>> torch.logical_xor(a.double(), b)\n    tensor([ True,  True, False, False])\n    >>> torch.logical_xor(a, b, out=torch.empty(4, dtype=torch.bool))\n    tensor([ True,  True, False, False])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "logit": {
      "Doc": "\nlogit(input, eps=None, *, out=None) -> Tensor\n\nAlias for :func:`torch.special.logit`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "eps": {
          "Type": null,
          "Default": "None"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "logspace": {
      "Doc": "\nlogspace(start, end, steps, base=10.0, *,          out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\n\nCreates a one-dimensional tensor of size :attr:`steps` whose values are evenly\nspaced from :math:`{{\\text{{base}}}}^{{\\text{{start}}}}` to\n:math:`{{\\text{{base}}}}^{{\\text{{end}}}}`, inclusive, on a logarithmic scale\nwith base :attr:`base`. That is, the values are:\n\n.. math::\n    (\\text{base}^{\\text{start}},\n    \\text{base}^{(\\text{start} + \\frac{\\text{end} - \\text{start}}{ \\text{steps} - 1})},\n    \\ldots,\n    \\text{base}^{(\\text{start} + (\\text{steps} - 2) * \\frac{\\text{end} - \\text{start}}{ \\text{steps} - 1})},\n    \\text{base}^{\\text{end}})\n\n\n\nFrom PyTorch 1.11 logspace requires the steps argument. Use steps=100 to restore the previous behavior.\n\nArgs:\n    start (float): the starting value for the set of points\n    end (float): the ending value for the set of points\n    steps (int): size of the constructed tensor\n    base (float, optional): base of the logarithm function. Default: ``10.0``.\n\nKeyword arguments:\n    out (Tensor, optional): the output tensor.\n    dtype (torch.dtype, optional): the data type to perform the computation in.\n        Default: if None, uses the global default dtype (see torch.get_default_dtype())\n        when both :attr:`start` and :attr:`end` are real,\n        and corresponding complex dtype when either is complex.\n    layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.\n        Default: ``torch.strided``.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n\nExample::\n\n    >>> torch.logspace(start=-10, end=10, steps=5)\n    tensor([ 1.0000e-10,  1.0000e-05,  1.0000e+00,  1.0000e+05,  1.0000e+10])\n    >>> torch.logspace(start=0.1, end=1.0, steps=5)\n    tensor([  1.2589,   2.1135,   3.5481,   5.9566,  10.0000])\n    >>> torch.logspace(start=0.1, end=1.0, steps=1)\n    tensor([1.2589])\n    >>> torch.logspace(start=2, end=2, steps=1, base=2)\n    tensor([4.0])\n",
      "Args": {
        "start": {
          "Type": null,
          "Default": null
        },
        "end": {
          "Type": null,
          "Default": null
        },
        "steps": {
          "Type": null,
          "Default": null
        },
        "base": {
          "Type": null,
          "Default": "10.0"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "torch.strided"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "logsumexp": {
      "Doc": "\nlogsumexp(input, dim, keepdim=False, *, out=None)\n\nReturns the log of summed exponentials of each row of the :attr:`input`\ntensor in the given dimension :attr:`dim`. The computation is numerically\nstabilized.\n\nFor summation index :math:`j` given by `dim` and other indices :math:`i`, the result is\n\n    .. math::\n        \\text{logsumexp}(x)_{i} = \\log \\sum_j \\exp(x_{ij})\n\n\nIf :attr:`keepdim` is ``True``, the output tensor is of the same size\nas :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.\nOtherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the\noutput tensor having 1 (or ``len(dim)``) fewer dimension(s).\n\n\nArgs:\n    input (Tensor): the input tensor.\n    \n    dim (int or tuple of ints, optional): the dimension or dimensions to reduce.\n        If ``None``, all dimensions are reduced.\n\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(3, 3)\n    >>> torch.logsumexp(a, 1)\n    tensor([1.4907, 1.0593, 1.5696])\n    >>> torch.dist(torch.logsumexp(a, 1), torch.log(torch.sum(torch.exp(a), 1)))\n    tensor(1.6859e-07)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "keepdim": {
          "Type": null,
          "Default": "False"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "lstm": {
      "Doc": null,
      "Args": null
    },
    "lstm_cell": {
      "Doc": null,
      "Args": null
    },
    "lstsq": {
      "Doc": null,
      "Args": {
        "input": {
          "Type": "<class 'torch.Tensor'>",
          "Default": null
        },
        "A": {
          "Type": "<class 'torch.Tensor'>",
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "lt": {
      "Doc": "\nlt(input, other, *, out=None) -> Tensor\n\nComputes :math:`\\text{input} < \\text{other}` element-wise.\n\n\nThe second argument can be a number or a tensor whose shape is\n:ref:`broadcastable <broadcasting-semantics>` with the first argument.\n\nArgs:\n    input (Tensor): the tensor to compare\n    other (Tensor or float): the tensor or value to compare\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nReturns:\n    A boolean tensor that is True where :attr:`input` is less than :attr:`other` and False elsewhere\n\nExample::\n\n    >>> torch.lt(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))\n    tensor([[False, False], [True, False]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "lu_solve": {
      "Doc": "\nlu_solve(b, LU_data, LU_pivots, *, out=None) -> Tensor\n\nReturns the LU solve of the linear system :math:`Ax = b` using the partially pivoted\nLU factorization of A from :func:`~linalg.lu_factor`.\n\nThis function supports ``float``, ``double``, ``cfloat`` and ``cdouble`` dtypes for :attr:`input`.\n\n.. warning::\n\n    :func:`torch.lu_solve` is deprecated in favor of :func:`torch.linalg.lu_solve`.\n    :func:`torch.lu_solve` will be removed in a future PyTorch release.\n    ``X = torch.lu_solve(B, LU, pivots)`` should be replaced with\n\n    .. code:: python\n\n        X = linalg.lu_solve(LU, pivots, B)\n\nArguments:\n    b (Tensor): the RHS tensor of size :math:`(*, m, k)`, where :math:`*`\n                is zero or more batch dimensions.\n    LU_data (Tensor): the pivoted LU factorization of A from :meth:`~linalg.lu_factor` of size :math:`(*, m, m)`,\n                       where :math:`*` is zero or more batch dimensions.\n    LU_pivots (IntTensor): the pivots of the LU factorization from :meth:`~linalg.lu_factor` of size :math:`(*, m)`,\n                           where :math:`*` is zero or more batch dimensions.\n                           The batch dimensions of :attr:`LU_pivots` must be equal to the batch dimensions of\n                           :attr:`LU_data`.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> A = torch.randn(2, 3, 3)\n    >>> b = torch.randn(2, 3, 1)\n    >>> LU, pivots = torch.linalg.lu_factor(A)\n    >>> x = torch.lu_solve(b, LU, pivots)\n    >>> torch.dist(A @ x, b)\n    tensor(1.00000e-07 *\n           2.8312)\n",
      "Args": {
        "b": {
          "Type": null,
          "Default": null
        },
        "LU_data": {
          "Type": null,
          "Default": null
        },
        "LU_pivots": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "lu_unpack": {
      "Doc": "\nlu_unpack(LU_data, LU_pivots, unpack_data=True, unpack_pivots=True, *, out=None) -> (Tensor, Tensor, Tensor)\n\nUnpacks the LU decomposition returned by :func:`~linalg.lu_factor` into the `P, L, U` matrices.\n\n.. seealso::\n\n    :func:`~linalg.lu` returns the matrices from the LU decomposition. Its gradient formula is more efficient\n    than that of doing :func:`~linalg.lu_factor` followed by :func:`~linalg.lu_unpack`.\n\nArgs:\n    LU_data (Tensor): the packed LU factorization data\n    LU_pivots (Tensor): the packed LU factorization pivots\n    unpack_data (bool): flag indicating if the data should be unpacked.\n                        If ``False``, then the returned ``L`` and ``U`` are empty tensors.\n                        Default: ``True``\n    unpack_pivots (bool): flag indicating if the pivots should be unpacked into a permutation matrix ``P``.\n                          If ``False``, then the returned ``P`` is  an empty tensor.\n                          Default: ``True``\n\nKeyword args:\n    out (tuple, optional): output tuple of three tensors. Ignored if `None`.\n\nReturns:\n    A namedtuple ``(P, L, U)``\n\nExamples::\n\n    >>> A = torch.randn(2, 3, 3)\n    >>> LU, pivots = torch.linalg.lu_factor(A)\n    >>> P, L, U = torch.lu_unpack(LU, pivots)\n    >>> # We can recover A from the factorization\n    >>> A_ = P @ L @ U\n    >>> torch.allclose(A, A_)\n    True\n\n    >>> # LU factorization of a rectangular matrix:\n    >>> A = torch.randn(2, 3, 2)\n    >>> LU, pivots = torch.linalg.lu_factor(A)\n    >>> P, L, U = torch.lu_unpack(LU, pivots)\n    >>> # P, L, U are the same as returned by linalg.lu\n    >>> P_, L_, U_ = torch.linalg.lu(A)\n    >>> torch.allclose(P, P_) and torch.allclose(L, L_) and torch.allclose(U, U_)\n    True\n\n",
      "Args": {
        "LU_data": {
          "Type": null,
          "Default": null
        },
        "LU_pivots": {
          "Type": null,
          "Default": null
        },
        "unpack_data": {
          "Type": null,
          "Default": "True"
        },
        "unpack_pivots": {
          "Type": null,
          "Default": "True"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None) -> (Tensor"
        },
        "Tensor": {
          "Type": null,
          "Default": null
        }
      }
    },
    "manual_seed": {
      "Doc": "Sets the seed for generating random numbers. Returns a\n    `torch.Generator` object.\n\n    Args:\n        seed (int): The desired seed. Value must be within the inclusive range\n            `[-0x8000_0000_0000_0000, 0xffff_ffff_ffff_ffff]`. Otherwise, a RuntimeError\n            is raised. Negative inputs are remapped to positive values with the formula\n            `0xffff_ffff_ffff_ffff + seed`.\n    ",
      "Args": {
        "seed": {
          "Type": null,
          "Default": null
        }
      }
    },
    "margin_ranking_loss": {
      "Doc": null,
      "Args": null
    },
    "masked_fill": {
      "Doc": null,
      "Args": null
    },
    "masked_scatter": {
      "Doc": null,
      "Args": null
    },
    "masked_select": {
      "Doc": "\nmasked_select(input, mask, *, out=None) -> Tensor\n\nReturns a new 1-D tensor which indexes the :attr:`input` tensor according to\nthe boolean mask :attr:`mask` which is a `BoolTensor`.\n\nThe shapes of the :attr:`mask` tensor and the :attr:`input` tensor don't need\nto match, but they must be :ref:`broadcastable <broadcasting-semantics>`.\n\n.. note:: The returned tensor does **not** use the same storage\n          as the original tensor\n\nArgs:\n    input (Tensor): the input tensor.\n    mask  (BoolTensor): the tensor containing the binary mask to index with\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> x = torch.randn(3, 4)\n    >>> x\n    tensor([[ 0.3552, -2.3825, -0.8297,  0.3477],\n            [-1.2035,  1.2252,  0.5002,  0.6248],\n            [ 0.1307, -2.0608,  0.1244,  2.0139]])\n    >>> mask = x.ge(0.5)\n    >>> mask\n    tensor([[False, False, False, False],\n            [False, True, True, True],\n            [False, False, False, True]])\n    >>> torch.masked_select(x, mask)\n    tensor([ 1.2252,  0.5002,  0.6248,  2.0139])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "mask": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "matmul": {
      "Doc": "\nmatmul(input, other, *, out=None) -> Tensor\n\nMatrix product of two tensors.\n\nThe behavior depends on the dimensionality of the tensors as follows:\n\n- If both tensors are 1-dimensional, the dot product (scalar) is returned.\n- If both arguments are 2-dimensional, the matrix-matrix product is returned.\n- If the first argument is 1-dimensional and the second argument is 2-dimensional,\n  a 1 is prepended to its dimension for the purpose of the matrix multiply.\n  After the matrix multiply, the prepended dimension is removed.\n- If the first argument is 2-dimensional and the second argument is 1-dimensional,\n  the matrix-vector product is returned.\n- If both arguments are at least 1-dimensional and at least one argument is\n  N-dimensional (where N > 2), then a batched matrix multiply is returned.  If the first\n  argument is 1-dimensional, a 1 is prepended to its dimension for the purpose of the\n  batched matrix multiply and removed after.  If the second argument is 1-dimensional, a\n  1 is appended to its dimension for the purpose of the batched matrix multiple and removed after.\n  The non-matrix (i.e. batch) dimensions are :ref:`broadcasted <broadcasting-semantics>` (and thus\n  must be broadcastable).  For example, if :attr:`input` is a\n  :math:`(j \\times 1 \\times n \\times n)` tensor and :attr:`other` is a :math:`(k \\times n \\times n)`\n  tensor, :attr:`out` will be a :math:`(j \\times k \\times n \\times n)` tensor.\n\n  Note that the broadcasting logic only looks at the batch dimensions when determining if the inputs\n  are broadcastable, and not the matrix dimensions. For example, if :attr:`input` is a\n  :math:`(j \\times 1 \\times n \\times m)` tensor and :attr:`other` is a :math:`(k \\times m \\times p)`\n  tensor, these inputs are valid for broadcasting even though the final two dimensions (i.e. the\n  matrix dimensions) are different. :attr:`out` will be a :math:`(j \\times k \\times n \\times p)` tensor.\n\nThis operation has support for arguments with :ref:`sparse layouts<sparse-docs>`. In particular the\nmatrix-matrix (both arguments 2-dimensional) supports sparse arguments with the same restrictions\nas :func:`torch.mm`\n\n\n.. warning::\n    Sparse support is a beta feature and some layout(s)/dtype/device combinations may not be supported,\n    or may not have autograd support. If you notice missing functionality please\n    open a feature request.\n\nThis operator supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\nOn certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.\n\n.. note::\n\n    The 1-dimensional dot product version of this function does not support an :attr:`out` parameter.\n\nArguments:\n    input (Tensor): the first tensor to be multiplied\n    other (Tensor): the second tensor to be multiplied\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> # vector x vector\n    >>> tensor1 = torch.randn(3)\n    >>> tensor2 = torch.randn(3)\n    >>> torch.matmul(tensor1, tensor2).size()\n    torch.Size([])\n    >>> # matrix x vector\n    >>> tensor1 = torch.randn(3, 4)\n    >>> tensor2 = torch.randn(4)\n    >>> torch.matmul(tensor1, tensor2).size()\n    torch.Size([3])\n    >>> # batched matrix x broadcasted vector\n    >>> tensor1 = torch.randn(10, 3, 4)\n    >>> tensor2 = torch.randn(4)\n    >>> torch.matmul(tensor1, tensor2).size()\n    torch.Size([10, 3])\n    >>> # batched matrix x batched matrix\n    >>> tensor1 = torch.randn(10, 3, 4)\n    >>> tensor2 = torch.randn(10, 4, 5)\n    >>> torch.matmul(tensor1, tensor2).size()\n    torch.Size([10, 3, 5])\n    >>> # batched matrix x broadcasted matrix\n    >>> tensor1 = torch.randn(10, 3, 4)\n    >>> tensor2 = torch.randn(4, 5)\n    >>> torch.matmul(tensor1, tensor2).size()\n    torch.Size([10, 3, 5])\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "matrix_exp": {
      "Doc": "\nmatrix_exp(A) -> Tensor\n\nAlias for :func:`torch.linalg.matrix_exp`.\n",
      "Args": {
        "A": {
          "Type": null,
          "Default": null
        }
      }
    },
    "matrix_power": {
      "Doc": "\nmatrix_power(input, n, *, out=None) -> Tensor\n\nAlias for :func:`torch.linalg.matrix_power`\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "n": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "matrix_rank": {
      "Doc": null,
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "tol": {
          "Type": null,
          "Default": "None"
        },
        "symmetric": {
          "Type": null,
          "Default": "False"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "max": {
      "Doc": "\nmax(input) -> Tensor\n\nReturns the maximum value of all elements in the ``input`` tensor.\n\n.. warning::\n    This function produces deterministic (sub)gradients unlike ``max(dim=0)``\n\nArgs:\n    input (Tensor): the input tensor.\n\nExample::\n\n    >>> a = torch.randn(1, 3)\n    >>> a\n    tensor([[ 0.6763,  0.7445, -2.2369]])\n    >>> torch.max(a)\n    tensor(0.7445)\n\n.. function:: max(input, dim, keepdim=False, *, out=None) -> (Tensor, LongTensor)\n   :noindex:\n\nReturns a namedtuple ``(values, indices)`` where ``values`` is the maximum\nvalue of each row of the :attr:`input` tensor in the given dimension\n:attr:`dim`. And ``indices`` is the index location of each maximum value found\n(argmax).\n\nIf ``keepdim`` is ``True``, the output tensors are of the same size\nas ``input`` except in the dimension ``dim`` where they are of size 1.\nOtherwise, ``dim`` is squeezed (see :func:`torch.squeeze`), resulting\nin the output tensors having 1 fewer dimension than ``input``.\n\n.. note:: If there are multiple maximal values in a reduced row then\n          the indices of the first maximal value are returned.\n\nArgs:\n    input (Tensor): the input tensor.\n    dim (int): the dimension to reduce.\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not. Default: ``False``.\n\nKeyword args:\n    out (tuple, optional): the result tuple of two output tensors (max, max_indices)\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[-1.2360, -0.2942, -0.1222,  0.8475],\n            [ 1.1949, -1.1127, -2.2379, -0.6702],\n            [ 1.5717, -0.9207,  0.1297, -1.8768],\n            [-0.6172,  1.0036, -0.6060, -0.2432]])\n    >>> torch.max(a, 1)\n    torch.return_types.max(values=tensor([0.8475, 1.1949, 1.5717, 1.0036]), indices=tensor([3, 0, 0, 1]))\n\n.. function:: max(input, other, *, out=None) -> Tensor\n   :noindex:\n\nSee :func:`torch.maximum`.\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "max_pool1d": {
      "Doc": null,
      "Args": null
    },
    "max_pool1d_with_indices": {
      "Doc": null,
      "Args": null
    },
    "max_pool2d": {
      "Doc": null,
      "Args": null
    },
    "max_pool3d": {
      "Doc": null,
      "Args": null
    },
    "maximum": {
      "Doc": "\nmaximum(input, other, *, out=None) -> Tensor\n\nComputes the element-wise maximum of :attr:`input` and :attr:`other`.\n\n.. note::\n    If one of the elements being compared is a NaN, then that element is returned.\n    :func:`maximum` is not supported for tensors with complex dtypes.\n\nArgs:\n    input (Tensor): the input tensor.\n    other (Tensor): the second input tensor\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.tensor((1, 2, -1))\n    >>> b = torch.tensor((3, 0, 4))\n    >>> torch.maximum(a, b)\n    tensor([3, 2, 4])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "mean": {
      "Doc": "\nmean(input, *, dtype=None) -> Tensor\n\nReturns the mean value of all elements in the :attr:`input` tensor.\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        If specified, the input tensor is casted to :attr:`dtype` before the operation\n        is performed. This is useful for preventing data type overflows. Default: None.\n\nExample::\n\n    >>> a = torch.randn(1, 3)\n    >>> a\n    tensor([[ 0.2294, -0.5481,  1.3288]])\n    >>> torch.mean(a)\n    tensor(0.3367)\n\n.. function:: mean(input, dim, keepdim=False, *, dtype=None, out=None) -> Tensor\n   :noindex:\n\nReturns the mean value of each row of the :attr:`input` tensor in the given\ndimension :attr:`dim`. If :attr:`dim` is a list of dimensions,\nreduce over all of them.\n\n\nIf :attr:`keepdim` is ``True``, the output tensor is of the same size\nas :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.\nOtherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the\noutput tensor having 1 (or ``len(dim)``) fewer dimension(s).\n\n\nArgs:\n    input (Tensor): the input tensor.\n    dim (int or tuple of ints): the dimension or dimensions to reduce.\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        If specified, the input tensor is casted to :attr:`dtype` before the operation\n        is performed. This is useful for preventing data type overflows. Default: None.\n    out (Tensor, optional): the output tensor.\n\n.. seealso::\n\n    :func:`torch.nanmean` computes the mean value of `non-NaN` elements.\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[-0.3841,  0.6320,  0.4254, -0.7384],\n            [-0.9644,  1.0131, -0.6549, -1.4279],\n            [-0.2951, -1.3350, -0.7694,  0.5600],\n            [ 1.0842, -0.9580,  0.3623,  0.2343]])\n    >>> torch.mean(a, 1)\n    tensor([-0.0163, -0.5085, -0.4599,  0.1807])\n    >>> torch.mean(a, 1, True)\n    tensor([[-0.0163],\n            [-0.5085],\n            [-0.4599],\n            [ 0.1807]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "median": {
      "Doc": "\nmedian(input) -> Tensor\n\nReturns the median of the values in :attr:`input`.\n\n.. note::\n    The median is not unique for :attr:`input` tensors with an even number\n    of elements. In this case the lower of the two medians is returned. To\n    compute the mean of both medians, use :func:`torch.quantile` with ``q=0.5`` instead.\n\n.. warning::\n    This function produces deterministic (sub)gradients unlike ``median(dim=0)``\n\nArgs:\n    input (Tensor): the input tensor.\n\nExample::\n\n    >>> a = torch.randn(1, 3)\n    >>> a\n    tensor([[ 1.5219, -1.5212,  0.2202]])\n    >>> torch.median(a)\n    tensor(0.2202)\n\n.. function:: median(input, dim=-1, keepdim=False, *, out=None) -> (Tensor, LongTensor)\n   :noindex:\n\nReturns a namedtuple ``(values, indices)`` where ``values`` contains the median of each row of :attr:`input`\nin the dimension :attr:`dim`, and ``indices`` contains the index of the median values found in the dimension :attr:`dim`.\n\nBy default, :attr:`dim` is the last dimension of the :attr:`input` tensor.\n\nIf :attr:`keepdim` is ``True``, the output tensors are of the same size\nas :attr:`input` except in the dimension :attr:`dim` where they are of size 1.\nOtherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in\nthe outputs tensor having 1 fewer dimension than :attr:`input`.\n\n.. note::\n    The median is not unique for :attr:`input` tensors with an even number\n    of elements in the dimension :attr:`dim`. In this case the lower of the\n    two medians is returned. To compute the mean of both medians in\n    :attr:`input`, use :func:`torch.quantile` with ``q=0.5`` instead.\n\n.. warning::\n    ``indices`` does not necessarily contain the first occurrence of each\n    median value found, unless it is unique.\n    The exact implementation details are device-specific.\n    Do not expect the same result when run on CPU and GPU in general.\n    For the same reason do not expect the gradients to be deterministic.\n\nArgs:\n    input (Tensor): the input tensor.\n    dim (int): the dimension to reduce.\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not.\n\nKeyword args:\n    out ((Tensor, Tensor), optional): The first tensor will be populated with the median values and the second\n                                      tensor, which must have dtype long, with their indices in the dimension\n                                      :attr:`dim` of :attr:`input`.\n\nExample::\n\n    >>> a = torch.randn(4, 5)\n    >>> a\n    tensor([[ 0.2505, -0.3982, -0.9948,  0.3518, -1.3131],\n            [ 0.3180, -0.6993,  1.0436,  0.0438,  0.2270],\n            [-0.2751,  0.7303,  0.2192,  0.3321,  0.2488],\n            [ 1.0778, -1.9510,  0.7048,  0.4742, -0.7125]])\n    >>> torch.median(a, 1)\n    torch.return_types.median(values=tensor([-0.3982,  0.2270,  0.2488,  0.4742]), indices=tensor([1, 4, 4, 3]))\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "merge_type_from_type_comment": {
      "Doc": "merge_type_from_type_comment(arg0: torch._C._jit_tree_views.Decl, arg1: torch._C._jit_tree_views.Decl, arg2: bool) -> torch._C._jit_tree_views.Decl\n",
      "Args": {
        "arg0": {
          "Type": "torch._C._jit_tree_views.Decl",
          "Default": null
        },
        "arg1": {
          "Type": "torch._C._jit_tree_views.Decl",
          "Default": null
        },
        "arg2": {
          "Type": "bool",
          "Default": null
        }
      }
    },
    "meshgrid": {
      "Doc": "Creates grids of coordinates specified by the 1D inputs in `attr`:tensors.\n\n        This is helpful when you want to visualize data over some\n        range of inputs. See below for a plotting example.\n\n        Given :math:`N` 1D tensors :math:`T_0 \\ldots T_{N-1}` as\n        inputs with corresponding sizes :math:`S_0 \\ldots S_{N-1}`,\n        this creates :math:`N` N-dimensional tensors :math:`G_0 \\ldots\n        G_{N-1}`, each with shape :math:`(S_0, ..., S_{N-1})` where\n        the output :math:`G_i` is constructed by expanding :math:`T_i`\n        to the result shape.\n\n        .. note::\n            0D inputs are treated equivalently to 1D inputs of a\n            single element.\n\n        .. warning::\n            `torch.meshgrid(*tensors)` currently has the same behavior\n            as calling `numpy.meshgrid(*arrays, indexing='ij')`.\n\n            In the future `torch.meshgrid` will transition to\n            `indexing='xy'` as the default.\n\n            https://github.com/pytorch/pytorch/issues/50276 tracks\n            this issue with the goal of migrating to NumPy's behavior.\n\n        .. seealso::\n\n            :func:`torch.cartesian_prod` has the same effect but it\n            collects the data in a tensor of vectors.\n\n        Args:\n            tensors (list of Tensor): list of scalars or 1 dimensional tensors. Scalars will be\n                treated as tensors of size :math:`(1,)` automatically\n\n            indexing: (str, optional): the indexing mode, either \"xy\"\n                or \"ij\", defaults to \"ij\". See warning for future changes.\n\n                If \"xy\" is selected, the first dimension corresponds\n                to the cardinality of the second input and the second\n                dimension corresponds to the cardinality of the first\n                input.\n\n                If \"ij\" is selected, the dimensions are in the same\n                order as the cardinality of the inputs.\n\n        Returns:\n            seq (sequence of Tensors): If the input has :math:`N`\n            tensors of size :math:`S_0 \\ldots S_{N-1}``, then the\n            output will also have :math:`N` tensors, where each tensor\n            is of shape :math:`(S_0, ..., S_{N-1})`.\n\n        Example::\n\n            >>> x = torch.tensor([1, 2, 3])\n            >>> y = torch.tensor([4, 5, 6])\n\n            Observe the element-wise pairings across the grid, (1, 4),\n            (1, 5), ..., (3, 6). This is the same thing as the\n            cartesian product.\n            >>> grid_x, grid_y = torch.meshgrid(x, y, indexing='ij')\n            >>> grid_x\n            tensor([[1, 1, 1],\n                    [2, 2, 2],\n                    [3, 3, 3]])\n            >>> grid_y\n            tensor([[4, 5, 6],\n                    [4, 5, 6],\n                    [4, 5, 6]])\n\n            This correspondence can be seen when these grids are\n            stacked properly.\n            >>> torch.equal(torch.cat(tuple(torch.dstack([grid_x, grid_y]))),\n            ...             torch.cartesian_prod(x, y))\n            True\n\n            `torch.meshgrid` is commonly used to produce a grid for\n            plotting.\n            >>> # xdoctest: +REQUIRES(module:matplotlib)\n            >>> import matplotlib.pyplot as plt\n            >>> xs = torch.linspace(-5, 5, steps=100)\n            >>> ys = torch.linspace(-5, 5, steps=100)\n            >>> x, y = torch.meshgrid(xs, ys, indexing='xy')\n            >>> z = torch.sin(torch.sqrt(x * x + y * y))\n            >>> ax = plt.axes(projection='3d')\n            >>> ax.plot_surface(x.numpy(), y.numpy(), z.numpy())\n            >>> plt.show()\n\n        .. image:: ../_static/img/meshgrid.png\n            :width: 512\n\n        ",
      "Args": {
        "*tensors": {
          "Type": null,
          "Default": null
        },
        "indexing": {
          "Type": "typing.Optional[str]",
          "Default": "None"
        }
      }
    },
    "min": {
      "Doc": "\nmin(input) -> Tensor\n\nReturns the minimum value of all elements in the :attr:`input` tensor.\n\n.. warning::\n    This function produces deterministic (sub)gradients unlike ``min(dim=0)``\n\nArgs:\n    input (Tensor): the input tensor.\n\nExample::\n\n    >>> a = torch.randn(1, 3)\n    >>> a\n    tensor([[ 0.6750,  1.0857,  1.7197]])\n    >>> torch.min(a)\n    tensor(0.6750)\n\n.. function:: min(input, dim, keepdim=False, *, out=None) -> (Tensor, LongTensor)\n   :noindex:\n\nReturns a namedtuple ``(values, indices)`` where ``values`` is the minimum\nvalue of each row of the :attr:`input` tensor in the given dimension\n:attr:`dim`. And ``indices`` is the index location of each minimum value found\n(argmin).\n\nIf :attr:`keepdim` is ``True``, the output tensors are of the same size as\n:attr:`input` except in the dimension :attr:`dim` where they are of size 1.\nOtherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in\nthe output tensors having 1 fewer dimension than :attr:`input`.\n\n.. note:: If there are multiple minimal values in a reduced row then\n          the indices of the first minimal value are returned.\n\nArgs:\n    input (Tensor): the input tensor.\n    dim (int): the dimension to reduce.\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not.\n\nKeyword args:\n    out (tuple, optional): the tuple of two output tensors (min, min_indices)\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[-0.6248,  1.1334, -1.1899, -0.2803],\n            [-1.4644, -0.2635, -0.3651,  0.6134],\n            [ 0.2457,  0.0384,  1.0128,  0.7015],\n            [-0.1153,  2.9849,  2.1458,  0.5788]])\n    >>> torch.min(a, 1)\n    torch.return_types.min(values=tensor([-1.1899, -1.4644,  0.0384, -0.1153]), indices=tensor([2, 0, 1, 0]))\n\n.. function:: min(input, other, *, out=None) -> Tensor\n   :noindex:\n\nSee :func:`torch.minimum`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "minimum": {
      "Doc": "\nminimum(input, other, *, out=None) -> Tensor\n\nComputes the element-wise minimum of :attr:`input` and :attr:`other`.\n\n.. note::\n    If one of the elements being compared is a NaN, then that element is returned.\n    :func:`minimum` is not supported for tensors with complex dtypes.\n\nArgs:\n    input (Tensor): the input tensor.\n    other (Tensor): the second input tensor\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.tensor((1, 2, -1))\n    >>> b = torch.tensor((3, 0, 4))\n    >>> torch.minimum(a, b)\n    tensor([1, 0, -1])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "miopen_batch_norm": {
      "Doc": null,
      "Args": null
    },
    "miopen_convolution": {
      "Doc": null,
      "Args": null
    },
    "miopen_convolution_add_relu": {
      "Doc": null,
      "Args": null
    },
    "miopen_convolution_relu": {
      "Doc": null,
      "Args": null
    },
    "miopen_convolution_transpose": {
      "Doc": null,
      "Args": null
    },
    "miopen_depthwise_convolution": {
      "Doc": null,
      "Args": null
    },
    "miopen_rnn": {
      "Doc": null,
      "Args": null
    },
    "mkldnn_adaptive_avg_pool2d": {
      "Doc": null,
      "Args": null
    },
    "mkldnn_convolution": {
      "Doc": null,
      "Args": null
    },
    "mkldnn_linear_backward_weights": {
      "Doc": null,
      "Args": null
    },
    "mkldnn_max_pool2d": {
      "Doc": null,
      "Args": null
    },
    "mkldnn_max_pool3d": {
      "Doc": null,
      "Args": null
    },
    "mm": {
      "Doc": "\nmm(input, mat2, *, out=None) -> Tensor\n\nPerforms a matrix multiplication of the matrices :attr:`input` and :attr:`mat2`.\n\nIf :attr:`input` is a :math:`(n \\times m)` tensor, :attr:`mat2` is a\n:math:`(m \\times p)` tensor, :attr:`out` will be a :math:`(n \\times p)` tensor.\n\n.. note:: This function does not :ref:`broadcast <broadcasting-semantics>`.\n          For broadcasting matrix products, see :func:`torch.matmul`.\n\nSupports strided and sparse 2-D tensors as inputs, autograd with\nrespect to strided inputs.\n\nThis operation has support for arguments with :ref:`sparse layouts<sparse-docs>`.\nIf :attr:`out` is provided it's layout will be used. Otherwise, the result\nlayout will be deduced from that of :attr:`input`.\n\n\n.. warning::\n    Sparse support is a beta feature and some layout(s)/dtype/device combinations may not be supported,\n    or may not have autograd support. If you notice missing functionality please\n    open a feature request.\n\nThis operator supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\nOn certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.\n\nArgs:\n    input (Tensor): the first matrix to be matrix multiplied\n    mat2 (Tensor): the second matrix to be matrix multiplied\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> mat1 = torch.randn(2, 3)\n    >>> mat2 = torch.randn(3, 3)\n    >>> torch.mm(mat1, mat2)\n    tensor([[ 0.4851,  0.5037, -0.3633],\n            [-0.0760, -3.6705,  2.4784]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "mat2": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "mode": {
      "Doc": "\nmode(input, dim=-1, keepdim=False, *, out=None) -> (Tensor, LongTensor)\n\nReturns a namedtuple ``(values, indices)`` where ``values`` is the mode\nvalue of each row of the :attr:`input` tensor in the given dimension\n:attr:`dim`, i.e. a value which appears most often\nin that row, and ``indices`` is the index location of each mode value found.\n\nBy default, :attr:`dim` is the last dimension of the :attr:`input` tensor.\n\nIf :attr:`keepdim` is ``True``, the output tensors are of the same size as\n:attr:`input` except in the dimension :attr:`dim` where they are of size 1.\nOtherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting\nin the output tensors having 1 fewer dimension than :attr:`input`.\n\n.. note:: This function is not defined for ``torch.cuda.Tensor`` yet.\n\nArgs:\n    input (Tensor): the input tensor.\n    dim (int): the dimension to reduce.\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not.\n\nKeyword args:\n    out (tuple, optional): the result tuple of two output tensors (values, indices)\n\nExample::\n\n    >>> a = torch.randint(10, (5,))\n    >>> a\n    tensor([6, 5, 1, 0, 2])\n    >>> b = a + (torch.randn(50, 1) * 5).long()\n    >>> torch.mode(b, 0)\n    torch.return_types.mode(values=tensor([6, 5, 1, 0, 2]), indices=tensor([2, 2, 2, 2, 2]))\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "-1"
        },
        "keepdim": {
          "Type": null,
          "Default": "False"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None) -> (Tensor"
        },
        "LongTensor": {
          "Type": null,
          "Default": null
        }
      }
    },
    "moveaxis": {
      "Doc": "\nmoveaxis(input, source, destination) -> Tensor\n\nAlias for :func:`torch.movedim`.\n\nThis function is equivalent to NumPy's moveaxis function.\n\nExamples::\n\n    >>> t = torch.randn(3,2,1)\n    >>> t\n    tensor([[[-0.3362],\n            [-0.8437]],\n\n            [[-0.9627],\n            [ 0.1727]],\n\n            [[ 0.5173],\n            [-0.1398]]])\n    >>> torch.moveaxis(t, 1, 0).shape\n    torch.Size([2, 3, 1])\n    >>> torch.moveaxis(t, 1, 0)\n    tensor([[[-0.3362],\n            [-0.9627],\n            [ 0.5173]],\n\n            [[-0.8437],\n            [ 0.1727],\n            [-0.1398]]])\n    >>> torch.moveaxis(t, (1, 2), (0, 1)).shape\n    torch.Size([2, 1, 3])\n    >>> torch.moveaxis(t, (1, 2), (0, 1))\n    tensor([[[-0.3362, -0.9627,  0.5173]],\n\n            [[-0.8437,  0.1727, -0.1398]]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "source": {
          "Type": null,
          "Default": null
        },
        "destination": {
          "Type": null,
          "Default": null
        }
      }
    },
    "movedim": {
      "Doc": "\nmovedim(input, source, destination) -> Tensor\n\nMoves the dimension(s) of :attr:`input` at the position(s) in :attr:`source`\nto the position(s) in :attr:`destination`.\n\nOther dimensions of :attr:`input` that are not explicitly moved remain in\ntheir original order and appear at the positions not specified in :attr:`destination`.\n\nArgs:\n    input (Tensor): the input tensor.\n    source (int or tuple of ints): Original positions of the dims to move. These must be unique.\n    destination (int or tuple of ints): Destination positions for each of the original dims. These must also be unique.\n\nExamples::\n\n    >>> t = torch.randn(3,2,1)\n    >>> t\n    tensor([[[-0.3362],\n            [-0.8437]],\n\n            [[-0.9627],\n            [ 0.1727]],\n\n            [[ 0.5173],\n            [-0.1398]]])\n    >>> torch.movedim(t, 1, 0).shape\n    torch.Size([2, 3, 1])\n    >>> torch.movedim(t, 1, 0)\n    tensor([[[-0.3362],\n            [-0.9627],\n            [ 0.5173]],\n\n            [[-0.8437],\n            [ 0.1727],\n            [-0.1398]]])\n    >>> torch.movedim(t, (1, 2), (0, 1)).shape\n    torch.Size([2, 1, 3])\n    >>> torch.movedim(t, (1, 2), (0, 1))\n    tensor([[[-0.3362, -0.9627,  0.5173]],\n\n            [[-0.8437,  0.1727, -0.1398]]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "source": {
          "Type": null,
          "Default": null
        },
        "destination": {
          "Type": null,
          "Default": null
        }
      }
    },
    "msort": {
      "Doc": "\nmsort(input, *, out=None) -> Tensor\n\nSorts the elements of the :attr:`input` tensor along its first dimension\nin ascending order by value.\n\n.. note:: `torch.msort(t)` is equivalent to `torch.sort(t, dim=0)[0]`.\n          See also :func:`torch.sort`.\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> t = torch.randn(3, 4)\n    >>> t\n    tensor([[-0.1321,  0.4370, -1.2631, -1.1289],\n            [-2.0527, -1.1250,  0.2275,  0.3077],\n            [-0.0881, -0.1259, -0.5495,  1.0284]])\n    >>> torch.msort(t)\n    tensor([[-2.0527, -1.1250, -1.2631, -1.1289],\n            [-0.1321, -0.1259, -0.5495,  0.3077],\n            [-0.0881,  0.4370,  0.2275,  1.0284]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "mul": {
      "Doc": "\nmul(input, other, *, out=None) -> Tensor\n\nMultiplies :attr:`input` by :attr:`other`.\n\n\n.. math::\n    \\text{out}_i = \\text{input}_i \\times \\text{other}_i\n\n\nSupports :ref:`broadcasting to a common shape <broadcasting-semantics>`,\n:ref:`type promotion <type-promotion-doc>`, and integer, float, and complex inputs.\n\nArgs:\n    input (Tensor): the input tensor.\n    other (Tensor or Number) - the tensor or number to multiply input by.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExamples::\n\n    >>> a = torch.randn(3)\n    >>> a\n    tensor([ 0.2015, -0.4255,  2.6087])\n    >>> torch.mul(a, 100)\n    tensor([  20.1494,  -42.5491,  260.8663])\n\n    >>> b = torch.randn(4, 1)\n    >>> b\n    tensor([[ 1.1207],\n            [-0.3137],\n            [ 0.0700],\n            [ 0.8378]])\n    >>> c = torch.randn(1, 4)\n    >>> c\n    tensor([[ 0.5146,  0.1216, -0.5244,  2.2382]])\n    >>> torch.mul(b, c)\n    tensor([[ 0.5767,  0.1363, -0.5877,  2.5083],\n            [-0.1614, -0.0382,  0.1645, -0.7021],\n            [ 0.0360,  0.0085, -0.0367,  0.1567],\n            [ 0.4312,  0.1019, -0.4394,  1.8753]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "multinomial": {
      "Doc": "\nmultinomial(input, num_samples, replacement=False, *, generator=None, out=None) -> LongTensor\n\nReturns a tensor where each row contains :attr:`num_samples` indices sampled\nfrom the multinomial probability distribution located in the corresponding row\nof tensor :attr:`input`.\n\n.. note::\n    The rows of :attr:`input` do not need to sum to one (in which case we use\n    the values as weights), but must be non-negative, finite and have\n    a non-zero sum.\n\nIndices are ordered from left to right according to when each was sampled\n(first samples are placed in first column).\n\nIf :attr:`input` is a vector, :attr:`out` is a vector of size :attr:`num_samples`.\n\nIf :attr:`input` is a matrix with `m` rows, :attr:`out` is an matrix of shape\n:math:`(m \\times \\text{num\\_samples})`.\n\nIf replacement is ``True``, samples are drawn with replacement.\n\nIf not, they are drawn without replacement, which means that when a\nsample index is drawn for a row, it cannot be drawn again for that row.\n\n.. note::\n    When drawn without replacement, :attr:`num_samples` must be lower than\n    number of non-zero elements in :attr:`input` (or the min number of non-zero\n    elements in each row of :attr:`input` if it is a matrix).\n\nArgs:\n    input (Tensor): the input tensor containing probabilities\n    num_samples (int): number of samples to draw\n    replacement (bool, optional): whether to draw with replacement or not\n\nKeyword args:\n    generator (:class:`torch.Generator`, optional): a pseudorandom number generator for sampling\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> weights = torch.tensor([0, 10, 3, 0], dtype=torch.float) # create a tensor of weights\n    >>> torch.multinomial(weights, 2)\n    tensor([1, 2])\n    >>> torch.multinomial(weights, 4) # ERROR!\n    RuntimeError: invalid argument 2: invalid multinomial distribution (with replacement=False,\n    not enough non-negative category to sample) at ../aten/src/TH/generic/THTensorRandom.cpp:320\n    >>> torch.multinomial(weights, 4, replacement=True)\n    tensor([ 2,  1,  1,  1])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "num_samples": {
          "Type": null,
          "Default": null
        },
        "replacement": {
          "Type": null,
          "Default": "False"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "generator": {
          "Type": null,
          "Default": "None"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "multiply": {
      "Doc": "\nmultiply(input, other, *, out=None)\n\nAlias for :func:`torch.mul`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "mv": {
      "Doc": "\nmv(input, vec, *, out=None) -> Tensor\n\nPerforms a matrix-vector product of the matrix :attr:`input` and the vector\n:attr:`vec`.\n\nIf :attr:`input` is a :math:`(n \\times m)` tensor, :attr:`vec` is a 1-D tensor of\nsize :math:`m`, :attr:`out` will be 1-D of size :math:`n`.\n\n.. note:: This function does not :ref:`broadcast <broadcasting-semantics>`.\n\nArgs:\n    input (Tensor): matrix to be multiplied\n    vec (Tensor): vector to be multiplied\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> mat = torch.randn(2, 3)\n    >>> vec = torch.randn(3)\n    >>> torch.mv(mat, vec)\n    tensor([ 1.0404, -0.6361])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "vec": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "mvlgamma": {
      "Doc": "\nmvlgamma(input, p, *, out=None) -> Tensor\n\nAlias for :func:`torch.special.multigammaln`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "p": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "nan_to_num": {
      "Doc": "\nnan_to_num(input, nan=0.0, posinf=None, neginf=None, *, out=None) -> Tensor\n\nReplaces :literal:`NaN`, positive infinity, and negative infinity values in :attr:`input`\nwith the values specified by :attr:`nan`, :attr:`posinf`, and :attr:`neginf`, respectively.\nBy default, :literal:`NaN`\\ s are replaced with zero, positive infinity is replaced with the\ngreatest finite value representable by :attr:`input`'s dtype, and negative infinity\nis replaced with the least finite value representable by :attr:`input`'s dtype.\n\nArgs:\n    input (Tensor): the input tensor.\n    nan (Number, optional): the value to replace :literal:`NaN`\\s with. Default is zero.\n    posinf (Number, optional): if a Number, the value to replace positive infinity values with.\n        If None, positive infinity values are replaced with the greatest finite value representable by :attr:`input`'s dtype.\n        Default is None.\n    neginf (Number, optional): if a Number, the value to replace negative infinity values with.\n        If None, negative infinity values are replaced with the lowest finite value representable by :attr:`input`'s dtype.\n        Default is None.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> x = torch.tensor([float('nan'), float('inf'), -float('inf'), 3.14])\n    >>> torch.nan_to_num(x)\n    tensor([ 0.0000e+00,  3.4028e+38, -3.4028e+38,  3.1400e+00])\n    >>> torch.nan_to_num(x, nan=2.0)\n    tensor([ 2.0000e+00,  3.4028e+38, -3.4028e+38,  3.1400e+00])\n    >>> torch.nan_to_num(x, nan=2.0, posinf=1.0)\n    tensor([ 2.0000e+00,  1.0000e+00, -3.4028e+38,  3.1400e+00])\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "nan": {
          "Type": null,
          "Default": "0.0"
        },
        "posinf": {
          "Type": null,
          "Default": "None"
        },
        "neginf": {
          "Type": null,
          "Default": "None"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "nanmean": {
      "Doc": "\nnanmean(input, dim=None, keepdim=False, *, dtype=None, out=None) -> Tensor\n\nComputes the mean of all `non-NaN` elements along the specified dimensions.\n\nThis function is identical to :func:`torch.mean` when there are no `NaN` values\nin the :attr:`input` tensor. In the presence of `NaN`, :func:`torch.mean` will\npropagate the `NaN` to the output whereas :func:`torch.nanmean` will ignore the\n`NaN` values (`torch.nanmean(a)` is equivalent to `torch.mean(a[~a.isnan()])`).\n\n\nIf :attr:`keepdim` is ``True``, the output tensor is of the same size\nas :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.\nOtherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the\noutput tensor having 1 (or ``len(dim)``) fewer dimension(s).\n\n\nArgs:\n    input (Tensor): the input tensor.\n    \n    dim (int or tuple of ints, optional): the dimension or dimensions to reduce.\n        If ``None``, all dimensions are reduced.\n\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        If specified, the input tensor is casted to :attr:`dtype` before the operation\n        is performed. This is useful for preventing data type overflows. Default: None.\n    out (Tensor, optional): the output tensor.\n\n.. seealso::\n\n    :func:`torch.mean` computes the mean value, propagating `NaN`.\n\nExample::\n\n    >>> x = torch.tensor([[torch.nan, 1, 2], [1, 2, 3]])\n    >>> x.mean()\n    tensor(nan)\n    >>> x.nanmean()\n    tensor(1.8000)\n    >>> x.mean(dim=0)\n    tensor([   nan, 1.5000, 2.5000])\n    >>> x.nanmean(dim=0)\n    tensor([1.0000, 1.5000, 2.5000])\n\n    # If all elements in the reduced dimensions are NaN then the result is NaN\n    >>> torch.tensor([torch.nan]).nanmean()\n    tensor(nan)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "None"
        },
        "keepdim": {
          "Type": null,
          "Default": "False"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "nanmedian": {
      "Doc": "\nnanmedian(input) -> Tensor\n\nReturns the median of the values in :attr:`input`, ignoring ``NaN`` values.\n\nThis function is identical to :func:`torch.median` when there are no ``NaN`` values in :attr:`input`.\nWhen :attr:`input` has one or more ``NaN`` values, :func:`torch.median` will always return ``NaN``,\nwhile this function will return the median of the non-``NaN`` elements in :attr:`input`.\nIf all the elements in :attr:`input` are ``NaN`` it will also return ``NaN``.\n\nArgs:\n    input (Tensor): the input tensor.\n\nExample::\n\n    >>> a = torch.tensor([1, float('nan'), 3, 2])\n    >>> a.median()\n    tensor(nan)\n    >>> a.nanmedian()\n    tensor(2.)\n\n.. function:: nanmedian(input, dim=-1, keepdim=False, *, out=None) -> (Tensor, LongTensor)\n   :noindex:\n\nReturns a namedtuple ``(values, indices)`` where ``values`` contains the median of each row of :attr:`input`\nin the dimension :attr:`dim`, ignoring ``NaN`` values, and ``indices`` contains the index of the median values\nfound in the dimension :attr:`dim`.\n\nThis function is identical to :func:`torch.median` when there are no ``NaN`` values in a reduced row. When a reduced row has\none or more ``NaN`` values, :func:`torch.median` will always reduce it to ``NaN``, while this function will reduce it to the\nmedian of the non-``NaN`` elements. If all the elements in a reduced row are ``NaN`` then it will be reduced to ``NaN``, too.\n\nArgs:\n    input (Tensor): the input tensor.\n    dim (int): the dimension to reduce.\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not.\n\nKeyword args:\n    out ((Tensor, Tensor), optional): The first tensor will be populated with the median values and the second\n                                      tensor, which must have dtype long, with their indices in the dimension\n                                      :attr:`dim` of :attr:`input`.\n\nExample::\n\n    >>> a = torch.tensor([[2, 3, 1], [float('nan'), 1, float('nan')]])\n    >>> a\n    tensor([[2., 3., 1.],\n            [nan, 1., nan]])\n    >>> a.median(0)\n    torch.return_types.median(values=tensor([nan, 1., nan]), indices=tensor([1, 1, 1]))\n    >>> a.nanmedian(0)\n    torch.return_types.nanmedian(values=tensor([2., 1., 1.]), indices=tensor([0, 1, 0]))\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "nanquantile": {
      "Doc": "\nnanquantile(input, q, dim=None, keepdim=False, *, interpolation='linear', out=None) -> Tensor\n\nThis is a variant of :func:`torch.quantile` that \"ignores\" ``NaN`` values,\ncomputing the quantiles :attr:`q` as if ``NaN`` values in :attr:`input` did\nnot exist. If all values in a reduced row are ``NaN`` then the quantiles for\nthat reduction will be ``NaN``. See the documentation for :func:`torch.quantile`.\n\nArgs:\n    input (Tensor): the input tensor.\n    q (float or Tensor): a scalar or 1D tensor of quantile values in the range [0, 1]\n    dim (int): the dimension to reduce.\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not.\n\nKeyword arguments:\n    interpolation (str): interpolation method to use when the desired quantile lies between two data points.\n                            Can be ``linear``, ``lower``, ``higher``, ``midpoint`` and ``nearest``.\n                            Default is ``linear``.\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> t = torch.tensor([float('nan'), 1, 2])\n    >>> t.quantile(0.5)\n    tensor(nan)\n    >>> t.nanquantile(0.5)\n    tensor(1.5000)\n    >>> t = torch.tensor([[float('nan'), float('nan')], [1, 2]])\n    >>> t\n    tensor([[nan, nan],\n            [1., 2.]])\n    >>> t.nanquantile(0.5, dim=0)\n    tensor([1., 2.])\n    >>> t.nanquantile(0.5, dim=1)\n    tensor([   nan, 1.5000])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "q": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "None"
        },
        "keepdim": {
          "Type": null,
          "Default": "False"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "interpolation": {
          "Type": null,
          "Default": "'linear'"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "nansum": {
      "Doc": "\nnansum(input, *, dtype=None) -> Tensor\n\nReturns the sum of all elements, treating Not a Numbers (NaNs) as zero.\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        If specified, the input tensor is casted to :attr:`dtype` before the operation\n        is performed. This is useful for preventing data type overflows. Default: None.\n\nExample::\n\n    >>> a = torch.tensor([1., 2., float('nan'), 4.])\n    >>> torch.nansum(a)\n    tensor(7.)\n\n.. function:: nansum(input, dim, keepdim=False, *, dtype=None) -> Tensor\n   :noindex:\n\nReturns the sum of each row of the :attr:`input` tensor in the given\ndimension :attr:`dim`, treating Not a Numbers (NaNs) as zero.\nIf :attr:`dim` is a list of dimensions, reduce over all of them.\n\n\nIf :attr:`keepdim` is ``True``, the output tensor is of the same size\nas :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.\nOtherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the\noutput tensor having 1 (or ``len(dim)``) fewer dimension(s).\n\n\nArgs:\n    input (Tensor): the input tensor.\n    \n    dim (int or tuple of ints, optional): the dimension or dimensions to reduce.\n        If ``None``, all dimensions are reduced.\n\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        If specified, the input tensor is casted to :attr:`dtype` before the operation\n        is performed. This is useful for preventing data type overflows. Default: None.\n\nExample::\n\n    >>> torch.nansum(torch.tensor([1., float(\"nan\")]))\n    1.0\n    >>> a = torch.tensor([[1, 2], [3., float(\"nan\")]])\n    >>> torch.nansum(a)\n    tensor(6.)\n    >>> torch.nansum(a, dim=0)\n    tensor([4., 2.])\n    >>> torch.nansum(a, dim=1)\n    tensor([3., 3.])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "narrow": {
      "Doc": "\nnarrow(input, dim, start, length) -> Tensor\n\nReturns a new tensor that is a narrowed version of :attr:`input` tensor. The\ndimension :attr:`dim` is input from :attr:`start` to ``start + length``. The\nreturned tensor and :attr:`input` tensor share the same underlying storage.\n\nArgs:\n    input (Tensor): the tensor to narrow\n    dim (int): the dimension along which to narrow\n    start (Tensor or int): the starting dimension\n    length (int): the distance to the ending dimension\n\nExample::\n\n    >>> x = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    >>> torch.narrow(x, 0, 0, 2)\n    tensor([[ 1,  2,  3],\n            [ 4,  5,  6]])\n    >>> torch.narrow(x, 1, 1, 2)\n    tensor([[ 2,  3],\n            [ 5,  6],\n            [ 8,  9]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "start": {
          "Type": null,
          "Default": null
        },
        "length": {
          "Type": null,
          "Default": null
        }
      }
    },
    "narrow_copy": {
      "Doc": "\nnarrow_copy(input, dim, start, length, *, out=None) -> Tensor\n\nSame as :meth:`Tensor.narrow` except this returns a copy rather\nthan shared storage. This is primarily for sparse tensors, which\ndo not have a shared-storage narrow method.\n\nArgs:\n    input (Tensor): the tensor to narrow\n    dim (int): the dimension along which to narrow\n    start (int): the starting offset\n    length (int): the distance to the ending dimension\n\nKeyword args:\n    {out}\n\nExample::\n\n    >>> x = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    >>> torch.narrow_copy(x, 0, 0, 2)\n    tensor([[ 1,  2,  3],\n            [ 4,  5,  6]])\n    >>> torch.narrow_copy(x, 1, 1, 2)\n    tensor([[ 2,  3],\n            [ 5,  6],\n            [ 8,  9]])\n    >>> s = torch.arange(16).reshape(2, 2, 2, 2).to_sparse(2)\n    >>> torch.narrow_copy(s, 0, 0, 1)\n    tensor(indices=tensor([[0, 0],\n                        [0, 1]]),\n        values=tensor([[[0, 1],\n                        [2, 3]],\n\n                        [[4, 5],\n                        [6, 7]]]),\n        size=(1, 2, 2, 2), nnz=2, layout=torch.sparse_coo)\n\n.. seealso::\n\n        :func:`torch.narrow` for a non copy variant\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "start": {
          "Type": null,
          "Default": null
        },
        "length": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "native_batch_norm": {
      "Doc": null,
      "Args": null
    },
    "native_channel_shuffle": {
      "Doc": "\nnative_channel_shuffle(input, groups) -> Tensor\n\nNative kernel level implementation of the `channel_shuffle`.\nThis function might become private in future releases, use with caution.\n\nDivide the channels in a tensor of shape :math:`(*, C , H, W)`\ninto g groups and rearrange them as :math:`(*, C \\frac g, g, H, W)`,\nwhile keeping the original tensor shape.\n\nSee :class:`~torch.nn.ChannelShuffle` for details.\n\nArgs:\n    input (Tensor): the input tensor\n    groups (int): number of groups to divide channels in and rearrange.\n\nExamples::\n\n    >>> input = torch.randn(1, 4, 2, 2)\n    >>> print(input)\n    [[[[1, 2],\n       [3, 4]],\n      [[5, 6],\n       [7, 8]],\n      [[9, 10],\n       [11, 12]],\n      [[13, 14],\n       [15, 16]],\n     ]]\n    >>> output = torch.nn.functional.native_channel_shuffle(input, 2)\n    >>> print(output)\n    [[[[1, 2],\n       [3, 4]],\n      [[9, 10],\n       [11, 12]],\n      [[5, 6],\n       [7, 8]],\n      [[13, 14],\n       [15, 16]],\n     ]]\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "groups": {
          "Type": null,
          "Default": null
        }
      }
    },
    "native_dropout": {
      "Doc": null,
      "Args": null
    },
    "native_group_norm": {
      "Doc": null,
      "Args": null
    },
    "native_layer_norm": {
      "Doc": null,
      "Args": null
    },
    "native_norm": {
      "Doc": null,
      "Args": null
    },
    "ne": {
      "Doc": "\nne(input, other, *, out=None) -> Tensor\n\nComputes :math:`\\text{input} \\neq \\text{other}` element-wise.\n\n\nThe second argument can be a number or a tensor whose shape is\n:ref:`broadcastable <broadcasting-semantics>` with the first argument.\n\nArgs:\n    input (Tensor): the tensor to compare\n    other (Tensor or float): the tensor or value to compare\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nReturns:\n    A boolean tensor that is True where :attr:`input` is not equal to :attr:`other` and False elsewhere\n\nExample::\n\n    >>> torch.ne(torch.tensor([[1, 2], [3, 4]]), torch.tensor([[1, 1], [4, 4]]))\n    tensor([[False, True], [True, False]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "neg": {
      "Doc": "\nneg(input, *, out=None) -> Tensor\n\nReturns a new tensor with the negative of the elements of :attr:`input`.\n\n.. math::\n    \\text{out} = -1 \\times \\text{input}\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(5)\n    >>> a\n    tensor([ 0.0090, -0.2262, -0.0682, -0.2866,  0.3940])\n    >>> torch.neg(a)\n    tensor([-0.0090,  0.2262,  0.0682,  0.2866, -0.3940])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "negative": {
      "Doc": "\nnegative(input, *, out=None) -> Tensor\n\nAlias for :func:`torch.neg`\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "nextafter": {
      "Doc": "\nnextafter(input, other, *, out=None) -> Tensor\n\nReturn the next floating-point value after :attr:`input` towards :attr:`other`, elementwise.\n\nThe shapes of ``input`` and ``other`` must be\n:ref:`broadcastable <broadcasting-semantics>`.\n\nArgs:\n    input (Tensor): the first input tensor\n    other (Tensor): the second input tensor\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> eps = torch.finfo(torch.float32).eps\n    >>> torch.nextafter(torch.tensor([1.0, 2.0]), torch.tensor([2.0, 1.0])) == torch.tensor([eps + 1, 2 - eps])\n    tensor([True, True])\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "nonzero": {
      "Doc": "\nnonzero(input, *, out=None, as_tuple=False) -> LongTensor or tuple of LongTensors\n\n.. note::\n    :func:`torch.nonzero(..., as_tuple=False) <torch.nonzero>` (default) returns a\n    2-D tensor where each row is the index for a nonzero value.\n\n    :func:`torch.nonzero(..., as_tuple=True) <torch.nonzero>` returns a tuple of 1-D\n    index tensors, allowing for advanced indexing, so ``x[x.nonzero(as_tuple=True)]``\n    gives all nonzero values of tensor ``x``. Of the returned tuple, each index tensor\n    contains nonzero indices for a certain dimension.\n\n    See below for more details on the two behaviors.\n\n    When :attr:`input` is on CUDA, :func:`torch.nonzero() <torch.nonzero>` causes\n    host-device synchronization.\n\n**When** :attr:`as_tuple` **is** ``False`` **(default)**:\n\nReturns a tensor containing the indices of all non-zero elements of\n:attr:`input`.  Each row in the result contains the indices of a non-zero\nelement in :attr:`input`. The result is sorted lexicographically, with\nthe last index changing the fastest (C-style).\n\nIf :attr:`input` has :math:`n` dimensions, then the resulting indices tensor\n:attr:`out` is of size :math:`(z \\times n)`, where :math:`z` is the total number of\nnon-zero elements in the :attr:`input` tensor.\n\n**When** :attr:`as_tuple` **is** ``True``:\n\nReturns a tuple of 1-D tensors, one for each dimension in :attr:`input`,\neach containing the indices (in that dimension) of all non-zero elements of\n:attr:`input` .\n\nIf :attr:`input` has :math:`n` dimensions, then the resulting tuple contains :math:`n`\ntensors of size :math:`z`, where :math:`z` is the total number of\nnon-zero elements in the :attr:`input` tensor.\n\nAs a special case, when :attr:`input` has zero dimensions and a nonzero scalar\nvalue, it is treated as a one-dimensional tensor with one element.\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (LongTensor, optional): the output tensor containing indices\n\nReturns:\n    LongTensor or tuple of LongTensor: If :attr:`as_tuple` is ``False``, the output\n    tensor containing indices. If :attr:`as_tuple` is ``True``, one 1-D tensor for\n    each dimension, containing the indices of each nonzero element along that\n    dimension.\n\nExample::\n\n    >>> torch.nonzero(torch.tensor([1, 1, 1, 0, 1]))\n    tensor([[ 0],\n            [ 1],\n            [ 2],\n            [ 4]])\n    >>> torch.nonzero(torch.tensor([[0.6, 0.0, 0.0, 0.0],\n    ...                             [0.0, 0.4, 0.0, 0.0],\n    ...                             [0.0, 0.0, 1.2, 0.0],\n    ...                             [0.0, 0.0, 0.0,-0.4]]))\n    tensor([[ 0,  0],\n            [ 1,  1],\n            [ 2,  2],\n            [ 3,  3]])\n    >>> torch.nonzero(torch.tensor([1, 1, 1, 0, 1]), as_tuple=True)\n    (tensor([0, 1, 2, 4]),)\n    >>> torch.nonzero(torch.tensor([[0.6, 0.0, 0.0, 0.0],\n    ...                             [0.0, 0.4, 0.0, 0.0],\n    ...                             [0.0, 0.0, 1.2, 0.0],\n    ...                             [0.0, 0.0, 0.0,-0.4]]), as_tuple=True)\n    (tensor([0, 1, 2, 3]), tensor([0, 1, 2, 3]))\n    >>> torch.nonzero(torch.tensor(5), as_tuple=True)\n    (tensor([0]),)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        },
        "as_tuple": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "norm": {
      "Doc": "Returns the matrix norm or vector norm of a given tensor.\n\n    .. warning::\n\n        torch.norm is deprecated and may be removed in a future PyTorch release.\n        Its documentation and behavior may be incorrect, and it is no longer\n        actively maintained.\n\n        Use :func:`torch.linalg.norm`, instead, or :func:`torch.linalg.vector_norm`\n        when computing vector norms and :func:`torch.linalg.matrix_norm` when\n        computing matrix norms. Note, however, the signature for these functions\n        is slightly different than the signature for torch.norm.\n\n    Args:\n        input (Tensor): The input tensor. Its data type must be either a floating\n            point or complex type. For complex inputs, the norm is calculated using the\n            absolute value of each element. If the input is complex and neither\n            :attr:`dtype` nor :attr:`out` is specified, the result's data type will\n            be the corresponding floating point type (e.g. float if :attr:`input` is\n            complexfloat).\n\n        p (int, float, inf, -inf, 'fro', 'nuc', optional): the order of norm. Default: ``'fro'``\n            The following norms can be calculated:\n\n            ======  ==============  ==========================\n            ord     matrix norm     vector norm\n            ======  ==============  ==========================\n            'fro'   Frobenius norm  --\n            'nuc'   nuclear norm    --\n            Number  --              sum(abs(x)**ord)**(1./ord)\n            ======  ==============  ==========================\n\n            The vector norm can be calculated across any number of dimensions.\n            The corresponding dimensions of :attr:`input` are flattened into\n            one dimension, and the norm is calculated on the flattened\n            dimension.\n\n            Frobenius norm produces the same result as ``p=2`` in all cases\n            except when :attr:`dim` is a list of three or more dims, in which\n            case Frobenius norm throws an error.\n\n            Nuclear norm can only be calculated across exactly two dimensions.\n\n        dim (int, tuple of ints, list of ints, optional):\n            Specifies which dimension or dimensions of :attr:`input` to\n            calculate the norm across. If :attr:`dim` is ``None``, the norm will\n            be calculated across all dimensions of :attr:`input`. If the norm\n            type indicated by :attr:`p` does not support the specified number of\n            dimensions, an error will occur.\n        keepdim (bool, optional): whether the output tensors have :attr:`dim`\n            retained or not. Ignored if :attr:`dim` = ``None`` and\n            :attr:`out` = ``None``. Default: ``False``\n        out (Tensor, optional): the output tensor. Ignored if\n            :attr:`dim` = ``None`` and :attr:`out` = ``None``.\n        dtype (:class:`torch.dtype`, optional): the desired data type of\n            returned tensor. If specified, the input tensor is casted to\n            :attr:`dtype` while performing the operation. Default: None.\n\n    .. note::\n        Even though ``p='fro'`` supports any number of dimensions, the true\n        mathematical definition of Frobenius norm only applies to tensors with\n        exactly two dimensions. :func:`torch.linalg.norm` with ``ord='fro'`` aligns\n        with the mathematical definition, since it can only be applied across\n        exactly two dimensions.\n\n    Example::\n\n        >>> import torch\n        >>> a = torch.arange(9, dtype= torch.float) - 4\n        >>> b = a.reshape((3, 3))\n        >>> torch.norm(a)\n        tensor(7.7460)\n        >>> torch.norm(b)\n        tensor(7.7460)\n        >>> torch.norm(a, float('inf'))\n        tensor(4.)\n        >>> torch.norm(b, float('inf'))\n        tensor(4.)\n        >>> c = torch.tensor([[ 1, 2, 3],[-1, 1, 4]] , dtype= torch.float)\n        >>> torch.norm(c, dim=0)\n        tensor([1.4142, 2.2361, 5.0000])\n        >>> torch.norm(c, dim=1)\n        tensor([3.7417, 4.2426])\n        >>> torch.norm(c, p=1, dim=1)\n        tensor([6., 6.])\n        >>> d = torch.arange(8, dtype= torch.float).reshape(2,2,2)\n        >>> torch.norm(d, dim=(1,2))\n        tensor([ 3.7417, 11.2250])\n        >>> torch.norm(d[0, :, :]), torch.norm(d[1, :, :])\n        (tensor(3.7417), tensor(11.2250))\n    ",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "p": {
          "Type": null,
          "Default": "fro"
        },
        "dim": {
          "Type": null,
          "Default": "None"
        },
        "keepdim": {
          "Type": null,
          "Default": "False"
        },
        "out": {
          "Type": null,
          "Default": "None"
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "norm_except_dim": {
      "Doc": null,
      "Args": null
    },
    "normal": {
      "Doc": "\nnormal(mean, std, *, generator=None, out=None) -> Tensor\n\nReturns a tensor of random numbers drawn from separate normal distributions\nwhose mean and standard deviation are given.\n\nThe :attr:`mean` is a tensor with the mean of\neach output element's normal distribution\n\nThe :attr:`std` is a tensor with the standard deviation of\neach output element's normal distribution\n\nThe shapes of :attr:`mean` and :attr:`std` don't need to match, but the\ntotal number of elements in each tensor need to be the same.\n\n.. note:: When the shapes do not match, the shape of :attr:`mean`\n          is used as the shape for the returned output tensor\n\n.. note:: When :attr:`std` is a CUDA tensor, this function synchronizes\n          its device with the CPU.\n\nArgs:\n    mean (Tensor): the tensor of per-element means\n    std (Tensor): the tensor of per-element standard deviations\n\nKeyword args:\n    generator (:class:`torch.Generator`, optional): a pseudorandom number generator for sampling\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> torch.normal(mean=torch.arange(1., 11.), std=torch.arange(1, 0, -0.1))\n    tensor([  1.0425,   3.5672,   2.7969,   4.2925,   4.7229,   6.2134,\n              8.0505,   8.1408,   9.0563,  10.0566])\n\n.. function:: normal(mean=0.0, std, *, out=None) -> Tensor\n   :noindex:\n\nSimilar to the function above, but the means are shared among all drawn\nelements.\n\nArgs:\n    mean (float, optional): the mean for all distributions\n    std (Tensor): the tensor of per-element standard deviations\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> torch.normal(mean=0.5, std=torch.arange(1., 6.))\n    tensor([-1.2793, -1.0732, -2.0687,  5.1177, -1.2303])\n\n.. function:: normal(mean, std=1.0, *, out=None) -> Tensor\n   :noindex:\n\nSimilar to the function above, but the standard deviations are shared among\nall drawn elements.\n\nArgs:\n    mean (Tensor): the tensor of per-element means\n    std (float, optional): the standard deviation for all distributions\n\nKeyword args:\n    out (Tensor, optional): the output tensor\n\nExample::\n\n    >>> torch.normal(mean=torch.arange(1., 6.))\n    tensor([ 1.1552,  2.6148,  2.6535,  5.8318,  4.2361])\n\n.. function:: normal(mean, std, size, *, out=None) -> Tensor\n   :noindex:\n\nSimilar to the function above, but the means and standard deviations are shared\namong all drawn elements. The resulting tensor has size given by :attr:`size`.\n\nArgs:\n    mean (float): the mean for all distributions\n    std (float): the standard deviation for all distributions\n    size (int...): a sequence of integers defining the shape of the output tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> torch.normal(2, 3, size=(1, 4))\n    tensor([[-1.3987, -1.9544,  3.6048,  0.7909]])\n",
      "Args": {
        "mean": {
          "Type": null,
          "Default": null
        },
        "std": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "generator": {
          "Type": null,
          "Default": "None"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "not_equal": {
      "Doc": "\nnot_equal(input, other, *, out=None) -> Tensor\n\nAlias for :func:`torch.ne`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "nuclear_norm": {
      "Doc": null,
      "Args": null
    },
    "numel": {
      "Doc": "\nnumel(input) -> int\n\nReturns the total number of elements in the :attr:`input` tensor.\n\nArgs:\n    input (Tensor): the input tensor.\n\nExample::\n\n    >>> a = torch.randn(1, 2, 3, 4, 5)\n    >>> torch.numel(a)\n    120\n    >>> a = torch.zeros(4,4)\n    >>> torch.numel(a)\n    16\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "obj": {
      "Doc": "\nzeros_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor\n\nReturns a tensor filled with the scalar value `0`, with the same size as\n:attr:`input`. ``torch.zeros_like(input)`` is equivalent to\n``torch.zeros(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.\n\n.. warning::\n    As of 0.4, this function does not support an :attr:`out` keyword. As an alternative,\n    the old ``torch.zeros_like(input, out=output)`` is equivalent to\n    ``torch.zeros(input.size(), out=output)``.\n\nArgs:\n    input (Tensor): the size of :attr:`input` will determine size of the output tensor.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.\n        Default: if ``None``, defaults to the dtype of :attr:`input`.\n    layout (:class:`torch.layout`, optional): the desired layout of returned tensor.\n        Default: if ``None``, defaults to the layout of :attr:`input`.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, defaults to the device of :attr:`input`.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n    memory_format (:class:`torch.memory_format`, optional): the desired memory format of\n        returned Tensor. Default: ``torch.preserve_format``.\n\nExample::\n\n    >>> input = torch.empty(2, 3)\n    >>> torch.zeros_like(input)\n    tensor([[ 0.,  0.,  0.],\n            [ 0.,  0.,  0.]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "None"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        },
        "memory_format": {
          "Type": null,
          "Default": "torch.preserve_format"
        }
      }
    },
    "ones": {
      "Doc": "\nones(*size, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nReturns a tensor filled with the scalar value `1`, with the shape defined\nby the variable argument :attr:`size`.\n\nArgs:\n    size (int...): a sequence of integers defining the shape of the output tensor.\n        Can be a variable number of arguments or a collection like a list or tuple.\n\nKeyword arguments:\n    out (Tensor, optional): the output tensor.\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).\n    layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.\n        Default: ``torch.strided``.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n\nExample::\n\n    >>> torch.ones(2, 3)\n    tensor([[ 1.,  1.,  1.],\n            [ 1.,  1.,  1.]])\n\n    >>> torch.ones(5)\n    tensor([ 1.,  1.,  1.,  1.,  1.])\n\n",
      "Args": {
        "*size": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "torch.strided"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "ones_like": {
      "Doc": "\nones_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor\n\nReturns a tensor filled with the scalar value `1`, with the same size as\n:attr:`input`. ``torch.ones_like(input)`` is equivalent to\n``torch.ones(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.\n\n.. warning::\n    As of 0.4, this function does not support an :attr:`out` keyword. As an alternative,\n    the old ``torch.ones_like(input, out=output)`` is equivalent to\n    ``torch.ones(input.size(), out=output)``.\n\nArgs:\n    input (Tensor): the size of :attr:`input` will determine size of the output tensor.\n\nKeyword arguments:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.\n        Default: if ``None``, defaults to the dtype of :attr:`input`.\n    layout (:class:`torch.layout`, optional): the desired layout of returned tensor.\n        Default: if ``None``, defaults to the layout of :attr:`input`.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, defaults to the device of :attr:`input`.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n    memory_format (:class:`torch.memory_format`, optional): the desired memory format of\n        returned Tensor. Default: ``torch.preserve_format``.\n\nExample::\n\n    >>> input = torch.empty(2, 3)\n    >>> torch.ones_like(input)\n    tensor([[ 1.,  1.,  1.],\n            [ 1.,  1.,  1.]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "None"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        },
        "memory_format": {
          "Type": null,
          "Default": "torch.preserve_format"
        }
      }
    },
    "orgqr": {
      "Doc": "\norgqr(input, tau) -> Tensor\n\nAlias for :func:`torch.linalg.householder_product`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "tau": {
          "Type": null,
          "Default": null
        }
      }
    },
    "ormqr": {
      "Doc": "\normqr(input, tau, other, left=True, transpose=False, *, out=None) -> Tensor\n\nComputes the matrix-matrix multiplication of a product of Householder matrices with a general matrix.\n\nMultiplies a :math:`m \\times n` matrix `C` (given by :attr:`other`) with a matrix `Q`,\nwhere `Q` is represented using Householder reflectors `(input, tau)`.\nSee `Representation of Orthogonal or Unitary Matrices`_ for further details.\n\nIf :attr:`left` is `True` then `op(Q)` times `C` is computed, otherwise the result is `C` times `op(Q)`.\nWhen :attr:`left` is `True`, the implicit matrix `Q` has size :math:`m \\times m`.\nIt has size :math:`n \\times n` otherwise.\nIf :attr:`transpose` is `True` then `op` is the conjugate transpose operation, otherwise it's a no-op.\n\nSupports inputs of float, double, cfloat and cdouble dtypes.\nAlso supports batched inputs, and, if the input is batched, the output is batched with the same dimensions.\n\n.. seealso::\n\n        :func:`torch.geqrf` can be used to form the Householder representation `(input, tau)` of matrix `Q`\n        from the QR decomposition.\n\nArgs:\n    input (Tensor): tensor of shape `(*, mn, k)` where `*` is zero or more batch dimensions\n                    and `mn` equals to `m` or `n` depending on the :attr:`left`.\n    tau (Tensor): tensor of shape `(*, min(mn, k))` where `*` is zero or more batch dimensions.\n    other (Tensor): tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions.\n    left (bool): controls the order of multiplication.\n    transpose (bool): controls whether the matrix `Q` is conjugate transposed or not.\n\nKeyword args:\n    out (Tensor, optional): the output Tensor. Ignored if `None`. Default: `None`.\n\n.. _Representation of Orthogonal or Unitary Matrices:\n    https://www.netlib.org/lapack/lug/node128.html\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "tau": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "left": {
          "Type": null,
          "Default": "True"
        },
        "transpose": {
          "Type": null,
          "Default": "False"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "outer": {
      "Doc": "\nouter(input, vec2, *, out=None) -> Tensor\n\nOuter product of :attr:`input` and :attr:`vec2`.\nIf :attr:`input` is a vector of size :math:`n` and :attr:`vec2` is a vector of\nsize :math:`m`, then :attr:`out` must be a matrix of size :math:`(n \\times m)`.\n\n.. note:: This function does not :ref:`broadcast <broadcasting-semantics>`.\n\nArgs:\n    input (Tensor): 1-D input vector\n    vec2 (Tensor): 1-D input vector\n\nKeyword args:\n    out (Tensor, optional): optional output matrix\n\nExample::\n\n    >>> v1 = torch.arange(1., 5.)\n    >>> v2 = torch.arange(1., 4.)\n    >>> torch.outer(v1, v2)\n    tensor([[  1.,   2.,   3.],\n            [  2.,   4.,   6.],\n            [  3.,   6.,   9.],\n            [  4.,   8.,  12.]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "vec2": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "pairwise_distance": {
      "Doc": "\npairwise_distance(x1, x2, p=2.0, eps=1e-6, keepdim=False) -> Tensor\n\nSee :class:`torch.nn.PairwiseDistance` for details\n",
      "Args": {
        "x1": {
          "Type": null,
          "Default": null
        },
        "x2": {
          "Type": null,
          "Default": null
        },
        "p": {
          "Type": null,
          "Default": "2.0"
        },
        "eps": {
          "Type": null,
          "Default": "1e-6"
        },
        "keepdim": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "parse_ir": {
      "Doc": "parse_ir(input: str, parse_tensor_constants: bool = False) -> torch::jit::Graph\n",
      "Args": {
        "input": {
          "Type": "str",
          "Default": null
        },
        "parse_tensor_constants": {
          "Type": "bool = False",
          "Default": "False"
        }
      }
    },
    "parse_schema": {
      "Doc": "parse_schema(arg0: str) -> c10::FunctionSchema\n",
      "Args": {
        "arg0": {
          "Type": "str",
          "Default": null
        }
      }
    },
    "parse_type_comment": {
      "Doc": "parse_type_comment(arg0: str) -> torch._C._jit_tree_views.Decl\n",
      "Args": {
        "arg0": {
          "Type": "str",
          "Default": null
        }
      }
    },
    "pca_lowrank": {
      "Doc": "Performs linear Principal Component Analysis (PCA) on a low-rank\n    matrix, batches of such matrices, or sparse matrix.\n\n    This function returns a namedtuple ``(U, S, V)`` which is the\n    nearly optimal approximation of a singular value decomposition of\n    a centered matrix :math:`A` such that :math:`A = U diag(S) V^T`.\n\n    .. note:: The relation of ``(U, S, V)`` to PCA is as follows:\n\n                - :math:`A` is a data matrix with ``m`` samples and\n                  ``n`` features\n\n                - the :math:`V` columns represent the principal directions\n\n                - :math:`S ** 2 / (m - 1)` contains the eigenvalues of\n                  :math:`A^T A / (m - 1)` which is the covariance of\n                  ``A`` when ``center=True`` is provided.\n\n                - ``matmul(A, V[:, :k])`` projects data to the first k\n                  principal components\n\n    .. note:: Different from the standard SVD, the size of returned\n              matrices depend on the specified rank and q\n              values as follows:\n\n                - :math:`U` is m x q matrix\n\n                - :math:`S` is q-vector\n\n                - :math:`V` is n x q matrix\n\n    .. note:: To obtain repeatable results, reset the seed for the\n              pseudorandom number generator\n\n    Args:\n\n        A (Tensor): the input tensor of size :math:`(*, m, n)`\n\n        q (int, optional): a slightly overestimated rank of\n                           :math:`A`. By default, ``q = min(6, m,\n                           n)``.\n\n        center (bool, optional): if True, center the input tensor,\n                                 otherwise, assume that the input is\n                                 centered.\n\n        niter (int, optional): the number of subspace iterations to\n                               conduct; niter must be a nonnegative\n                               integer, and defaults to 2.\n\n    References::\n\n        - Nathan Halko, Per-Gunnar Martinsson, and Joel Tropp, Finding\n          structure with randomness: probabilistic algorithms for\n          constructing approximate matrix decompositions,\n          arXiv:0909.4061 [math.NA; math.PR], 2009 (available at\n          `arXiv <http://arxiv.org/abs/0909.4061>`_).\n\n    ",
      "Args": {
        "A": {
          "Type": "<class 'torch.Tensor'>",
          "Default": null
        },
        "q": {
          "Type": "typing.Optional[int]",
          "Default": "None"
        },
        "center": {
          "Type": "<class 'bool'>",
          "Default": "True"
        },
        "niter": {
          "Type": "<class 'int'>",
          "Default": "2"
        }
      }
    },
    "pdist": {
      "Doc": "\npdist(input, p=2) -> Tensor\n\nComputes the p-norm distance between every pair of row vectors in the input.\nThis is identical to the upper triangular portion, excluding the diagonal, of\n`torch.norm(input[:, None] - input, dim=2, p=p)`. This function will be faster\nif the rows are contiguous.\n\nIf input has shape :math:`N \\times M` then the output will have shape\n:math:`\\frac{1}{2} N (N - 1)`.\n\nThis function is equivalent to ``scipy.spatial.distance.pdist(input,\n'minkowski', p=p)`` if :math:`p \\in (0, \\infty)`. When :math:`p = 0` it is\nequivalent to ``scipy.spatial.distance.pdist(input, 'hamming') * M``.\nWhen :math:`p = \\infty`, the closest scipy function is\n``scipy.spatial.distance.pdist(xn, lambda x, y: np.abs(x - y).max())``.\n\nArgs:\n    input: input tensor of shape :math:`N \\times M`.\n    p: p value for the p-norm distance to calculate between each vector pair\n        :math:`\\in [0, \\infty]`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "p": {
          "Type": null,
          "Default": "2"
        }
      }
    },
    "permute": {
      "Doc": "\npermute(input, dims) -> Tensor\n\nReturns a view of the original tensor :attr:`input` with its dimensions permuted.\n\nArgs:\n    input (Tensor): the input tensor.\n    dims (tuple of int): The desired ordering of dimensions\n\nExample:\n    >>> x = torch.randn(2, 3, 5)\n    >>> x.size()\n    torch.Size([2, 3, 5])\n    >>> torch.permute(x, (2, 0, 1)).size()\n    torch.Size([5, 2, 3])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dims": {
          "Type": null,
          "Default": null
        }
      }
    },
    "permute_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.permute`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "pinverse": {
      "Doc": "\npinverse(input, rcond=1e-15) -> Tensor\n\nAlias for :func:`torch.linalg.pinv`\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "rcond": {
          "Type": null,
          "Default": "1e-15"
        }
      }
    },
    "pixel_shuffle": {
      "Doc": "\npixel_shuffle(input, upscale_factor) -> Tensor\n\nRearranges elements in a tensor of shape :math:`(*, C \\times r^2, H, W)` to a\ntensor of shape :math:`(*, C, H \\times r, W \\times r)`, where r is the :attr:`upscale_factor`.\n\nSee :class:`~torch.nn.PixelShuffle` for details.\n\nArgs:\n    input (Tensor): the input tensor\n    upscale_factor (int): factor to increase spatial resolution by\n\nExamples::\n\n    >>> input = torch.randn(1, 9, 4, 4)\n    >>> output = torch.nn.functional.pixel_shuffle(input, 3)\n    >>> print(output.size())\n    torch.Size([1, 1, 12, 12])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "upscale_factor": {
          "Type": null,
          "Default": null
        }
      }
    },
    "pixel_unshuffle": {
      "Doc": "\npixel_unshuffle(input, downscale_factor) -> Tensor\n\nReverses the :class:`~torch.nn.PixelShuffle` operation by rearranging elements in a\ntensor of shape :math:`(*, C, H \\times r, W \\times r)` to a tensor of shape\n:math:`(*, C \\times r^2, H, W)`, where r is the :attr:`downscale_factor`.\n\nSee :class:`~torch.nn.PixelUnshuffle` for details.\n\nArgs:\n    input (Tensor): the input tensor\n    downscale_factor (int): factor to increase spatial resolution by\n\nExamples::\n\n    >>> input = torch.randn(1, 1, 12, 12)\n    >>> output = torch.nn.functional.pixel_unshuffle(input, 3)\n    >>> print(output.size())\n    torch.Size([1, 9, 4, 4])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "downscale_factor": {
          "Type": null,
          "Default": null
        }
      }
    },
    "poisson": {
      "Doc": "\npoisson(input, generator=None) -> Tensor\n\nReturns a tensor of the same size as :attr:`input` with each element\nsampled from a Poisson distribution with rate parameter given by the corresponding\nelement in :attr:`input` i.e.,\n\n.. math::\n    \\text{out}_i \\sim \\text{Poisson}(\\text{input}_i)\n\n:attr:`input` must be non-negative.\n\nArgs:\n    input (Tensor): the input tensor containing the rates of the Poisson distribution\n\nKeyword args:\n    generator (:class:`torch.Generator`, optional): a pseudorandom number generator for sampling\n\nExample::\n\n    >>> rates = torch.rand(4, 4) * 5  # rate parameter between 0 and 5\n    >>> torch.poisson(rates)\n    tensor([[9., 1., 3., 5.],\n            [8., 6., 6., 0.],\n            [0., 4., 5., 3.],\n            [2., 1., 4., 2.]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "generator": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "poisson_nll_loss": {
      "Doc": null,
      "Args": null
    },
    "polar": {
      "Doc": "\npolar(abs, angle, *, out=None) -> Tensor\n\nConstructs a complex tensor whose elements are Cartesian coordinates\ncorresponding to the polar coordinates with absolute value :attr:`abs` and angle\n:attr:`angle`.\n\n.. math::\n    \\text{out} = \\text{abs} \\cdot \\cos(\\text{angle}) + \\text{abs} \\cdot \\sin(\\text{angle}) \\cdot j\n\n.. note::\n    `torch.polar` is similar to\n    `std::polar <https://en.cppreference.com/w/cpp/numeric/complex/polar>`_\n    and does not compute the polar decomposition\n    of a complex tensor like Python's `cmath.polar` and SciPy's `linalg.polar` do.\n    The behavior of this function is undefined if `abs` is negative or NaN, or if `angle` is\n    infinite.\n\n\nArgs:\n    abs (Tensor): The absolute value the complex tensor. Must be float or double.\n    angle (Tensor): The angle of the complex tensor. Must be same dtype as\n        :attr:`abs`.\n\nKeyword args:\n    out (Tensor): If the inputs are ``torch.float32``, must be\n        ``torch.complex64``. If the inputs are ``torch.float64``, must be\n        ``torch.complex128``.\n\nExample::\n\n    >>> import numpy as np\n    >>> abs = torch.tensor([1, 2], dtype=torch.float64)\n    >>> angle = torch.tensor([np.pi / 2, 5 * np.pi / 4], dtype=torch.float64)\n    >>> z = torch.polar(abs, angle)\n    >>> z\n    tensor([(0.0000+1.0000j), (-1.4142-1.4142j)], dtype=torch.complex128)\n",
      "Args": {
        "abs": {
          "Type": null,
          "Default": null
        },
        "angle": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "polygamma": {
      "Doc": "\npolygamma(n, input, *, out=None) -> Tensor\n\nAlias for :func:`torch.special.polygamma`.\n",
      "Args": {
        "n": {
          "Type": null,
          "Default": null
        },
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "positive": {
      "Doc": "\npositive(input) -> Tensor\n\nReturns :attr:`input`.\nThrows a runtime error if :attr:`input` is a bool tensor.\n\nArgs:\n    input (Tensor): the input tensor.\n\nExample::\n\n    >>> t = torch.randn(5)\n    >>> t\n    tensor([ 0.0090, -0.2262, -0.0682, -0.2866,  0.3940])\n    >>> torch.positive(t)\n    tensor([ 0.0090, -0.2262, -0.0682, -0.2866,  0.3940])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "pow": {
      "Doc": "\npow(input, exponent, *, out=None) -> Tensor\n\nTakes the power of each element in :attr:`input` with :attr:`exponent` and\nreturns a tensor with the result.\n\n:attr:`exponent` can be either a single ``float`` number or a `Tensor`\nwith the same number of elements as :attr:`input`.\n\nWhen :attr:`exponent` is a scalar value, the operation applied is:\n\n.. math::\n    \\text{out}_i = x_i ^ \\text{exponent}\n\nWhen :attr:`exponent` is a tensor, the operation applied is:\n\n.. math::\n    \\text{out}_i = x_i ^ {\\text{exponent}_i}\n\nWhen :attr:`exponent` is a tensor, the shapes of :attr:`input`\nand :attr:`exponent` must be :ref:`broadcastable <broadcasting-semantics>`.\n\nArgs:\n    input (Tensor): the input tensor.\n    exponent (float or tensor): the exponent value\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 0.4331,  1.2475,  0.6834, -0.2791])\n    >>> torch.pow(a, 2)\n    tensor([ 0.1875,  1.5561,  0.4670,  0.0779])\n    >>> exp = torch.arange(1., 5.)\n\n    >>> a = torch.arange(1., 5.)\n    >>> a\n    tensor([ 1.,  2.,  3.,  4.])\n    >>> exp\n    tensor([ 1.,  2.,  3.,  4.])\n    >>> torch.pow(a, exp)\n    tensor([   1.,    4.,   27.,  256.])\n\n.. function:: pow(self, exponent, *, out=None) -> Tensor\n   :noindex:\n\n:attr:`self` is a scalar ``float`` value, and :attr:`exponent` is a tensor.\nThe returned tensor :attr:`out` is of the same shape as :attr:`exponent`\n\nThe operation applied is:\n\n.. math::\n    \\text{out}_i = \\text{self} ^ {\\text{exponent}_i}\n\nArgs:\n    self (float): the scalar base value for the power operation\n    exponent (Tensor): the exponent tensor\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> exp = torch.arange(1., 5.)\n    >>> base = 2\n    >>> torch.pow(base, exp)\n    tensor([  2.,   4.,   8.,  16.])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "exponent": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "prelu": {
      "Doc": "prelu(input, weight) -> Tensor\n\nApplies element-wise the function\n:math:`\\text{PReLU}(x) = \\max(0,x) + \\text{weight} * \\min(0,x)` where weight is a\nlearnable parameter.\n\n.. note::\n    `weight` is expected to be a scalar or 1-D tensor. If `weight` is 1-D,\n    its size must match the number of input channels, determined by\n    `input.size(1)` when `input.dim() >= 2`, otherwise 1.\n    In the 1-D case, note that when `input` has dim > 2, `weight` can be expanded\n    to the shape of `input` in a way that is not possible using normal\n    :ref:`broadcasting semantics<broadcasting-semantics>`.\n\nSee :class:`~torch.nn.PReLU` for more details.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "weight": {
          "Type": null,
          "Default": null
        }
      }
    },
    "prepare_multiprocessing_environment": {
      "Doc": null,
      "Args": {
        "path": {
          "Type": "<class 'str'>",
          "Default": null
        }
      }
    },
    "prod": {
      "Doc": "\nprod(input, *, dtype=None) -> Tensor\n\nReturns the product of all elements in the :attr:`input` tensor.\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        If specified, the input tensor is casted to :attr:`dtype` before the operation\n        is performed. This is useful for preventing data type overflows. Default: None.\n\nExample::\n\n    >>> a = torch.randn(1, 3)\n    >>> a\n    tensor([[-0.8020,  0.5428, -1.5854]])\n    >>> torch.prod(a)\n    tensor(0.6902)\n\n.. function:: prod(input, dim, keepdim=False, *, dtype=None) -> Tensor\n   :noindex:\n\nReturns the product of each row of the :attr:`input` tensor in the given\ndimension :attr:`dim`.\n\nIf :attr:`keepdim` is ``True``, the output tensor is of the same size\nas :attr:`input` except in the dimension :attr:`dim` where it is of size 1.\nOtherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in\nthe output tensor having 1 fewer dimension than :attr:`input`.\n\nArgs:\n    input (Tensor): the input tensor.\n    dim (int): the dimension to reduce.\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        If specified, the input tensor is casted to :attr:`dtype` before the operation\n        is performed. This is useful for preventing data type overflows. Default: None.\n\nExample::\n\n    >>> a = torch.randn(4, 2)\n    >>> a\n    tensor([[ 0.5261, -0.3837],\n            [ 1.1857, -0.2498],\n            [-1.1646,  0.0705],\n            [ 1.1131, -1.0629]])\n    >>> torch.prod(a, 1)\n    tensor([-0.2018, -0.2962, -0.0821, -1.1831])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "promote_types": {
      "Doc": "\npromote_types(type1, type2) -> dtype\n\nReturns the :class:`torch.dtype` with the smallest size and scalar kind that is\nnot smaller nor of lower kind than either `type1` or `type2`. See type promotion\n:ref:`documentation <type-promotion-doc>` for more information on the type\npromotion logic.\n\nArgs:\n    type1 (:class:`torch.dtype`)\n    type2 (:class:`torch.dtype`)\n\nExample::\n\n    >>> torch.promote_types(torch.int32, torch.float32)\n    torch.float32\n    >>> torch.promote_types(torch.uint8, torch.long)\n    torch.long\n",
      "Args": {
        "type1": {
          "Type": null,
          "Default": null
        },
        "type2": {
          "Type": null,
          "Default": null
        }
      }
    },
    "put": {
      "Doc": null,
      "Args": null
    },
    "q_per_channel_axis": {
      "Doc": null,
      "Args": null
    },
    "q_per_channel_scales": {
      "Doc": null,
      "Args": null
    },
    "q_per_channel_zero_points": {
      "Doc": null,
      "Args": null
    },
    "q_scale": {
      "Doc": null,
      "Args": null
    },
    "q_zero_point": {
      "Doc": null,
      "Args": null
    },
    "qr": {
      "Doc": "\nqr(input, some=True, *, out=None) -> (Tensor, Tensor)\n\nComputes the QR decomposition of a matrix or a batch of matrices :attr:`input`,\nand returns a namedtuple (Q, R) of tensors such that :math:`\\text{input} = Q R`\nwith :math:`Q` being an orthogonal matrix or batch of orthogonal matrices and\n:math:`R` being an upper triangular matrix or batch of upper triangular matrices.\n\nIf :attr:`some` is ``True``, then this function returns the thin (reduced) QR factorization.\nOtherwise, if :attr:`some` is ``False``, this function returns the complete QR factorization.\n\n.. warning::\n\n    :func:`torch.qr` is deprecated in favor of :func:`torch.linalg.qr`\n    and will be removed in a future PyTorch release. The boolean parameter :attr:`some` has been\n    replaced with a string parameter :attr:`mode`.\n\n    ``Q, R = torch.qr(A)`` should be replaced with\n\n    .. code:: python\n\n        Q, R = torch.linalg.qr(A)\n\n    ``Q, R = torch.qr(A, some=False)`` should be replaced with\n\n    .. code:: python\n\n        Q, R = torch.linalg.qr(A, mode=\"complete\")\n\n.. warning::\n          If you plan to backpropagate through QR, note that the current backward implementation\n          is only well-defined when the first :math:`\\min(input.size(-1), input.size(-2))`\n          columns of :attr:`input` are linearly independent.\n          This behavior will propably change once QR supports pivoting.\n\n.. note:: This function uses LAPACK for CPU inputs and MAGMA for CUDA inputs,\n          and may produce different (valid) decompositions on different device types\n          or different platforms.\n\nArgs:\n    input (Tensor): the input tensor of size :math:`(*, m, n)` where `*` is zero or more\n                batch dimensions consisting of matrices of dimension :math:`m \\times n`.\n    some (bool, optional): Set to ``True`` for reduced QR decomposition and ``False`` for\n                complete QR decomposition. If `k = min(m, n)` then:\n\n                  * ``some=True`` : returns `(Q, R)` with dimensions (m, k), (k, n) (default)\n\n                  * ``'some=False'``: returns `(Q, R)` with dimensions (m, m), (m, n)\n\nKeyword args:\n    out (tuple, optional): tuple of `Q` and `R` tensors.\n                The dimensions of `Q` and `R` are detailed in the description of :attr:`some` above.\n\nExample::\n\n    >>> a = torch.tensor([[12., -51, 4], [6, 167, -68], [-4, 24, -41]])\n    >>> q, r = torch.qr(a)\n    >>> q\n    tensor([[-0.8571,  0.3943,  0.3314],\n            [-0.4286, -0.9029, -0.0343],\n            [ 0.2857, -0.1714,  0.9429]])\n    >>> r\n    tensor([[ -14.0000,  -21.0000,   14.0000],\n            [   0.0000, -175.0000,   70.0000],\n            [   0.0000,    0.0000,  -35.0000]])\n    >>> torch.mm(q, r).round()\n    tensor([[  12.,  -51.,    4.],\n            [   6.,  167.,  -68.],\n            [  -4.,   24.,  -41.]])\n    >>> torch.mm(q.t(), q).round()\n    tensor([[ 1.,  0.,  0.],\n            [ 0.,  1., -0.],\n            [ 0., -0.,  1.]])\n    >>> a = torch.randn(3, 4, 5)\n    >>> q, r = torch.qr(a, some=False)\n    >>> torch.allclose(torch.matmul(q, r), a)\n    True\n    >>> torch.allclose(torch.matmul(q.mT, q), torch.eye(5))\n    True\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "some": {
          "Type": null,
          "Default": "True"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None) -> (Tensor"
        },
        "Tensor": {
          "Type": null,
          "Default": null
        }
      }
    },
    "quantile": {
      "Doc": "\nquantile(input, q, dim=None, keepdim=False, *, interpolation='linear', out=None) -> Tensor\n\nComputes the q-th quantiles of each row of the :attr:`input` tensor along the dimension :attr:`dim`.\n\nTo compute the quantile, we map q in [0, 1] to the range of indices [0, n] to find the location\nof the quantile in the sorted input. If the quantile lies between two data points ``a < b`` with\nindices ``i`` and ``j`` in the sorted order, result is computed according to the given\n:attr:`interpolation` method as follows:\n\n- ``linear``: ``a + (b - a) * fraction``, where ``fraction`` is the fractional part of the computed quantile index.\n- ``lower``: ``a``.\n- ``higher``: ``b``.\n- ``nearest``: ``a`` or ``b``, whichever's index is closer to the computed quantile index (rounding down for .5 fractions).\n- ``midpoint``: ``(a + b) / 2``.\n\nIf :attr:`q` is a 1D tensor, the first dimension of the output represents the quantiles and has size\nequal to the size of :attr:`q`, the remaining dimensions are what remains from the reduction.\n\n.. note::\n    By default :attr:`dim` is ``None`` resulting in the :attr:`input` tensor being flattened before computation.\n\nArgs:\n    input (Tensor): the input tensor.\n    q (float or Tensor): a scalar or 1D tensor of values in the range [0, 1].\n    dim (int): the dimension to reduce.\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not.\n\nKeyword arguments:\n    interpolation (str): interpolation method to use when the desired quantile lies between two data points.\n                            Can be ``linear``, ``lower``, ``higher``, ``midpoint`` and ``nearest``.\n                            Default is ``linear``.\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(2, 3)\n    >>> a\n    tensor([[ 0.0795, -1.2117,  0.9765],\n            [ 1.1707,  0.6706,  0.4884]])\n    >>> q = torch.tensor([0.25, 0.5, 0.75])\n    >>> torch.quantile(a, q, dim=1, keepdim=True)\n    tensor([[[-0.5661],\n            [ 0.5795]],\n\n            [[ 0.0795],\n            [ 0.6706]],\n\n            [[ 0.5280],\n            [ 0.9206]]])\n    >>> torch.quantile(a, q, dim=1, keepdim=True).shape\n    torch.Size([3, 2, 1])\n    >>> a = torch.arange(4.)\n    >>> a\n    tensor([0., 1., 2., 3.])\n    >>> torch.quantile(a, 0.6, interpolation='linear')\n    tensor(1.8000)\n    >>> torch.quantile(a, 0.6, interpolation='lower')\n    tensor(1.)\n    >>> torch.quantile(a, 0.6, interpolation='higher')\n    tensor(2.)\n    >>> torch.quantile(a, 0.6, interpolation='midpoint')\n    tensor(1.5000)\n    >>> torch.quantile(a, 0.6, interpolation='nearest')\n    tensor(2.)\n    >>> torch.quantile(a, 0.4, interpolation='nearest')\n    tensor(1.)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "q": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "None"
        },
        "keepdim": {
          "Type": null,
          "Default": "False"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "interpolation": {
          "Type": null,
          "Default": "'linear'"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "quantize_per_channel": {
      "Doc": "\nquantize_per_channel(input, scales, zero_points, axis, dtype) -> Tensor\n\nConverts a float tensor to a per-channel quantized tensor with given scales and zero points.\n\nArguments:\n    input (Tensor): float tensor to quantize\n    scales (Tensor): float 1D tensor of scales to use, size should match ``input.size(axis)``\n    zero_points (int): integer 1D tensor of offset to use, size should match ``input.size(axis)``\n    axis (int): dimension on which apply per-channel quantization\n    dtype (:class:`torch.dtype`): the desired data type of returned tensor.\n        Has to be one of the quantized dtypes: ``torch.quint8``, ``torch.qint8``, ``torch.qint32``\n\nReturns:\n    Tensor: A newly quantized tensor\n\nExample::\n\n    >>> x = torch.tensor([[-1.0, 0.0], [1.0, 2.0]])\n    >>> torch.quantize_per_channel(x, torch.tensor([0.1, 0.01]), torch.tensor([10, 0]), 0, torch.quint8)\n    tensor([[-1.,  0.],\n            [ 1.,  2.]], size=(2, 2), dtype=torch.quint8,\n           quantization_scheme=torch.per_channel_affine,\n           scale=tensor([0.1000, 0.0100], dtype=torch.float64),\n           zero_point=tensor([10,  0]), axis=0)\n    >>> torch.quantize_per_channel(x, torch.tensor([0.1, 0.01]), torch.tensor([10, 0]), 0, torch.quint8).int_repr()\n    tensor([[  0,  10],\n            [100, 200]], dtype=torch.uint8)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "scales": {
          "Type": null,
          "Default": null
        },
        "zero_points": {
          "Type": null,
          "Default": null
        },
        "axis": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": null
        }
      }
    },
    "quantize_per_tensor": {
      "Doc": "\nquantize_per_tensor(input, scale, zero_point, dtype) -> Tensor\n\nConverts a float tensor to a quantized tensor with given scale and zero point.\n\nArguments:\n    input (Tensor): float tensor or list of tensors to quantize\n    scale (float or Tensor): scale to apply in quantization formula\n    zero_point (int or Tensor): offset in integer value that maps to float zero\n    dtype (:class:`torch.dtype`): the desired data type of returned tensor.\n        Has to be one of the quantized dtypes: ``torch.quint8``, ``torch.qint8``, ``torch.qint32``\n\nReturns:\n    Tensor: A newly quantized tensor or list of quantized tensors.\n\nExample::\n\n    >>> torch.quantize_per_tensor(torch.tensor([-1.0, 0.0, 1.0, 2.0]), 0.1, 10, torch.quint8)\n    tensor([-1.,  0.,  1.,  2.], size=(4,), dtype=torch.quint8,\n           quantization_scheme=torch.per_tensor_affine, scale=0.1, zero_point=10)\n    >>> torch.quantize_per_tensor(torch.tensor([-1.0, 0.0, 1.0, 2.0]), 0.1, 10, torch.quint8).int_repr()\n    tensor([ 0, 10, 20, 30], dtype=torch.uint8)\n    >>> torch.quantize_per_tensor([torch.tensor([-1.0, 0.0]), torch.tensor([-2.0, 2.0])],\n    >>> torch.tensor([0.1, 0.2]), torch.tensor([10, 20]), torch.quint8)\n    (tensor([-1.,  0.], size=(2,), dtype=torch.quint8,\n        quantization_scheme=torch.per_tensor_affine, scale=0.1, zero_point=10),\n        tensor([-2.,  2.], size=(2,), dtype=torch.quint8,\n        quantization_scheme=torch.per_tensor_affine, scale=0.2, zero_point=20))\n    >>> torch.quantize_per_tensor(torch.tensor([-1.0, 0.0, 1.0, 2.0]), torch.tensor(0.1), torch.tensor(10), torch.quint8)\n    tensor([-1.,  0.,  1.,  2.], size=(4,), dtype=torch.quint8,\n       quantization_scheme=torch.per_tensor_affine, scale=0.10, zero_point=10)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "scale": {
          "Type": null,
          "Default": null
        },
        "zero_point": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": null
        }
      }
    },
    "quantize_per_tensor_dynamic": {
      "Doc": "\nquantize_per_tensor_dynamic(input, dtype, reduce_range) -> Tensor\n\nConverts a float tensor to a quantized tensor with scale and zero_point calculated\ndynamically based on the input.\n\nArguments:\n    input (Tensor): float tensor or list of tensors to quantize\n    dtype (:class:`torch.dtype`): the desired data type of returned tensor.\n        Has to be one of the quantized dtypes: ``torch.quint8``, ``torch.qint8``\n    reduce_range (bool): a flag to indicate whether to reduce the range of quantized\n    data by 1 bit, it's required to avoid instruction overflow for some hardwares\n\nReturns:\n    Tensor: A newly (dynamically) quantized tensor\n\nExample::\n\n    >>> t = torch.quantize_per_tensor_dynamic(torch.tensor([-1.0, 0.0, 1.0, 2.0]), torch.quint8, False)\n    >>> print(t)\n    tensor([-1.,  0.,  1.,  2.], size=(4,), dtype=torch.quint8,\n           quantization_scheme=torch.per_tensor_affine, scale=0.011764705882352941,\n           zero_point=85)\n    >>> t.int_repr()\n    tensor([  0,  85, 170, 255], dtype=torch.uint8)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": null
        },
        "reduce_range": {
          "Type": null,
          "Default": null
        }
      }
    },
    "quantized_batch_norm": {
      "Doc": "\nquantized_batch_norm(input, weight=None, bias=None, mean, var, eps, output_scale, output_zero_point) -> Tensor\n\nApplies batch normalization on a 4D (NCHW) quantized tensor.\n\n.. math::\n\n        y = \\frac{x - \\mathrm{E}[x]}{\\sqrt{\\mathrm{Var}[x] + \\epsilon}} * \\gamma + \\beta\n\nArguments:\n    input (Tensor): quantized tensor\n    weight (Tensor): float tensor that corresponds to the gamma, size C\n    bias (Tensor):  float tensor that corresponds to the beta, size C\n    mean (Tensor): float mean value in batch normalization, size C\n    var (Tensor): float tensor for variance, size C\n    eps (float): a value added to the denominator for numerical stability.\n    output_scale (float): output quantized tensor scale\n    output_zero_point (int): output quantized tensor zero_point\n\nReturns:\n    Tensor: A quantized tensor with batch normalization applied.\n\nExample::\n\n    >>> qx = torch.quantize_per_tensor(torch.rand(2, 2, 2, 2), 1.5, 3, torch.quint8)\n    >>> torch.quantized_batch_norm(qx, torch.ones(2), torch.zeros(2), torch.rand(2), torch.rand(2), 0.00001, 0.2, 2)\n    tensor([[[[-0.2000, -0.2000],\n          [ 1.6000, -0.2000]],\n\n         [[-0.4000, -0.4000],\n          [-0.4000,  0.6000]]],\n\n\n        [[[-0.2000, -0.2000],\n          [-0.2000, -0.2000]],\n\n         [[ 0.6000, -0.4000],\n          [ 0.6000, -0.4000]]]], size=(2, 2, 2, 2), dtype=torch.quint8,\n       quantization_scheme=torch.per_tensor_affine, scale=0.2, zero_point=2)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "weight": {
          "Type": null,
          "Default": "None"
        },
        "bias": {
          "Type": null,
          "Default": "None"
        },
        "mean": {
          "Type": null,
          "Default": null
        },
        "var": {
          "Type": null,
          "Default": null
        },
        "eps": {
          "Type": null,
          "Default": null
        },
        "output_scale": {
          "Type": null,
          "Default": null
        },
        "output_zero_point": {
          "Type": null,
          "Default": null
        }
      }
    },
    "quantized_gru_cell": {
      "Doc": null,
      "Args": null
    },
    "quantized_lstm_cell": {
      "Doc": null,
      "Args": null
    },
    "quantized_max_pool1d": {
      "Doc": "\nquantized_max_pool1d(input, kernel_size, stride=[], padding=0, dilation=1, ceil_mode=False) -> Tensor\n\nApplies a 1D max pooling over an input quantized tensor composed of several input planes.\n\nArguments:\n    input (Tensor): quantized tensor\n    kernel_size (list of int): the size of the sliding window\n    stride (``list of int``, optional): the stride of the sliding window\n    padding (``list of int``, opttional): padding to be added on both sides, must be >= 0 and <= kernel_size / 2\n    dilation (``list of int``, optional): The stride between elements within a sliding window, must be > 0. Default 1\n    ceil_mode (bool, optional):  If True, will use ceil instead of floor to compute the output shape.\n        Defaults to False.\n\n\nReturns:\n    Tensor: A quantized tensor with max_pool1d applied.\n\nExample::\n\n    >>> qx = torch.quantize_per_tensor(torch.rand(2, 2), 1.5, 3, torch.quint8)\n    >>> torch.quantized_max_pool1d(qx, [2])\n    tensor([[0.0000],\n            [1.5000]], size=(2, 1), dtype=torch.quint8,\n        quantization_scheme=torch.per_tensor_affine, scale=1.5, zero_point=3)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "kernel_size": {
          "Type": null,
          "Default": null
        },
        "stride": {
          "Type": null,
          "Default": "[]"
        },
        "padding": {
          "Type": null,
          "Default": "0"
        },
        "dilation": {
          "Type": null,
          "Default": "1"
        },
        "ceil_mode": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "quantized_max_pool2d": {
      "Doc": "\nquantized_max_pool2d(input, kernel_size, stride=[], padding=0, dilation=1, ceil_mode=False) -> Tensor\n\nApplies a 2D max pooling over an input quantized tensor composed of several input planes.\n\nArguments:\n    input (Tensor): quantized tensor\n    kernel_size (``list of int``): the size of the sliding window\n    stride (``list of int``, optional): the stride of the sliding window\n    padding (``list of int``, optional): padding to be added on both sides, must be >= 0 and <= kernel_size / 2\n    dilation (``list of int``, optional): The stride between elements within a sliding window, must be > 0. Default 1\n    ceil_mode (bool, optional):  If True, will use ceil instead of floor to compute the output shape.\n        Defaults to False.\n\n\nReturns:\n    Tensor: A quantized tensor with max_pool2d applied.\n\nExample::\n\n    >>> qx = torch.quantize_per_tensor(torch.rand(2, 2, 2, 2), 1.5, 3, torch.quint8)\n    >>> torch.quantized_max_pool2d(qx, [2,2])\n    tensor([[[[1.5000]],\n\n            [[1.5000]]],\n\n\n            [[[0.0000]],\n\n            [[0.0000]]]], size=(2, 2, 1, 1), dtype=torch.quint8,\n        quantization_scheme=torch.per_tensor_affine, scale=1.5, zero_point=3)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "kernel_size": {
          "Type": null,
          "Default": null
        },
        "stride": {
          "Type": null,
          "Default": "[]"
        },
        "padding": {
          "Type": null,
          "Default": "0"
        },
        "dilation": {
          "Type": null,
          "Default": "1"
        },
        "ceil_mode": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "quantized_rnn_relu_cell": {
      "Doc": null,
      "Args": null
    },
    "quantized_rnn_tanh_cell": {
      "Doc": null,
      "Args": null
    },
    "rad2deg": {
      "Doc": "\nrad2deg(input, *, out=None) -> Tensor\n\nReturns a new tensor with each of the elements of :attr:`input`\nconverted from angles in radians to degrees.\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword arguments:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.tensor([[3.142, -3.142], [6.283, -6.283], [1.570, -1.570]])\n    >>> torch.rad2deg(a)\n    tensor([[ 180.0233, -180.0233],\n            [ 359.9894, -359.9894],\n            [  89.9544,  -89.9544]])\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "rand": {
      "Doc": "\nrand(*size, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False, pin_memory=False) -> Tensor\n\nReturns a tensor filled with random numbers from a uniform distribution\non the interval :math:`[0, 1)`\n\nThe shape of the tensor is defined by the variable argument :attr:`size`.\n\nArgs:\n    size (int...): a sequence of integers defining the shape of the output tensor.\n        Can be a variable number of arguments or a collection like a list or tuple.\n\nKeyword args:\n    generator (:class:`torch.Generator`, optional): a pseudorandom number generator for sampling\n    out (Tensor, optional): the output tensor.\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).\n    layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.\n        Default: ``torch.strided``.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n    pin_memory (bool, optional): If set, returned tensor would be allocated in\n        the pinned memory. Works only for CPU tensors. Default: ``False``.\n\nExample::\n\n    >>> torch.rand(4)\n    tensor([ 0.5204,  0.2503,  0.3525,  0.5673])\n    >>> torch.rand(2, 3)\n    tensor([[ 0.8237,  0.5781,  0.6879],\n            [ 0.3816,  0.7249,  0.0998]])\n",
      "Args": {
        "*size": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "torch.strided"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        },
        "pin_memory": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "rand_like": {
      "Doc": "\nrand_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor\n\nReturns a tensor with the same size as :attr:`input` that is filled with\nrandom numbers from a uniform distribution on the interval :math:`[0, 1)`.\n``torch.rand_like(input)`` is equivalent to\n``torch.rand(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.\n\nArgs:\n    input (Tensor): the size of :attr:`input` will determine size of the output tensor.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.\n        Default: if ``None``, defaults to the dtype of :attr:`input`.\n    layout (:class:`torch.layout`, optional): the desired layout of returned tensor.\n        Default: if ``None``, defaults to the layout of :attr:`input`.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, defaults to the device of :attr:`input`.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n    memory_format (:class:`torch.memory_format`, optional): the desired memory format of\n        returned Tensor. Default: ``torch.preserve_format``.\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "None"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        },
        "memory_format": {
          "Type": null,
          "Default": "torch.preserve_format"
        }
      }
    },
    "randint": {
      "Doc": "\nrandint(low=0, high, size, \\*, generator=None, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nReturns a tensor filled with random integers generated uniformly\nbetween :attr:`low` (inclusive) and :attr:`high` (exclusive).\n\nThe shape of the tensor is defined by the variable argument :attr:`size`.\n\n.. note::\n    With the global dtype default (``torch.float32``), this function returns\n    a tensor with dtype ``torch.int64``.\n\nArgs:\n    low (int, optional): Lowest integer to be drawn from the distribution. Default: 0.\n    high (int): One above the highest integer to be drawn from the distribution.\n    size (tuple): a tuple defining the shape of the output tensor.\n\nKeyword args:\n    generator (:class:`torch.Generator`, optional): a pseudorandom number generator for sampling\n    out (Tensor, optional): the output tensor.\n    dtype (`torch.dtype`, optional) - the desired data type of returned tensor. Default: if ``None``,\n        this function returns a tensor with dtype ``torch.int64``.\n    layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.\n        Default: ``torch.strided``.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n\nExample::\n\n    >>> torch.randint(3, 5, (3,))\n    tensor([4, 3, 4])\n\n\n    >>> torch.randint(10, (2, 2))\n    tensor([[0, 2],\n            [5, 5]])\n\n\n    >>> torch.randint(3, 10, (2, 2))\n    tensor([[4, 5],\n            [6, 7]])\n\n\n",
      "Args": {
        "low": {
          "Type": null,
          "Default": "0"
        },
        "high": {
          "Type": null,
          "Default": null
        },
        "size": {
          "Type": null,
          "Default": null
        },
        "\\*": {
          "Type": null,
          "Default": null
        },
        "generator": {
          "Type": null,
          "Default": "None"
        },
        "out": {
          "Type": null,
          "Default": "None"
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "torch.strided"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "randint_like": {
      "Doc": "\nrandint_like(input, low=0, high, \\*, dtype=None, layout=torch.strided, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor\n\nReturns a tensor with the same shape as Tensor :attr:`input` filled with\nrandom integers generated uniformly between :attr:`low` (inclusive) and\n:attr:`high` (exclusive).\n\n.. note:\n    With the global dtype default (``torch.float32``), this function returns\n    a tensor with dtype ``torch.int64``.\n\nArgs:\n    input (Tensor): the size of :attr:`input` will determine size of the output tensor.\n    low (int, optional): Lowest integer to be drawn from the distribution. Default: 0.\n    high (int): One above the highest integer to be drawn from the distribution.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.\n        Default: if ``None``, defaults to the dtype of :attr:`input`.\n    layout (:class:`torch.layout`, optional): the desired layout of returned tensor.\n        Default: if ``None``, defaults to the layout of :attr:`input`.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, defaults to the device of :attr:`input`.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n    memory_format (:class:`torch.memory_format`, optional): the desired memory format of\n        returned Tensor. Default: ``torch.preserve_format``.\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "low": {
          "Type": null,
          "Default": "0"
        },
        "high": {
          "Type": null,
          "Default": null
        },
        "\\*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "torch.strided"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        },
        "memory_format": {
          "Type": null,
          "Default": "torch.preserve_format"
        }
      }
    },
    "randn": {
      "Doc": "\nrandn(*size, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False, pin_memory=False) -> Tensor\n\n\nReturns a tensor filled with random numbers from a normal distribution\nwith mean `0` and variance `1` (also called the standard normal\ndistribution).\n\n.. math::\n    \\text{out}_{i} \\sim \\mathcal{N}(0, 1)\n\nThe shape of the tensor is defined by the variable argument :attr:`size`.\n\nArgs:\n    size (int...): a sequence of integers defining the shape of the output tensor.\n        Can be a variable number of arguments or a collection like a list or tuple.\n\nKeyword args:\n    generator (:class:`torch.Generator`, optional): a pseudorandom number generator for sampling\n    out (Tensor, optional): the output tensor.\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).\n    layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.\n        Default: ``torch.strided``.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n    pin_memory (bool, optional): If set, returned tensor would be allocated in\n        the pinned memory. Works only for CPU tensors. Default: ``False``.\n\nExample::\n\n    >>> torch.randn(4)\n    tensor([-2.1436,  0.9966,  2.3426, -0.6366])\n    >>> torch.randn(2, 3)\n    tensor([[ 1.5954,  2.8929, -1.0923],\n            [ 1.1719, -0.4709, -0.1996]])\n",
      "Args": {
        "*size": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "torch.strided"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        },
        "pin_memory": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "randn_like": {
      "Doc": "\nrandn_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor\n\nReturns a tensor with the same size as :attr:`input` that is filled with\nrandom numbers from a normal distribution with mean 0 and variance 1.\n``torch.randn_like(input)`` is equivalent to\n``torch.randn(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.\n\nArgs:\n    input (Tensor): the size of :attr:`input` will determine size of the output tensor.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.\n        Default: if ``None``, defaults to the dtype of :attr:`input`.\n    layout (:class:`torch.layout`, optional): the desired layout of returned tensor.\n        Default: if ``None``, defaults to the layout of :attr:`input`.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, defaults to the device of :attr:`input`.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n    memory_format (:class:`torch.memory_format`, optional): the desired memory format of\n        returned Tensor. Default: ``torch.preserve_format``.\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "None"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        },
        "memory_format": {
          "Type": null,
          "Default": "torch.preserve_format"
        }
      }
    },
    "randperm": {
      "Doc": "\nrandperm(n, *, generator=None, out=None, dtype=torch.int64,layout=torch.strided, device=None, requires_grad=False, pin_memory=False) -> Tensor\n\nReturns a random permutation of integers from ``0`` to ``n - 1``.\n\nArgs:\n    n (int): the upper bound (exclusive)\n\nKeyword args:\n    generator (:class:`torch.Generator`, optional): a pseudorandom number generator for sampling\n    out (Tensor, optional): the output tensor.\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: ``torch.int64``.\n    layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.\n        Default: ``torch.strided``.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n    pin_memory (bool, optional): If set, returned tensor would be allocated in\n        the pinned memory. Works only for CPU tensors. Default: ``False``.\n\nExample::\n\n    >>> torch.randperm(4)\n    tensor([2, 1, 0, 3])\n",
      "Args": {
        "n": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "generator": {
          "Type": null,
          "Default": "None"
        },
        "out": {
          "Type": null,
          "Default": "None"
        },
        "dtype": {
          "Type": null,
          "Default": "torch.int64"
        },
        "layout": {
          "Type": null,
          "Default": "torch.strided"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        },
        "pin_memory": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "range": {
      "Doc": "\nrange(start=0, end, step=1, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nReturns a 1-D tensor of size :math:`\\left\\lfloor \\frac{\\text{end} - \\text{start}}{\\text{step}} \\right\\rfloor + 1`\nwith values from :attr:`start` to :attr:`end` with step :attr:`step`. Step is\nthe gap between two values in the tensor.\n\n.. math::\n    \\text{out}_{i+1} = \\text{out}_i + \\text{step}.\n\n.. warning::\n    This function is deprecated and will be removed in a future release because its behavior is inconsistent with\n    Python's range builtin. Instead, use :func:`torch.arange`, which produces values in [start, end).\n\nArgs:\n    start (float): the starting value for the set of points. Default: ``0``.\n    end (float): the ending value for the set of points\n    step (float): the gap between each pair of adjacent points. Default: ``1``.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`). If `dtype` is not given, infer the data type from the other input\n        arguments. If any of `start`, `end`, or `stop` are floating-point, the\n        `dtype` is inferred to be the default dtype, see\n        :meth:`~torch.get_default_dtype`. Otherwise, the `dtype` is inferred to\n        be `torch.int64`.\n    layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.\n        Default: ``torch.strided``.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n\nExample::\n\n    >>> torch.range(1, 4)\n    tensor([ 1.,  2.,  3.,  4.])\n    >>> torch.range(1, 4, 0.5)\n    tensor([ 1.0000,  1.5000,  2.0000,  2.5000,  3.0000,  3.5000,  4.0000])\n",
      "Args": {
        "start": {
          "Type": null,
          "Default": "0"
        },
        "end": {
          "Type": null,
          "Default": null
        },
        "step": {
          "Type": null,
          "Default": "1"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "torch.strided"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "ravel": {
      "Doc": "\nravel(input) -> Tensor\n\nReturn a contiguous flattened tensor. A copy is made only if needed.\n\nArgs:\n    input (Tensor): the input tensor.\n\nExample::\n\n    >>> t = torch.tensor([[[1, 2],\n    ...                    [3, 4]],\n    ...                   [[5, 6],\n    ...                    [7, 8]]])\n    >>> torch.ravel(t)\n    tensor([1, 2, 3, 4, 5, 6, 7, 8])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "read_vitals": {
      "Doc": "read_vitals() -> str\n",
      "Args": null
    },
    "real": {
      "Doc": "\nreal(input) -> Tensor\n\nReturns a new tensor containing real values of the :attr:`self` tensor.\nThe returned tensor and :attr:`self` share the same underlying storage.\n\nArgs:\n    input (Tensor): the input tensor.\n\nExample::\n\n    >>> x=torch.randn(4, dtype=torch.cfloat)\n    >>> x\n    tensor([(0.3100+0.3553j), (-0.5445-0.7896j), (-1.6492-0.0633j), (-0.0638-0.8119j)])\n    >>> x.real\n    tensor([ 0.3100, -0.5445, -1.6492, -0.0638])\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "reciprocal": {
      "Doc": "\nreciprocal(input, *, out=None) -> Tensor\n\nReturns a new tensor with the reciprocal of the elements of :attr:`input`\n\n.. math::\n    \\text{out}_{i} = \\frac{1}{\\text{input}_{i}}\n\n.. note::\n    Unlike NumPy's reciprocal, torch.reciprocal supports integral inputs. Integral\n    inputs to reciprocal are automatically :ref:`promoted <type-promotion-doc>` to\n    the default scalar type.\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([-0.4595, -2.1219, -1.4314,  0.7298])\n    >>> torch.reciprocal(a)\n    tensor([-2.1763, -0.4713, -0.6986,  1.3702])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "relu": {
      "Doc": null,
      "Args": null
    },
    "remainder": {
      "Doc": "\nremainder(input, other, *, out=None) -> Tensor\n\nComputes\n`Python's modulus operation <https://docs.python.org/3/reference/expressions.html#binary-arithmetic-operations>`_\nentrywise.  The result has the same sign as the divisor :attr:`other` and its absolute value\nis less than that of :attr:`other`.\n\nIt may also be defined in terms of :func:`torch.div` as\n\n.. code:: python\n\n    torch.remainder(a, b) == a - a.div(b, rounding_mode=\"floor\") * b\n\nSupports :ref:`broadcasting to a common shape <broadcasting-semantics>`,\n:ref:`type promotion <type-promotion-doc>`, and integer and float inputs.\n\n.. note::\n    Complex inputs are not supported. In some cases, it is not mathematically\n    possible to satisfy the definition of a modulo operation with complex numbers.\n    See :func:`torch.fmod` for how division by zero is handled.\n\n.. seealso::\n\n    :func:`torch.fmod` which implements C++'s `std::fmod <https://en.cppreference.com/w/cpp/numeric/math/fmod>`_.\n    This one is defined in terms of division rounding towards zero.\n\nArgs:\n    input (Tensor or Scalar): the dividend\n    other (Tensor or Scalar): the divisor\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> torch.remainder(torch.tensor([-3., -2, -1, 1, 2, 3]), 2)\n    tensor([ 1.,  0.,  1.,  1.,  0.,  1.])\n    >>> torch.remainder(torch.tensor([1, 2, 3, 4, 5]), -1.5)\n    tensor([ -0.5000, -1.0000,  0.0000, -0.5000, -1.0000 ])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "renorm": {
      "Doc": "\nrenorm(input, p, dim, maxnorm, *, out=None) -> Tensor\n\nReturns a tensor where each sub-tensor of :attr:`input` along dimension\n:attr:`dim` is normalized such that the `p`-norm of the sub-tensor is lower\nthan the value :attr:`maxnorm`\n\n.. note:: If the norm of a row is lower than `maxnorm`, the row is unchanged\n\nArgs:\n    input (Tensor): the input tensor.\n    p (float): the power for the norm computation\n    dim (int): the dimension to slice over to get the sub-tensors\n    maxnorm (float): the maximum norm to keep each sub-tensor under\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> x = torch.ones(3, 3)\n    >>> x[1].fill_(2)\n    tensor([ 2.,  2.,  2.])\n    >>> x[2].fill_(3)\n    tensor([ 3.,  3.,  3.])\n    >>> x\n    tensor([[ 1.,  1.,  1.],\n            [ 2.,  2.,  2.],\n            [ 3.,  3.,  3.]])\n    >>> torch.renorm(x, 1, 0, 5)\n    tensor([[ 1.0000,  1.0000,  1.0000],\n            [ 1.6667,  1.6667,  1.6667],\n            [ 1.6667,  1.6667,  1.6667]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "p": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "maxnorm": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "repeat_interleave": {
      "Doc": "\nrepeat_interleave(input, repeats, dim=None, *, output_size=None) -> Tensor\n\nRepeat elements of a tensor.\n\n.. warning::\n\n    This is different from :meth:`torch.Tensor.repeat` but similar to ``numpy.repeat``.\n\nArgs:\n    input (Tensor): the input tensor.\n    repeats (Tensor or int): The number of repetitions for each element.\n        repeats is broadcasted to fit the shape of the given axis.\n    dim (int, optional): The dimension along which to repeat values.\n        By default, use the flattened input array, and return a flat output\n        array.\n\nKeyword args:\n    output_size (int, optional): Total output size for the given axis\n        ( e.g. sum of repeats). If given, it will avoid stream syncronization\n        needed to calculate output shape of the tensor.\n\nReturns:\n    Tensor: Repeated tensor which has the same shape as input, except along the given axis.\n\nExample::\n\n    >>> x = torch.tensor([1, 2, 3])\n    >>> x.repeat_interleave(2)\n    tensor([1, 1, 2, 2, 3, 3])\n    >>> y = torch.tensor([[1, 2], [3, 4]])\n    >>> torch.repeat_interleave(y, 2)\n    tensor([1, 1, 2, 2, 3, 3, 4, 4])\n    >>> torch.repeat_interleave(y, 3, dim=1)\n    tensor([[1, 1, 1, 2, 2, 2],\n            [3, 3, 3, 4, 4, 4]])\n    >>> torch.repeat_interleave(y, torch.tensor([1, 2]), dim=0)\n    tensor([[1, 2],\n            [3, 4],\n            [3, 4]])\n    >>> torch.repeat_interleave(y, torch.tensor([1, 2]), dim=0, output_size=3)\n    tensor([[1, 2],\n            [3, 4],\n            [3, 4]])\n\n.. function:: repeat_interleave(repeats, *, output_size=None) -> Tensor\n   :noindex:\n\nIf the `repeats` is `tensor([n1, n2, n3, ...])`, then the output will be\n`tensor([0, 0, ..., 1, 1, ..., 2, 2, ..., ...])` where `0` appears `n1` times,\n`1` appears `n2` times, `2` appears `n3` times, etc.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "repeats": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "None"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "output_size": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "reshape": {
      "Doc": "\nreshape(input, shape) -> Tensor\n\nReturns a tensor with the same data and number of elements as :attr:`input`,\nbut with the specified shape. When possible, the returned tensor will be a view\nof :attr:`input`. Otherwise, it will be a copy. Contiguous inputs and inputs\nwith compatible strides can be reshaped without copying, but you should not\ndepend on the copying vs. viewing behavior.\n\nSee :meth:`torch.Tensor.view` on when it is possible to return a view.\n\nA single dimension may be -1, in which case it's inferred from the remaining\ndimensions and the number of elements in :attr:`input`.\n\nArgs:\n    input (Tensor): the tensor to be reshaped\n    shape (tuple of int): the new shape\n\nExample::\n\n    >>> a = torch.arange(4.)\n    >>> torch.reshape(a, (2, 2))\n    tensor([[ 0.,  1.],\n            [ 2.,  3.]])\n    >>> b = torch.tensor([[0, 1], [2, 3]])\n    >>> torch.reshape(b, (-1,))\n    tensor([ 0,  1,  2,  3])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "shape": {
          "Type": null,
          "Default": null
        }
      }
    },
    "resolve_conj": {
      "Doc": "\nresolve_conj(input) -> Tensor\n\nReturns a new tensor with materialized conjugation if :attr:`input`'s conjugate bit is set to `True`,\nelse returns :attr:`input`. The output tensor will always have its conjugate bit set to `False`.\n\nArgs:\n    input (Tensor): the input tensor.\n\nExample::\n\n    >>> x = torch.tensor([-1 + 1j, -2 + 2j, 3 - 3j])\n    >>> y = x.conj()\n    >>> y.is_conj()\n    True\n    >>> z = y.resolve_conj()\n    >>> z\n    tensor([-1 - 1j, -2 - 2j, 3 + 3j])\n    >>> z.is_conj()\n    False\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "resolve_neg": {
      "Doc": "\nresolve_neg(input) -> Tensor\n\nReturns a new tensor with materialized negation if :attr:`input`'s negative bit is set to `True`,\nelse returns :attr:`input`. The output tensor will always have its negative bit set to `False`.\nArgs:\n    input (Tensor): the input tensor.\n\nExample::\n\n    >>> x = torch.tensor([-1 + 1j, -2 + 2j, 3 - 3j])\n    >>> y = x.conj()\n    >>> z = y.imag\n    >>> z.is_neg()\n    True\n    >>> out = y.resolve_neg()\n    >>> out\n    tensor([-1, -2, -3])\n    >>> out.is_neg()\n    False\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "result_type": {
      "Doc": "\nresult_type(tensor1, tensor2) -> dtype\n\nReturns the :class:`torch.dtype` that would result from performing an arithmetic\noperation on the provided input tensors. See type promotion :ref:`documentation <type-promotion-doc>`\nfor more information on the type promotion logic.\n\nArgs:\n    tensor1 (Tensor or Number): an input tensor or number\n    tensor2 (Tensor or Number): an input tensor or number\n\nExample::\n\n    >>> torch.result_type(torch.tensor([1, 2], dtype=torch.int), 1.0)\n    torch.float32\n    >>> torch.result_type(torch.tensor([1, 2], dtype=torch.uint8), torch.tensor(1))\n    torch.uint8\n",
      "Args": {
        "tensor1": {
          "Type": null,
          "Default": null
        },
        "tensor2": {
          "Type": null,
          "Default": null
        }
      }
    },
    "rnn_relu": {
      "Doc": null,
      "Args": null
    },
    "rnn_relu_cell": {
      "Doc": null,
      "Args": null
    },
    "rnn_tanh": {
      "Doc": null,
      "Args": null
    },
    "rnn_tanh_cell": {
      "Doc": null,
      "Args": null
    },
    "roll": {
      "Doc": "\nroll(input, shifts, dims=None) -> Tensor\n\nRoll the tensor :attr:`input` along the given dimension(s). Elements that are\nshifted beyond the last position are re-introduced at the first position. If\n:attr:`dims` is `None`, the tensor will be flattened before rolling and then\nrestored to the original shape.\n\nArgs:\n    input (Tensor): the input tensor.\n    shifts (int or tuple of ints): The number of places by which the elements\n        of the tensor are shifted. If shifts is a tuple, dims must be a tuple of\n        the same size, and each dimension will be rolled by the corresponding\n        value\n    dims (int or tuple of ints): Axis along which to roll\n\nExample::\n\n    >>> x = torch.tensor([1, 2, 3, 4, 5, 6, 7, 8]).view(4, 2)\n    >>> x\n    tensor([[1, 2],\n            [3, 4],\n            [5, 6],\n            [7, 8]])\n    >>> torch.roll(x, 1)\n    tensor([[8, 1],\n            [2, 3],\n            [4, 5],\n            [6, 7]])\n    >>> torch.roll(x, 1, 0)\n    tensor([[7, 8],\n            [1, 2],\n            [3, 4],\n            [5, 6]])\n    >>> torch.roll(x, -1, 0)\n    tensor([[3, 4],\n            [5, 6],\n            [7, 8],\n            [1, 2]])\n    >>> torch.roll(x, shifts=(2, 1), dims=(0, 1))\n    tensor([[6, 5],\n            [8, 7],\n            [2, 1],\n            [4, 3]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "shifts": {
          "Type": null,
          "Default": null
        },
        "dims": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "rot90": {
      "Doc": "\nrot90(input, k=1, dims=[0,1]) -> Tensor\n\nRotate a n-D tensor by 90 degrees in the plane specified by dims axis.\nRotation direction is from the first towards the second axis if k > 0, and from the second towards the first for k < 0.\n\nArgs:\n    input (Tensor): the input tensor.\n    k (int): number of times to rotate. Default value is 1\n    dims (a list or tuple): axis to rotate. Default value is [0, 1]\n\nExample::\n\n    >>> x = torch.arange(4).view(2, 2)\n    >>> x\n    tensor([[0, 1],\n            [2, 3]])\n    >>> torch.rot90(x, 1, [0, 1])\n    tensor([[1, 3],\n            [0, 2]])\n\n    >>> x = torch.arange(8).view(2, 2, 2)\n    >>> x\n    tensor([[[0, 1],\n             [2, 3]],\n\n            [[4, 5],\n             [6, 7]]])\n    >>> torch.rot90(x, 1, [1, 2])\n    tensor([[[1, 3],\n             [0, 2]],\n\n            [[5, 7],\n             [4, 6]]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "k": {
          "Type": null,
          "Default": "1"
        },
        "dims": {
          "Type": null,
          "Default": "[0"
        },
        "1]": {
          "Type": null,
          "Default": null
        }
      }
    },
    "round": {
      "Doc": "\nround(input, *, decimals=0, out=None) -> Tensor\n\nRounds elements of :attr:`input` to the nearest integer.\n\nFor integer inputs, follows the array-api convention of returning a\ncopy of the input tensor.\n\n.. note::\n    This function implements the \"round half to even\" to\n    break ties when a number is equidistant from two\n    integers (e.g. `round(2.5)` is 2).\n\n    When the :attr:\\`decimals\\` argument is specified the\n    algorithm used is similar to NumPy's `around`. This\n    algorithm is fast but inexact and it can easily\n    overflow for low precision dtypes.\n    Eg. `round(tensor([10000], dtype=torch.float16), decimals=3)` is `inf`.\n\n.. seealso::\n    :func:`torch.ceil`, which rounds up.\n    :func:`torch.floor`, which rounds down.\n    :func:`torch.trunc`, which rounds towards zero.\n\nArgs:\n    input (Tensor): the input tensor.\n    decimals (int): Number of decimal places to round to (default: 0).\n        If decimals is negative, it specifies the number of positions\n        to the left of the decimal point.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> torch.round(torch.tensor((4.7, -2.3, 9.1, -7.7)))\n    tensor([ 5.,  -2.,  9., -8.])\n\n    >>> # Values equidistant from two integers are rounded towards the\n    >>> #   the nearest even value (zero is treated as even)\n    >>> torch.round(torch.tensor([-0.5, 0.5, 1.5, 2.5]))\n    tensor([-0., 0., 2., 2.])\n\n    >>> # A positive decimals argument rounds to the to that decimal place\n    >>> torch.round(torch.tensor([0.1234567]), decimals=3)\n    tensor([0.1230])\n\n    >>> # A negative decimals argument rounds to the left of the decimal\n    >>> torch.round(torch.tensor([1200.1234567]), decimals=-3)\n    tensor([1000.])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "decimals": {
          "Type": null,
          "Default": "0"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "row_indices_copy": {
      "Doc": null,
      "Args": null
    },
    "row_stack": {
      "Doc": "\nrow_stack(tensors, *, out=None) -> Tensor\n\nAlias of :func:`torch.vstack`.\n",
      "Args": {
        "tensors": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "rrelu": {
      "Doc": null,
      "Args": null
    },
    "rsqrt": {
      "Doc": "\nrsqrt(input, *, out=None) -> Tensor\n\nReturns a new tensor with the reciprocal of the square-root of each of\nthe elements of :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\frac{1}{\\sqrt{\\text{input}_{i}}}\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([-0.0370,  0.2970,  1.5420, -0.9105])\n    >>> torch.rsqrt(a)\n    tensor([    nan,  1.8351,  0.8053,     nan])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "rsub": {
      "Doc": null,
      "Args": null
    },
    "saddmm": {
      "Doc": null,
      "Args": null
    },
    "save": {
      "Doc": "save(obj, f, pickle_module=pickle, pickle_protocol=DEFAULT_PROTOCOL, _use_new_zipfile_serialization=True)\n\n    Saves an object to a disk file.\n\n    See also: :ref:`saving-loading-tensors`\n\n    Args:\n        obj: saved object\n        f: a file-like object (has to implement write and flush) or a string or\n           os.PathLike object containing a file name\n        pickle_module: module used for pickling metadata and objects\n        pickle_protocol: can be specified to override the default protocol\n\n    .. note::\n        A common PyTorch convention is to save tensors using .pt file extension.\n\n    .. note::\n        PyTorch preserves storage sharing across serialization. See\n        :ref:`preserve-storage-sharing` for more details.\n\n    .. note::\n        The 1.6 release of PyTorch switched ``torch.save`` to use a new\n        zipfile-based file format. ``torch.load`` still retains the ability to\n        load files in the old format. If for any reason you want ``torch.save``\n        to use the old format, pass the kwarg ``_use_new_zipfile_serialization=False``.\n\n    Example:\n        >>> # Save to file\n        >>> x = torch.tensor([0, 1, 2, 3, 4])\n        >>> torch.save(x, 'tensor.pt')\n        >>> # Save to io.BytesIO buffer\n        >>> buffer = io.BytesIO()\n        >>> torch.save(x, buffer)\n    ",
      "Args": {
        "obj": {
          "Type": "<class 'object'>",
          "Default": null
        },
        "f": {
          "Type": "typing.Union[str, os.PathLike, typing.BinaryIO, typing.IO[bytes]]",
          "Default": null
        },
        "pickle_module": {
          "Type": "typing.Any",
          "Default": "<module 'pickle' from 'c:\\\\Users\\\\kozlo\\\\anaconda3\\\\lib\\\\pickle.py'>"
        },
        "pickle_protocol": {
          "Type": "<class 'int'>",
          "Default": "2"
        },
        "_use_new_zipfile_serialization": {
          "Type": "<class 'bool'>",
          "Default": "True"
        }
      }
    },
    "scalar_tensor": {
      "Doc": null,
      "Args": null
    },
    "scatter": {
      "Doc": "\nscatter(input, dim, index, src) -> Tensor\n\nOut-of-place version of :meth:`torch.Tensor.scatter_`\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "index": {
          "Type": null,
          "Default": null
        },
        "src": {
          "Type": null,
          "Default": null
        }
      }
    },
    "scatter_add": {
      "Doc": "\nscatter_add(input, dim, index, src) -> Tensor\n\nOut-of-place version of :meth:`torch.Tensor.scatter_add_`\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "index": {
          "Type": null,
          "Default": null
        },
        "src": {
          "Type": null,
          "Default": null
        }
      }
    },
    "scatter_reduce": {
      "Doc": "\nscatter_reduce(input, dim, index, src, reduce, *, include_self=True) -> Tensor\n\nOut-of-place version of :meth:`torch.Tensor.scatter_reduce_`\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "index": {
          "Type": null,
          "Default": null
        },
        "src": {
          "Type": null,
          "Default": null
        },
        "reduce": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "include_self": {
          "Type": null,
          "Default": "True"
        }
      }
    },
    "searchsorted": {
      "Doc": "\nsearchsorted(sorted_sequence, values, *, out_int32=False, right=False, side='left', out=None, sorter=None) -> Tensor\n\nFind the indices from the *innermost* dimension of :attr:`sorted_sequence` such that, if the\ncorresponding values in :attr:`values` were inserted before the indices, when sorted, the order\nof the corresponding *innermost* dimension within :attr:`sorted_sequence` would be preserved.\nReturn a new tensor with the same size as :attr:`values`. If :attr:`right` is False or side is\n'left (default), then the left boundary of :attr:`sorted_sequence` is closed. More formally,\nthe returned index satisfies the following rules:\n\n.. list-table::\n   :widths: 12 10 78\n   :header-rows: 1\n\n   * - :attr:`sorted_sequence`\n     - :attr:`right`\n     - *returned index satisfies*\n   * - 1-D\n     - False\n     - ``sorted_sequence[i-1] < values[m][n]...[l][x] <= sorted_sequence[i]``\n   * - 1-D\n     - True\n     - ``sorted_sequence[i-1] <= values[m][n]...[l][x] < sorted_sequence[i]``\n   * - N-D\n     - False\n     - ``sorted_sequence[m][n]...[l][i-1] < values[m][n]...[l][x] <= sorted_sequence[m][n]...[l][i]``\n   * - N-D\n     - True\n     - ``sorted_sequence[m][n]...[l][i-1] <= values[m][n]...[l][x] < sorted_sequence[m][n]...[l][i]``\n\nArgs:\n    sorted_sequence (Tensor): N-D or 1-D tensor, containing monotonically increasing sequence on the *innermost*\n                              dimension unless :attr:`sorter` is provided, in which case the sequence does not\n                              need to be sorted\n    values (Tensor or Scalar): N-D tensor or a Scalar containing the search value(s).\n\nKeyword args:\n    out_int32 (bool, optional): indicate the output data type. torch.int32 if True, torch.int64 otherwise.\n                                Default value is False, i.e. default output data type is torch.int64.\n    right (bool, optional): if False, return the first suitable location that is found. If True, return the\n                            last such index. If no suitable index found, return 0 for non-numerical value\n                            (eg. nan, inf) or the size of *innermost* dimension within :attr:`sorted_sequence`\n                            (one pass the last index of the *innermost* dimension). In other words, if False,\n                            gets the lower bound index for each value in :attr:`values` on the corresponding\n                            *innermost* dimension of the :attr:`sorted_sequence`. If True, gets the upper\n                            bound index instead. Default value is False. :attr:`side` does the same and is\n                            preferred. It will error if :attr:`side` is set to \"left\" while this is True.\n    side (str, optional): the same as :attr:`right` but preferred. \"left\" corresponds to False for :attr:`right`\n                            and \"right\" corresponds to True for :attr:`right`. It will error if this is set to\n                            \"left\" while :attr:`right` is True.\n    out (Tensor, optional): the output tensor, must be the same size as :attr:`values` if provided.\n    sorter (LongTensor, optional): if provided, a tensor matching the shape of the unsorted\n                            :attr:`sorted_sequence` containing a sequence of indices that sort it in the\n                            ascending order on the innermost dimension\n\n\nExample::\n\n    >>> sorted_sequence = torch.tensor([[1, 3, 5, 7, 9], [2, 4, 6, 8, 10]])\n    >>> sorted_sequence\n    tensor([[ 1,  3,  5,  7,  9],\n            [ 2,  4,  6,  8, 10]])\n    >>> values = torch.tensor([[3, 6, 9], [3, 6, 9]])\n    >>> values\n    tensor([[3, 6, 9],\n            [3, 6, 9]])\n    >>> torch.searchsorted(sorted_sequence, values)\n    tensor([[1, 3, 4],\n            [1, 2, 4]])\n    >>> torch.searchsorted(sorted_sequence, values, side='right')\n    tensor([[2, 3, 5],\n            [1, 3, 4]])\n\n    >>> sorted_sequence_1d = torch.tensor([1, 3, 5, 7, 9])\n    >>> sorted_sequence_1d\n    tensor([1, 3, 5, 7, 9])\n    >>> torch.searchsorted(sorted_sequence_1d, values)\n    tensor([[1, 3, 4],\n            [1, 3, 4]])\n",
      "Args": {
        "sorted_sequence": {
          "Type": null,
          "Default": null
        },
        "values": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out_int32": {
          "Type": null,
          "Default": "False"
        },
        "right": {
          "Type": null,
          "Default": "False"
        },
        "side": {
          "Type": null,
          "Default": "'left'"
        },
        "out": {
          "Type": null,
          "Default": "None"
        },
        "sorter": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "seed": {
      "Doc": "Sets the seed for generating random numbers to a non-deterministic\n    random number. Returns a 64 bit number used to seed the RNG.\n    ",
      "Args": {}
    },
    "segment_reduce": {
      "Doc": null,
      "Args": null
    },
    "select": {
      "Doc": "\nselect(input, dim, index) -> Tensor\n\nSlices the :attr:`input` tensor along the selected dimension at the given index.\nThis function returns a view of the original tensor with the given dimension removed.\n\nArgs:\n    input (Tensor): the input tensor.\n    dim (int): the dimension to slice\n    index (int): the index to select with\n\n.. note::\n\n    :meth:`select` is equivalent to slicing. For example,\n    ``tensor.select(0, index)`` is equivalent to ``tensor[index]`` and\n    ``tensor.select(2, index)`` is equivalent to ``tensor[:,:,index]``.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "index": {
          "Type": null,
          "Default": null
        }
      }
    },
    "select_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.select`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "select_scatter": {
      "Doc": "\nselect_scatter(input, src, dim, index) -> Tensor\n\nEmbeds the values of the :attr:`src` tensor into :attr:`input` at the given index.\nThis function returns a tensor with fresh storage; it does not create a view.\n\n\nArgs:\n    input (Tensor): the input tensor.\n    src (Tensor): The tensor to embed into :attr:`input`\n    dim (int): the dimension to insert the slice into.\n    index (int): the index to select with\n\n.. note::\n\n    :attr:`src` must be of the proper size in order to be embedded\n    into :attr:`input`. Specifically, it should have the same shape as\n    ``torch.select(input, dim, index)``\n\nExample::\n\n    >>> a = torch.zeros(2, 2)\n    >>> b = torch.ones(2)\n    >>> a.select_scatter(b, 0, 0)\n    tensor([[1., 1.],\n            [0., 0.]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "src": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "index": {
          "Type": null,
          "Default": null
        }
      }
    },
    "selu": {
      "Doc": null,
      "Args": null
    },
    "set_anomaly_enabled": {
      "Doc": null,
      "Args": null
    },
    "set_autocast_cache_enabled": {
      "Doc": null,
      "Args": null
    },
    "set_autocast_cpu_dtype": {
      "Doc": null,
      "Args": null
    },
    "set_autocast_cpu_enabled": {
      "Doc": null,
      "Args": null
    },
    "set_autocast_enabled": {
      "Doc": null,
      "Args": null
    },
    "set_autocast_gpu_dtype": {
      "Doc": null,
      "Args": null
    },
    "set_default_dtype": {
      "Doc": "\n\n    Sets the default floating point dtype to :attr:`d`. Supports torch.float32\n    and torch.float64 as inputs. Other dtypes may be accepted without complaint\n    but are not supported and are unlikely to work as expected.\n\n    When PyTorch is initialized its default floating point dtype is torch.float32,\n    and the intent of set_default_dtype(torch.float64) is to facilitate NumPy-like\n    type inference. The default floating point dtype is used to:\n\n    1. Implicitly determine the default complex dtype. When the default floating point\n       type is float32 the default complex dtype is complex64, and when the default\n       floating point type is float64 the default complex type is complex128.\n    2. Infer the dtype for tensors constructed using Python floats or complex Python\n       numbers. See examples below.\n    3. Determine the result of type promotion between bool and integer tensors and\n       Python floats and complex Python numbers.\n\n    Args:\n        d (:class:`torch.dtype`): the floating point dtype to make the default.\n                                  Either torch.float32 or torch.float64.\n\n    Example:\n        >>> # xdoctest: +SKIP(\"Other tests may have changed the default type. Can we reset it?\")\n        >>> # initial default for floating point is torch.float32\n        >>> # Python floats are interpreted as float32\n        >>> torch.tensor([1.2, 3]).dtype\n        torch.float32\n        >>> # initial default for floating point is torch.complex64\n        >>> # Complex Python numbers are interpreted as complex64\n        >>> torch.tensor([1.2, 3j]).dtype\n        torch.complex64\n\n        >>> torch.set_default_dtype(torch.float64)\n\n        >>> # Python floats are now interpreted as float64\n        >>> torch.tensor([1.2, 3]).dtype    # a new floating point tensor\n        torch.float64\n        >>> # Complex Python numbers are now interpreted as complex128\n        >>> torch.tensor([1.2, 3j]).dtype   # a new complex tensor\n        torch.complex128\n\n    ",
      "Args": {
        "d": {
          "Type": null,
          "Default": null
        }
      }
    },
    "set_default_tensor_type": {
      "Doc": "Sets the default ``torch.Tensor`` type to floating point tensor type\n    ``t``. This type will also be used as default floating point type for\n    type inference in :func:`torch.tensor`.\n\n    The default floating point tensor type is initially ``torch.FloatTensor``.\n\n    Args:\n        t (type or string): the floating point tensor type or its name\n\n    Example::\n\n        >>> # xdoctest: +SKIP(\"Other tests may have changed the default type. Can we reset it?\")\n        >>> torch.tensor([1.2, 3]).dtype    # initial default for floating point is torch.float32\n        torch.float32\n        >>> torch.set_default_tensor_type(torch.DoubleTensor)\n        >>> torch.tensor([1.2, 3]).dtype    # a new floating point tensor\n        torch.float64\n\n    ",
      "Args": {
        "t": {
          "Type": null,
          "Default": null
        }
      }
    },
    "set_deterministic_debug_mode": {
      "Doc": "Sets the debug mode for deterministic operations.\n\n    .. note:: This is an alternative interface for\n        :func:`torch.use_deterministic_algorithms`. Refer to that function's\n        documentation for details about affected operations.\n\n    Args:\n        debug_mode(str or int): If \"default\" or 0, don't error or warn on\n            nondeterministic operations. If \"warn\" or 1, warn on\n            nondeterministic operations. If \"error\" or 2, error on\n            nondeterministic operations.\n    ",
      "Args": {
        "debug_mode": {
          "Type": "typing.Union[int, str]",
          "Default": null
        }
      }
    },
    "set_float32_matmul_precision": {
      "Doc": "Sets the internal precision of float32 matrix multiplications.\n\n    Running float32 matrix multiplications in lower precision may significantly increase\n    performance, and in some programs the loss of precision has a negligible impact.\n\n    Supports three settings:\n\n        * \"highest\", float32 matrix multiplications use the float32 datatype for\n          internal computations.\n        * \"high\", float32 matrix multiplications use the TensorFloat32 or bfloat16_3x\n          datatypes for internal computations, if fast matrix multiplication algorithms\n          using those datatypes internally are available. Otherwise float32\n          matrix multiplications are computed as if the precision is \"highest\".\n        * \"medium\", float32 matrix multiplications use the bfloat16 datatype for\n          internal computations, if a fast matrix multiplication algorithm\n          using that datatype internally is available. Otherwise float32\n          matrix multiplications are computed as if the precision is \"high\".\n\n    .. note::\n\n        This does not change the output dtype of float32 matrix multiplications,\n        it controls how the internal computation of the matrix multiplication is performed.\n\n    .. note::\n\n        This does not change the precision of convolution operations. Other flags,\n        like `torch.backends.cudnn.allow_tf32`, may control the precision of convolution\n        operations.\n\n    .. note::\n\n        This flag currently only affects one native device type: CUDA.\n        If \"high\" or \"medium\" are set then the TensorFloat32 datatype will be used\n        when computing float32 matrix multiplications, equivalent to setting\n        `torch.backends.cuda.matmul.allow_tf32 = True`. When \"highest\" (the default)\n        is set then the float32 datatype is used for internal computations, equivalent\n        to setting `torch.backends.cuda.matmul.allow_tf32 = False`.\n\n    Args:\n        precision(str): can be set to \"highest\" (default), \"high\", or \"medium\" (see above).\n\n    ",
      "Args": {
        "precision": {
          "Type": null,
          "Default": null
        }
      }
    },
    "set_flush_denormal": {
      "Doc": "\nset_flush_denormal(mode) -> bool\n\nDisables denormal floating numbers on CPU.\n\nReturns ``True`` if your system supports flushing denormal numbers and it\nsuccessfully configures flush denormal mode.  :meth:`~torch.set_flush_denormal`\nis only supported on x86 architectures supporting SSE3.\n\nArgs:\n    mode (bool): Controls whether to enable flush denormal mode or not\n\nExample::\n\n    >>> torch.set_flush_denormal(True)\n    True\n    >>> torch.tensor([1e-323], dtype=torch.float64)\n    tensor([ 0.], dtype=torch.float64)\n    >>> torch.set_flush_denormal(False)\n    True\n    >>> torch.tensor([1e-323], dtype=torch.float64)\n    tensor(9.88131e-324 *\n           [ 1.0000], dtype=torch.float64)\n",
      "Args": {
        "mode": {
          "Type": null,
          "Default": null
        }
      }
    },
    "set_num_interop_threads": {
      "Doc": "\nset_num_interop_threads(int)\n\nSets the number of threads used for interop parallelism\n(e.g. in JIT interpreter) on CPU.\n\n.. warning::\n    Can only be called once and before any inter-op parallel work\n    is started (e.g. JIT execution).\n",
      "Args": {
        "int": {
          "Type": null,
          "Default": null
        }
      }
    },
    "set_num_threads": {
      "Doc": "\nset_num_threads(int)\n\nSets the number of threads used for intraop parallelism on CPU.\n\n.. warning::\n    To ensure that the correct number of threads is used, set_num_threads\n    must be called before running eager, JIT or autograd code.\n",
      "Args": {
        "int": {
          "Type": null,
          "Default": null
        }
      }
    },
    "set_printoptions": {
      "Doc": "Set options for printing. Items shamelessly taken from NumPy\n\n    Args:\n        precision: Number of digits of precision for floating point output\n            (default = 4).\n        threshold: Total number of array elements which trigger summarization\n            rather than full `repr` (default = 1000).\n        edgeitems: Number of array items in summary at beginning and end of\n            each dimension (default = 3).\n        linewidth: The number of characters per line for the purpose of\n            inserting line breaks (default = 80). Thresholded matrices will\n            ignore this parameter.\n        profile: Sane defaults for pretty printing. Can override with any of\n            the above options. (any one of `default`, `short`, `full`)\n        sci_mode: Enable (True) or disable (False) scientific notation. If\n            None (default) is specified, the value is defined by\n            `torch._tensor_str._Formatter`. This value is automatically chosen\n            by the framework.\n\n    Example::\n\n        >>> # Limit the precision of elements\n        >>> torch.set_printoptions(precision=2)\n        >>> torch.tensor([1.12345])\n        tensor([1.12])\n        >>> # Limit the number of elements shown\n        >>> torch.set_printoptions(threshold=5)\n        >>> torch.arange(10)\n        tensor([0, 1, 2, ..., 7, 8, 9])\n        >>> # Restore defaults\n        >>> torch.set_printoptions(profile='default')\n        >>> torch.tensor([1.12345])\n        tensor([1.1235])\n        >>> torch.arange(10)\n        tensor([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    ",
      "Args": {
        "precision": {
          "Type": null,
          "Default": "None"
        },
        "threshold": {
          "Type": null,
          "Default": "None"
        },
        "edgeitems": {
          "Type": null,
          "Default": "None"
        },
        "linewidth": {
          "Type": null,
          "Default": "None"
        },
        "profile": {
          "Type": null,
          "Default": "None"
        },
        "sci_mode": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "set_rng_state": {
      "Doc": "Sets the random number generator state.\n\n    .. note: This function only works for CPU. For CUDA, please use\n             torch.manual_seed(seed), which works for both CPU and CUDA.\n\n    Args:\n        new_state (torch.ByteTensor): The desired state\n    ",
      "Args": {
        "new_state": {
          "Type": "<class 'torch.Tensor'>",
          "Default": null
        }
      }
    },
    "set_vital": {
      "Doc": "set_vital(arg0: str, arg1: str, arg2: str) -> bool\n",
      "Args": {
        "arg0": {
          "Type": "str",
          "Default": null
        },
        "arg1": {
          "Type": "str",
          "Default": null
        },
        "arg2": {
          "Type": "str",
          "Default": null
        }
      }
    },
    "set_warn_always": {
      "Doc": "When this flag is False (default) then some PyTorch warnings may only\n    appear once per process. This helps avoid excessive warning information.\n    Setting it to True causes these warnings to always appear, which may be\n    helpful when debugging.\n\n    Args:\n        b (:class:`bool`): If True, force warnings to always be emitted\n                           If False, set to the default behaviour\n    ",
      "Args": {
        "b": {
          "Type": null,
          "Default": null
        }
      }
    },
    "sgn": {
      "Doc": "\nsgn(input, *, out=None) -> Tensor\n\nThis function is an extension of torch.sign() to complex tensors.\nIt computes a new tensor whose elements have\nthe same angles as the corresponding elements of :attr:`input` and\nabsolute values (i.e. magnitudes) of one for complex tensors and\nis equivalent to torch.sign() for non-complex tensors.\n\n.. math::\n    \\text{out}_{i} = \\begin{cases}\n                    0 & |\\text{{input}}_i| == 0 \\\\\n                    \\frac{{\\text{{input}}_i}}{|{\\text{{input}}_i}|} & \\text{otherwise}\n                    \\end{cases}\n\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n  out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> t = torch.tensor([3+4j, 7-24j, 0, 1+2j])\n    >>> t.sgn()\n    tensor([0.6000+0.8000j, 0.2800-0.9600j, 0.0000+0.0000j, 0.4472+0.8944j])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "sigmoid": {
      "Doc": "\nsigmoid(input, *, out=None) -> Tensor\n\nAlias for :func:`torch.special.expit`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "sign": {
      "Doc": "\nsign(input, *, out=None) -> Tensor\n\nReturns a new tensor with the signs of the elements of :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\operatorname{sgn}(\\text{input}_{i})\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.tensor([0.7, -1.2, 0., 2.3])\n    >>> a\n    tensor([ 0.7000, -1.2000,  0.0000,  2.3000])\n    >>> torch.sign(a)\n    tensor([ 1., -1.,  0.,  1.])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "signbit": {
      "Doc": "\nsignbit(input, *, out=None) -> Tensor\n\nTests if each element of :attr:`input` has its sign bit set or not.\n\nArgs:\n  input (Tensor): the input tensor.\n\nKeyword args:\n  out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.tensor([0.7, -1.2, 0., 2.3])\n    >>> torch.signbit(a)\n    tensor([ False, True,  False,  False])\n    >>> a = torch.tensor([-0.0, 0.0])\n    >>> torch.signbit(a)\n    tensor([ True,  False])\n\n.. note::\n    signbit handles signed zeros, so negative zero (-0) returns True.\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "sin": {
      "Doc": "\nsin(input, *, out=None) -> Tensor\n\nReturns a new tensor with the sine of the elements of :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\sin(\\text{input}_{i})\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([-0.5461,  0.1347, -2.7266, -0.2746])\n    >>> torch.sin(a)\n    tensor([-0.5194,  0.1343, -0.4032, -0.2711])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "sinc": {
      "Doc": "\nsinc(input, *, out=None) -> Tensor\n\nAlias for :func:`torch.special.sinc`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "sinh": {
      "Doc": "\nsinh(input, *, out=None) -> Tensor\n\nReturns a new tensor with the hyperbolic sine of the elements of\n:attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\sinh(\\text{input}_{i})\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 0.5380, -0.8632, -0.1265,  0.9399])\n    >>> torch.sinh(a)\n    tensor([ 0.5644, -0.9744, -0.1268,  1.0845])\n\n.. note::\n   When :attr:`input` is on the CPU, the implementation of torch.sinh may use\n   the Sleef library, which rounds very large results to infinity or negative\n   infinity. See `here <https://sleef.org/purec.xhtml>`_ for details.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "slice_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.slice`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "slice_scatter": {
      "Doc": "\nslice_scatter(input, src, dim=0, start=None, end=None, step=1) -> Tensor\n\nEmbeds the values of the :attr:`src` tensor into :attr:`input` at the given\ndimension.\nThis function returns a tensor with fresh storage; it does not create a view.\n\n\nArgs:\n    input (Tensor): the input tensor.\n    src (Tensor): The tensor to embed into :attr:`input`\n    dim (int): the dimension to insert the slice into\n    start (Optional[int]): the start index of where to insert the slice\n    end (Optional[int]): the end index of where to insert the slice\n    step (int): the how many elements to skip in\n\nExample::\n\n    >>> a = torch.zeros(8, 8)\n    >>> b = torch.ones(8)\n    >>> a.slice_scatter(b, start=6)\n    tensor([[0., 0., 0., 0., 0., 0., 0., 0.],\n            [0., 0., 0., 0., 0., 0., 0., 0.],\n            [0., 0., 0., 0., 0., 0., 0., 0.],\n            [0., 0., 0., 0., 0., 0., 0., 0.],\n            [0., 0., 0., 0., 0., 0., 0., 0.],\n            [0., 0., 0., 0., 0., 0., 0., 0.],\n            [1., 1., 1., 1., 1., 1., 1., 1.],\n            [1., 1., 1., 1., 1., 1., 1., 1.]])\n\n    >>> b = torch.ones(2)\n    >>> a.slice_scatter(b, dim=1, start=2, end=6, step=2)\n    tensor([[0., 0., 1., 0., 1., 0., 0., 0.],\n            [0., 0., 1., 0., 1., 0., 0., 0.],\n            [0., 0., 1., 0., 1., 0., 0., 0.],\n            [0., 0., 1., 0., 1., 0., 0., 0.],\n            [0., 0., 1., 0., 1., 0., 0., 0.],\n            [0., 0., 1., 0., 1., 0., 0., 0.],\n            [0., 0., 1., 0., 1., 0., 0., 0.],\n            [0., 0., 1., 0., 1., 0., 0., 0.]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "src": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "0"
        },
        "start": {
          "Type": null,
          "Default": "None"
        },
        "end": {
          "Type": null,
          "Default": "None"
        },
        "step": {
          "Type": null,
          "Default": "1"
        }
      }
    },
    "slogdet": {
      "Doc": "\nslogdet(input) -> (Tensor, Tensor)\n\nAlias for :func:`torch.linalg.slogdet`\n",
      "Args": {
        "input) -> (Tensor": {
          "Type": null,
          "Default": null
        },
        "Tensor": {
          "Type": null,
          "Default": null
        }
      }
    },
    "smm": {
      "Doc": "\nsmm(input, mat) -> Tensor\n\nPerforms a matrix multiplication of the sparse matrix :attr:`input`\nwith the dense matrix :attr:`mat`.\n\nArgs:\n    input (Tensor): a sparse matrix to be matrix multiplied\n    mat (Tensor): a dense matrix to be matrix multiplied\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "mat": {
          "Type": null,
          "Default": null
        }
      }
    },
    "softmax": {
      "Doc": null,
      "Args": null
    },
    "solve": {
      "Doc": null,
      "Args": {
        "input": {
          "Type": "<class 'torch.Tensor'>",
          "Default": null
        },
        "A": {
          "Type": "<class 'torch.Tensor'>",
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "sort": {
      "Doc": "\nsort(input, dim=-1, descending=False, stable=False, *, out=None) -> (Tensor, LongTensor)\n\nSorts the elements of the :attr:`input` tensor along a given dimension\nin ascending order by value.\n\nIf :attr:`dim` is not given, the last dimension of the `input` is chosen.\n\nIf :attr:`descending` is ``True`` then the elements are sorted in descending\norder by value.\n\nIf :attr:`stable` is ``True`` then the sorting routine becomes stable, preserving\nthe order of equivalent elements.\n\nA namedtuple of (values, indices) is returned, where the `values` are the\nsorted values and `indices` are the indices of the elements in the original\n`input` tensor.\n\nArgs:\n    input (Tensor): the input tensor.\n    dim (int, optional): the dimension to sort along\n    descending (bool, optional): controls the sorting order (ascending or descending)\n    stable (bool, optional): makes the sorting routine stable, which guarantees that the order\n       of equivalent elements is preserved.\n\nKeyword args:\n    out (tuple, optional): the output tuple of (`Tensor`, `LongTensor`) that can\n        be optionally given to be used as output buffers\n\nExample::\n\n    >>> x = torch.randn(3, 4)\n    >>> sorted, indices = torch.sort(x)\n    >>> sorted\n    tensor([[-0.2162,  0.0608,  0.6719,  2.3332],\n            [-0.5793,  0.0061,  0.6058,  0.9497],\n            [-0.5071,  0.3343,  0.9553,  1.0960]])\n    >>> indices\n    tensor([[ 1,  0,  2,  3],\n            [ 3,  1,  0,  2],\n            [ 0,  3,  1,  2]])\n\n    >>> sorted, indices = torch.sort(x, 0)\n    >>> sorted\n    tensor([[-0.5071, -0.2162,  0.6719, -0.5793],\n            [ 0.0608,  0.0061,  0.9497,  0.3343],\n            [ 0.6058,  0.9553,  1.0960,  2.3332]])\n    >>> indices\n    tensor([[ 2,  0,  0,  1],\n            [ 0,  1,  1,  2],\n            [ 1,  2,  2,  0]])\n    >>> x = torch.tensor([0, 1] * 9)\n    >>> x.sort()\n    torch.return_types.sort(\n        values=tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1]),\n        indices=tensor([ 2, 16,  4,  6, 14,  8,  0, 10, 12,  9, 17, 15, 13, 11,  7,  5,  3,  1]))\n    >>> x.sort(stable=True)\n    torch.return_types.sort(\n        values=tensor([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1]),\n        indices=tensor([ 0,  2,  4,  6,  8, 10, 12, 14, 16,  1,  3,  5,  7,  9, 11, 13, 15, 17]))\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "-1"
        },
        "descending": {
          "Type": null,
          "Default": "False"
        },
        "stable": {
          "Type": null,
          "Default": "False"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None) -> (Tensor"
        },
        "LongTensor": {
          "Type": null,
          "Default": null
        }
      }
    },
    "sparse_bsc_tensor": {
      "Doc": "\nsparse_bsc_tensor(ccol_indices, row_indices, values, size=None, *, dtype=None, device=None, requires_grad=False) -> Tensor\n\nConstructs a :ref:`sparse tensor in BSC (Block Compressed Sparse\nColumn)) <sparse-bsc-docs>` with specified 2-dimensional blocks at the\ngiven :attr:`ccol_indices` and :attr:`row_indices`. Sparse matrix\nmultiplication operations in BSC format are typically faster than that\nfor sparse tensors in COO format. Make you have a look at :ref:`the\nnote on the data type of the indices <sparse-bsc-docs>`.\n\nArgs:\n    ccol_indices (array_like): (B+1)-dimensional array of size\n        ``(*batchsize, ncolblocks + 1)``. The last element of each\n        batch is the number of non-zeros. This tensor encodes the\n        index in values and row_indices depending on where the given\n        column starts. Each successive number in the tensor subtracted\n        by the number before it denotes the number of elements in a\n        given column.\n    row_indices (array_like): Row block co-ordinates of each block in\n        values. (B+1)-dimensional tensor with the same length\n        as values.\n    values (array_list): Initial blocks for the tensor. Can be a list,\n        tuple, NumPy ``ndarray``, and other types that\n        represents a (1 + 2 + K)-dimensonal tensor where ``K`` is the\n        number of dense dimensions.\n    size (list, tuple, :class:`torch.Size`, optional): Size of the\n        sparse tensor: ``(*batchsize, nrows * blocksize[0], ncols *\n        blocksize[1], *densesize)`` If not provided, the size will be\n        inferred as the minimum size big enough to hold all non-zero\n        blocks.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of\n        returned tensor.  Default: if None, infers data type from\n        :attr:`values`.\n    device (:class:`torch.device`, optional): the desired device of\n        returned tensor.  Default: if None, uses the current device\n        for the default tensor type (see\n        :func:`torch.set_default_tensor_type`). :attr:`device` will be\n        the CPU for CPU tensor types and the current CUDA device for\n        CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n\nExample::\n    >>> ccol_indices = [0, 1, 2]\n    >>> row_indices = [0, 1]\n    >>> values = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]\n    >>> torch.sparse_bsc_tensor(torch.tensor(ccol_indices, dtype=torch.int64),\n    ...                         torch.tensor(row_indices, dtype=torch.int64),\n    ...                         torch.tensor(values), dtype=torch.double)\n    tensor(ccol_indices=tensor([0, 1, 2]),\n           row_indices=tensor([0, 1]),\n           values=tensor([[[1., 2.],\n                           [3., 4.]],\n                          [[5., 6.],\n                           [7., 8.]]]), size=(2, 2), nnz=2, dtype=torch.float64,\n           layout=torch.sparse_bsc)\n",
      "Args": {
        "ccol_indices": {
          "Type": null,
          "Default": null
        },
        "row_indices": {
          "Type": null,
          "Default": null
        },
        "values": {
          "Type": null,
          "Default": null
        },
        "size": {
          "Type": null,
          "Default": "None"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "sparse_bsr_tensor": {
      "Doc": "\nsparse_bsr_tensor(crow_indices, col_indices, values, size=None, *, dtype=None, device=None, requires_grad=False) -> Tensor\n\nConstructs a :ref:`sparse tensor in BSR (Block Compressed Sparse Row))\n<sparse-bsr-docs>` with specified 2-dimensional blocks at the given\n:attr:`crow_indices` and :attr:`col_indices`. Sparse matrix\nmultiplication operations in BSR format are typically faster than that\nfor sparse tensors in COO format. Make you have a look at :ref:`the\nnote on the data type of the indices <sparse-bsr-docs>`.\n\nArgs:\n    crow_indices (array_like): (B+1)-dimensional array of size\n        ``(*batchsize, nrowblocks + 1)``.  The last element of each\n        batch is the number of non-zeros. This tensor encodes the\n        block index in values and col_indices depending on where the\n        given row block starts. Each successive number in the tensor\n        subtracted by the number before it denotes the number of\n        blocks in a given row.\n    col_indices (array_like): Column block co-ordinates of each block\n        in values. (B+1)-dimensional tensor with the same length as\n        values.\n    values (array_list): Initial values for the tensor. Can be a list,\n        tuple, NumPy ``ndarray``, scalar, and other types that\n        represents a (1 + 2 + K)-dimensonal tensor where ``K`` is the\n        number of dense dimensions.\n    size (list, tuple, :class:`torch.Size`, optional): Size of the\n        sparse tensor: ``(*batchsize, nrows * blocksize[0], ncols *\n        blocksize[1], *densesize)`` where ``blocksize ==\n        values.shape[1:3]``. If not provided, the size will be\n        inferred as the minimum size big enough to hold all non-zero\n        blocks.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of\n        returned tensor.  Default: if None, infers data type from\n        :attr:`values`.\n    device (:class:`torch.device`, optional): the desired device of\n        returned tensor.  Default: if None, uses the current device\n        for the default tensor type (see\n        :func:`torch.set_default_tensor_type`). :attr:`device` will be\n        the CPU for CPU tensor types and the current CUDA device for\n        CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n\nExample::\n    >>> crow_indices = [0, 1, 2]\n    >>> col_indices = [0, 1]\n    >>> values = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]\n    >>> torch.sparse_bsr_tensor(torch.tensor(crow_indices, dtype=torch.int64),\n    ...                         torch.tensor(col_indices, dtype=torch.int64),\n    ...                         torch.tensor(values), dtype=torch.double)\n    tensor(crow_indices=tensor([0, 1, 2]),\n           col_indices=tensor([0, 1]),\n           values=tensor([[[1., 2.],\n                           [3., 4.]],\n                          [[5., 6.],\n                           [7., 8.]]]), size=(2, 2), nnz=2, dtype=torch.float64,\n           layout=torch.sparse_bsr)\n",
      "Args": {
        "crow_indices": {
          "Type": null,
          "Default": null
        },
        "col_indices": {
          "Type": null,
          "Default": null
        },
        "values": {
          "Type": null,
          "Default": null
        },
        "size": {
          "Type": null,
          "Default": "None"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "sparse_compressed_tensor": {
      "Doc": "sparse_compressed_tensor(compressed_indices, plain_indices, values, size=None, *, dtype=None, layout=None, device=None, requires_grad=False) -> Tensor\n\nConstructs a :ref:`sparse tensor in Compressed Sparse format - CSR,\nCSC, BSR, or BSC - <sparse-compressed-docs>` with specified values at\nthe given :attr:`compressed_indices` and :attr:`plain_indices`. Sparse\nmatrix multiplication operations in Compressed Sparse format are\ntypically faster than that for sparse tensors in COO format. Make you\nhave a look at :ref:`the note on the data type of the indices\n<sparse-compressed-docs>`.\n\nArgs:\n    compressed_indices (array_like): (B+1)-dimensional array of size\n        ``(*batchsize, compressed_dim_size + 1)``.  The last element of\n        each batch is the number of non-zero elements or blocks. This\n        tensor encodes the index in ``values`` and ``plain_indices``\n        depending on where the given compressed dimension (row or\n        column) starts. Each successive number in the tensor\n        subtracted by the number before it denotes the number of\n        elements or blocks in a given compressed dimension.\n    plain_indices (array_like): Plain dimension (column or row)\n        co-ordinates of each element or block in values. (B+1)-dimensional\n        tensor with the same length as values.\n    values (array_list): Initial values for the tensor. Can be a list,\n        tuple, NumPy ``ndarray``, scalar, and other types.  that\n        represents a (1+K)-dimensional or (1+2+K)-dimensional tensor\n        where ``K`` is the number of dense dimensions.\n    size (list, tuple, :class:`torch.Size`, optional): Size of the\n        sparse tensor: ``(*batchsize, nrows * blocksize[0], ncols *\n        blocksize[1], *densesize)`` where ``blocksize[0] ==\n        blocksize[1] == 1`` for CSR and CSC formats. If not provided,\n        the size will be inferred as the minimum size big enough to\n        hold all non-zero elements or blocks.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of\n        returned tensor.  Default: if None, infers data type from\n        :attr:`values`.\n    layout (:class:`torch.layout`, required): the desired layout of\n        returned tensor: :attr:`torch.sparse_csr`,\n        :attr:`torch.sparse_csc`, :attr:`torch.sparse_bsr`, or\n        :attr:`torch.sparse_bsc`.\n    device (:class:`torch.device`, optional): the desired device of\n        returned tensor.  Default: if None, uses the current device\n        for the default tensor type (see\n        :func:`torch.set_default_tensor_type`). :attr:`device` will be\n        the CPU for CPU tensor types and the current CUDA device for\n        CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n\nExample::\n    >>> compressed_indices = [0, 2, 4]\n    >>> plain_indices = [0, 1, 0, 1]\n    >>> values = [1, 2, 3, 4]\n    >>> torch.sparse_compressed_tensor(torch.tensor(compressed_indices, dtype=torch.int64),\n    ...                                torch.tensor(plain_indices, dtype=torch.int64),\n    ...                                torch.tensor(values), dtype=torch.double, layout=torch.sparse_csr)\n    tensor(crow_indices=tensor([0, 2, 4]),\n           col_indices=tensor([0, 1, 0, 1]),\n           values=tensor([1., 2., 3., 4.]), size=(2, 2), nnz=4,\n           dtype=torch.float64, layout=torch.sparse_csr)\n",
      "Args": {
        "compressed_indices": {
          "Type": null,
          "Default": null
        },
        "plain_indices": {
          "Type": null,
          "Default": null
        },
        "values": {
          "Type": null,
          "Default": null
        },
        "size": {
          "Type": null,
          "Default": "None"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "None"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "sparse_coo_tensor": {
      "Doc": "\nsparse_coo_tensor(indices, values, size=None, *, dtype=None, device=None, requires_grad=False) -> Tensor\n\nConstructs a :ref:`sparse tensor in COO(rdinate) format\n<sparse-coo-docs>` with specified values at the given\n:attr:`indices`.\n\n.. note::\n\n   This function returns an :ref:`uncoalesced tensor <sparse-uncoalesced-coo-docs>`.\n\nArgs:\n    indices (array_like): Initial data for the tensor. Can be a list, tuple,\n        NumPy ``ndarray``, scalar, and other types. Will be cast to a :class:`torch.LongTensor`\n        internally. The indices are the coordinates of the non-zero values in the matrix, and thus\n        should be two-dimensional where the first dimension is the number of tensor dimensions and\n        the second dimension is the number of non-zero values.\n    values (array_like): Initial values for the tensor. Can be a list, tuple,\n        NumPy ``ndarray``, scalar, and other types.\n    size (list, tuple, or :class:`torch.Size`, optional): Size of the sparse tensor. If not\n        provided the size will be inferred as the minimum size big enough to hold all non-zero\n        elements.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if None, infers data type from :attr:`values`.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if None, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n\n\nExample::\n\n    >>> i = torch.tensor([[0, 1, 1],\n    ...                   [2, 0, 2]])\n    >>> v = torch.tensor([3, 4, 5], dtype=torch.float32)\n    >>> torch.sparse_coo_tensor(i, v, [2, 4])\n    tensor(indices=tensor([[0, 1, 1],\n                           [2, 0, 2]]),\n           values=tensor([3., 4., 5.]),\n           size=(2, 4), nnz=3, layout=torch.sparse_coo)\n\n    >>> torch.sparse_coo_tensor(i, v)  # Shape inference\n    tensor(indices=tensor([[0, 1, 1],\n                           [2, 0, 2]]),\n           values=tensor([3., 4., 5.]),\n           size=(2, 3), nnz=3, layout=torch.sparse_coo)\n\n    >>> torch.sparse_coo_tensor(i, v, [2, 4],\n    ...                         dtype=torch.float64,\n    ...                         device=torch.device('cuda:0'))\n    tensor(indices=tensor([[0, 1, 1],\n                           [2, 0, 2]]),\n           values=tensor([3., 4., 5.]),\n           device='cuda:0', size=(2, 4), nnz=3, dtype=torch.float64,\n           layout=torch.sparse_coo)\n\n    # Create an empty sparse tensor with the following invariants:\n    #   1. sparse_dim + dense_dim = len(SparseTensor.shape)\n    #   2. SparseTensor._indices().shape = (sparse_dim, nnz)\n    #   3. SparseTensor._values().shape = (nnz, SparseTensor.shape[sparse_dim:])\n    #\n    # For instance, to create an empty sparse tensor with nnz = 0, dense_dim = 0 and\n    # sparse_dim = 1 (hence indices is a 2D tensor of shape = (1, 0))\n    >>> S = torch.sparse_coo_tensor(torch.empty([1, 0]), [], [1])\n    tensor(indices=tensor([], size=(1, 0)),\n           values=tensor([], size=(0,)),\n           size=(1,), nnz=0, layout=torch.sparse_coo)\n\n    # and to create an empty sparse tensor with nnz = 0, dense_dim = 1 and\n    # sparse_dim = 1\n    >>> S = torch.sparse_coo_tensor(torch.empty([1, 0]), torch.empty([0, 2]), [1, 2])\n    tensor(indices=tensor([], size=(1, 0)),\n           values=tensor([], size=(0, 2)),\n           size=(1, 2), nnz=0, layout=torch.sparse_coo)\n\n.. _torch.sparse: https://pytorch.org/docs/stable/sparse.html\n",
      "Args": {
        "indices": {
          "Type": null,
          "Default": null
        },
        "values": {
          "Type": null,
          "Default": null
        },
        "size": {
          "Type": null,
          "Default": "None"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "sparse_csc_tensor": {
      "Doc": "\nsparse_csc_tensor(ccol_indices, row_indices, values, size=None, *, dtype=None, device=None, requires_grad=False) -> Tensor\n\nConstructs a :ref:`sparse tensor in CSC (Compressed Sparse Column)\n<sparse-csc-docs>` with specified values at the given\n:attr:`ccol_indices` and :attr:`row_indices`. Sparse matrix\nmultiplication operations in CSC format are typically faster than that\nfor sparse tensors in COO format. Make you have a look at :ref:`the\nnote on the data type of the indices <sparse-csc-docs>`.\n\nArgs:\n    ccol_indices (array_like): (B+1)-dimensional array of size\n        ``(*batchsize, ncols + 1)``.  The last element of each batch\n        is the number of non-zeros. This tensor encodes the index in\n        values and row_indices depending on where the given column\n        starts. Each successive number in the tensor subtracted by the\n        number before it denotes the number of elements in a given\n        column.\n    row_indices (array_like): Row co-ordinates of each element in\n        values. (B+1)-dimensional tensor with the same length as\n        values.\n    values (array_list): Initial values for the tensor. Can be a list,\n        tuple, NumPy ``ndarray``, scalar, and other types that\n        represents a (1+K)-dimensonal tensor where ``K`` is the number\n        of dense dimensions.\n    size (list, tuple, :class:`torch.Size`, optional): Size of the\n        sparse tensor: ``(*batchsize, nrows, ncols, *densesize)``. If\n        not provided, the size will be inferred as the minimum size\n        big enough to hold all non-zero elements.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of\n        returned tensor.  Default: if None, infers data type from\n        :attr:`values`.\n    device (:class:`torch.device`, optional): the desired device of\n        returned tensor.  Default: if None, uses the current device\n        for the default tensor type (see\n        :func:`torch.set_default_tensor_type`). :attr:`device` will be\n        the CPU for CPU tensor types and the current CUDA device for\n        CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n\nExample::\n    >>> ccol_indices = [0, 2, 4]\n    >>> row_indices = [0, 1, 0, 1]\n    >>> values = [1, 2, 3, 4]\n    >>> torch.sparse_csc_tensor(torch.tensor(ccol_indices, dtype=torch.int64),\n    ...                         torch.tensor(row_indices, dtype=torch.int64),\n    ...                         torch.tensor(values), dtype=torch.double)\n    tensor(ccol_indices=tensor([0, 2, 4]),\n           row_indices=tensor([0, 1, 0, 1]),\n           values=tensor([1., 2., 3., 4.]), size=(2, 2), nnz=4,\n           dtype=torch.float64, layout=torch.sparse_csc)\n",
      "Args": {
        "ccol_indices": {
          "Type": null,
          "Default": null
        },
        "row_indices": {
          "Type": null,
          "Default": null
        },
        "values": {
          "Type": null,
          "Default": null
        },
        "size": {
          "Type": null,
          "Default": "None"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "sparse_csr_tensor": {
      "Doc": "\nsparse_csr_tensor(crow_indices, col_indices, values, size=None, *, dtype=None, device=None, requires_grad=False) -> Tensor\n\nConstructs a :ref:`sparse tensor in CSR (Compressed Sparse Row) <sparse-csr-docs>` with specified\nvalues at the given :attr:`crow_indices` and :attr:`col_indices`. Sparse matrix multiplication operations\nin CSR format are typically faster than that for sparse tensors in COO format. Make you have a look\nat :ref:`the note on the data type of the indices <sparse-csr-docs>`.\n\nArgs:\n    crow_indices (array_like): (B+1)-dimensional array of size\n        ``(*batchsize, nrows + 1)``.  The last element of each batch\n        is the number of non-zeros. This tensor encodes the index in\n        values and col_indices depending on where the given row\n        starts. Each successive number in the tensor subtracted by the\n        number before it denotes the number of elements in a given\n        row.\n    col_indices (array_like): Column co-ordinates of each element in\n        values. (B+1)-dimensional tensor with the same length\n        as values.\n    values (array_list): Initial values for the tensor. Can be a list,\n        tuple, NumPy ``ndarray``, scalar, and other types that\n        represents a (1+K)-dimensonal tensor where ``K`` is the number\n        of dense dimensions.\n    size (list, tuple, :class:`torch.Size`, optional): Size of the\n        sparse tensor: ``(*batchsize, nrows, ncols, *densesize)``. If\n        not provided, the size will be inferred as the minimum size\n        big enough to hold all non-zero elements.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of\n        returned tensor.  Default: if None, infers data type from\n        :attr:`values`.\n    device (:class:`torch.device`, optional): the desired device of\n        returned tensor.  Default: if None, uses the current device\n        for the default tensor type (see\n        :func:`torch.set_default_tensor_type`). :attr:`device` will be\n        the CPU for CPU tensor types and the current CUDA device for\n        CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n\nExample::\n    >>> crow_indices = [0, 2, 4]\n    >>> col_indices = [0, 1, 0, 1]\n    >>> values = [1, 2, 3, 4]\n    >>> torch.sparse_csr_tensor(torch.tensor(crow_indices, dtype=torch.int64),\n    ...                         torch.tensor(col_indices, dtype=torch.int64),\n    ...                         torch.tensor(values), dtype=torch.double)\n    tensor(crow_indices=tensor([0, 2, 4]),\n           col_indices=tensor([0, 1, 0, 1]),\n           values=tensor([1., 2., 3., 4.]), size=(2, 2), nnz=4,\n           dtype=torch.float64, layout=torch.sparse_csr)\n",
      "Args": {
        "crow_indices": {
          "Type": null,
          "Default": null
        },
        "col_indices": {
          "Type": null,
          "Default": null
        },
        "values": {
          "Type": null,
          "Default": null
        },
        "size": {
          "Type": null,
          "Default": "None"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "split": {
      "Doc": "Splits the tensor into chunks. Each chunk is a view of the original tensor.\n\n    If :attr:`split_size_or_sections` is an integer type, then :attr:`tensor` will\n    be split into equally sized chunks (if possible). Last chunk will be smaller if\n    the tensor size along the given dimension :attr:`dim` is not divisible by\n    :attr:`split_size`.\n\n    If :attr:`split_size_or_sections` is a list, then :attr:`tensor` will be split\n    into ``len(split_size_or_sections)`` chunks with sizes in :attr:`dim` according\n    to :attr:`split_size_or_sections`.\n\n    Args:\n        tensor (Tensor): tensor to split.\n        split_size_or_sections (int) or (list(int)): size of a single chunk or\n            list of sizes for each chunk\n        dim (int): dimension along which to split the tensor.\n\n    Example::\n\n        >>> a = torch.arange(10).reshape(5,2)\n        >>> a\n        tensor([[0, 1],\n                [2, 3],\n                [4, 5],\n                [6, 7],\n                [8, 9]])\n        >>> torch.split(a, 2)\n        (tensor([[0, 1],\n                 [2, 3]]),\n         tensor([[4, 5],\n                 [6, 7]]),\n         tensor([[8, 9]]))\n        >>> torch.split(a, [1,4])\n        (tensor([[0, 1]]),\n         tensor([[2, 3],\n                 [4, 5],\n                 [6, 7],\n                 [8, 9]]))\n    ",
      "Args": {
        "tensor": {
          "Type": "<class 'torch.Tensor'>",
          "Default": null
        },
        "split_size_or_sections": {
          "Type": "typing.Union[int, typing.List[int]]",
          "Default": null
        },
        "dim": {
          "Type": "<class 'int'>",
          "Default": "0"
        }
      }
    },
    "split_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.split`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "split_with_sizes": {
      "Doc": null,
      "Args": null
    },
    "split_with_sizes_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.split_with_sizes`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "spmm": {
      "Doc": null,
      "Args": null
    },
    "sqrt": {
      "Doc": "\nsqrt(input, *, out=None) -> Tensor\n\nReturns a new tensor with the square-root of the elements of :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\sqrt{\\text{input}_{i}}\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([-2.0755,  1.0226,  0.0831,  0.4806])\n    >>> torch.sqrt(a)\n    tensor([    nan,  1.0112,  0.2883,  0.6933])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "square": {
      "Doc": "\nsquare(input, *, out=None) -> Tensor\n\nReturns a new tensor with the square of the elements of :attr:`input`.\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([-2.0755,  1.0226,  0.0831,  0.4806])\n    >>> torch.square(a)\n    tensor([ 4.3077,  1.0457,  0.0069,  0.2310])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "squeeze": {
      "Doc": "\nsqueeze(input, dim=None) -> Tensor\n\nReturns a tensor with all the dimensions of :attr:`input` of size `1` removed.\n\nFor example, if `input` is of shape:\n:math:`(A \\times 1 \\times B \\times C \\times 1 \\times D)` then the `out` tensor\nwill be of shape: :math:`(A \\times B \\times C \\times D)`.\n\nWhen :attr:`dim` is given, a squeeze operation is done only in the given\ndimension. If `input` is of shape: :math:`(A \\times 1 \\times B)`,\n``squeeze(input, 0)`` leaves the tensor unchanged, but ``squeeze(input, 1)``\nwill squeeze the tensor to the shape :math:`(A \\times B)`.\n\n.. note:: The returned tensor shares the storage with the input tensor,\n          so changing the contents of one will change the contents of the other.\n\n.. warning:: If the tensor has a batch dimension of size 1, then `squeeze(input)`\n          will also remove the batch dimension, which can lead to unexpected\n          errors.\n\nArgs:\n    input (Tensor): the input tensor.\n    dim (int, optional): if given, the input will be squeezed only in\n           this dimension\n\nExample::\n\n    >>> x = torch.zeros(2, 1, 2, 1, 2)\n    >>> x.size()\n    torch.Size([2, 1, 2, 1, 2])\n    >>> y = torch.squeeze(x)\n    >>> y.size()\n    torch.Size([2, 2, 2])\n    >>> y = torch.squeeze(x, 0)\n    >>> y.size()\n    torch.Size([2, 1, 2, 1, 2])\n    >>> y = torch.squeeze(x, 1)\n    >>> y.size()\n    torch.Size([2, 2, 1, 2])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "squeeze_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.squeeze`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "sspaddmm": {
      "Doc": "\nsspaddmm(input, mat1, mat2, *, beta=1, alpha=1, out=None) -> Tensor\n\nMatrix multiplies a sparse tensor :attr:`mat1` with a dense tensor\n:attr:`mat2`, then adds the sparse tensor :attr:`input` to the result.\n\nNote: This function is equivalent to :func:`torch.addmm`, except\n:attr:`input` and :attr:`mat1` are sparse.\n\nArgs:\n    input (Tensor): a sparse matrix to be added\n    mat1 (Tensor): a sparse matrix to be matrix multiplied\n    mat2 (Tensor): a dense matrix to be matrix multiplied\n\nKeyword args:\n    beta (Number, optional): multiplier for :attr:`mat` (:math:`\\beta`)\n    alpha (Number, optional): multiplier for :math:`mat1 @ mat2` (:math:`\\alpha`)\n    out (Tensor, optional): the output tensor.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "mat1": {
          "Type": null,
          "Default": null
        },
        "mat2": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "beta": {
          "Type": null,
          "Default": "1"
        },
        "alpha": {
          "Type": null,
          "Default": "1"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "stack": {
      "Doc": "\nstack(tensors, dim=0, *, out=None) -> Tensor\n\nConcatenates a sequence of tensors along a new dimension.\n\nAll tensors need to be of the same size.\n\nArguments:\n    tensors (sequence of Tensors): sequence of tensors to concatenate\n    dim (int): dimension to insert. Has to be between 0 and the number\n        of dimensions of concatenated tensors (inclusive)\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n",
      "Args": {
        "tensors": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "0"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "std": {
      "Doc": "\nstd(input, dim, unbiased, keepdim=False, *, out=None) -> Tensor\n\nIf :attr:`unbiased` is ``True``, Bessel's correction will be used.\nOtherwise, the sample deviation is calculated, without any correction.\n\nArgs:\n    input (Tensor): the input tensor.\n    dim (int or tuple of ints): the dimension or dimensions to reduce.\n\nKeyword args:\n    unbiased (bool): whether to use Bessel's correction (:math:`\\delta N = 1`).\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not.\n    out (Tensor, optional): the output tensor.\n\n\n.. function:: std(input, unbiased) -> Tensor\n   :noindex:\n\nCalculates the standard deviation of all elements in the :attr:`input` tensor.\n\nIf :attr:`unbiased` is ``True``, Bessel's correction will be used.\nOtherwise, the sample deviation is calculated, without any correction.\n\nArgs:\n    input (Tensor): the input tensor.\n    unbiased (bool): whether to use Bessel's correction (:math:`\\delta N = 1`).\n\nExample::\n\n    >>> a = torch.tensor([[-0.8166, -1.3802, -0.3560]])\n    >>> torch.std(a, unbiased=False)\n    tensor(0.4188)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "unbiased": {
          "Type": null,
          "Default": null
        },
        "keepdim": {
          "Type": null,
          "Default": "False"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "std_mean": {
      "Doc": "\nstd_mean(input, dim, unbiased, keepdim=False, *, out=None) -> (Tensor, Tensor)\n\nIf :attr:`unbiased` is ``True``, Bessel's correction will be used to calculate\nthe standard deviation. Otherwise, the sample deviation is calculated, without\nany correction.\n\nArgs:\n    input (Tensor): the input tensor.\n    \n    dim (int or tuple of ints, optional): the dimension or dimensions to reduce.\n        If ``None``, all dimensions are reduced.\n\n\nKeyword args:\n    unbiased (bool): whether to use Bessel's correction (:math:`\\delta N = 1`).\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not.\n    out (Tensor, optional): the output tensor.\n\nReturns:\n    A tuple (std, mean) containing the standard deviation and mean.\n\n.. function:: std_mean(input, unbiased) -> (Tensor, Tensor)\n   :noindex:\n\nCalculates the standard deviation and mean of all elements in the :attr:`input`\ntensor.\n\nIf :attr:`unbiased` is ``True``, Bessel's correction will be used.\nOtherwise, the sample deviation is calculated, without any correction.\n\nArgs:\n    input (Tensor): the input tensor.\n    unbiased (bool): whether to use Bessel's correction (:math:`\\delta N = 1`).\n\nReturns:\n    A tuple (std, mean) containing the standard deviation and mean.\n\nExample::\n\n    >>> a = torch.tensor([[-0.8166, -1.3802, -0.3560]])\n    >>> torch.std_mean(a, unbiased=False)\n    (tensor(0.4188), tensor(-0.8509))\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "unbiased": {
          "Type": null,
          "Default": null
        },
        "keepdim": {
          "Type": null,
          "Default": "False"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None) -> (Tensor"
        },
        "Tensor": {
          "Type": null,
          "Default": null
        }
      }
    },
    "stft": {
      "Doc": "Short-time Fourier transform (STFT).\n\n    .. warning::\n        From version 1.8.0, :attr:`return_complex` must always be given\n        explicitly for real inputs and `return_complex=False` has been\n        deprecated. Strongly prefer `return_complex=True` as in a future\n        pytorch release, this function will only return complex tensors.\n\n        Note that :func:`torch.view_as_real` can be used to recover a real\n        tensor with an extra last dimension for real and imaginary components.\n\n    The STFT computes the Fourier transform of short overlapping windows of the\n    input. This giving frequency components of the signal as they change over\n    time. The interface of this function is modeled after (but *not* a drop-in\n    replacement for) librosa_ stft function.\n\n    .. _librosa: https://librosa.org/doc/latest/generated/librosa.stft.html\n\n    Ignoring the optional batch dimension, this method computes the following\n    expression:\n\n    .. math::\n        X[\\omega, m] = \\sum_{k = 0}^{\\text{win\\_length-1}}%\n                            \\text{window}[k]\\ \\text{input}[m \\times \\text{hop\\_length} + k]\\ %\n                            \\exp\\left(- j \\frac{2 \\pi \\cdot \\omega k}{\\text{win\\_length}}\\right),\n\n    where :math:`m` is the index of the sliding window, and :math:`\\omega` is\n    the frequency :math:`0 \\leq \\omega < \\text{n\\_fft}` for ``onesided=False``,\n    or :math:`0 \\leq \\omega < \\lfloor \\text{n\\_fft} / 2 \\rfloor + 1` for ``onesided=True``.\n\n    * :attr:`input` must be either a 1-D time sequence or a 2-D batch of time\n      sequences.\n\n    * If :attr:`hop_length` is ``None`` (default), it is treated as equal to\n      ``floor(n_fft / 4)``.\n\n    * If :attr:`win_length` is ``None`` (default), it is treated as equal to\n      :attr:`n_fft`.\n\n    * :attr:`window` can be a 1-D tensor of size :attr:`win_length`, e.g., from\n      :meth:`torch.hann_window`. If :attr:`window` is ``None`` (default), it is\n      treated as if having :math:`1` everywhere in the window. If\n      :math:`\\text{win\\_length} < \\text{n\\_fft}`, :attr:`window` will be padded on\n      both sides to length :attr:`n_fft` before being applied.\n\n    * If :attr:`center` is ``True`` (default), :attr:`input` will be padded on\n      both sides so that the :math:`t`-th frame is centered at time\n      :math:`t \\times \\text{hop\\_length}`. Otherwise, the :math:`t`-th frame\n      begins at time  :math:`t \\times \\text{hop\\_length}`.\n\n    * :attr:`pad_mode` determines the padding method used on :attr:`input` when\n      :attr:`center` is ``True``. See :meth:`torch.nn.functional.pad` for\n      all available options. Default is ``\"reflect\"``.\n\n    * If :attr:`onesided` is ``True`` (default for real input), only values for\n      :math:`\\omega` in :math:`\\left[0, 1, 2, \\dots, \\left\\lfloor\n      \\frac{\\text{n\\_fft}}{2} \\right\\rfloor + 1\\right]` are returned because\n      the real-to-complex Fourier transform satisfies the conjugate symmetry,\n      i.e., :math:`X[m, \\omega] = X[m, \\text{n\\_fft} - \\omega]^*`.\n      Note if the input or window tensors are complex, then :attr:`onesided`\n      output is not possible.\n\n    * If :attr:`normalized` is ``True`` (default is ``False``), the function\n      returns the normalized STFT results, i.e., multiplied by :math:`(\\text{frame\\_length})^{-0.5}`.\n\n    * If :attr:`return_complex` is ``True`` (default if input is complex), the\n      return is a ``input.dim() + 1`` dimensional complex tensor. If ``False``,\n      the output is a ``input.dim() + 2`` dimensional real tensor where the last\n      dimension represents the real and imaginary components.\n\n    Returns either a complex tensor of size :math:`(* \\times N \\times T)` if\n    :attr:`return_complex` is true, or a real tensor of size :math:`(* \\times N\n    \\times T \\times 2)`. Where :math:`*` is the optional batch size of\n    :attr:`input`, :math:`N` is the number of frequencies where STFT is applied\n    and :math:`T` is the total number of frames used.\n\n    .. warning::\n      This function changed signature at version 0.4.1. Calling with the\n      previous signature may cause error or return incorrect result.\n\n    Args:\n        input (Tensor): the input tensor\n        n_fft (int): size of Fourier transform\n        hop_length (int, optional): the distance between neighboring sliding window\n            frames. Default: ``None`` (treated as equal to ``floor(n_fft / 4)``)\n        win_length (int, optional): the size of window frame and STFT filter.\n            Default: ``None``  (treated as equal to :attr:`n_fft`)\n        window (Tensor, optional): the optional window function.\n            Default: ``None`` (treated as window of all :math:`1` s)\n        center (bool, optional): whether to pad :attr:`input` on both sides so\n            that the :math:`t`-th frame is centered at time :math:`t \\times \\text{hop\\_length}`.\n            Default: ``True``\n        pad_mode (str, optional): controls the padding method used when\n            :attr:`center` is ``True``. Default: ``\"reflect\"``\n        normalized (bool, optional): controls whether to return the normalized STFT results\n             Default: ``False``\n        onesided (bool, optional): controls whether to return half of results to\n            avoid redundancy for real inputs.\n            Default: ``True`` for real :attr:`input` and :attr:`window`, ``False`` otherwise.\n        return_complex (bool, optional): whether to return a complex tensor, or\n            a real tensor with an extra last dimension for the real and\n            imaginary components.\n\n    Returns:\n        Tensor: A tensor containing the STFT result with shape described above\n\n    ",
      "Args": {
        "input": {
          "Type": "<class 'torch.Tensor'>",
          "Default": null
        },
        "n_fft": {
          "Type": "<class 'int'>",
          "Default": null
        },
        "hop_length": {
          "Type": "typing.Optional[int]",
          "Default": "None"
        },
        "win_length": {
          "Type": "typing.Optional[int]",
          "Default": "None"
        },
        "window": {
          "Type": "typing.Optional[torch.Tensor]",
          "Default": "None"
        },
        "center": {
          "Type": "<class 'bool'>",
          "Default": "True"
        },
        "pad_mode": {
          "Type": "<class 'str'>",
          "Default": "reflect"
        },
        "normalized": {
          "Type": "<class 'bool'>",
          "Default": "False"
        },
        "onesided": {
          "Type": "typing.Optional[bool]",
          "Default": "None"
        },
        "return_complex": {
          "Type": "typing.Optional[bool]",
          "Default": "None"
        }
      }
    },
    "sub": {
      "Doc": "\nsub(input, other, *, alpha=1, out=None) -> Tensor\n\nSubtracts :attr:`other`, scaled by :attr:`alpha`, from :attr:`input`.\n\n.. math::\n    \\text{{out}}_i = \\text{{input}}_i - \\text{{alpha}} \\times \\text{{other}}_i\n\n\nSupports :ref:`broadcasting to a common shape <broadcasting-semantics>`,\n:ref:`type promotion <type-promotion-doc>`, and integer, float, and complex inputs.\n\nArgs:\n    input (Tensor): the input tensor.\n    other (Tensor or Number): the tensor or number to subtract from :attr:`input`.\n\nKeyword args:\n    alpha (Number): the multiplier for :attr:`other`.\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.tensor((1, 2))\n    >>> b = torch.tensor((0, 1))\n    >>> torch.sub(a, b, alpha=2)\n    tensor([1, 0])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "alpha": {
          "Type": null,
          "Default": "1"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "subtract": {
      "Doc": "\nsubtract(input, other, *, alpha=1, out=None) -> Tensor\n\nAlias for :func:`torch.sub`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "alpha": {
          "Type": null,
          "Default": "1"
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "sum": {
      "Doc": "\nsum(input, *, dtype=None) -> Tensor\n\nReturns the sum of all elements in the :attr:`input` tensor.\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        If specified, the input tensor is casted to :attr:`dtype` before the operation\n        is performed. This is useful for preventing data type overflows. Default: None.\n\nExample::\n\n    >>> a = torch.randn(1, 3)\n    >>> a\n    tensor([[ 0.1133, -0.9567,  0.2958]])\n    >>> torch.sum(a)\n    tensor(-0.5475)\n\n.. function:: sum(input, dim, keepdim=False, *, dtype=None) -> Tensor\n   :noindex:\n\nReturns the sum of each row of the :attr:`input` tensor in the given\ndimension :attr:`dim`. If :attr:`dim` is a list of dimensions,\nreduce over all of them.\n\n\nIf :attr:`keepdim` is ``True``, the output tensor is of the same size\nas :attr:`input` except in the dimension(s) :attr:`dim` where it is of size 1.\nOtherwise, :attr:`dim` is squeezed (see :func:`torch.squeeze`), resulting in the\noutput tensor having 1 (or ``len(dim)``) fewer dimension(s).\n\n\nArgs:\n    input (Tensor): the input tensor.\n    \n    dim (int or tuple of ints, optional): the dimension or dimensions to reduce.\n        If ``None``, all dimensions are reduced.\n\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        If specified, the input tensor is casted to :attr:`dtype` before the operation\n        is performed. This is useful for preventing data type overflows. Default: None.\n\nExample::\n\n    >>> a = torch.randn(4, 4)\n    >>> a\n    tensor([[ 0.0569, -0.2475,  0.0737, -0.3429],\n            [-0.2993,  0.9138,  0.9337, -1.6864],\n            [ 0.1132,  0.7892, -0.1003,  0.5688],\n            [ 0.3637, -0.9906, -0.4752, -1.5197]])\n    >>> torch.sum(a, 1)\n    tensor([-0.4598, -0.1381,  1.3708, -2.6217])\n    >>> b = torch.arange(4 * 5 * 6).view(4, 5, 6)\n    >>> torch.sum(b, (2, 1))\n    tensor([  435.,  1335.,  2235.,  3135.])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "svd": {
      "Doc": "\nsvd(input, some=True, compute_uv=True, *, out=None) -> (Tensor, Tensor, Tensor)\n\nComputes the singular value decomposition of either a matrix or batch of\nmatrices :attr:`input`. The singular value decomposition is represented as a\nnamedtuple `(U, S, V)`, such that :attr:`input` :math:`= U \\text{diag}(S) V^{\\text{H}}`.\nwhere :math:`V^{\\text{H}}` is the transpose of `V` for real inputs,\nand the conjugate transpose of `V` for complex inputs.\nIf :attr:`input` is a batch of matrices, then `U`, `S`, and `V` are also\nbatched with the same batch dimensions as :attr:`input`.\n\nIf :attr:`some` is `True` (default), the method returns the reduced singular\nvalue decomposition. In this case, if the last two dimensions of :attr:`input` are\n`m` and `n`, then the returned `U` and `V` matrices will contain only\n`min(n, m)` orthonormal columns.\n\nIf :attr:`compute_uv` is `False`, the returned `U` and `V` will be\nzero-filled matrices of shape `(m, m)` and `(n, n)`\nrespectively, and the same device as :attr:`input`. The argument :attr:`some`\nhas no effect when :attr:`compute_uv` is `False`.\n\nSupports :attr:`input` of float, double, cfloat and cdouble data types.\nThe dtypes of `U` and `V` are the same as :attr:`input`'s. `S` will\nalways be real-valued, even if :attr:`input` is complex.\n\n.. warning::\n\n    :func:`torch.svd` is deprecated in favor of :func:`torch.linalg.svd`\n    and will be removed in a future PyTorch release.\n\n    ``U, S, V = torch.svd(A, some=some, compute_uv=True)`` (default) should be replaced with\n\n    .. code:: python\n\n        U, S, Vh = torch.linalg.svd(A, full_matrices=not some)\n        V = Vh.mH\n\n    ``_, S, _ = torch.svd(A, some=some, compute_uv=False)`` should be replaced with\n\n    .. code:: python\n\n        S = torch.linalg.svdvals(A)\n\n.. note:: Differences with :func:`torch.linalg.svd`:\n\n             * :attr:`some` is the opposite of\n               :func:`torch.linalg.svd`'s :attr:`full_matrices`. Note that\n               default value for both is `True`, so the default behavior is\n               effectively the opposite.\n             * :func:`torch.svd` returns `V`, whereas :func:`torch.linalg.svd` returns\n               `Vh`, that is, :math:`V^{\\text{H}}`.\n             * If :attr:`compute_uv` is `False`, :func:`torch.svd` returns zero-filled\n               tensors for `U` and `Vh`, whereas :func:`torch.linalg.svd` returns\n               empty tensors.\n\n.. note:: The singular values are returned in descending order. If :attr:`input` is a batch of matrices,\n          then the singular values of each matrix in the batch are returned in descending order.\n\n.. note:: The `S` tensor can only be used to compute gradients if :attr:`compute_uv` is `True`.\n\n.. note:: When :attr:`some` is `False`, the gradients on `U[..., :, min(m, n):]`\n          and `V[..., :, min(m, n):]` will be ignored in the backward pass, as those vectors\n          can be arbitrary bases of the corresponding subspaces.\n\n.. note:: The implementation of :func:`torch.linalg.svd` on CPU uses LAPACK's routine `?gesdd`\n          (a divide-and-conquer algorithm) instead of `?gesvd` for speed. Analogously,\n          on GPU, it uses cuSOLVER's routines `gesvdj` and `gesvdjBatched` on CUDA 10.1.243\n          and later, and MAGMA's routine `gesdd` on earlier versions of CUDA.\n\n.. note:: The returned `U` will not be contiguous. The matrix (or batch of matrices) will\n          be represented as a column-major matrix (i.e. Fortran-contiguous).\n\n.. warning:: The gradients with respect to `U` and `V` will only be finite when the input does not\n             have zero nor repeated singular values.\n\n.. warning:: If the distance between any two singular values is close to zero, the gradients with respect to\n             `U` and `V` will be numerically unstable, as they depends on\n             :math:`\\frac{1}{\\min_{i \\neq j} \\sigma_i^2 - \\sigma_j^2}`. The same happens when the matrix\n             has small singular values, as these gradients also depend on `S\u207b\u00b9`.\n\n.. warning:: For complex-valued :attr:`input` the singular value decomposition is not unique,\n             as `U` and `V` may be multiplied by an arbitrary phase factor :math:`e^{i \\phi}` on every column.\n             The same happens when :attr:`input` has repeated singular values, where one may multiply\n             the columns of the spanning subspace in `U` and `V` by a rotation matrix\n             and `the resulting vectors will span the same subspace`_.\n             Different platforms, like NumPy, or inputs on different device types,\n             may produce different `U` and `V` tensors.\n\nArgs:\n    input (Tensor): the input tensor of size `(*, m, n)` where `*` is zero or more\n                    batch dimensions consisting of `(m, n)` matrices.\n    some (bool, optional): controls whether to compute the reduced or full decomposition, and\n                           consequently, the shape of returned `U` and `V`. Default: `True`.\n    compute_uv (bool, optional): controls whether to compute `U` and `V`. Default: `True`.\n\nKeyword args:\n    out (tuple, optional): the output tuple of tensors\n\nExample::\n\n    >>> a = torch.randn(5, 3)\n    >>> a\n    tensor([[ 0.2364, -0.7752,  0.6372],\n            [ 1.7201,  0.7394, -0.0504],\n            [-0.3371, -1.0584,  0.5296],\n            [ 0.3550, -0.4022,  1.5569],\n            [ 0.2445, -0.0158,  1.1414]])\n    >>> u, s, v = torch.svd(a)\n    >>> u\n    tensor([[ 0.4027,  0.0287,  0.5434],\n            [-0.1946,  0.8833,  0.3679],\n            [ 0.4296, -0.2890,  0.5261],\n            [ 0.6604,  0.2717, -0.2618],\n            [ 0.4234,  0.2481, -0.4733]])\n    >>> s\n    tensor([2.3289, 2.0315, 0.7806])\n    >>> v\n    tensor([[-0.0199,  0.8766,  0.4809],\n            [-0.5080,  0.4054, -0.7600],\n            [ 0.8611,  0.2594, -0.4373]])\n    >>> torch.dist(a, torch.mm(torch.mm(u, torch.diag(s)), v.t()))\n    tensor(8.6531e-07)\n    >>> a_big = torch.randn(7, 5, 3)\n    >>> u, s, v = torch.svd(a_big)\n    >>> torch.dist(a_big, torch.matmul(torch.matmul(u, torch.diag_embed(s)), v.mT))\n    tensor(2.6503e-06)\n\n.. _the resulting vectors will span the same subspace:\n       (https://en.wikipedia.org/wiki/Singular_value_decomposition#Singular_values,_singular_vectors,_and_their_relation_to_the_SVD)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "some": {
          "Type": null,
          "Default": "True"
        },
        "compute_uv": {
          "Type": null,
          "Default": "True"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None) -> (Tensor"
        },
        "Tensor": {
          "Type": null,
          "Default": null
        }
      }
    },
    "svd_lowrank": {
      "Doc": "Return the singular value decomposition ``(U, S, V)`` of a matrix,\n    batches of matrices, or a sparse matrix :math:`A` such that\n    :math:`A \\approx U diag(S) V^T`. In case :math:`M` is given, then\n    SVD is computed for the matrix :math:`A - M`.\n\n    .. note:: The implementation is based on the Algorithm 5.1 from\n              Halko et al, 2009.\n\n    .. note:: To obtain repeatable results, reset the seed for the\n              pseudorandom number generator\n\n    .. note:: The input is assumed to be a low-rank matrix.\n\n    .. note:: In general, use the full-rank SVD implementation\n              :func:`torch.linalg.svd` for dense matrices due to its 10-fold\n              higher performance characteristics. The low-rank SVD\n              will be useful for huge sparse matrices that\n              :func:`torch.linalg.svd` cannot handle.\n\n    Args::\n        A (Tensor): the input tensor of size :math:`(*, m, n)`\n\n        q (int, optional): a slightly overestimated rank of A.\n\n        niter (int, optional): the number of subspace iterations to\n                               conduct; niter must be a nonnegative\n                               integer, and defaults to 2\n\n        M (Tensor, optional): the input tensor's mean of size\n                              :math:`(*, 1, n)`.\n\n    References::\n        - Nathan Halko, Per-Gunnar Martinsson, and Joel Tropp, Finding\n          structure with randomness: probabilistic algorithms for\n          constructing approximate matrix decompositions,\n          arXiv:0909.4061 [math.NA; math.PR], 2009 (available at\n          `arXiv <https://arxiv.org/abs/0909.4061>`_).\n\n    ",
      "Args": {
        "A": {
          "Type": "<class 'torch.Tensor'>",
          "Default": null
        },
        "q": {
          "Type": "typing.Optional[int]",
          "Default": "6"
        },
        "niter": {
          "Type": "typing.Optional[int]",
          "Default": "2"
        },
        "M": {
          "Type": "typing.Optional[torch.Tensor]",
          "Default": "None"
        }
      }
    },
    "swapaxes": {
      "Doc": "\nswapaxes(input, axis0, axis1) -> Tensor\n\nAlias for :func:`torch.transpose`.\n\nThis function is equivalent to NumPy's swapaxes function.\n\nExamples::\n\n    >>> x = torch.tensor([[[0,1],[2,3]],[[4,5],[6,7]]])\n    >>> x\n    tensor([[[0, 1],\n            [2, 3]],\n\n            [[4, 5],\n            [6, 7]]])\n    >>> torch.swapaxes(x, 0, 1)\n    tensor([[[0, 1],\n            [4, 5]],\n\n            [[2, 3],\n            [6, 7]]])\n    >>> torch.swapaxes(x, 0, 2)\n    tensor([[[0, 4],\n            [2, 6]],\n\n            [[1, 5],\n            [3, 7]]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "axis0": {
          "Type": null,
          "Default": null
        },
        "axis1": {
          "Type": null,
          "Default": null
        }
      }
    },
    "swapdims": {
      "Doc": "\nswapdims(input, dim0, dim1) -> Tensor\n\nAlias for :func:`torch.transpose`.\n\nThis function is equivalent to NumPy's swapaxes function.\n\nExamples::\n\n    >>> x = torch.tensor([[[0,1],[2,3]],[[4,5],[6,7]]])\n    >>> x\n    tensor([[[0, 1],\n            [2, 3]],\n\n            [[4, 5],\n            [6, 7]]])\n    >>> torch.swapdims(x, 0, 1)\n    tensor([[[0, 1],\n            [4, 5]],\n\n            [[2, 3],\n            [6, 7]]])\n    >>> torch.swapdims(x, 0, 2)\n    tensor([[[0, 4],\n            [2, 6]],\n\n            [[1, 5],\n            [3, 7]]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim0": {
          "Type": null,
          "Default": null
        },
        "dim1": {
          "Type": null,
          "Default": null
        }
      }
    },
    "symeig": {
      "Doc": "\nsymeig(input, eigenvectors=False, upper=True, *, out=None) -> (Tensor, Tensor)\n\nThis function returns eigenvalues and eigenvectors\nof a real symmetric or complex Hermitian matrix :attr:`input` or a batch thereof,\nrepresented by a namedtuple (eigenvalues, eigenvectors).\n\nThis function calculates all eigenvalues (and vectors) of :attr:`input`\nsuch that :math:`\\text{input} = V \\text{diag}(e) V^T`.\n\nThe boolean argument :attr:`eigenvectors` defines computation of\nboth eigenvectors and eigenvalues or eigenvalues only.\n\nIf it is ``False``, only eigenvalues are computed. If it is ``True``,\nboth eigenvalues and eigenvectors are computed.\n\nSince the input matrix :attr:`input` is supposed to be symmetric or Hermitian,\nonly the upper triangular portion is used by default.\n\nIf :attr:`upper` is ``False``, then lower triangular portion is used.\n\n.. warning::\n\n    :func:`torch.symeig` is deprecated in favor of :func:`torch.linalg.eigh`\n    and will be removed in a future PyTorch release. The default behavior has changed\n    from using the upper triangular portion of the matrix by default to using the\n    lower triangular portion.\n\n    ``L, _ = torch.symeig(A, upper=upper)`` should be replaced with\n\n    .. code :: python\n\n        UPLO = \"U\" if upper else \"L\"\n        L = torch.linalg.eigvalsh(A, UPLO=UPLO)\n\n    ``L, V = torch.symeig(A, eigenvectors=True, upper=upper)`` should be replaced with\n\n    .. code :: python\n\n        UPLO = \"U\" if upper else \"L\"\n        L, V = torch.linalg.eigh(A, UPLO=UPLO)\n\n.. note:: The eigenvalues are returned in ascending order. If :attr:`input` is a batch of matrices,\n          then the eigenvalues of each matrix in the batch is returned in ascending order.\n\n.. note:: Irrespective of the original strides, the returned matrix `V` will\n          be transposed, i.e. with strides `V.contiguous().mT.stride()`.\n\n.. warning:: Extra care needs to be taken when backward through outputs. Such\n             operation is only stable when all eigenvalues are distinct and becomes\n             less stable the smaller :math:`\\min_{i \\neq j} |\\lambda_i - \\lambda_j|` is.\n\nArgs:\n    input (Tensor): the input tensor of size :math:`(*, n, n)` where `*` is zero or more\n                    batch dimensions consisting of symmetric or Hermitian matrices.\n    eigenvectors(bool, optional): controls whether eigenvectors have to be computed\n    upper(bool, optional): controls whether to consider upper-triangular or lower-triangular region\n\nKeyword args:\n    out (tuple, optional): the output tuple of (Tensor, Tensor)\n\nReturns:\n    (Tensor, Tensor): A namedtuple (eigenvalues, eigenvectors) containing\n\n        - **eigenvalues** (*Tensor*): Shape :math:`(*, m)`. The eigenvalues in ascending order.\n        - **eigenvectors** (*Tensor*): Shape :math:`(*, m, m)`.\n          If ``eigenvectors=False``, it's an empty tensor.\n          Otherwise, this tensor contains the orthonormal eigenvectors of the ``input``.\n\nExamples::\n\n\n    >>> a = torch.randn(5, 5)\n    >>> a = a + a.t()  # To make a symmetric\n    >>> a\n    tensor([[-5.7827,  4.4559, -0.2344, -1.7123, -1.8330],\n            [ 4.4559,  1.4250, -2.8636, -3.2100, -0.1798],\n            [-0.2344, -2.8636,  1.7112, -5.5785,  7.1988],\n            [-1.7123, -3.2100, -5.5785, -2.6227,  3.1036],\n            [-1.8330, -0.1798,  7.1988,  3.1036, -5.1453]])\n    >>> e, v = torch.symeig(a, eigenvectors=True)\n    >>> e\n    tensor([-13.7012,  -7.7497,  -2.3163,   5.2477,   8.1050])\n    >>> v\n    tensor([[ 0.1643,  0.9034, -0.0291,  0.3508,  0.1817],\n            [-0.2417, -0.3071, -0.5081,  0.6534,  0.4026],\n            [-0.5176,  0.1223, -0.0220,  0.3295, -0.7798],\n            [-0.4850,  0.2695, -0.5773, -0.5840,  0.1337],\n            [ 0.6415, -0.0447, -0.6381, -0.0193, -0.4230]])\n    >>> a_big = torch.randn(5, 2, 2)\n    >>> a_big = a_big + a_big.mT  # To make a_big symmetric\n    >>> e, v = a_big.symeig(eigenvectors=True)\n    >>> torch.allclose(torch.matmul(v, torch.matmul(e.diag_embed(), v.mT)), a_big)\n    True\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "eigenvectors": {
          "Type": null,
          "Default": "False"
        },
        "upper": {
          "Type": null,
          "Default": "True"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None) -> (Tensor"
        },
        "Tensor": {
          "Type": null,
          "Default": null
        }
      }
    },
    "t": {
      "Doc": "\nt(input) -> Tensor\n\nExpects :attr:`input` to be <= 2-D tensor and transposes dimensions 0\nand 1.\n\n0-D and 1-D tensors are returned as is. When input is a 2-D tensor this\nis equivalent to ``transpose(input, 0, 1)``.\n\nArgs:\n    input (Tensor): the input tensor.\n\nExample::\n\n    >>> x = torch.randn(())\n    >>> x\n    tensor(0.1995)\n    >>> torch.t(x)\n    tensor(0.1995)\n    >>> x = torch.randn(3)\n    >>> x\n    tensor([ 2.4320, -0.4608,  0.7702])\n    >>> torch.t(x)\n    tensor([ 2.4320, -0.4608,  0.7702])\n    >>> x = torch.randn(2, 3)\n    >>> x\n    tensor([[ 0.4875,  0.9158, -0.5872],\n            [ 0.3938, -0.6929,  0.6932]])\n    >>> torch.t(x)\n    tensor([[ 0.4875,  0.3938],\n            [ 0.9158, -0.6929],\n            [-0.5872,  0.6932]])\n\nSee also :func:`torch.transpose`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "t_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.t`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "take": {
      "Doc": "\ntake(input, index) -> Tensor\n\nReturns a new tensor with the elements of :attr:`input` at the given indices.\nThe input tensor is treated as if it were viewed as a 1-D tensor. The result\ntakes the same shape as the indices.\n\nArgs:\n    input (Tensor): the input tensor.\n    index (LongTensor): the indices into tensor\n\nExample::\n\n    >>> src = torch.tensor([[4, 3, 5],\n    ...                     [6, 7, 8]])\n    >>> torch.take(src, torch.tensor([0, 2, 5]))\n    tensor([ 4,  5,  8])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "index": {
          "Type": null,
          "Default": null
        }
      }
    },
    "take_along_dim": {
      "Doc": "\ntake_along_dim(input, indices, dim, *, out=None) -> Tensor\n\nSelects values from :attr:`input` at the 1-dimensional indices from :attr:`indices` along the given :attr:`dim`.\n\nFunctions that return indices along a dimension, like :func:`torch.argmax` and :func:`torch.argsort`,\nare designed to work with this function. See the examples below.\n\n.. note::\n    This function is similar to NumPy's `take_along_axis`.\n    See also :func:`torch.gather`.\n\nArgs:\n    input (Tensor): the input tensor.\n    indices (tensor): the indices into :attr:`input`. Must have long dtype.\n    dim (int): dimension to select along.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> t = torch.tensor([[10, 30, 20], [60, 40, 50]])\n    >>> max_idx = torch.argmax(t)\n    >>> torch.take_along_dim(t, max_idx)\n    tensor([60])\n    >>> sorted_idx = torch.argsort(t, dim=1)\n    >>> torch.take_along_dim(t, sorted_idx, dim=1)\n    tensor([[10, 20, 30],\n            [40, 50, 60]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "indices": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "tan": {
      "Doc": "\ntan(input, *, out=None) -> Tensor\n\nReturns a new tensor with the tangent of the elements of :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\tan(\\text{input}_{i})\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([-1.2027, -1.7687,  0.4412, -1.3856])\n    >>> torch.tan(a)\n    tensor([-2.5930,  4.9859,  0.4722, -5.3366])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "tanh": {
      "Doc": "\ntanh(input, *, out=None) -> Tensor\n\nReturns a new tensor with the hyperbolic tangent of the elements\nof :attr:`input`.\n\n.. math::\n    \\text{out}_{i} = \\tanh(\\text{input}_{i})\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 0.8986, -0.7279,  1.1745,  0.2611])\n    >>> torch.tanh(a)\n    tensor([ 0.7156, -0.6218,  0.8257,  0.2553])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "tensor": {
      "Doc": "\ntensor(data, *, dtype=None, device=None, requires_grad=False, pin_memory=False) -> Tensor\n\nConstructs a tensor with no autograd history (also known as a \"leaf tensor\", see :doc:`/notes/autograd`) by copying :attr:`data`.\n\n.. warning::\n\n    When working with tensors prefer using :func:`torch.Tensor.clone`,\n    :func:`torch.Tensor.detach`, and :func:`torch.Tensor.requires_grad_` for\n    readability. Letting `t` be a tensor, ``torch.tensor(t)`` is equivalent to\n    ``t.clone().detach()``, and ``torch.tensor(t, requires_grad=True)``\n    is equivalent to ``t.clone().detach().requires_grad_(True)``.\n\n.. seealso::\n\n    :func:`torch.as_tensor` preserves autograd history and avoids copies where possible.\n    :func:`torch.from_numpy` creates a tensor that shares storage with a NumPy array.\n\nArgs:\n    data (array_like): Initial data for the tensor. Can be a list, tuple,\n        NumPy ``ndarray``, scalar, and other types.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, infers data type from :attr:`data`.\n    device (:class:`torch.device`, optional): the device of the constructed tensor. If None and data is a tensor\n        then the device of data is used. If None and data is not a tensor then\n        the result tensor is constructed on the CPU.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n    pin_memory (bool, optional): If set, returned tensor would be allocated in\n        the pinned memory. Works only for CPU tensors. Default: ``False``.\n\n\nExample::\n\n    >>> torch.tensor([[0.1, 1.2], [2.2, 3.1], [4.9, 5.2]])\n    tensor([[ 0.1000,  1.2000],\n            [ 2.2000,  3.1000],\n            [ 4.9000,  5.2000]])\n\n    >>> torch.tensor([0, 1])  # Type inference on data\n    tensor([ 0,  1])\n\n    >>> torch.tensor([[0.11111, 0.222222, 0.3333333]],\n    ...              dtype=torch.float64,\n    ...              device=torch.device('cuda:0'))  # creates a double tensor on a CUDA device\n    tensor([[ 0.1111,  0.2222,  0.3333]], dtype=torch.float64, device='cuda:0')\n\n    >>> torch.tensor(3.14159)  # Create a zero-dimensional (scalar) tensor\n    tensor(3.1416)\n\n    >>> torch.tensor([])  # Create an empty tensor (of size (0,))\n    tensor([])\n",
      "Args": {
        "data": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        },
        "pin_memory": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "tensor_split": {
      "Doc": "\ntensor_split(input, indices_or_sections, dim=0) -> List of Tensors\n\nSplits a tensor into multiple sub-tensors, all of which are views of :attr:`input`,\nalong dimension :attr:`dim` according to the indices or number of sections specified\nby :attr:`indices_or_sections`. This function is based on NumPy's\n:func:`numpy.array_split`.\n\nArgs:\n    input (Tensor): the tensor to split\n    indices_or_sections (Tensor, int or list or tuple of ints):\n        If :attr:`indices_or_sections` is an integer ``n`` or a zero dimensional long tensor\n        with value ``n``, :attr:`input` is split into ``n`` sections along dimension :attr:`dim`.\n        If :attr:`input` is divisible by ``n`` along dimension :attr:`dim`, each\n        section will be of equal size, :code:`input.size(dim) / n`. If :attr:`input`\n        is not divisible by ``n``, the sizes of the first :code:`int(input.size(dim) % n)`\n        sections will have size :code:`int(input.size(dim) / n) + 1`, and the rest will\n        have size :code:`int(input.size(dim) / n)`.\n\n        If :attr:`indices_or_sections` is a list or tuple of ints, or a one-dimensional long\n        tensor, then :attr:`input` is split along dimension :attr:`dim` at each of the indices\n        in the list, tuple or tensor. For instance, :code:`indices_or_sections=[2, 3]` and :code:`dim=0`\n        would result in the tensors :code:`input[:2]`, :code:`input[2:3]`, and :code:`input[3:]`.\n\n        If indices_or_sections is a tensor, it must be a zero-dimensional or one-dimensional\n        long tensor on the CPU.\n\n    dim (int, optional): dimension along which to split the tensor. Default: ``0``\n\nExample::\n\n    >>> x = torch.arange(8)\n    >>> torch.tensor_split(x, 3)\n    (tensor([0, 1, 2]), tensor([3, 4, 5]), tensor([6, 7]))\n\n    >>> x = torch.arange(7)\n    >>> torch.tensor_split(x, 3)\n    (tensor([0, 1, 2]), tensor([3, 4]), tensor([5, 6]))\n    >>> torch.tensor_split(x, (1, 6))\n    (tensor([0]), tensor([1, 2, 3, 4, 5]), tensor([6]))\n\n    >>> x = torch.arange(14).reshape(2, 7)\n    >>> x\n    tensor([[ 0,  1,  2,  3,  4,  5,  6],\n            [ 7,  8,  9, 10, 11, 12, 13]])\n    >>> torch.tensor_split(x, 3, dim=1)\n    (tensor([[0, 1, 2],\n            [7, 8, 9]]),\n     tensor([[ 3,  4],\n            [10, 11]]),\n     tensor([[ 5,  6],\n            [12, 13]]))\n    >>> torch.tensor_split(x, (1, 6), dim=1)\n    (tensor([[0],\n            [7]]),\n     tensor([[ 1,  2,  3,  4,  5],\n            [ 8,  9, 10, 11, 12]]),\n     tensor([[ 6],\n            [13]]))\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "indices_or_sections": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "0"
        }
      }
    },
    "tensordot": {
      "Doc": "Returns a contraction of a and b over multiple dimensions.\n\n    :attr:`tensordot` implements a generalized matrix product.\n\n    Args:\n      a (Tensor): Left tensor to contract\n      b (Tensor): Right tensor to contract\n      dims (int or Tuple[List[int], List[int]] or List[List[int]] containing two lists or Tensor): number of dimensions to\n         contract or explicit lists of dimensions for :attr:`a` and\n         :attr:`b` respectively\n\n    When called with a non-negative integer argument :attr:`dims` = :math:`d`, and\n    the number of dimensions of :attr:`a` and :attr:`b` is :math:`m` and :math:`n`,\n    respectively, :func:`~torch.tensordot` computes\n\n    .. math::\n        r_{i_0,...,i_{m-d}, i_d,...,i_n}\n          = \\sum_{k_0,...,k_{d-1}} a_{i_0,...,i_{m-d},k_0,...,k_{d-1}} \\times b_{k_0,...,k_{d-1}, i_d,...,i_n}.\n\n    When called with :attr:`dims` of the list form, the given dimensions will be contracted\n    in place of the last :math:`d` of :attr:`a` and the first :math:`d` of :math:`b`. The sizes\n    in these dimensions must match, but :func:`~torch.tensordot` will deal with broadcasted\n    dimensions.\n\n    Examples::\n\n        >>> a = torch.arange(60.).reshape(3, 4, 5)\n        >>> b = torch.arange(24.).reshape(4, 3, 2)\n        >>> torch.tensordot(a, b, dims=([1, 0], [0, 1]))\n        tensor([[4400., 4730.],\n                [4532., 4874.],\n                [4664., 5018.],\n                [4796., 5162.],\n                [4928., 5306.]])\n\n        >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA)\n        >>> a = torch.randn(3, 4, 5, device='cuda')\n        >>> b = torch.randn(4, 5, 6, device='cuda')\n        >>> c = torch.tensordot(a, b, dims=2).cpu()\n        tensor([[ 8.3504, -2.5436,  6.2922,  2.7556, -1.0732,  3.2741],\n                [ 3.3161,  0.0704,  5.0187, -0.4079, -4.3126,  4.8744],\n                [ 0.8223,  3.9445,  3.2168, -0.2400,  3.4117,  1.7780]])\n\n        >>> a = torch.randn(3, 5, 4, 6)\n        >>> b = torch.randn(6, 4, 5, 3)\n        >>> torch.tensordot(a, b, dims=([2, 1, 3], [1, 2, 0]))\n        tensor([[  7.7193,  -2.4867, -10.3204],\n                [  1.5513, -14.4737,  -6.5113],\n                [ -0.2850,   4.2573,  -3.5997]])\n    ",
      "Args": {
        "a": {
          "Type": null,
          "Default": null
        },
        "b": {
          "Type": null,
          "Default": null
        },
        "dims": {
          "Type": null,
          "Default": "2"
        },
        "out": {
          "Type": "typing.Optional[torch.Tensor]",
          "Default": "None"
        }
      }
    },
    "threshold": {
      "Doc": null,
      "Args": null
    },
    "tile": {
      "Doc": "\ntile(input, dims) -> Tensor\n\nConstructs a tensor by repeating the elements of :attr:`input`.\nThe :attr:`dims` argument specifies the number of repetitions\nin each dimension.\n\nIf :attr:`dims` specifies fewer dimensions than :attr:`input` has, then\nones are prepended to :attr:`dims` until all dimensions are specified.\nFor example, if :attr:`input` has shape (8, 6, 4, 2) and :attr:`dims`\nis (2, 2), then :attr:`dims` is treated as (1, 1, 2, 2).\n\nAnalogously, if :attr:`input` has fewer dimensions than :attr:`dims`\nspecifies, then :attr:`input` is treated as if it were unsqueezed at\ndimension zero until it has as many dimensions as :attr:`dims` specifies.\nFor example, if :attr:`input` has shape (4, 2) and :attr:`dims`\nis (3, 3, 2, 2), then :attr:`input` is treated as if it had the\nshape (1, 1, 4, 2).\n\n.. note::\n\n    This function is similar to NumPy's tile function.\n\nArgs:\n    input (Tensor): the tensor whose elements to repeat.\n    dims (tuple): the number of repetitions per dimension.\n\nExample::\n\n    >>> x = torch.tensor([1, 2, 3])\n    >>> x.tile((2,))\n    tensor([1, 2, 3, 1, 2, 3])\n    >>> y = torch.tensor([[1, 2], [3, 4]])\n    >>> torch.tile(y, (2, 2))\n    tensor([[1, 2, 1, 2],\n            [3, 4, 3, 4],\n            [1, 2, 1, 2],\n            [3, 4, 3, 4]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dims": {
          "Type": null,
          "Default": null
        }
      }
    },
    "topk": {
      "Doc": "\ntopk(input, k, dim=None, largest=True, sorted=True, *, out=None) -> (Tensor, LongTensor)\n\nReturns the :attr:`k` largest elements of the given :attr:`input` tensor along\na given dimension.\n\nIf :attr:`dim` is not given, the last dimension of the `input` is chosen.\n\nIf :attr:`largest` is ``False`` then the `k` smallest elements are returned.\n\nA namedtuple of `(values, indices)` is returned with the `values` and\n`indices` of the largest `k` elements of each row of the `input` tensor in the\ngiven dimension `dim`.\n\nThe boolean option :attr:`sorted` if ``True``, will make sure that the returned\n`k` elements are themselves sorted\n\nArgs:\n    input (Tensor): the input tensor.\n    k (int): the k in \"top-k\"\n    dim (int, optional): the dimension to sort along\n    largest (bool, optional): controls whether to return largest or\n           smallest elements\n    sorted (bool, optional): controls whether to return the elements\n           in sorted order\n\nKeyword args:\n    out (tuple, optional): the output tuple of (Tensor, LongTensor) that can be\n        optionally given to be used as output buffers\n\nExample::\n\n    >>> x = torch.arange(1., 6.)\n    >>> x\n    tensor([ 1.,  2.,  3.,  4.,  5.])\n    >>> torch.topk(x, 3)\n    torch.return_types.topk(values=tensor([5., 4., 3.]), indices=tensor([4, 3, 2]))\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "k": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "None"
        },
        "largest": {
          "Type": null,
          "Default": "True"
        },
        "sorted": {
          "Type": null,
          "Default": "True"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None) -> (Tensor"
        },
        "LongTensor": {
          "Type": null,
          "Default": null
        }
      }
    },
    "trace": {
      "Doc": "\ntrace(input) -> Tensor\n\nReturns the sum of the elements of the diagonal of the input 2-D matrix.\n\nExample::\n\n    >>> x = torch.arange(1., 10.).view(3, 3)\n    >>> x\n    tensor([[ 1.,  2.,  3.],\n            [ 4.,  5.,  6.],\n            [ 7.,  8.,  9.]])\n    >>> torch.trace(x)\n    tensor(15.)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "transpose": {
      "Doc": "\ntranspose(input, dim0, dim1) -> Tensor\n\nReturns a tensor that is a transposed version of :attr:`input`.\nThe given dimensions :attr:`dim0` and :attr:`dim1` are swapped.\n\nIf :attr:`input` is a strided tensor then the resulting :attr:`out`\ntensor shares its underlying storage with the :attr:`input` tensor, so\nchanging the content of one would change the content of the other.\n\nIf :attr:`input` is a :ref:`sparse tensor <sparse-docs>` then the\nresulting :attr:`out` tensor *does not* share the underlying storage\nwith the :attr:`input` tensor.\n\nIf :attr:`input` is a :ref:`sparse tensor <sparse-docs>` with compressed\nlayout (SparseCSR, SparseBSR, SparseCSC or SparseBSC) the arguments\n:attr:`dim0` and :attr:`dim1` must be both batch dimensions, or must\nboth be sparse dimensions. The batch dimensions of a sparse tensor are the\ndimensions preceding the sparse dimensions.\n\n.. note::\n    Transpositions which interchange the sparse dimensions of a `SparseCSR`\n    or `SparseCSC` layout tensor will result in the layout changing between\n    the two options. Transposition of the sparse dimensions of a ` SparseBSR`\n    or `SparseBSC` layout tensor will likewise generate a result with the\n    opposite layout.\n\n\nArgs:\n    input (Tensor): the input tensor.\n    dim0 (int): the first dimension to be transposed\n    dim1 (int): the second dimension to be transposed\n\nExample::\n\n    >>> x = torch.randn(2, 3)\n    >>> x\n    tensor([[ 1.0028, -0.9893,  0.5809],\n            [-0.1669,  0.7299,  0.4942]])\n    >>> torch.transpose(x, 0, 1)\n    tensor([[ 1.0028, -0.1669],\n            [-0.9893,  0.7299],\n            [ 0.5809,  0.4942]])\n\nSee also :func:`torch.t`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim0": {
          "Type": null,
          "Default": null
        },
        "dim1": {
          "Type": null,
          "Default": null
        }
      }
    },
    "transpose_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.transpose`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "trapezoid": {
      "Doc": "\ntrapezoid(y, x=None, *, dx=None, dim=-1) -> Tensor\n\nComputes the `trapezoidal rule <https://en.wikipedia.org/wiki/Trapezoidal_rule>`_ along\n:attr:`dim`. By default the spacing between elements is assumed to be 1, but\n:attr:`dx` can be used to specify a different constant spacing, and :attr:`x` can be\nused to specify arbitrary spacing along :attr:`dim`.\n\n\nAssuming :attr:`y` is a one-dimensional tensor with elements :math:`{y_0, y_1, ..., y_n}`,\nthe default computation is\n\n.. math::\n    \\begin{aligned}\n        \\sum_{i = 1}^{n-1} \\frac{1}{2} (y_i + y_{i-1})\n    \\end{aligned}\n\nWhen :attr:`dx` is specified the computation becomes\n\n.. math::\n    \\begin{aligned}\n        \\sum_{i = 1}^{n-1} \\frac{\\Delta x}{2} (y_i + y_{i-1})\n    \\end{aligned}\n\neffectively multiplying the result by :attr:`dx`. When :attr:`x` is specified,\nassuming :attr:`x` is also a one-dimensional tensor with\nelements :math:`{x_0, x_1, ..., x_n}`, the computation becomes\n\n.. math::\n    \\begin{aligned}\n        \\sum_{i = 1}^{n-1} \\frac{(x_i - x_{i-1})}{2} (y_i + y_{i-1})\n    \\end{aligned}\n\nWhen :attr:`x` and :attr:`y` have the same size, the computation is as described above and no broadcasting is needed.\nThe broadcasting behavior of this function is as follows when their sizes are different. For both :attr:`x`\nand :attr:`y`, the function computes the difference between consecutive elements along\ndimension :attr:`dim`. This effectively creates two tensors, `x_diff` and `y_diff`, that have\nthe same shape as the original tensors except their lengths along the dimension :attr:`dim` is reduced by 1.\nAfter that, those two tensors are broadcast together to compute final output as part of the trapezoidal rule.\nSee the examples below for details.\n\n.. note::\n    The trapezoidal rule is a technique for approximating the definite integral of a function\n    by averaging its left and right Riemann sums. The approximation becomes more accurate as\n    the resolution of the partition increases.\n\nArguments:\n    y (Tensor): Values to use when computing the trapezoidal rule.\n    x (Tensor): If specified, defines spacing between values as specified above.\n\nKeyword arguments:\n    dx (float): constant spacing between values. If neither :attr:`x` or :attr:`dx`\n        are specified then this defaults to 1. Effectively multiplies the result by its value.\n    dim (int): The dimension along which to compute the trapezoidal rule.\n        The last (inner-most) dimension by default.\n\nExamples::\n\n    >>> # Computes the trapezoidal rule in 1D, spacing is implicitly 1\n    >>> y = torch.tensor([1, 5, 10])\n    >>> torch.trapezoid(y)\n    tensor(10.5)\n\n    >>> # Computes the same trapezoidal rule directly to verify\n    >>> (1 + 10 + 10) / 2\n    10.5\n\n    >>> # Computes the trapezoidal rule in 1D with constant spacing of 2\n    >>> # NOTE: the result is the same as before, but multiplied by 2\n    >>> torch.trapezoid(y, dx=2)\n    21.0\n\n    >>> # Computes the trapezoidal rule in 1D with arbitrary spacing\n    >>> x = torch.tensor([1, 3, 6])\n    >>> torch.trapezoid(y, x)\n    28.5\n\n    >>> # Computes the same trapezoidal rule directly to verify\n    >>> ((3 - 1) * (1 + 5) + (6 - 3) * (5 + 10)) / 2\n    28.5\n\n    >>> # Computes the trapezoidal rule for each row of a 3x3 matrix\n    >>> y = torch.arange(9).reshape(3, 3)\n    tensor([[0, 1, 2],\n            [3, 4, 5],\n            [6, 7, 8]])\n    >>> torch.trapezoid(y)\n    tensor([ 2., 8., 14.])\n\n    >>> # Computes the trapezoidal rule for each column of the matrix\n    >>> torch.trapezoid(y, dim=0)\n    tensor([ 6., 8., 10.])\n\n    >>> # Computes the trapezoidal rule for each row of a 3x3 ones matrix\n    >>> #   with the same arbitrary spacing\n    >>> y = torch.ones(3, 3)\n    >>> x = torch.tensor([1, 3, 6])\n    >>> torch.trapezoid(y, x)\n    array([5., 5., 5.])\n\n    >>> # Computes the trapezoidal rule for each row of a 3x3 ones matrix\n    >>> #   with different arbitrary spacing per row\n    >>> y = torch.ones(3, 3)\n    >>> x = torch.tensor([[1, 2, 3], [1, 3, 5], [1, 4, 7]])\n    >>> torch.trapezoid(y, x)\n    array([2., 4., 6.])\n",
      "Args": {
        "y": {
          "Type": null,
          "Default": null
        },
        "x": {
          "Type": null,
          "Default": "None"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dx": {
          "Type": null,
          "Default": "None"
        },
        "dim": {
          "Type": null,
          "Default": "-1"
        }
      }
    },
    "trapz": {
      "Doc": "\ntrapz(y, x, *, dim=-1) -> Tensor\n\nAlias for :func:`torch.trapezoid`.\n",
      "Args": {
        "y": {
          "Type": null,
          "Default": null
        },
        "x": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "-1"
        }
      }
    },
    "triangular_solve": {
      "Doc": "\ntriangular_solve(b, A, upper=True, transpose=False, unitriangular=False, *, out=None) -> (Tensor, Tensor)\n\nSolves a system of equations with a square upper or lower triangular invertible matrix :math:`A`\nand multiple right-hand sides :math:`b`.\n\nIn symbols, it solves :math:`AX = b` and assumes :math:`A` is square upper-triangular\n(or lower-triangular if :attr:`upper`\\ `= False`) and does not have zeros on the diagonal.\n\n`torch.triangular_solve(b, A)` can take in 2D inputs `b, A` or inputs that are\nbatches of 2D matrices. If the inputs are batches, then returns\nbatched outputs `X`\n\nIf the diagonal of :attr:`A` contains zeros or elements that are very close to zero and\n:attr:`unitriangular`\\ `= False` (default) or if the input matrix is badly conditioned,\nthe result may contain `NaN` s.\n\nSupports input of float, double, cfloat and cdouble data types.\n\n.. warning::\n\n    :func:`torch.triangular_solve` is deprecated in favor of :func:`torch.linalg.solve_triangular`\n    and will be removed in a future PyTorch release.\n    :func:`torch.linalg.solve_triangular` has its arguments reversed and does not return a\n    copy of one of the inputs.\n\n    ``X = torch.triangular_solve(B, A).solution`` should be replaced with\n\n    .. code:: python\n\n        X = torch.linalg.solve_triangular(A, B)\n\nArgs:\n    b (Tensor): multiple right-hand sides of size :math:`(*, m, k)` where\n                :math:`*` is zero of more batch dimensions\n    A (Tensor): the input triangular coefficient matrix of size :math:`(*, m, m)`\n                where :math:`*` is zero or more batch dimensions\n    upper (bool, optional): whether :math:`A` is upper or lower triangular. Default: ``True``.\n    transpose (bool, optional): solves `op(A)X = b` where `op(A) = A^T` if this flag is ``True``,\n                                and `op(A) = A` if it is ``False``. Default: ``False``.\n    unitriangular (bool, optional): whether :math:`A` is unit triangular.\n        If True, the diagonal elements of :math:`A` are assumed to be\n        1 and not referenced from :math:`A`. Default: ``False``.\n\nKeyword args:\n    out ((Tensor, Tensor), optional): tuple of two tensors to write\n        the output to. Ignored if `None`. Default: `None`.\n\nReturns:\n    A namedtuple `(solution, cloned_coefficient)` where `cloned_coefficient`\n    is a clone of :math:`A` and `solution` is the solution :math:`X` to :math:`AX = b`\n    (or whatever variant of the system of equations, depending on the keyword arguments.)\n\nExamples::\n\n    >>> A = torch.randn(2, 2).triu()\n    >>> A\n    tensor([[ 1.1527, -1.0753],\n            [ 0.0000,  0.7986]])\n    >>> b = torch.randn(2, 3)\n    >>> b\n    tensor([[-0.0210,  2.3513, -1.5492],\n            [ 1.5429,  0.7403, -1.0243]])\n    >>> torch.triangular_solve(b, A)\n    torch.return_types.triangular_solve(\n    solution=tensor([[ 1.7841,  2.9046, -2.5405],\n            [ 1.9320,  0.9270, -1.2826]]),\n    cloned_coefficient=tensor([[ 1.1527, -1.0753],\n            [ 0.0000,  0.7986]]))\n",
      "Args": {
        "b": {
          "Type": null,
          "Default": null
        },
        "A": {
          "Type": null,
          "Default": null
        },
        "upper": {
          "Type": null,
          "Default": "True"
        },
        "transpose": {
          "Type": null,
          "Default": "False"
        },
        "unitriangular": {
          "Type": null,
          "Default": "False"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None) -> (Tensor"
        },
        "Tensor": {
          "Type": null,
          "Default": null
        }
      }
    },
    "tril": {
      "Doc": "\ntril(input, diagonal=0, *, out=None) -> Tensor\n\nReturns the lower triangular part of the matrix (2-D tensor) or batch of matrices\n:attr:`input`, the other elements of the result tensor :attr:`out` are set to 0.\n\nThe lower triangular part of the matrix is defined as the elements on and\nbelow the diagonal.\n\nThe argument :attr:`diagonal` controls which diagonal to consider. If\n:attr:`diagonal` = 0, all elements on and below the main diagonal are\nretained. A positive value includes just as many diagonals above the main\ndiagonal, and similarly a negative value excludes just as many diagonals below\nthe main diagonal. The main diagonal are the set of indices\n:math:`\\lbrace (i, i) \\rbrace` for :math:`i \\in [0, \\min\\{d_{1}, d_{2}\\} - 1]` where\n:math:`d_{1}, d_{2}` are the dimensions of the matrix.\n\nArgs:\n    input (Tensor): the input tensor.\n    diagonal (int, optional): the diagonal to consider\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(3, 3)\n    >>> a\n    tensor([[-1.0813, -0.8619,  0.7105],\n            [ 0.0935,  0.1380,  2.2112],\n            [-0.3409, -0.9828,  0.0289]])\n    >>> torch.tril(a)\n    tensor([[-1.0813,  0.0000,  0.0000],\n            [ 0.0935,  0.1380,  0.0000],\n            [-0.3409, -0.9828,  0.0289]])\n\n    >>> b = torch.randn(4, 6)\n    >>> b\n    tensor([[ 1.2219,  0.5653, -0.2521, -0.2345,  1.2544,  0.3461],\n            [ 0.4785, -0.4477,  0.6049,  0.6368,  0.8775,  0.7145],\n            [ 1.1502,  3.2716, -1.1243, -0.5413,  0.3615,  0.6864],\n            [-0.0614, -0.7344, -1.3164, -0.7648, -1.4024,  0.0978]])\n    >>> torch.tril(b, diagonal=1)\n    tensor([[ 1.2219,  0.5653,  0.0000,  0.0000,  0.0000,  0.0000],\n            [ 0.4785, -0.4477,  0.6049,  0.0000,  0.0000,  0.0000],\n            [ 1.1502,  3.2716, -1.1243, -0.5413,  0.0000,  0.0000],\n            [-0.0614, -0.7344, -1.3164, -0.7648, -1.4024,  0.0000]])\n    >>> torch.tril(b, diagonal=-1)\n    tensor([[ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],\n            [ 0.4785,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],\n            [ 1.1502,  3.2716,  0.0000,  0.0000,  0.0000,  0.0000],\n            [-0.0614, -0.7344, -1.3164,  0.0000,  0.0000,  0.0000]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "diagonal": {
          "Type": null,
          "Default": "0"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "tril_indices": {
      "Doc": "\ntril_indices(row, col, offset=0, *, dtype=torch.long, device='cpu', layout=torch.strided) -> Tensor\n\nReturns the indices of the lower triangular part of a :attr:`row`-by-\n:attr:`col` matrix in a 2-by-N Tensor, where the first row contains row\ncoordinates of all indices and the second row contains column coordinates.\nIndices are ordered based on rows and then columns.\n\nThe lower triangular part of the matrix is defined as the elements on and\nbelow the diagonal.\n\nThe argument :attr:`offset` controls which diagonal to consider. If\n:attr:`offset` = 0, all elements on and below the main diagonal are\nretained. A positive value includes just as many diagonals above the main\ndiagonal, and similarly a negative value excludes just as many diagonals below\nthe main diagonal. The main diagonal are the set of indices\n:math:`\\lbrace (i, i) \\rbrace` for :math:`i \\in [0, \\min\\{d_{1}, d_{2}\\} - 1]`\nwhere :math:`d_{1}, d_{2}` are the dimensions of the matrix.\n\n.. note::\n    When running on CUDA, ``row * col`` must be less than :math:`2^{59}` to\n    prevent overflow during calculation.\n\nArgs:\n    row (``int``): number of rows in the 2-D matrix.\n    col (``int``): number of columns in the 2-D matrix.\n    offset (``int``): diagonal offset from the main diagonal.\n        Default: if not provided, 0.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, ``torch.long``.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    layout (:class:`torch.layout`, optional): currently only support ``torch.strided``.\n\nExample::\n\n    >>> a = torch.tril_indices(3, 3)\n    >>> a\n    tensor([[0, 1, 1, 2, 2, 2],\n            [0, 0, 1, 0, 1, 2]])\n\n    >>> a = torch.tril_indices(4, 3, -1)\n    >>> a\n    tensor([[1, 2, 2, 3, 3, 3],\n            [0, 0, 1, 0, 1, 2]])\n\n    >>> a = torch.tril_indices(4, 3, 1)\n    >>> a\n    tensor([[0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3],\n            [0, 1, 0, 1, 2, 0, 1, 2, 0, 1, 2]])\n",
      "Args": {
        "row": {
          "Type": null,
          "Default": null
        },
        "col": {
          "Type": null,
          "Default": null
        },
        "offset": {
          "Type": null,
          "Default": "0"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "torch.long"
        },
        "device": {
          "Type": null,
          "Default": "'cpu'"
        },
        "layout": {
          "Type": null,
          "Default": "torch.strided"
        }
      }
    },
    "triplet_margin_loss": {
      "Doc": null,
      "Args": null
    },
    "triu": {
      "Doc": "\ntriu(input, diagonal=0, *, out=None) -> Tensor\n\nReturns the upper triangular part of a matrix (2-D tensor) or batch of matrices\n:attr:`input`, the other elements of the result tensor :attr:`out` are set to 0.\n\nThe upper triangular part of the matrix is defined as the elements on and\nabove the diagonal.\n\nThe argument :attr:`diagonal` controls which diagonal to consider. If\n:attr:`diagonal` = 0, all elements on and above the main diagonal are\nretained. A positive value excludes just as many diagonals above the main\ndiagonal, and similarly a negative value includes just as many diagonals below\nthe main diagonal. The main diagonal are the set of indices\n:math:`\\lbrace (i, i) \\rbrace` for :math:`i \\in [0, \\min\\{d_{1}, d_{2}\\} - 1]` where\n:math:`d_{1}, d_{2}` are the dimensions of the matrix.\n\nArgs:\n    input (Tensor): the input tensor.\n    diagonal (int, optional): the diagonal to consider\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(3, 3)\n    >>> a\n    tensor([[ 0.2309,  0.5207,  2.0049],\n            [ 0.2072, -1.0680,  0.6602],\n            [ 0.3480, -0.5211, -0.4573]])\n    >>> torch.triu(a)\n    tensor([[ 0.2309,  0.5207,  2.0049],\n            [ 0.0000, -1.0680,  0.6602],\n            [ 0.0000,  0.0000, -0.4573]])\n    >>> torch.triu(a, diagonal=1)\n    tensor([[ 0.0000,  0.5207,  2.0049],\n            [ 0.0000,  0.0000,  0.6602],\n            [ 0.0000,  0.0000,  0.0000]])\n    >>> torch.triu(a, diagonal=-1)\n    tensor([[ 0.2309,  0.5207,  2.0049],\n            [ 0.2072, -1.0680,  0.6602],\n            [ 0.0000, -0.5211, -0.4573]])\n\n    >>> b = torch.randn(4, 6)\n    >>> b\n    tensor([[ 0.5876, -0.0794, -1.8373,  0.6654,  0.2604,  1.5235],\n            [-0.2447,  0.9556, -1.2919,  1.3378, -0.1768, -1.0857],\n            [ 0.4333,  0.3146,  0.6576, -1.0432,  0.9348, -0.4410],\n            [-0.9888,  1.0679, -1.3337, -1.6556,  0.4798,  0.2830]])\n    >>> torch.triu(b, diagonal=1)\n    tensor([[ 0.0000, -0.0794, -1.8373,  0.6654,  0.2604,  1.5235],\n            [ 0.0000,  0.0000, -1.2919,  1.3378, -0.1768, -1.0857],\n            [ 0.0000,  0.0000,  0.0000, -1.0432,  0.9348, -0.4410],\n            [ 0.0000,  0.0000,  0.0000,  0.0000,  0.4798,  0.2830]])\n    >>> torch.triu(b, diagonal=-1)\n    tensor([[ 0.5876, -0.0794, -1.8373,  0.6654,  0.2604,  1.5235],\n            [-0.2447,  0.9556, -1.2919,  1.3378, -0.1768, -1.0857],\n            [ 0.0000,  0.3146,  0.6576, -1.0432,  0.9348, -0.4410],\n            [ 0.0000,  0.0000, -1.3337, -1.6556,  0.4798,  0.2830]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "diagonal": {
          "Type": null,
          "Default": "0"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "triu_indices": {
      "Doc": "\ntriu_indices(row, col, offset=0, *, dtype=torch.long, device='cpu', layout=torch.strided) -> Tensor\n\nReturns the indices of the upper triangular part of a :attr:`row` by\n:attr:`col` matrix in a 2-by-N Tensor, where the first row contains row\ncoordinates of all indices and the second row contains column coordinates.\nIndices are ordered based on rows and then columns.\n\nThe upper triangular part of the matrix is defined as the elements on and\nabove the diagonal.\n\nThe argument :attr:`offset` controls which diagonal to consider. If\n:attr:`offset` = 0, all elements on and above the main diagonal are\nretained. A positive value excludes just as many diagonals above the main\ndiagonal, and similarly a negative value includes just as many diagonals below\nthe main diagonal. The main diagonal are the set of indices\n:math:`\\lbrace (i, i) \\rbrace` for :math:`i \\in [0, \\min\\{d_{1}, d_{2}\\} - 1]`\nwhere :math:`d_{1}, d_{2}` are the dimensions of the matrix.\n\n.. note::\n    When running on CUDA, ``row * col`` must be less than :math:`2^{59}` to\n    prevent overflow during calculation.\n\nArgs:\n    row (``int``): number of rows in the 2-D matrix.\n    col (``int``): number of columns in the 2-D matrix.\n    offset (``int``): diagonal offset from the main diagonal.\n        Default: if not provided, 0.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, ``torch.long``.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    layout (:class:`torch.layout`, optional): currently only support ``torch.strided``.\n\nExample::\n\n    >>> a = torch.triu_indices(3, 3)\n    >>> a\n    tensor([[0, 0, 0, 1, 1, 2],\n            [0, 1, 2, 1, 2, 2]])\n\n    >>> a = torch.triu_indices(4, 3, -1)\n    >>> a\n    tensor([[0, 0, 0, 1, 1, 1, 2, 2, 3],\n            [0, 1, 2, 0, 1, 2, 1, 2, 2]])\n\n    >>> a = torch.triu_indices(4, 3, 1)\n    >>> a\n    tensor([[0, 0, 1],\n            [1, 2, 2]])\n",
      "Args": {
        "row": {
          "Type": null,
          "Default": null
        },
        "col": {
          "Type": null,
          "Default": null
        },
        "offset": {
          "Type": null,
          "Default": "0"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "torch.long"
        },
        "device": {
          "Type": null,
          "Default": "'cpu'"
        },
        "layout": {
          "Type": null,
          "Default": "torch.strided"
        }
      }
    },
    "true_divide": {
      "Doc": "\ntrue_divide(dividend, divisor, *, out) -> Tensor\n\nAlias for :func:`torch.div` with ``rounding_mode=None``.\n",
      "Args": {
        "dividend": {
          "Type": null,
          "Default": null
        },
        "divisor": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": null
        }
      }
    },
    "trunc": {
      "Doc": "\ntrunc(input, *, out=None) -> Tensor\n\nReturns a new tensor with the truncated integer values of\nthe elements of :attr:`input`.\n\nFor integer inputs, follows the array-api convention of returning a\ncopy of the input tensor.\n\nArgs:\n    input (Tensor): the input tensor.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.randn(4)\n    >>> a\n    tensor([ 3.4742,  0.5466, -0.8008, -0.9079])\n    >>> torch.trunc(a)\n    tensor([ 3.,  0., -0., -0.])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "typename": {
      "Doc": null,
      "Args": {
        "o": {
          "Type": null,
          "Default": null
        }
      }
    },
    "unbind": {
      "Doc": "\nunbind(input, dim=0) -> seq\n\nRemoves a tensor dimension.\n\nReturns a tuple of all slices along a given dimension, already without it.\n\nArguments:\n    input (Tensor): the tensor to unbind\n    dim (int): dimension to remove\n\nExample::\n\n    >>> torch.unbind(torch.tensor([[1, 2, 3],\n    >>>                            [4, 5, 6],\n    >>>                            [7, 8, 9]]))\n    (tensor([1, 2, 3]), tensor([4, 5, 6]), tensor([7, 8, 9]))\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "0"
        }
      }
    },
    "unbind_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.unbind`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "unflatten": {
      "Doc": "\nunflatten(input, dim, sizes) -> Tensor\n\nExpands a dimension of the input tensor over multiple dimensions.\n\n.. seealso::\n\n    :func:`torch.flatten` the inverse of this function. It coalesces several dimensions into one.\n\nArgs:\n    input (Tensor): the input tensor.\n    dim (int): Dimension to be unflattened, specified as an index into\n         ``input.shape``.\n    sizes (Tuple[int]): New shape of the unflattened dimension.\n         One of its elements can be `-1` in which case the corresponding output\n         dimension is inferred. Otherwise, the product of ``sizes`` *must*\n         equal ``input.shape[dim]``.\n\nReturns:\n    A View of input with the specified dimension unflattened.\n\nExamples::\n    >>> torch.unflatten(torch.randn(3, 4, 1), 1, (2, 2)).shape\n    torch.Size([3, 2, 2, 1])\n    >>> torch.unflatten(torch.randn(3, 4, 1), 1, (-1, 2)).shape\n    torch.Size([3, 2, 2, 1])\n    >>> torch.unflatten(torch.randn(5, 12, 3), -1, (2, 2, 3, 1, 1)).shape\n    torch.Size([5, 2, 2, 3, 1, 1, 3])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "sizes": {
          "Type": null,
          "Default": null
        }
      }
    },
    "unfold_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.unfold`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "unify_type_list": {
      "Doc": "unify_type_list(arg0: List[c10::Type]) -> c10::Type\n",
      "Args": {
        "arg0": {
          "Type": "Type]",
          "Default": null
        }
      }
    },
    "unsafe_chunk": {
      "Doc": "\nunsafe_chunk(input, chunks, dim=0) -> List of Tensors\n\nWorks like :func:`torch.chunk` but without enforcing the autograd restrictions\non inplace modification of the outputs.\n\n.. warning::\n    This function is safe to use as long as only the input, or only the outputs\n    are modified inplace after calling this function. It is user's\n    responsibility to ensure that is the case. If both the input and one or more\n    of the outputs are modified inplace, gradients computed by autograd will be\n    silently incorrect.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "chunks": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "0"
        }
      }
    },
    "unsafe_split": {
      "Doc": "\nunsafe_split(tensor, split_size_or_sections, dim=0) -> List of Tensors\n\nWorks like :func:`torch.split` but without enforcing the autograd restrictions\non inplace modification of the outputs.\n\n.. warning::\n    This function is safe to use as long as only the input, or only the outputs\n    are modified inplace after calling this function. It is user's\n    responsibility to ensure that is the case. If both the input and one or more\n    of the outputs are modified inplace, gradients computed by autograd will be\n    silently incorrect.\n",
      "Args": {
        "tensor": {
          "Type": null,
          "Default": null
        },
        "split_size_or_sections": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": "0"
        }
      }
    },
    "unsafe_split_with_sizes": {
      "Doc": null,
      "Args": null
    },
    "unsqueeze": {
      "Doc": "\nunsqueeze(input, dim) -> Tensor\n\nReturns a new tensor with a dimension of size one inserted at the\nspecified position.\n\nThe returned tensor shares the same underlying data with this tensor.\n\nA :attr:`dim` value within the range ``[-input.dim() - 1, input.dim() + 1)``\ncan be used. Negative :attr:`dim` will correspond to :meth:`unsqueeze`\napplied at :attr:`dim` = ``dim + input.dim() + 1``.\n\nArgs:\n    input (Tensor): the input tensor.\n    dim (int): the index at which to insert the singleton dimension\n\nExample::\n\n    >>> x = torch.tensor([1, 2, 3, 4])\n    >>> torch.unsqueeze(x, 0)\n    tensor([[ 1,  2,  3,  4]])\n    >>> torch.unsqueeze(x, 1)\n    tensor([[ 1],\n            [ 2],\n            [ 3],\n            [ 4]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        }
      }
    },
    "unsqueeze_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.unsqueeze`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "use_deterministic_algorithms": {
      "Doc": " Sets whether PyTorch operations must use \"deterministic\"\n    algorithms. That is, algorithms which, given the same input, and when\n    run on the same software and hardware, always produce the same output.\n    When enabled, operations will use deterministic algorithms when available,\n    and if only nondeterministic algorithms are available they will throw a\n    :class:`RuntimeError` when called.\n\n    .. note:: This setting alone is not always enough to make an application\n        reproducible. Refer to :ref:`reproducibility` for more information.\n\n    .. note:: :func:`torch.set_deterministic_debug_mode` offers an alternative\n        interface for this feature.\n\n    The following normally-nondeterministic operations will act\n    deterministically when ``mode=True``:\n\n        * :class:`torch.nn.Conv1d` when called on CUDA tensor\n        * :class:`torch.nn.Conv2d` when called on CUDA tensor\n        * :class:`torch.nn.Conv3d` when called on CUDA tensor\n        * :class:`torch.nn.ConvTranspose1d` when called on CUDA tensor\n        * :class:`torch.nn.ConvTranspose2d` when called on CUDA tensor\n        * :class:`torch.nn.ConvTranspose3d` when called on CUDA tensor\n        * :func:`torch.bmm` when called on sparse-dense CUDA tensors\n        * :func:`torch.Tensor.__getitem__` when attempting to differentiate a CPU tensor\n          and the index is a list of tensors\n        * :func:`torch.Tensor.index_put` with ``accumulate=False``\n        * :func:`torch.Tensor.index_put` with ``accumulate=True`` when called on a CPU\n          tensor\n        * :func:`torch.Tensor.put_` with ``accumulate=True`` when called on a CPU\n          tensor\n        * :func:`torch.Tensor.scatter_add_` when called on a CUDA tensor\n        * :func:`torch.gather` when called on a CUDA tensor that requires grad\n        * :func:`torch.index_add` when called on CUDA tensor\n        * :func:`torch.index_select` when attempting to differentiate a CUDA tensor\n        * :func:`torch.repeat_interleave` when attempting to differentiate a CUDA tensor\n        * :func:`torch.Tensor.index_copy` when called on a CPU or CUDA tensor\n\n    The following normally-nondeterministic operations will throw a\n    :class:`RuntimeError` when ``mode=True``:\n\n        * :class:`torch.nn.AvgPool3d` when attempting to differentiate a CUDA tensor\n        * :class:`torch.nn.AdaptiveAvgPool2d` when attempting to differentiate a CUDA tensor\n        * :class:`torch.nn.AdaptiveAvgPool3d` when attempting to differentiate a CUDA tensor\n        * :class:`torch.nn.MaxPool3d` when attempting to differentiate a CUDA tensor\n        * :class:`torch.nn.AdaptiveMaxPool2d` when attempting to differentiate a CUDA tensor\n        * :class:`torch.nn.FractionalMaxPool2d` when attempting to differentiate a CUDA tensor\n        * :class:`torch.nn.FractionalMaxPool3d` when attempting to differentiate a CUDA tensor\n        * :class:`torch.nn.MaxUnpool1d`\n        * :class:`torch.nn.MaxUnpool2d`\n        * :class:`torch.nn.MaxUnpool3d`\n        * :func:`torch.nn.functional.interpolate` when attempting to differentiate a CUDA tensor\n          and one of the following modes is used:\n\n          - ``linear``\n          - ``bilinear``\n          - ``bicubic``\n          - ``trilinear``\n\n        * :class:`torch.nn.ReflectionPad1d` when attempting to differentiate a CUDA tensor\n        * :class:`torch.nn.ReflectionPad2d` when attempting to differentiate a CUDA tensor\n        * :class:`torch.nn.ReflectionPad3d` when attempting to differentiate a CUDA tensor\n        * :class:`torch.nn.ReplicationPad1d` when attempting to differentiate a CUDA tensor\n        * :class:`torch.nn.ReplicationPad2d` when attempting to differentiate a CUDA tensor\n        * :class:`torch.nn.ReplicationPad3d` when attempting to differentiate a CUDA tensor\n        * :class:`torch.nn.NLLLoss` when called on a CUDA tensor\n        * :class:`torch.nn.CTCLoss` when attempting to differentiate a CUDA tensor\n        * :class:`torch.nn.EmbeddingBag` when attempting to differentiate a CUDA tensor when\n          ``mode='max'``\n        * :func:`torch.Tensor.put_` when ``accumulate=False``\n        * :func:`torch.Tensor.put_` when ``accumulate=True`` and called on a CUDA tensor\n        * :func:`torch.histc` when called on a CUDA tensor\n        * :func:`torch.bincount` when called on a CUDA tensor\n        * :func:`torch.kthvalue` with called on a CUDA tensor\n        * :func:`torch.median` with indices output when called on a CUDA tensor\n        * :func:`torch.nn.functional.grid_sample` when attempting to differentiate a CUDA tensor\n        * :func:`torch.cumsum` when called on a CUDA tensor when dtype is floating point or complex\n\n    A handful of CUDA operations are nondeterministic if the CUDA version is\n    10.2 or greater, unless the environment variable ``CUBLAS_WORKSPACE_CONFIG=:4096:8``\n    or ``CUBLAS_WORKSPACE_CONFIG=:16:8`` is set. See the CUDA documentation for more\n    details: `<https://docs.nvidia.com/cuda/cublas/index.html#cublasApi_reproducibility>`_\n    If one of these environment variable configurations is not set, a :class:`RuntimeError`\n    will be raised from these operations when called with CUDA tensors:\n\n        * :func:`torch.mm`\n        * :func:`torch.mv`\n        * :func:`torch.bmm`\n\n    Note that deterministic operations tend to have worse performance than\n    nondeterministic operations.\n\n    .. note::\n\n        This flag does not detect or prevent nondeterministic behavior caused\n        by calling an inplace operation on a tensor with an internal memory\n        overlap or by giving such a tensor as the :attr:`out` argument for an\n        operation. In these cases, multiple writes of different data may target\n        a single memory location, and the order of writes is not guaranteed.\n\n    Args:\n        mode (:class:`bool`): If True, makes potentially nondeterministic\n            operations switch to a deterministic algorithm or throw a runtime\n            error. If False, allows nondeterministic operations.\n\n    Keyword args:\n        warn_only (:class:`bool`, optional): If True, operations that do not\n            have a deterministic implementation will throw a warning instead of\n            an error. Default: ``False``\n\n    Example::\n\n        >>> torch.use_deterministic_algorithms(True)\n\n        # Forward mode nondeterministic error\n        >>> # xdoctest: +SKIP\n        >>> torch.randn(10, device='cuda').kthvalue(0)\n        ...\n        RuntimeError: kthvalue CUDA does not have a deterministic implementation...\n\n        # Backward mode nondeterministic error\n        >>> torch.nn.AvgPool3d(1)(torch.randn(3, 4, 5, 6, requires_grad=True).cuda()).sum().backward()\n        ...\n        RuntimeError: avg_pool3d_backward_cuda does not have a deterministic implementation...\n    ",
      "Args": {
        "mode": {
          "Type": null,
          "Default": null
        },
        "warn_only": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "values_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.values`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "vander": {
      "Doc": "\nvander(x, N=None, increasing=False) -> Tensor\n\nGenerates a Vandermonde matrix.\n\nThe columns of the output matrix are elementwise powers of the input vector :math:`x^{(N-1)}, x^{(N-2)}, ..., x^0`.\nIf increasing is True, the order of the columns is reversed :math:`x^0, x^1, ..., x^{(N-1)}`. Such a\nmatrix with a geometric progression in each row is named for Alexandre-Theophile Vandermonde.\n\nArguments:\n    x (Tensor): 1-D input tensor.\n    N (int, optional): Number of columns in the output. If N is not specified,\n        a square array is returned :math:`(N = len(x))`.\n    increasing (bool, optional): Order of the powers of the columns. If True,\n        the powers increase from left to right, if False (the default) they are reversed.\n\nReturns:\n    Tensor: Vandermonde matrix. If increasing is False, the first column is :math:`x^{(N-1)}`,\n    the second :math:`x^{(N-2)}` and so forth. If increasing is True, the columns\n    are :math:`x^0, x^1, ..., x^{(N-1)}`.\n\nExample::\n\n    >>> x = torch.tensor([1, 2, 3, 5])\n    >>> torch.vander(x)\n    tensor([[  1,   1,   1,   1],\n            [  8,   4,   2,   1],\n            [ 27,   9,   3,   1],\n            [125,  25,   5,   1]])\n    >>> torch.vander(x, N=3)\n    tensor([[ 1,  1,  1],\n            [ 4,  2,  1],\n            [ 9,  3,  1],\n            [25,  5,  1]])\n    >>> torch.vander(x, N=3, increasing=True)\n    tensor([[ 1,  1,  1],\n            [ 1,  2,  4],\n            [ 1,  3,  9],\n            [ 1,  5, 25]])\n\n",
      "Args": {
        "x": {
          "Type": null,
          "Default": null
        },
        "N": {
          "Type": null,
          "Default": "None"
        },
        "increasing": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "var": {
      "Doc": "\nvar(input, dim, unbiased, keepdim=False, *, out=None) -> Tensor\n\nIf :attr:`unbiased` is ``True``, Bessel's correction will be used.\nOtherwise, the sample variance is calculated, without any correction.\n\nArgs:\n    input (Tensor): the input tensor.\n    \n    dim (int or tuple of ints, optional): the dimension or dimensions to reduce.\n        If ``None``, all dimensions are reduced.\n\n\nKeyword args:\n    unbiased (bool): whether to use Bessel's correction (:math:`\\delta N = 1`).\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not.\n    out (Tensor, optional): the output tensor.\n\n.. function:: var(input, unbiased) -> Tensor\n   :noindex:\n\nCalculates the variance of all elements in the :attr:`input` tensor.\n\nIf :attr:`unbiased` is ``True``, Bessel's correction will be used.\nOtherwise, the sample deviation is calculated, without any correction.\n\nArgs:\n    input (Tensor): the input tensor.\n    unbiased (bool): whether to use Bessel's correction (:math:`\\delta N = 1`).\n\nExample::\n\n    >>> a = torch.tensor([[-0.8166, -1.3802, -0.3560]])\n    >>> torch.var(a, unbiased=False)\n    tensor(0.1754)\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "unbiased": {
          "Type": null,
          "Default": null
        },
        "keepdim": {
          "Type": null,
          "Default": "False"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "var_mean": {
      "Doc": "\nvar_mean(input, dim, unbiased, keepdim=False, *, out=None) -> (Tensor, Tensor)\n\nIf :attr:`unbiased` is ``True``, Bessel's correction will be used to calculate\nthe variance. Otherwise, the sample variance is calculated, without any\ncorrection.\n\nArgs:\n    input (Tensor): the input tensor.\n    \n    dim (int or tuple of ints, optional): the dimension or dimensions to reduce.\n        If ``None``, all dimensions are reduced.\n\n\nKeyword args:\n    unbiased (bool): whether to use Bessel's correction (:math:`\\delta N = 1`).\n    keepdim (bool): whether the output tensor has :attr:`dim` retained or not.\n    out (Tensor, optional): the output tensor.\n\nReturns:\n    A tuple (var, mean) containing the variance and mean.\n\n.. function:: var_mean(input, unbiased) -> (Tensor, Tensor)\n   :noindex:\n\nCalculates the variance and mean of all elements in the :attr:`input`\ntensor.\n\nIf :attr:`unbiased` is ``True``, Bessel's correction will be used.\nOtherwise, the sample deviation is calculated, without any correction.\n\nArgs:\n    input (Tensor): the input tensor.\n    unbiased (bool): whether to use Bessel's correction (:math:`\\delta N = 1`).\n\nReturns:\n    A tuple (var, mean) containing the variance and mean.\n\nExample::\n\n    >>> a = torch.tensor([[-0.8166, -1.3802, -0.3560]])\n    >>> torch.var_mean(a, unbiased=False)\n    (tensor(0.1754), tensor(-0.8509))\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "dim": {
          "Type": null,
          "Default": null
        },
        "unbiased": {
          "Type": null,
          "Default": null
        },
        "keepdim": {
          "Type": null,
          "Default": "False"
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None) -> (Tensor"
        },
        "Tensor": {
          "Type": null,
          "Default": null
        }
      }
    },
    "vdot": {
      "Doc": "\nvdot(input, other, *, out=None) -> Tensor\n\nComputes the dot product of two 1D vectors along a dimension.\n\nIn symbols, this function computes\n\n.. math::\n\n    \\sum_{i=1}^n \\overline{x_i}y_i.\n\nwhere :math:`\\overline{x_i}` denotes the conjugate for complex\nvectors, and it is the identity for real vectors.\n\n.. note::\n\n    Unlike NumPy's vdot, torch.vdot intentionally only supports computing the dot product\n    of two 1D tensors with the same number of elements.\n\n.. seealso::\n\n        :func:`torch.linalg.vecdot` computes the dot product of two batches of vectors along a dimension.\n\nArgs:\n    input (Tensor): first tensor in the dot product, must be 1D. Its conjugate is used if it's complex.\n    other (Tensor): second tensor in the dot product, must be 1D.\n\nKeyword args:\n\n.. note:: out (Tensor, optional): the output tensor.\n\n\nExample::\n\n    >>> torch.vdot(torch.tensor([2, 3]), torch.tensor([2, 1]))\n    tensor(7)\n    >>> a = torch.tensor((1 +2j, 3 - 1j))\n    >>> b = torch.tensor((2 +1j, 4 - 0j))\n    >>> torch.vdot(a, b)\n    tensor([16.+1.j])\n    >>> torch.vdot(b, a)\n    tensor([16.-1.j])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "view_as_complex": {
      "Doc": "\nview_as_complex(input) -> Tensor\n\nReturns a view of :attr:`input` as a complex tensor. For an input complex\ntensor of :attr:`size` :math:`m1, m2, \\dots, mi, 2`, this function returns a\nnew complex tensor of :attr:`size` :math:`m1, m2, \\dots, mi` where the last\ndimension of the input tensor is expected to represent the real and imaginary\ncomponents of complex numbers.\n\n.. warning::\n    :func:`view_as_complex` is only supported for tensors with\n    :class:`torch.dtype` ``torch.float64`` and ``torch.float32``.  The input is\n    expected to have the last dimension of :attr:`size` 2. In addition, the\n    tensor must have a `stride` of 1 for its last dimension. The strides of all\n    other dimensions must be even numbers.\n\nArgs:\n    input (Tensor): the input tensor.\n\nExample::\n\n    >>> x=torch.randn(4, 2)\n    >>> x\n    tensor([[ 1.6116, -0.5772],\n            [-1.4606, -0.9120],\n            [ 0.0786, -1.7497],\n            [-0.6561, -1.6623]])\n    >>> torch.view_as_complex(x)\n    tensor([(1.6116-0.5772j), (-1.4606-0.9120j), (0.0786-1.7497j), (-0.6561-1.6623j)])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "view_as_complex_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.view_as_complex`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "view_as_real": {
      "Doc": "\nview_as_real(input) -> Tensor\n\nReturns a view of :attr:`input` as a real tensor. For an input complex tensor of\n:attr:`size` :math:`m1, m2, \\dots, mi`, this function returns a new\nreal tensor of size :math:`m1, m2, \\dots, mi, 2`, where the last dimension of size 2\nrepresents the real and imaginary components of complex numbers.\n\n.. warning::\n    :func:`view_as_real` is only supported for tensors with ``complex dtypes``.\n\nArgs:\n    input (Tensor): the input tensor.\n\nExample::\n\n    >>> x=torch.randn(4, dtype=torch.cfloat)\n    >>> x\n    tensor([(0.4737-0.3839j), (-0.2098-0.6699j), (0.3470-0.9451j), (-0.5174-1.3136j)])\n    >>> torch.view_as_real(x)\n    tensor([[ 0.4737, -0.3839],\n            [-0.2098, -0.6699],\n            [ 0.3470, -0.9451],\n            [-0.5174, -1.3136]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        }
      }
    },
    "view_as_real_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.view_as_real`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "view_copy": {
      "Doc": "\nPerforms the same operation as :func:`torch.view`, but all output tensors\nare freshly created instead of aliasing the input.\n",
      "Args": null
    },
    "vitals_enabled": {
      "Doc": "vitals_enabled() -> bool\n",
      "Args": null
    },
    "vsplit": {
      "Doc": "\nvsplit(input, indices_or_sections) -> List of Tensors\n\nSplits :attr:`input`, a tensor with two or more dimensions, into multiple tensors\nvertically according to :attr:`indices_or_sections`. Each split is a view of\n:attr:`input`.\n\nThis is equivalent to calling torch.tensor_split(input, indices_or_sections, dim=0)\n(the split dimension is 0), except that if :attr:`indices_or_sections` is an integer\nit must evenly divide the split dimension or a runtime error will be thrown.\n\nThis function is based on NumPy's :func:`numpy.vsplit`.\n\nArgs:\n    input (Tensor): tensor to split.\n    indices_or_sections (int or list or tuple of ints): See argument in :func:`torch.tensor_split`.\n\nExample::\n    >>> t = torch.arange(16.0).reshape(4,4)\n    >>> t\n    tensor([[ 0.,  1.,  2.,  3.],\n            [ 4.,  5.,  6.,  7.],\n            [ 8.,  9., 10., 11.],\n            [12., 13., 14., 15.]])\n    >>> torch.vsplit(t, 2)\n    (tensor([[0., 1., 2., 3.],\n             [4., 5., 6., 7.]]),\n     tensor([[ 8.,  9., 10., 11.],\n             [12., 13., 14., 15.]]))\n    >>> torch.vsplit(t, [3, 6])\n    (tensor([[ 0.,  1.,  2.,  3.],\n             [ 4.,  5.,  6.,  7.],\n             [ 8.,  9., 10., 11.]]),\n     tensor([[12., 13., 14., 15.]]),\n     tensor([], size=(0, 4)))\n\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "indices_or_sections": {
          "Type": null,
          "Default": null
        }
      }
    },
    "vstack": {
      "Doc": "\nvstack(tensors, *, out=None) -> Tensor\n\nStack tensors in sequence vertically (row wise).\n\nThis is equivalent to concatenation along the first axis after all 1-D tensors have been reshaped by :func:`torch.atleast_2d`.\n\nArgs:\n    tensors (sequence of Tensors): sequence of tensors to concatenate\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n\nExample::\n\n    >>> a = torch.tensor([1, 2, 3])\n    >>> b = torch.tensor([4, 5, 6])\n    >>> torch.vstack((a,b))\n    tensor([[1, 2, 3],\n            [4, 5, 6]])\n    >>> a = torch.tensor([[1],[2],[3]])\n    >>> b = torch.tensor([[4],[5],[6]])\n    >>> torch.vstack((a,b))\n    tensor([[1],\n            [2],\n            [3],\n            [4],\n            [5],\n            [6]])\n\n\n",
      "Args": {
        "tensors": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "wait": {
      "Doc": "wait(arg0: torch._C.Future) -> object\n",
      "Args": {
        "arg0": {
          "Type": "torch._C.Future",
          "Default": null
        }
      }
    },
    "where": {
      "Doc": "\nwhere(condition, x, y) -> Tensor\n\nReturn a tensor of elements selected from either :attr:`x` or :attr:`y`, depending on :attr:`condition`.\n\nThe operation is defined as:\n\n.. math::\n    \\text{out}_i = \\begin{cases}\n        \\text{x}_i & \\text{if } \\text{condition}_i \\\\\n        \\text{y}_i & \\text{otherwise} \\\\\n    \\end{cases}\n\n.. note::\n    The tensors :attr:`condition`, :attr:`x`, :attr:`y` must be :ref:`broadcastable <broadcasting-semantics>`.\n\nArguments:\n    condition (BoolTensor): When True (nonzero), yield x, otherwise yield y\n    x (Tensor or Scalar): value (if :attr:`x` is a scalar) or values selected at indices\n                          where :attr:`condition` is ``True``\n    y (Tensor or Scalar): value (if :attr:`y` is a scalar) or values selected at indices\n                          where :attr:`condition` is ``False``\n\nReturns:\n    Tensor: A tensor of shape equal to the broadcasted shape of :attr:`condition`, :attr:`x`, :attr:`y`\n\nExample::\n\n    >>> x = torch.randn(3, 2)\n    >>> y = torch.ones(3, 2)\n    >>> x\n    tensor([[-0.4620,  0.3139],\n            [ 0.3898, -0.7197],\n            [ 0.0478, -0.1657]])\n    >>> torch.where(x > 0, x, y)\n    tensor([[ 1.0000,  0.3139],\n            [ 0.3898,  1.0000],\n            [ 0.0478,  1.0000]])\n    >>> x = torch.randn(2, 2, dtype=torch.double)\n    >>> x\n    tensor([[ 1.0779,  0.0383],\n            [-0.8785, -1.1089]], dtype=torch.float64)\n    >>> torch.where(x > 0, x, 0.)\n    tensor([[1.0779, 0.0383],\n            [0.0000, 0.0000]], dtype=torch.float64)\n\n.. function:: where(condition) -> tuple of LongTensor\n   :noindex:\n\n``torch.where(condition)`` is identical to\n``torch.nonzero(condition, as_tuple=True)``.\n\n.. note::\n    See also :func:`torch.nonzero`.\n",
      "Args": {
        "condition": {
          "Type": null,
          "Default": null
        },
        "x": {
          "Type": null,
          "Default": null
        },
        "y": {
          "Type": null,
          "Default": null
        }
      }
    },
    "xlogy": {
      "Doc": "\nxlogy(input, other, *, out=None) -> Tensor\n\nAlias for :func:`torch.special.xlogy`.\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "other": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        }
      }
    },
    "zeros": {
      "Doc": "\nzeros(*size, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) -> Tensor\n\nReturns a tensor filled with the scalar value `0`, with the shape defined\nby the variable argument :attr:`size`.\n\nArgs:\n    size (int...): a sequence of integers defining the shape of the output tensor.\n        Can be a variable number of arguments or a collection like a list or tuple.\n\nKeyword args:\n    out (Tensor, optional): the output tensor.\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n        Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).\n    layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.\n        Default: ``torch.strided``.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, uses the current device for the default tensor type\n        (see :func:`torch.set_default_tensor_type`). :attr:`device` will be the CPU\n        for CPU tensor types and the current CUDA device for CUDA tensor types.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n\nExample::\n\n    >>> torch.zeros(2, 3)\n    tensor([[ 0.,  0.,  0.],\n            [ 0.,  0.,  0.]])\n\n    >>> torch.zeros(5)\n    tensor([ 0.,  0.,  0.,  0.,  0.])\n",
      "Args": {
        "*size": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "out": {
          "Type": null,
          "Default": "None"
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "torch.strided"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        }
      }
    },
    "zeros_like": {
      "Doc": "\nzeros_like(input, *, dtype=None, layout=None, device=None, requires_grad=False, memory_format=torch.preserve_format) -> Tensor\n\nReturns a tensor filled with the scalar value `0`, with the same size as\n:attr:`input`. ``torch.zeros_like(input)`` is equivalent to\n``torch.zeros(input.size(), dtype=input.dtype, layout=input.layout, device=input.device)``.\n\n.. warning::\n    As of 0.4, this function does not support an :attr:`out` keyword. As an alternative,\n    the old ``torch.zeros_like(input, out=output)`` is equivalent to\n    ``torch.zeros(input.size(), out=output)``.\n\nArgs:\n    input (Tensor): the size of :attr:`input` will determine size of the output tensor.\n\nKeyword args:\n    dtype (:class:`torch.dtype`, optional): the desired data type of returned Tensor.\n        Default: if ``None``, defaults to the dtype of :attr:`input`.\n    layout (:class:`torch.layout`, optional): the desired layout of returned tensor.\n        Default: if ``None``, defaults to the layout of :attr:`input`.\n    device (:class:`torch.device`, optional): the desired device of returned tensor.\n        Default: if ``None``, defaults to the device of :attr:`input`.\n    requires_grad (bool, optional): If autograd should record operations on the\n        returned tensor. Default: ``False``.\n    memory_format (:class:`torch.memory_format`, optional): the desired memory format of\n        returned Tensor. Default: ``torch.preserve_format``.\n\nExample::\n\n    >>> input = torch.empty(2, 3)\n    >>> torch.zeros_like(input)\n    tensor([[ 0.,  0.,  0.],\n            [ 0.,  0.,  0.]])\n",
      "Args": {
        "input": {
          "Type": null,
          "Default": null
        },
        "*": {
          "Type": null,
          "Default": null
        },
        "dtype": {
          "Type": null,
          "Default": "None"
        },
        "layout": {
          "Type": null,
          "Default": "None"
        },
        "device": {
          "Type": null,
          "Default": "None"
        },
        "requires_grad": {
          "Type": null,
          "Default": "False"
        },
        "memory_format": {
          "Type": null,
          "Default": "torch.preserve_format"
        }
      }
    }
  },
  "Modules": {
    "linalg": {
      "Doc": null,
      "Functions": {
        "cholesky": {
          "Doc": "\nlinalg.cholesky(A, *, upper=False, out=None) -> Tensor\n\nComputes the Cholesky decomposition of a complex Hermitian or real symmetric positive-definite matrix.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthe **Cholesky decomposition** of a complex Hermitian or real symmetric positive-definite matrix\n:math:`A \\in \\mathbb{K}^{n \\times n}` is defined as\n\n.. math::\n\n    A = LL^{\\text{H}}\\mathrlap{\\qquad L \\in \\mathbb{K}^{n \\times n}}\n\nwhere :math:`L` is a lower triangular matrix with real positive diagonal (even in the complex case) and\n:math:`L^{\\text{H}}` is the conjugate transpose when :math:`L` is complex, and the transpose when :math:`L` is real-valued.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\n\n.. note:: When inputs are on a CUDA device, this function synchronizes that device with the CPU.\n\n\n.. seealso::\n\n        :func:`torch.linalg.cholesky_ex` for a version of this operation that\n        skips the (slow) error checking by default and instead returns the debug\n        information. This makes it a faster way to check if a matrix is\n        positive-definite.\n\n        :func:`torch.linalg.eigh` for a different decomposition of a Hermitian matrix.\n        The eigenvalue decomposition gives more information about the matrix but it\n        slower to compute than the Cholesky decomposition.\n\nArgs:\n    A (Tensor): tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions\n                consisting of symmetric or Hermitian positive-definite matrices.\n\nKeyword args:\n    upper (bool, optional): whether to return an upper triangular matrix.\n        The tensor returned with upper=True is the conjugate transpose of the tensor\n        returned with upper=False.\n    out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.\n\nRaises:\n    RuntimeError: if the :attr:`A` matrix or any matrix in a batched :attr:`A` is not Hermitian\n                  (resp. symmetric) positive-definite. If :attr:`A` is a batch of matrices,\n                  the error message will include the batch index of the first matrix that fails\n                  to meet this condition.\n\nExamples::\n\n    >>> A = torch.randn(2, 2, dtype=torch.complex128)\n    >>> A = A @ A.T.conj() + torch.eye(2) # creates a Hermitian positive-definite matrix\n    >>> A\n    tensor([[2.5266+0.0000j, 1.9586-2.0626j],\n            [1.9586+2.0626j, 9.4160+0.0000j]], dtype=torch.complex128)\n    >>> L = torch.linalg.cholesky(A)\n    >>> L\n    tensor([[1.5895+0.0000j, 0.0000+0.0000j],\n            [1.2322+1.2976j, 2.4928+0.0000j]], dtype=torch.complex128)\n    >>> torch.dist(L @ L.T.conj(), A)\n    tensor(4.4692e-16, dtype=torch.float64)\n\n    >>> A = torch.randn(3, 2, 2, dtype=torch.float64)\n    >>> A = A @ A.mT + torch.eye(2)  # batch of symmetric positive-definite matrices\n    >>> L = torch.linalg.cholesky(A)\n    >>> torch.dist(L @ L.mT, A)\n    tensor(5.8747e-16, dtype=torch.float64)\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "upper": {
              "Type": null,
              "Default": "False"
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "cholesky_ex": {
          "Doc": "\nlinalg.cholesky_ex(A, *, upper=False, check_errors=False, out=None) -> (Tensor, Tensor)\n\nComputes the Cholesky decomposition of a complex Hermitian or real\nsymmetric positive-definite matrix.\n\nThis function skips the (slow) error checking and error message construction\nof :func:`torch.linalg.cholesky`, instead directly returning the LAPACK\nerror codes as part of a named tuple ``(L, info)``. This makes this function\na faster way to check if a matrix is positive-definite, and it provides an\nopportunity to handle decomposition errors more gracefully or performantly\nthan :func:`torch.linalg.cholesky` does.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\nIf :attr:`A` is not a Hermitian positive-definite matrix, or if it's a batch of matrices\nand one or more of them is not a Hermitian positive-definite matrix,\nthen ``info`` stores a positive integer for the corresponding matrix.\nThe positive integer indicates the order of the leading minor that is not positive-definite,\nand the decomposition could not be completed.\n``info`` filled with zeros indicates that the decomposition was successful.\nIf ``check_errors=True`` and ``info`` contains positive integers, then a RuntimeError is thrown.\n\n\n.. note:: When the inputs are on a CUDA device, this function synchronizes only when :attr:`check_errors`\\ `= True`.\n\n.. warning:: This function is \"experimental\" and it may change in a future PyTorch release.\n\n\n.. seealso::\n        :func:`torch.linalg.cholesky` is a NumPy compatible variant that always checks for errors.\n\nArgs:\n    A (Tensor): the Hermitian `n \\times n` matrix or the batch of such matrices of size\n                    `(*, n, n)` where `*` is one or more batch dimensions.\n\nKeyword args:\n    upper (bool, optional): whether to return an upper triangular matrix.\n        The tensor returned with upper=True is the conjugate transpose of the tensor\n        returned with upper=False.\n    check_errors (bool, optional): controls whether to check the content of ``infos``. Default: `False`.\n    out (tuple, optional): tuple of two tensors to write the output to. Ignored if `None`. Default: `None`.\n\nExamples::\n\n    >>> A = torch.randn(2, 2, dtype=torch.complex128)\n    >>> A = A @ A.t().conj()  # creates a Hermitian positive-definite matrix\n    >>> L, info = torch.linalg.cholesky_ex(A)\n    >>> A\n    tensor([[ 2.3792+0.0000j, -0.9023+0.9831j],\n            [-0.9023-0.9831j,  0.8757+0.0000j]], dtype=torch.complex128)\n    >>> L\n    tensor([[ 1.5425+0.0000j,  0.0000+0.0000j],\n            [-0.5850-0.6374j,  0.3567+0.0000j]], dtype=torch.complex128)\n    >>> info\n    tensor(0, dtype=torch.int32)\n\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "upper": {
              "Type": null,
              "Default": "False"
            },
            "check_errors": {
              "Type": null,
              "Default": "False"
            },
            "out": {
              "Type": null,
              "Default": "None) -> (Tensor"
            },
            "Tensor": {
              "Type": null,
              "Default": null
            }
          }
        },
        "cond": {
          "Doc": "\nlinalg.cond(A, p=None, *, out=None) -> Tensor\n\nComputes the condition number of a matrix with respect to a matrix norm.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthe **condition number** :math:`\\kappa` of a matrix\n:math:`A \\in \\mathbb{K}^{n \\times n}` is defined as\n\n.. math::\n\n    \\kappa(A) = \\|A\\|_p\\|A^{-1}\\|_p\n\nThe condition number of :attr:`A` measures the numerical stability of the linear system `AX = B`\nwith respect to a matrix norm.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\n:attr:`p` defines the matrix norm that is computed. The following norms are supported:\n\n=========    =================================\n:attr:`p`    matrix norm\n=========    =================================\n`None`       `2`-norm (largest singular value)\n`'fro'`      Frobenius norm\n`'nuc'`      nuclear norm\n`inf`        `max(sum(abs(x), dim=1))`\n`-inf`       `min(sum(abs(x), dim=1))`\n`1`          `max(sum(abs(x), dim=0))`\n`-1`         `min(sum(abs(x), dim=0))`\n`2`          largest singular value\n`-2`         smallest singular value\n=========    =================================\n\nwhere `inf` refers to `float('inf')`, NumPy's `inf` object, or any equivalent object.\n\nFor :attr:`p` is one of `('fro', 'nuc', inf, -inf, 1, -1)`, this function uses\n:func:`torch.linalg.norm` and :func:`torch.linalg.inv`.\nAs such, in this case, the matrix (or every matrix in the batch) :attr:`A` has to be square\nand invertible.\n\nFor :attr:`p` in `(2, -2)`, this function can be computed in terms of the singular values\n:math:`\\sigma_1 \\geq \\ldots \\geq \\sigma_n`\n\n.. math::\n\n    \\kappa_2(A) = \\frac{\\sigma_1}{\\sigma_n}\\qquad \\kappa_{-2}(A) = \\frac{\\sigma_n}{\\sigma_1}\n\nIn these cases, it is computed using :func:`torch.linalg.svdvals`. For these norms, the matrix\n(or every matrix in the batch) :attr:`A` may have any shape.\n\n.. note :: When inputs are on a CUDA device, this function synchronizes that device with the CPU\n           if :attr:`p` is one of `('fro', 'nuc', inf, -inf, 1, -1)`.\n\n.. seealso::\n\n        :func:`torch.linalg.solve` for a function that solves linear systems of square matrices.\n\n        :func:`torch.linalg.lstsq` for a function that solves linear systems of general matrices.\n\nArgs:\n    A (Tensor): tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions\n                    for :attr:`p` in `(2, -2)`, and of shape `(*, n, n)` where every matrix\n                    is invertible for :attr:`p` in `('fro', 'nuc', inf, -inf, 1, -1)`.\n    p (int, inf, -inf, 'fro', 'nuc', optional):\n        the type of the matrix norm to use in the computations (see above). Default: `None`\n\nKeyword args:\n    out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.\n\nReturns:\n    A real-valued tensor, even when :attr:`A` is complex.\n\nRaises:\n    RuntimeError:\n        if :attr:`p` is one of `('fro', 'nuc', inf, -inf, 1, -1)`\n        and the :attr:`A` matrix or any matrix in the batch :attr:`A` is not square\n        or invertible.\n\nExamples::\n\n    >>> A = torch.randn(3, 4, 4, dtype=torch.complex64)\n    >>> torch.linalg.cond(A)\n    >>> A = torch.tensor([[1., 0, -1], [0, 1, 0], [1, 0, 1]])\n    >>> torch.linalg.cond(A)\n    tensor([1.4142])\n    >>> torch.linalg.cond(A, 'fro')\n    tensor(3.1623)\n    >>> torch.linalg.cond(A, 'nuc')\n    tensor(9.2426)\n    >>> torch.linalg.cond(A, float('inf'))\n    tensor(2.)\n    >>> torch.linalg.cond(A, float('-inf'))\n    tensor(1.)\n    >>> torch.linalg.cond(A, 1)\n    tensor(2.)\n    >>> torch.linalg.cond(A, -1)\n    tensor(1.)\n    >>> torch.linalg.cond(A, 2)\n    tensor([1.4142])\n    >>> torch.linalg.cond(A, -2)\n    tensor([0.7071])\n\n    >>> A = torch.randn(2, 3, 3)\n    >>> torch.linalg.cond(A)\n    tensor([[9.5917],\n            [3.2538]])\n    >>> A = torch.randn(2, 3, 3, dtype=torch.complex64)\n    >>> torch.linalg.cond(A)\n    tensor([[4.6245],\n            [4.5671]])\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "p": {
              "Type": null,
              "Default": "None"
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "cross": {
          "Doc": "\nlinalg.cross(input, other, *, dim=-1, out=None) -> Tensor\n\n\nComputes the cross product of two 3-dimensional vectors.\n\nSupports input of float, double, cfloat and cdouble dtypes. Also supports batches\nof vectors, for which it computes the product along the dimension :attr:`dim`.\nIt broadcasts over the batch dimensions.\n\nArgs:\n    input (Tensor): the first input tensor.\n    other (Tensor): the second input tensor.\n    dim  (int, optional): the dimension along which to take the cross-product. Default: `-1`.\n\nKeyword args:\n    out (Tensor, optional): the output tensor. Ignored if `None`. Default: `None`.\n\nExample:\n    >>> a = torch.randn(4, 3)\n    >>> a\n    tensor([[-0.3956,  1.1455,  1.6895],\n            [-0.5849,  1.3672,  0.3599],\n            [-1.1626,  0.7180, -0.0521],\n            [-0.1339,  0.9902, -2.0225]])\n    >>> b = torch.randn(4, 3)\n    >>> b\n    tensor([[-0.0257, -1.4725, -1.2251],\n            [-1.1479, -0.7005, -1.9757],\n            [-1.3904,  0.3726, -1.1836],\n            [-0.9688, -0.7153,  0.2159]])\n    >>> torch.linalg.cross(a, b)\n    tensor([[ 1.0844, -0.5281,  0.6120],\n            [-2.4490, -1.5687,  1.9792],\n            [-0.8304, -1.3037,  0.5650],\n            [-1.2329,  1.9883,  1.0551]])\n    >>> a = torch.randn(1, 3)  # a is broadcast to match shape of b\n    >>> a\n    tensor([[-0.9941, -0.5132,  0.5681]])\n    >>> torch.linalg.cross(a, b)\n    tensor([[ 1.4653, -1.2325,  1.4507],\n            [ 1.4119, -2.6163,  0.1073],\n            [ 0.3957, -1.9666, -1.0840],\n            [ 0.2956, -0.3357,  0.2139]])\n",
          "Args": {
            "input": {
              "Type": null,
              "Default": null
            },
            "other": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "dim": {
              "Type": null,
              "Default": "-1"
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "det": {
          "Doc": "\nlinalg.det(A, *, out=None) -> Tensor\n\nComputes the determinant of a square matrix.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\n.. seealso::\n\n        :func:`torch.linalg.slogdet` computes the sign (resp. angle) and natural logarithm of the\n        absolute value of the determinant of real-valued (resp. complex) square matrices.\n\nArgs:\n    A (Tensor): tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions.\n\nKeyword args:\n    out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.\n\nExamples::\n\n    >>> A = torch.randn(3, 3)\n    >>> torch.linalg.det(A)\n    tensor(0.0934)\n\n    >>> A = torch.randn(3, 2, 2)\n    >>> torch.linalg.det(A)\n    tensor([1.1990, 0.4099, 0.7386])\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "diagonal": {
          "Doc": "\nlinalg.diagonal(A, *, offset=0, dim1=-2, dim2=-1) -> Tensor\n\nAlias for :func:`torch.diagonal` with defaults :attr:`dim1`\\ `= -2`, :attr:`dim2`\\ `= -1`.\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "offset": {
              "Type": null,
              "Default": "0"
            },
            "dim1": {
              "Type": null,
              "Default": "-2"
            },
            "dim2": {
              "Type": null,
              "Default": "-1"
            }
          }
        },
        "eig": {
          "Doc": "\nlinalg.eig(A, *, out=None) -> (Tensor, Tensor)\n\nComputes the eigenvalue decomposition of a square matrix if it exists.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthe **eigenvalue decomposition** of a square matrix\n:math:`A \\in \\mathbb{K}^{n \\times n}` (if it exists) is defined as\n\n.. math::\n\n    A = V \\operatorname{diag}(\\Lambda) V^{-1}\\mathrlap{\\qquad V \\in \\mathbb{C}^{n \\times n}, \\Lambda \\in \\mathbb{C}^n}\n\nThis decomposition exists if and only if :math:`A` is `diagonalizable`_.\nThis is the case when all its eigenvalues are different.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\n.. note:: The eigenvalues and eigenvectors of a real matrix may be complex.\n\n\n.. note:: When inputs are on a CUDA device, this function synchronizes that device with the CPU.\n\n\n.. warning:: This function assumes that :attr:`A` is `diagonalizable`_ (for example, when all the\n             eigenvalues are different). If it is not diagonalizable, the returned\n             eigenvalues will be correct but :math:`A \\neq V \\operatorname{diag}(\\Lambda)V^{-1}`.\n\n.. warning:: The returned eigenvectors are normalized to have norm `1`.\n             Even then, the eigenvectors of a matrix are not unique, nor are they continuous with respect to\n             :attr:`A`. Due to this lack of uniqueness, different hardware and software may compute\n             different eigenvectors.\n\n             This non-uniqueness is caused by the fact that multiplying an eigenvector by\n             by :math:`e^{i \\phi}, \\phi \\in \\mathbb{R}` produces another set of valid eigenvectors\n             of the matrix.  For this reason, the loss function shall not depend on the phase of the\n             eigenvectors, as this quantity is not well-defined.\n             This is checked when computing the gradients of this function. As such,\n             when inputs are on a CUDA device, this function synchronizes that device with the CPU\n             when computing the gradients.\n             This is checked when computing the gradients of this function. As such,\n             when inputs are on a CUDA device, the computation of the gradients\n             of this function synchronizes that device with the CPU.\n\n\n.. warning:: Gradients computed using the `eigenvectors` tensor will only be finite when\n             :attr:`A` has distinct eigenvalues.\n             Furthermore, if the distance between any two eigenvalues is close to zero,\n             the gradient will be numerically unstable, as it depends on the eigenvalues\n             :math:`\\lambda_i` through the computation of\n             :math:`\\frac{1}{\\min_{i \\neq j} \\lambda_i - \\lambda_j}`.\n\n.. seealso::\n\n        :func:`torch.linalg.eigvals` computes only the eigenvalues.\n        Unlike :func:`torch.linalg.eig`, the gradients of :func:`~eigvals` are always\n        numerically stable.\n\n        :func:`torch.linalg.eigh` for a (faster) function that computes the eigenvalue decomposition\n        for Hermitian and symmetric matrices.\n\n        :func:`torch.linalg.svd` for a function that computes another type of spectral\n        decomposition that works on matrices of any shape.\n\n        :func:`torch.linalg.qr` for another (much faster) decomposition that works on matrices of\n        any shape.\n\nArgs:\n    A (Tensor): tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions\n                consisting of diagonalizable matrices.\n\nKeyword args:\n    out (tuple, optional): output tuple of two tensors. Ignored if `None`. Default: `None`.\n\nReturns:\n    A named tuple `(eigenvalues, eigenvectors)` which corresponds to :math:`\\Lambda` and :math:`V` above.\n\n    `eigenvalues` and `eigenvectors` will always be complex-valued, even when :attr:`A` is real. The eigenvectors\n    will be given by the columns of `eigenvectors`.\n\nExamples::\n\n    >>> A = torch.randn(2, 2, dtype=torch.complex128)\n    >>> A\n    tensor([[ 0.9828+0.3889j, -0.4617+0.3010j],\n            [ 0.1662-0.7435j, -0.6139+0.0562j]], dtype=torch.complex128)\n    >>> L, V = torch.linalg.eig(A)\n    >>> L\n    tensor([ 1.1226+0.5738j, -0.7537-0.1286j], dtype=torch.complex128)\n    >>> V\n    tensor([[ 0.9218+0.0000j,  0.1882-0.2220j],\n            [-0.0270-0.3867j,  0.9567+0.0000j]], dtype=torch.complex128)\n    >>> torch.dist(V @ torch.diag(L) @ torch.linalg.inv(V), A)\n    tensor(7.7119e-16, dtype=torch.float64)\n\n    >>> A = torch.randn(3, 2, 2, dtype=torch.float64)\n    >>> L, V = torch.linalg.eig(A)\n    >>> torch.dist(V @ torch.diag_embed(L) @ torch.linalg.inv(V), A)\n    tensor(3.2841e-16, dtype=torch.float64)\n\n.. _diagonalizable:\n    https://en.wikipedia.org/wiki/Diagonalizable_matrix#Definition\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "out": {
              "Type": null,
              "Default": "None) -> (Tensor"
            },
            "Tensor": {
              "Type": null,
              "Default": null
            }
          }
        },
        "eigh": {
          "Doc": "\nlinalg.eigh(A, UPLO='L', *, out=None) -> (Tensor, Tensor)\n\nComputes the eigenvalue decomposition of a complex Hermitian or real symmetric matrix.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthe **eigenvalue decomposition** of a complex Hermitian or real symmetric matrix\n:math:`A \\in \\mathbb{K}^{n \\times n}` is defined as\n\n.. math::\n\n    A = Q \\operatorname{diag}(\\Lambda) Q^{\\text{H}}\\mathrlap{\\qquad Q \\in \\mathbb{K}^{n \\times n}, \\Lambda \\in \\mathbb{R}^n}\n\nwhere :math:`Q^{\\text{H}}` is the conjugate transpose when :math:`Q` is complex, and the transpose when :math:`Q` is real-valued.\n:math:`Q` is orthogonal in the real case and unitary in the complex case.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\n:attr:`A` is assumed to be Hermitian (resp. symmetric), but this is not checked internally, instead:\n\n- If :attr:`UPLO`\\ `= 'L'` (default), only the lower triangular part of the matrix is used in the computation.\n- If :attr:`UPLO`\\ `= 'U'`, only the upper triangular part of the matrix is used.\n\nThe eigenvalues are returned in ascending order.\n\n\n.. note:: When inputs are on a CUDA device, this function synchronizes that device with the CPU.\n\n\n.. note:: The eigenvalues of real symmetric or complex Hermitian matrices are always real.\n\n.. warning:: The eigenvectors of a symmetric matrix are not unique, nor are they continuous with\n             respect to :attr:`A`. Due to this lack of uniqueness, different hardware and\n             software may compute different eigenvectors.\n\n             This non-uniqueness is caused by the fact that multiplying an eigenvector by\n             `-1` in the real case or by :math:`e^{i \\phi}, \\phi \\in \\mathbb{R}` in the complex\n             case produces another set of valid eigenvectors of the matrix.\n             For this reason, the loss function shall not depend on the phase of the eigenvectors, as\n             this quantity is not well-defined.\n             This is checked for complex inputs when computing the gradients of this function. As such,\n             when inputs are complex and are on a CUDA device, the computation of the gradients\n             of this function synchronizes that device with the CPU.\n\n.. warning:: Gradients computed using the `eigenvectors` tensor will only be finite when\n             :attr:`A` has distinct eigenvalues.\n             Furthermore, if the distance between any two eigenvalues is close to zero,\n             the gradient will be numerically unstable, as it depends on the eigenvalues\n             :math:`\\lambda_i` through the computation of\n             :math:`\\frac{1}{\\min_{i \\neq j} \\lambda_i - \\lambda_j}`.\n\n.. seealso::\n\n        :func:`torch.linalg.eigvalsh` computes only the eigenvalues of a Hermitian matrix.\n        Unlike :func:`torch.linalg.eigh`, the gradients of :func:`~eigvalsh` are always\n        numerically stable.\n\n        :func:`torch.linalg.cholesky` for a different decomposition of a Hermitian matrix.\n        The Cholesky decomposition gives less information about the matrix but is much faster\n        to compute than the eigenvalue decomposition.\n\n        :func:`torch.linalg.eig` for a (slower) function that computes the eigenvalue decomposition\n        of a not necessarily Hermitian square matrix.\n\n        :func:`torch.linalg.svd` for a (slower) function that computes the more general SVD\n        decomposition of matrices of any shape.\n\n        :func:`torch.linalg.qr` for another (much faster) decomposition that works on general\n        matrices.\n\nArgs:\n    A (Tensor): tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions\n                consisting of symmetric or Hermitian matrices.\n    UPLO ('L', 'U', optional): controls whether to use the upper or lower triangular part\n                               of :attr:`A` in the computations. Default: `'L'`.\n\nKeyword args:\n    out (tuple, optional): output tuple of two tensors. Ignored if `None`. Default: `None`.\n\nReturns:\n    A named tuple `(eigenvalues, eigenvectors)` which corresponds to :math:`\\Lambda` and :math:`Q` above.\n\n    `eigenvalues` will always be real-valued, even when :attr:`A` is complex.\n    It will also be ordered in ascending order.\n\n    `eigenvectors` will have the same dtype as :attr:`A` and will contain the eigenvectors as its columns.\n\nExamples::\n    >>> A = torch.randn(2, 2, dtype=torch.complex128)\n    >>> A = A + A.T.conj()  # creates a Hermitian matrix\n    >>> A\n    tensor([[2.9228+0.0000j, 0.2029-0.0862j],\n            [0.2029+0.0862j, 0.3464+0.0000j]], dtype=torch.complex128)\n    >>> L, Q = torch.linalg.eigh(A)\n    >>> L\n    tensor([0.3277, 2.9415], dtype=torch.float64)\n    >>> Q\n    tensor([[-0.0846+-0.0000j, -0.9964+0.0000j],\n            [ 0.9170+0.3898j, -0.0779-0.0331j]], dtype=torch.complex128)\n    >>> torch.dist(Q @ torch.diag(L.cdouble()) @ Q.T.conj(), A)\n    tensor(6.1062e-16, dtype=torch.float64)\n\n    >>> A = torch.randn(3, 2, 2, dtype=torch.float64)\n    >>> A = A + A.mT  # creates a batch of symmetric matrices\n    >>> L, Q = torch.linalg.eigh(A)\n    >>> torch.dist(Q @ torch.diag_embed(L) @ Q.mH, A)\n    tensor(1.5423e-15, dtype=torch.float64)\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "UPLO": {
              "Type": null,
              "Default": "'L'"
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "out": {
              "Type": null,
              "Default": "None) -> (Tensor"
            },
            "Tensor": {
              "Type": null,
              "Default": null
            }
          }
        },
        "eigvals": {
          "Doc": "\nlinalg.eigvals(A, *, out=None) -> Tensor\n\nComputes the eigenvalues of a square matrix.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthe **eigenvalues** of a square matrix :math:`A \\in \\mathbb{K}^{n \\times n}` are defined\nas the roots (counted with multiplicity) of the polynomial `p` of degree `n` given by\n\n.. math::\n\n    p(\\lambda) = \\operatorname{det}(A - \\lambda \\mathrm{I}_n)\\mathrlap{\\qquad \\lambda \\in \\mathbb{C}}\n\nwhere :math:`\\mathrm{I}_n` is the `n`-dimensional identity matrix.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\n.. note:: The eigenvalues of a real matrix may be complex, as the roots of a real polynomial may be complex.\n\n          The eigenvalues of a matrix are always well-defined, even when the matrix is not diagonalizable.\n\n\n.. note:: When inputs are on a CUDA device, this function synchronizes that device with the CPU.\n\n\n.. seealso::\n\n        :func:`torch.linalg.eig` computes the full eigenvalue decomposition.\n\nArgs:\n    A (Tensor): tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions.\n\nKeyword args:\n    out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.\n\nReturns:\n    A complex-valued tensor cointaining the eigenvalues even when :attr:`A` is real.\n\nExamples::\n\n    >>> A = torch.randn(2, 2, dtype=torch.complex128)\n    >>> L = torch.linalg.eigvals(A)\n    >>> L\n    tensor([ 1.1226+0.5738j, -0.7537-0.1286j], dtype=torch.complex128)\n\n    >>> torch.dist(L, torch.linalg.eig(A).eigenvalues)\n    tensor(2.4576e-07)\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "eigvalsh": {
          "Doc": "\nlinalg.eigvalsh(A, UPLO='L', *, out=None) -> Tensor\n\nComputes the eigenvalues of a complex Hermitian or real symmetric matrix.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthe **eigenvalues** of a complex Hermitian or real symmetric  matrix :math:`A \\in \\mathbb{K}^{n \\times n}`\nare defined as the roots (counted with multiplicity) of the polynomial `p` of degree `n` given by\n\n.. math::\n\n    p(\\lambda) = \\operatorname{det}(A - \\lambda \\mathrm{I}_n)\\mathrlap{\\qquad \\lambda \\in \\mathbb{R}}\n\nwhere :math:`\\mathrm{I}_n` is the `n`-dimensional identity matrix.\nThe eigenvalues of a real symmetric or complex Hermitian matrix are always real.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\nThe eigenvalues are returned in ascending order.\n\n:attr:`A` is assumed to be Hermitian (resp. symmetric), but this is not checked internally, instead:\n\n- If :attr:`UPLO`\\ `= 'L'` (default), only the lower triangular part of the matrix is used in the computation.\n- If :attr:`UPLO`\\ `= 'U'`, only the upper triangular part of the matrix is used.\n\n\n.. note:: When inputs are on a CUDA device, this function synchronizes that device with the CPU.\n\n\n.. seealso::\n\n        :func:`torch.linalg.eigh` computes the full eigenvalue decomposition.\n\nArgs:\n    A (Tensor): tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions\n                consisting of symmetric or Hermitian matrices.\n    UPLO ('L', 'U', optional): controls whether to use the upper or lower triangular part\n                               of :attr:`A` in the computations. Default: `'L'`.\n\nKeyword args:\n    out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.\n\nReturns:\n    A real-valued tensor cointaining the eigenvalues even when :attr:`A` is complex.\n    The eigenvalues are returned in ascending order.\n\nExamples::\n\n    >>> A = torch.randn(2, 2, dtype=torch.complex128)\n    >>> A = A + A.T.conj()  # creates a Hermitian matrix\n    >>> A\n    tensor([[2.9228+0.0000j, 0.2029-0.0862j],\n            [0.2029+0.0862j, 0.3464+0.0000j]], dtype=torch.complex128)\n    >>> torch.linalg.eigvalsh(A)\n    tensor([0.3277, 2.9415], dtype=torch.float64)\n\n    >>> A = torch.randn(3, 2, 2, dtype=torch.float64)\n    >>> A = A + A.mT  # creates a batch of symmetric matrices\n    >>> torch.linalg.eigvalsh(A)\n    tensor([[ 2.5797,  3.4629],\n            [-4.1605,  1.3780],\n            [-3.1113,  2.7381]], dtype=torch.float64)\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "UPLO": {
              "Type": null,
              "Default": "'L'"
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "householder_product": {
          "Doc": "\nhouseholder_product(A, tau, *, out=None) -> Tensor\n\nComputes the first `n` columns of a product of Householder matrices.\n\nLet :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`, and\nlet :math:`V \\in \\mathbb{K}^{m \\times n}` be a matrix with columns :math:`v_i \\in \\mathbb{K}^m`\nfor :math:`i=1,\\ldots,m` with :math:`m \\geq n`. Denote by :math:`w_i` the vector resulting from\nzeroing out the first :math:`i-1` compontents of :math:`v_i` and setting to `1` the :math:`i`-th.\nFor a vector :math:`\\tau \\in \\mathbb{K}^k` with :math:`k \\leq n`, this function computes the\nfirst :math:`n` columns of the matrix\n\n.. math::\n\n    H_1H_2 ... H_k \\qquad\\text{with}\\qquad H_i = \\mathrm{I}_m - \\tau_i w_i w_i^{\\text{H}}\n\nwhere :math:`\\mathrm{I}_m` is the `m`-dimensional identity matrix and :math:`w^{\\text{H}}` is the\nconjugate transpose when :math:`w` is complex, and the transpose when :math:`w` is real-valued.\nThe output matrix is the same size as the input matrix :attr:`A`.\n\nSee `Representation of Orthogonal or Unitary Matrices`_ for further details.\n\nSupports inputs of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if the inputs are batches of matrices then\nthe output has the same batch dimensions.\n\n.. seealso::\n\n        :func:`torch.geqrf` can be used together with this function to form the `Q` from the\n        :func:`~qr` decomposition.\n\n        :func:`torch.ormqr` is a related function that computes the matrix multiplication\n        of a product of Householder matrices with another matrix.\n        However, that function is not supported by autograd.\n\n.. warning::\n    Gradient computations are only well-defined if :math:`tau_i \\neq \\frac{1}{||v_i||^2}`.\n    If this condition is not met, no error will be thrown, but the gradient produced may contain `NaN`.\n\nArgs:\n    A (Tensor): tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions.\n    tau (Tensor): tensor of shape `(*, k)` where `*` is zero or more batch dimensions.\n\nKeyword args:\n    out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.\n\nRaises:\n    RuntimeError: if :attr:`A` doesn't satisfy the requirement `m >= n`,\n                  or :attr:`tau` doesn't satisfy the requirement `n >= k`.\n\nExamples::\n\n    >>> A = torch.randn(2, 2)\n    >>> h, tau = torch.geqrf(A)\n    >>> Q = torch.linalg.householder_product(h, tau)\n    >>> torch.dist(Q, torch.linalg.qr(A).Q)\n    tensor(0.)\n\n    >>> h = torch.randn(3, 2, 2, dtype=torch.complex128)\n    >>> tau = torch.randn(3, 1, dtype=torch.complex128)\n    >>> Q = torch.linalg.householder_product(h, tau)\n    >>> Q\n    tensor([[[ 1.8034+0.4184j,  0.2588-1.0174j],\n            [-0.6853+0.7953j,  2.0790+0.5620j]],\n\n            [[ 1.4581+1.6989j, -1.5360+0.1193j],\n            [ 1.3877-0.6691j,  1.3512+1.3024j]],\n\n            [[ 1.4766+0.5783j,  0.0361+0.6587j],\n            [ 0.6396+0.1612j,  1.3693+0.4481j]]], dtype=torch.complex128)\n\n.. _Representation of Orthogonal or Unitary Matrices:\n    https://www.netlib.org/lapack/lug/node128.html\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "tau": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "inv": {
          "Doc": "\nlinalg.inv(A, *, out=None) -> Tensor\n\nComputes the inverse of a square matrix if it exists.\nThrows a `RuntimeError` if the matrix is not invertible.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nfor a matrix :math:`A \\in \\mathbb{K}^{n \\times n}`,\nits **inverse matrix** :math:`A^{-1} \\in \\mathbb{K}^{n \\times n}` (if it exists) is defined as\n\n.. math::\n\n    A^{-1}A = AA^{-1} = \\mathrm{I}_n\n\nwhere :math:`\\mathrm{I}_n` is the `n`-dimensional identity matrix.\n\nThe inverse matrix exists if and only if :math:`A` is `invertible`_. In this case,\nthe inverse is unique.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices\nthen the output has the same batch dimensions.\n\n\n.. note:: When inputs are on a CUDA device, this function synchronizes that device with the CPU.\n\n\n.. note::\n    Consider using :func:`torch.linalg.solve` if possible for multiplying a matrix on the left by\n    the inverse, as::\n\n        linalg.solve(A, B) == linalg.inv(A) @ B  # When B is a matrix\n\n    It is always prefered to use :func:`~solve` when possible, as it is faster and more\n    numerically stable than computing the inverse explicitly.\n\n.. seealso::\n\n        :func:`torch.linalg.pinv` computes the pseudoinverse (Moore-Penrose inverse) of matrices\n        of any shape.\n\n        :func:`torch.linalg.solve` computes :attr:`A`\\ `.inv() @ \\ `:attr:`B` with a\n        numerically stable algorithm.\n\nArgs:\n    A (Tensor): tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions\n                consisting of invertible matrices.\n\nKeyword args:\n    out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.\n\nRaises:\n    RuntimeError: if the matrix :attr:`A` or any matrix in the batch of matrices :attr:`A` is not invertible.\n\nExamples::\n\n    >>> A = torch.randn(4, 4)\n    >>> Ainv = torch.linalg.inv(A)\n    >>> torch.dist(A @ Ainv, torch.eye(4))\n    tensor(1.1921e-07)\n\n    >>> A = torch.randn(2, 3, 4, 4)  # Batch of matrices\n    >>> Ainv = torch.linalg.inv(A)\n    >>> torch.dist(A @ Ainv, torch.eye(4))\n    tensor(1.9073e-06)\n\n    >>> A = torch.randn(4, 4, dtype=torch.complex128)  # Complex matrix\n    >>> Ainv = torch.linalg.inv(A)\n    >>> torch.dist(A @ Ainv, torch.eye(4))\n    tensor(7.5107e-16, dtype=torch.float64)\n\n.. _invertible:\n    https://en.wikipedia.org/wiki/Invertible_matrix#The_invertible_matrix_theorem\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "inv_ex": {
          "Doc": "\nlinalg.inv_ex(A, *, check_errors=False, out=None) -> (Tensor, Tensor)\n\nComputes the inverse of a square matrix if it is invertible.\n\nReturns a namedtuple ``(inverse, info)``. ``inverse`` contains the result of\ninverting :attr:`A` and ``info`` stores the LAPACK error codes.\n\nIf :attr:`A` is not an invertible matrix, or if it's a batch of matrices\nand one or more of them is not an invertible matrix,\nthen ``info`` stores a positive integer for the corresponding matrix.\nThe positive integer indicates the diagonal element of the LU decomposition of\nthe input matrix that is exactly zero.\n``info`` filled with zeros indicates that the inversion was successful.\nIf ``check_errors=True`` and ``info`` contains positive integers, then a RuntimeError is thrown.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\n\n.. note:: When the inputs are on a CUDA device, this function synchronizes only when :attr:`check_errors`\\ `= True`.\n\n.. warning:: This function is \"experimental\" and it may change in a future PyTorch release.\n\n\n.. seealso::\n\n        :func:`torch.linalg.inv` is a NumPy compatible variant that always checks for errors.\n\nArgs:\n    A (Tensor): tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions\n                    consisting of square matrices.\n    check_errors (bool, optional): controls whether to check the content of ``info``. Default: `False`.\n\nKeyword args:\n    out (tuple, optional): tuple of two tensors to write the output to. Ignored if `None`. Default: `None`.\n\nExamples::\n\n    >>> A = torch.randn(3, 3)\n    >>> Ainv, info = torch.linalg.inv_ex(A)\n    >>> torch.dist(torch.linalg.inv(A), Ainv)\n    tensor(0.)\n    >>> info\n    tensor(0, dtype=torch.int32)\n\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "check_errors": {
              "Type": null,
              "Default": "False"
            },
            "out": {
              "Type": null,
              "Default": "None) -> (Tensor"
            },
            "Tensor": {
              "Type": null,
              "Default": null
            }
          }
        },
        "ldl_factor": {
          "Doc": "\nlinalg.ldl_factor(A, *, hermitian=False, out=None) -> (Tensor, Tensor)\n\nComputes a compact representation of the LDL factorization of a Hermitian or symmetric (possibly indefinite) matrix.\n\nWhen :attr:`A` is complex valued it can be Hermitian (:attr:`hermitian`\\ `= True`)\nor symmetric (:attr:`hermitian`\\ `= False`).\n\nThe factorization is of the form the form :math:`A = L D L^T`.\nIf :attr:`hermitian` is `True` then transpose operation is the conjugate transpose.\n\n:math:`L` (or :math:`U`) and :math:`D` are stored in compact form in ``LD``.\nThey follow the format specified by `LAPACK's sytrf`_ function.\nThese tensors may be used in :func:`torch.linalg.ldl_solve` to solve linear systems.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\n\n.. note:: When inputs are on a CUDA device, this function synchronizes that device with the CPU. For a version of this function that does not synchronize, see :func:`torch.linalg.ldl_factor_ex`.\n\n\nArgs:\n    A (Tensor): tensor of shape (*, n, n) where * is zero or more batch dimensions consisting of symmetric or Hermitian matrices.\n                    `(*, n, n)` where `*` is one or more batch dimensions.\n\nKeyword args:\n    hermitian (bool, optional): whether to consider the input to be Hermitian or symmetric.\n                                For real-valued matrices, this switch has no effect. Default: `False`.\n    out (tuple, optional): tuple of two tensors to write the output to. Ignored if `None`. Default: `None`.\n\nReturns:\n    A named tuple `(LD, pivots)`.\n\nExamples::\n\n    >>> A = torch.randn(3, 3)\n    >>> A = A @ A.mT # make symmetric\n    >>> A\n    tensor([[7.2079, 4.2414, 1.9428],\n            [4.2414, 3.4554, 0.3264],\n            [1.9428, 0.3264, 1.3823]])\n    >>> LD, pivots = torch.linalg.ldl_factor(A)\n    >>> LD\n    tensor([[ 7.2079,  0.0000,  0.0000],\n            [ 0.5884,  0.9595,  0.0000],\n            [ 0.2695, -0.8513,  0.1633]])\n    >>> pivots\n    tensor([1, 2, 3], dtype=torch.int32)\n\n.. _LAPACK's sytrf:\n    https://www.netlib.org/lapack/explore-html/d3/db6/group__double_s_ycomputational_gad91bde1212277b3e909eb6af7f64858a.html\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "hermitian": {
              "Type": null,
              "Default": "False"
            },
            "out": {
              "Type": null,
              "Default": "None) -> (Tensor"
            },
            "Tensor": {
              "Type": null,
              "Default": null
            }
          }
        },
        "ldl_factor_ex": {
          "Doc": "\nlinalg.ldl_factor_ex(A, *, hermitian=False, check_errors=False, out=None) -> (Tensor, Tensor, Tensor)\n\nThis is a version of :func:`~ldl_factor` that does not perform error checks unless :attr:`check_errors`\\ `= True`.\nIt also returns the :attr:`info` tensor returned by `LAPACK's sytrf`_.\n``info`` stores integer error codes from the backend library.\nA positive integer indicates the diagonal element of :math:`D` that is zero.\nDivision by 0 will occur if the result is used for solving a system of linear equations.\n``info`` filled with zeros indicates that the factorization was successful.\nIf ``check_errors=True`` and ``info`` contains positive integers, then a `RuntimeError` is thrown.\n\n\n.. note:: When the inputs are on a CUDA device, this function synchronizes only when :attr:`check_errors`\\ `= True`.\n\n.. warning:: This function is \"experimental\" and it may change in a future PyTorch release.\n\n\nArgs:\n    A (Tensor): tensor of shape (*, n, n) where * is zero or more batch dimensions consisting of symmetric or Hermitian matrices.\n                    `(*, n, n)` where `*` is one or more batch dimensions.\n\nKeyword args:\n    hermitian (bool, optional): whether to consider the input to be Hermitian or symmetric.\n                                For real-valued matrices, this switch has no effect. Default: `False`.\n    check_errors (bool, optional): controls whether to check the content of ``info`` and raise\n                                   an error if it is non-zero. Default: `False`.\n    out (tuple, optional): tuple of three tensors to write the output to. Ignored if `None`. Default: `None`.\n\nReturns:\n    A named tuple `(LD, pivots, info)`.\n\nExamples::\n\n    >>> A = torch.randn(3, 3)\n    >>> A = A @ A.mT # make symmetric\n    >>> A\n    tensor([[7.2079, 4.2414, 1.9428],\n            [4.2414, 3.4554, 0.3264],\n            [1.9428, 0.3264, 1.3823]])\n    >>> LD, pivots, info = torch.linalg.ldl_factor_ex(A)\n    >>> LD\n    tensor([[ 7.2079,  0.0000,  0.0000],\n            [ 0.5884,  0.9595,  0.0000],\n            [ 0.2695, -0.8513,  0.1633]])\n    >>> pivots\n    tensor([1, 2, 3], dtype=torch.int32)\n    >>> info\n    tensor(0, dtype=torch.int32)\n\n.. _LAPACK's sytrf:\n    https://www.netlib.org/lapack/explore-html/d3/db6/group__double_s_ycomputational_gad91bde1212277b3e909eb6af7f64858a.html\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "hermitian": {
              "Type": null,
              "Default": "False"
            },
            "check_errors": {
              "Type": null,
              "Default": "False"
            },
            "out": {
              "Type": null,
              "Default": "None) -> (Tensor"
            },
            "Tensor": {
              "Type": null,
              "Default": null
            }
          }
        },
        "ldl_solve": {
          "Doc": "\nlinalg.ldl_solve(LD, pivots, B, *, hermitian=False, out=None) -> Tensor\n\nComputes the solution of a system of linear equations using the LDL factorization.\n\n:attr:`LD` and :attr:`pivots` are the compact representation of the LDL factorization and\nare expected to be computed by :func:`torch.linalg.ldl_factor_ex`.\n:attr:`hermitian` argument to this function should be the same\nas the corresponding argumens in :func:`torch.linalg.ldl_factor_ex`.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\n\n.. warning:: This function is \"experimental\" and it may change in a future PyTorch release.\n\n\nArgs:\n    LD (Tensor): the `n \\times n` matrix or the batch of such matrices of size\n                      `(*, n, n)` where `*` is one or more batch dimensions.\n    pivots (Tensor): the pivots corresponding to the LDL factorization of :attr:`LD`.\n    B (Tensor): right-hand side tensor of shape `(*, n, k)`.\n\nKeyword args:\n    hermitian (bool, optional): whether to consider the decomposed matrix to be Hermitian or symmetric.\n                                For real-valued matrices, this switch has no effect. Default: `False`.\n    out (tuple, optional): output tensor. `B` may be passed as `out` and the result is computed in-place on `B`.\n                           Ignored if `None`. Default: `None`.\n\nExamples::\n\n    >>> A = torch.randn(2, 3, 3)\n    >>> A = A @ A.mT # make symmetric\n    >>> LD, pivots, info = torch.linalg.ldl_factor_ex(A)\n    >>> B = torch.randn(2, 3, 4)\n    >>> X = torch.linalg.ldl_solve(LD, pivots, B)\n    >>> torch.linalg.norm(A @ X - B)\n    >>> tensor(0.0001)\n",
          "Args": {
            "LD": {
              "Type": null,
              "Default": null
            },
            "pivots": {
              "Type": null,
              "Default": null
            },
            "B": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "hermitian": {
              "Type": null,
              "Default": "False"
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "lstsq": {
          "Doc": "\ntorch.linalg.lstsq(A, B, rcond=None, *, driver=None) -> (Tensor, Tensor, Tensor, Tensor)\n\nComputes a solution to the least squares problem of a system of linear equations.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthe **least squares problem** for a linear system :math:`AX = B` with\n:math:`A \\in \\mathbb{K}^{m \\times n}, B \\in \\mathbb{K}^{m \\times k}` is defined as\n\n.. math::\n\n    \\min_{X \\in \\mathbb{K}^{n \\times k}} \\|AX - B\\|_F\n\nwhere :math:`\\|-\\|_F` denotes the Frobenius norm.\n\nSupports inputs of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if the inputs are batches of matrices then\nthe output has the same batch dimensions.\n\n:attr:`driver` chooses the LAPACK/MAGMA function that will be used.\nFor CPU inputs the valid values are `'gels'`, `'gelsy'`, `'gelsd`, `'gelss'`.\nFor CUDA input, the only valid driver is `'gels'`, which assumes that :attr:`A` is full-rank.\nTo choose the best driver on CPU consider:\n\n- If :attr:`A` is well-conditioned (its `condition number`_ is not too large), or you do not mind some precision loss.\n\n  - For a general matrix: `'gelsy'` (QR with pivoting) (default)\n  - If :attr:`A` is full-rank: `'gels'` (QR)\n\n- If :attr:`A` is not well-conditioned.\n\n  - `'gelsd'` (tridiagonal reduction and SVD)\n  - But if you run into memory issues: `'gelss'` (full SVD).\n\nSee also the `full description of these drivers`_\n\n:attr:`rcond` is used to determine the effective rank of the matrices in :attr:`A`\nwhen :attr:`driver` is one of (`'gelsy'`, `'gelsd'`, `'gelss'`).\nIn this case, if :math:`\\sigma_i` are the singular values of `A` in decreasing order,\n:math:`\\sigma_i` will be rounded down to zero if :math:`\\sigma_i \\leq \\text{rcond} \\cdot \\sigma_1`.\nIf :attr:`rcond`\\ `= None` (default), :attr:`rcond` is set to the machine precision of the dtype of :attr:`A` times `max(m, n)`.\n\nThis function returns the solution to the problem and some extra information in a named tuple of\nfour tensors `(solution, residuals, rank, singular_values)`. For inputs :attr:`A`, :attr:`B`\nof shape `(*, m, n)`, `(*, m, k)` respectively, it cointains\n\n- `solution`: the least squares solution. It has shape `(*, n, k)`.\n- `residuals`: the squared residuals of the solutions, that is, :math:`\\|AX - B\\|_F^2`.\n  It has shape equal to the batch dimensions of :attr:`A`.\n  It is computed when `m > n` and every matrix in :attr:`A` is full-rank,\n  otherwise, it is an empty tensor.\n  If :attr:`A` is a batch of matrices and any matrix in the batch is not full rank,\n  then an empty tensor is returned. This behavior may change in a future PyTorch release.\n- `rank`: tensor of ranks of the matrices in :attr:`A`.\n  It has shape equal to the batch dimensions of :attr:`A`.\n  It is computed when :attr:`driver` is one of (`'gelsy'`, `'gelsd'`, `'gelss'`),\n  otherwise it is an empty tensor.\n- `singular_values`: tensor of singular values of the matrices in :attr:`A`.\n  It has shape `(*, min(m, n))`.\n  It is computed when :attr:`driver` is one of (`'gelsd'`, `'gelss'`),\n  otherwise it is an empty tensor.\n\n.. note::\n    This function computes `X = \\ `:attr:`A`\\ `.pinverse() @ \\ `:attr:`B` in a faster and\n    more numerically stable way than performing the computations separately.\n\n.. warning::\n    The default value of :attr:`rcond` may change in a future PyTorch release.\n    It is therefore recommended to use a fixed value to avoid potential\n    breaking changes.\n\nArgs:\n    A (Tensor): lhs tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions.\n    B (Tensor): rhs tensor of shape `(*, m, k)` where `*` is zero or more batch dimensions.\n    rcond (float, optional): used to determine the effective rank of :attr:`A`.\n                             If :attr:`rcond`\\ `= None`, :attr:`rcond` is set to the machine\n                             precision of the dtype of :attr:`A` times `max(m, n)`. Default: `None`.\n\nKeyword args:\n    driver (str, optional): name of the LAPACK/MAGMA method to be used.\n        If `None`, `'gelsy'` is used for CPU inputs and `'gels'` for CUDA inputs.\n        Default: `None`.\n\nReturns:\n    A named tuple `(solution, residuals, rank, singular_values)`.\n\nExamples::\n\n    >>> A = torch.tensor([[[10, 2, 3], [3, 10, 5], [5, 6, 12]]], dtype=torch.float) # shape (1, 3, 3)\n    >>> B = torch.tensor([[[2, 5, 1], [3, 2, 1], [5, 1, 9]],\n                          [[4, 2, 9], [2, 0, 3], [2, 5, 3]]], dtype=torch.float) # shape (2, 3, 3)\n    >>> X = torch.linalg.lstsq(A, B).solution # A is broadcasted to shape (2, 3, 3)\n    >>> torch.dist(X, torch.linalg.pinv(A) @ B)\n    tensor(2.0862e-07)\n\n    >>> S = torch.linalg.lstsq(A, B, driver='gelsd').singular_values\n    >>> torch.dist(S, torch.linalg.svdvals(A))\n    tensor(5.7220e-06)\n\n    >>> A[:, 0].zero_()  # Decrease the rank of A\n    >>> rank = torch.linalg.lstsq(A, B).rank\n    >>> rank\n    tensor([2])\n\n.. _condition number:\n    https://pytorch.org/docs/master/linalg.html#torch.linalg.cond\n.. _full description of these drivers:\n    https://www.netlib.org/lapack/lug/node27.html\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "B": {
              "Type": null,
              "Default": null
            },
            "rcond": {
              "Type": null,
              "Default": "None"
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "driver": {
              "Type": null,
              "Default": "None) -> (Tensor"
            },
            "Tensor": {
              "Type": null,
              "Default": null
            }
          }
        },
        "lu": {
          "Doc": "\nlu(A, *, pivot=True, out=None) -> (Tensor, Tensor, Tensor)\n\nComputes the LU decomposition with partial pivoting of a matrix.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthe **LU decomposition with partial pivoting** of a matrix\n:math:`A \\in \\mathbb{K}^{m \\times n}` is defined as\n\n.. math::\n\n    A = PLU\\mathrlap{\\qquad P \\in \\mathbb{K}^{m \\times m}, L \\in \\mathbb{K}^{m \\times k}, U \\in \\mathbb{K}^{k \\times n}}\n\nwhere `k = min(m,n)`, :math:`P` is a `permutation matrix`_, :math:`L` is lower triangular with ones on the diagonal\nand :math:`U` is upper triangular.\n\nIf :attr:`pivot`\\ `= False` and :attr:`A` is on GPU, then the **LU decomposition without pivoting** is computed\n\n.. math::\n\n    A = LU\\mathrlap{\\qquad L \\in \\mathbb{K}^{m \\times k}, U \\in \\mathbb{K}^{k \\times n}}\n\nWhen :attr:`pivot`\\ `= False`, the returned matrix :attr:`P` will be empty.\nThe LU decomposition without pivoting `may not exist`_ if any of the principal minors of :attr:`A` is singular.\nIn this case, the output matrix may contain `inf` or `NaN`.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\n.. seealso::\n\n        :func:`torch.linalg.solve` solves a system of linear equations using the LU decomposition\n        with partial pivoting.\n\n.. warning:: The LU decomposition is almost never unique, as often there are different permutation\n             matrices that can yield different LU decompositions.\n             As such, different platforms, like SciPy, or inputs on different devices,\n             may produce different valid decompositions.\n\n.. warning:: Gradient computations are only supported if the input matrix is full-rank.\n             If this condition is not met, no error will be thrown, but the gradient\n             may not be finite.\n             This is because the LU decomposition with pivoting is not differentiable at these points.\n\nArgs:\n    A (Tensor): tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions.\n    pivot (bool, optional): Controls whether to compute the LU decomposition with partial pivoting or\n        no pivoting. Default: `True`.\n\nKeyword args:\n    out (tuple, optional): output tuple of three tensors. Ignored if `None`. Default: `None`.\n\nReturns:\n    A named tuple `(P, L, U)`.\n\nExamples::\n\n    >>> A = torch.randn(3, 2)\n    >>> P, L, U = torch.linalg.lu(A)\n    >>> P\n    tensor([[0., 1., 0.],\n            [0., 0., 1.],\n            [1., 0., 0.]])\n    >>> L\n    tensor([[1.0000, 0.0000],\n            [0.5007, 1.0000],\n            [0.0633, 0.9755]])\n    >>> U\n    tensor([[0.3771, 0.0489],\n            [0.0000, 0.9644]])\n    >>> torch.dist(A, P @ L @ U)\n    tensor(5.9605e-08)\n\n    >>> A = torch.randn(2, 5, 7, device=\"cuda\")\n    >>> P, L, U = torch.linalg.lu(A, pivot=False)\n    >>> P\n    tensor([], device='cuda:0')\n    >>> torch.dist(A, L @ U)\n    tensor(1.0376e-06, device='cuda:0')\n\n.. _permutation matrix:\n    https://en.wikipedia.org/wiki/Permutation_matrix\n.. _may not exist:\n    https://en.wikipedia.org/wiki/LU_decomposition#Definitions\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "pivot": {
              "Type": null,
              "Default": "True"
            },
            "out": {
              "Type": null,
              "Default": "None) -> (Tensor"
            },
            "Tensor": {
              "Type": null,
              "Default": null
            }
          }
        },
        "lu_factor": {
          "Doc": "\nlinalg.lu_factor(A, *, bool pivot=True, out=None) -> (Tensor, Tensor)\n\nComputes a compact representation of the LU factorization with partial pivoting of a matrix.\n\nThis function computes a compact representation of the decomposition given by :func:`torch.linalg.lu`.\nIf the matrix is square, this representation may be used in :func:`torch.linalg.lu_solve`\nto solve system of linear equations that share the matrix :attr:`A`.\n\nThe returned decomposition is represented as a named tuple `(LU, pivots)`.\nThe ``LU`` matrix has the same shape as the input matrix ``A``. Its upper and lower triangular\nparts encode the non-constant elements of ``L`` and ``U`` of the LU decomposition of ``A``.\n\nThe returned permutation matrix is represented by a 1-indexed vector. `pivots[i] == j` represents\nthat in the `i`-th step of the algorithm, the `i`-th row was permuted with the `j-1`-th row.\n\nOn CUDA, one may use :attr:`pivot`\\ `= False`. In this case, this function returns the LU\ndecomposition without pivoting if it exists.\n\nSupports inputs of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if the inputs are batches of matrices then\nthe output has the same batch dimensions.\n\n\n.. note:: When inputs are on a CUDA device, this function synchronizes that device with the CPU. For a version of this function that does not synchronize, see :func:`torch.linalg.lu_factor_ex`.\n\n.. warning:: The LU decomposition is almost never unique, as often there are different permutation\n             matrices that can yield different LU decompositions.\n             As such, different platforms, like SciPy, or inputs on different devices,\n             may produce different valid decompositions.\n\n             Gradient computations are only supported if the input matrix is full-rank.\n             If this condition is not met, no error will be thrown, but the gradient may not be finite.\n             This is because the LU decomposition with pivoting is not differentiable at these points.\n\n.. seealso::\n\n        :func:`torch.linalg.lu_solve` solves a system of linear equations given the output of this\n        function provided the input matrix was square and invertible.\n\n        :func:`torch.lu_unpack` unpacks the tensors returned by :func:`~lu_factor` into the three\n        matrices `P, L, U` that form the decomposition.\n\n        :func:`torch.linalg.lu` computes the LU decomposition with partial pivoting of a possibly\n        non-square matrix. It is a composition of :func:`~lu_factor` and :func:`torch.lu_unpack`.\n\n        :func:`torch.linalg.solve` solves a system of linear equations. It is a composition\n        of :func:`~lu_factor` and :func:`~lu_solve`.\n\nArgs:\n    A (Tensor): tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions.\n\nKeyword args:\n    pivot (bool, optional): Whether to compute the LU decomposition with partial pivoting, or the regular LU\n                            decomposition. :attr:`pivot`\\ `= False` not supported on CPU. Default: `True`.\n    out (tuple, optional): tuple of two tensors to write the output to. Ignored if `None`. Default: `None`.\n\nReturns:\n    A named tuple `(LU, pivots)`.\n\nRaises:\n    RuntimeError: if the :attr:`A` matrix is not invertible or any matrix in a batched :attr:`A`\n                  is not invertible.\n\nExamples::\n\n    >>> A = torch.randn(2, 3, 3)\n    >>> B1 = torch.randn(2, 3, 4)\n    >>> B2 = torch.randn(2, 3, 7)\n    >>> A_factor = torch.linalg.lu_factor(A)\n    >>> X1 = torch.linalg.lu_solve(A_factor, B1)\n    >>> X2 = torch.linalg.lu_solve(A_factor, B2)\n    >>> torch.allclose(A @ X1, B1)\n    True\n    >>> torch.allclose(A @ X2, B2)\n    True\n\n.. _invertible:\n    https://en.wikipedia.org/wiki/Invertible_matrix#The_invertible_matrix_theorem\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "bool pivot": {
              "Type": null,
              "Default": "True"
            },
            "out": {
              "Type": null,
              "Default": "None) -> (Tensor"
            },
            "Tensor": {
              "Type": null,
              "Default": null
            }
          }
        },
        "lu_factor_ex": {
          "Doc": "\nlinalg.lu_factor_ex(A, *, pivot=True, check_errors=False, out=None) -> (Tensor, Tensor, Tensor)\n\nThis is a version of :func:`~lu_factor` that does not perform error checks unless :attr:`check_errors`\\ `= True`.\nIt also returns the :attr:`info` tensor returned by `LAPACK's getrf`_.\n\n\n.. note:: When the inputs are on a CUDA device, this function synchronizes only when :attr:`check_errors`\\ `= True`.\n\n.. warning:: This function is \"experimental\" and it may change in a future PyTorch release.\n\n\nArgs:\n    A (Tensor): tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions.\n\nKeyword args:\n    pivot (bool, optional): Whether to compute the LU decomposition with partial pivoting, or the regular LU\n                            decomposition. :attr:`pivot`\\ `= False` not supported on CPU. Default: `True`.\n    check_errors (bool, optional): controls whether to check the content of ``infos`` and raise\n                                   an error if it is non-zero. Default: `False`.\n    out (tuple, optional): tuple of three tensors to write the output to. Ignored if `None`. Default: `None`.\n\nReturns:\n    A named tuple `(LU, pivots, info)`.\n\n.. _LAPACK's getrf:\n    https://www.netlib.org/lapack/explore-html/dd/d9a/group__double_g_ecomputational_ga0019443faea08275ca60a734d0593e60.html\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "pivot": {
              "Type": null,
              "Default": "True"
            },
            "check_errors": {
              "Type": null,
              "Default": "False"
            },
            "out": {
              "Type": null,
              "Default": "None) -> (Tensor"
            },
            "Tensor": {
              "Type": null,
              "Default": null
            }
          }
        },
        "lu_solve": {
          "Doc": "\nlinalg.lu_solve(LU, pivots, B, *, left=True, adjoint=False, out=None) -> Tensor\n\nComputes the solution of a square system of linear equations with a unique solution given an LU decomposition.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthis function computes the solution :math:`X \\in \\mathbb{K}^{n \\times k}` of the **linear system** associated to\n:math:`A \\in \\mathbb{K}^{n \\times n}, B \\in \\mathbb{K}^{n \\times k}`, which is defined as\n\n.. math:: AX = B\n\nwhere :math:`A` is given factorized as returned by :func:`~lu_factor`.\n\nIf :attr:`left`\\ `= False`, this function returns the matrix :math:`X \\in \\mathbb{K}^{n \\times k}` that solves the system\n\n.. math::\n\n    XA = B\\mathrlap{\\qquad A \\in \\mathbb{K}^{k \\times k}, B \\in \\mathbb{K}^{n \\times k}.}\n\nIf  :attr:`adjoint`\\ `= True` (and :attr:`left`\\ `= True), given an LU factorization of :math:`A`\nthis function function returns the :math:`X \\in \\mathbb{K}^{n \\times k}` that solves the system\n\n.. math::\n\n    A^{\\text{H}}X = B\\mathrlap{\\qquad A \\in \\mathbb{K}^{k \\times k}, B \\in \\mathbb{K}^{n \\times k}.}\n\nwhere :math:`A^{\\text{H}}` is the conjugate transpose when :math:`A` is complex, and the\ntranspose when :math:`A` is real-valued. The :attr:`left`\\ `= False` case is analogous.\n\nSupports inputs of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if the inputs are batches of matrices then\nthe output has the same batch dimensions.\n\nArgs:\n    LU (Tensor): tensor of shape `(*, n, n)` (or `(*, k, k)` if :attr:`left`\\ `= True`)\n                 where `*` is zero or more batch dimensions as returned by :func:`~lu_factor`.\n    pivots (Tensor): tensor of shape `(*, n)` (or `(*, k)` if :attr:`left`\\ `= True`)\n                     where `*` is zero or more batch dimensions as returned by :func:`~lu_factor`.\n    B (Tensor): right-hand side tensor of shape `(*, n, k)`.\n\nKeyword args:\n    left (bool, optional): whether to solve the system :math:`AX=B` or :math:`XA = B`. Default: `True`.\n    adjoint (bool, optional): whether to solve the system :math:`AX=B` or :math:`A^{\\text{H}}X = B`. Default: `False`.\n    out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.\n\nExamples::\n\n    >>> A = torch.randn(3, 3)\n    >>> LU, pivots = torch.linalg.lu_factor(A)\n    >>> B = torch.randn(3, 2)\n    >>> X = torch.linalg.lu_solve(LU, pivots, B)\n    >>> torch.allclose(A @ X, B)\n    True\n\n    >>> B = torch.randn(3, 3, 2)   # Broadcasting rules apply: A is broadcasted\n    >>> X = torch.linalg.lu_solve(LU, pivots, B)\n    >>> torch.allclose(A @ X, B)\n    True\n\n    >>> B = torch.randn(3, 5, 3)\n    >>> X = torch.linalg.lu_solve(LU, pivots, B, left=False)\n    >>> torch.allclose(X @ A, B)\n    True\n\n    >>> B = torch.randn(3, 3, 4)   # Now solve for A^T\n    >>> X = torch.linalg.lu_solve(LU, pivots, B, adjoint=True)\n    >>> torch.allclose(A.mT @ X, B)\n    True\n\n.. _invertible:\n    https://en.wikipedia.org/wiki/Invertible_matrix#The_invertible_matrix_theorem\n",
          "Args": {
            "LU": {
              "Type": null,
              "Default": null
            },
            "pivots": {
              "Type": null,
              "Default": null
            },
            "B": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "left": {
              "Type": null,
              "Default": "True"
            },
            "adjoint": {
              "Type": null,
              "Default": "False"
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "matmul": {
          "Doc": "\nlinalg.matmul(input, other, *, out=None) -> Tensor\n\nAlias for :func:`torch.matmul`\n",
          "Args": {
            "input": {
              "Type": null,
              "Default": null
            },
            "other": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "matrix_exp": {
          "Doc": "\nlinalg.matrix_exp(A) -> Tensor\n\nComputes the matrix exponential of a square matrix.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthis function computes the **matrix exponential** of :math:`A \\in \\mathbb{K}^{n \\times n}`, which is defined as\n\n.. math::\n    \\mathrm{matrix_exp}(A) = \\sum_{k=0}^\\infty \\frac{1}{k!}A^k \\in \\mathbb{K}^{n \\times n}.\n\nIf the matrix :math:`A` has eigenvalues :math:`\\lambda_i \\in \\mathbb{C}`,\nthe matrix :math:`\\mathrm{matrix_exp}(A)` has eigenvalues :math:`e^{\\lambda_i} \\in \\mathbb{C}`.\n\nSupports input of bfloat16, float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\nArgs:\n    A (Tensor): tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions.\n\nExample::\n\n    >>> A = torch.empty(2, 2, 2)\n    >>> A[0, :, :] = torch.eye(2, 2)\n    >>> A[1, :, :] = 2 * torch.eye(2, 2)\n    >>> A\n    tensor([[[1., 0.],\n             [0., 1.]],\n\n            [[2., 0.],\n             [0., 2.]]])\n    >>> torch.linalg.matrix_exp(A)\n    tensor([[[2.7183, 0.0000],\n             [0.0000, 2.7183]],\n\n             [[7.3891, 0.0000],\n              [0.0000, 7.3891]]])\n\n    >>> import math\n    >>> A = torch.tensor([[0, math.pi/3], [-math.pi/3, 0]]) # A is skew-symmetric\n    >>> torch.linalg.matrix_exp(A) # matrix_exp(A) = [[cos(pi/3), sin(pi/3)], [-sin(pi/3), cos(pi/3)]]\n    tensor([[ 0.5000,  0.8660],\n            [-0.8660,  0.5000]])\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            }
          }
        },
        "matrix_norm": {
          "Doc": "\nlinalg.matrix_norm(A, ord='fro', dim=(-2, -1), keepdim=False, *, dtype=None, out=None) -> Tensor\n\nComputes a matrix norm.\n\nIf :attr:`A` is complex valued, it computes the norm of :attr:`A`\\ `.abs()`\n\nSupport input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices: the norm will be computed over the\ndimensions specified by the 2-tuple :attr:`dim` and the other dimensions will\nbe treated as batch dimensions. The output will have the same batch dimensions.\n\n:attr:`ord` defines the matrix norm that is computed. The following norms are supported:\n\n======================   ========================================================\n:attr:`ord`              matrix norm\n======================   ========================================================\n`'fro'` (default)        Frobenius norm\n`'nuc'`                  nuclear norm\n`inf`                    `max(sum(abs(x), dim=1))`\n`-inf`                   `min(sum(abs(x), dim=1))`\n`1`                      `max(sum(abs(x), dim=0))`\n`-1`                     `min(sum(abs(x), dim=0))`\n`2`                      largest singular value\n`-2`                     smallest singular value\n======================   ========================================================\n\nwhere `inf` refers to `float('inf')`, NumPy's `inf` object, or any equivalent object.\n\nArgs:\n    A (Tensor): tensor with two or more dimensions. By default its\n        shape is interpreted as `(*, m, n)` where `*` is zero or more\n        batch dimensions, but this behavior can be controlled using :attr:`dim`.\n    ord (int, inf, -inf, 'fro', 'nuc', optional): order of norm. Default: `'fro'`\n    dim (Tuple[int, int], optional): dimensions over which to compute the norm. Default: `(-2, -1)`\n    keepdim (bool, optional): If set to `True`, the reduced dimensions are retained\n        in the result as dimensions with size one. Default: `False`\n\nKeyword args:\n    out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.\n    dtype (:class:`torch.dtype`, optional): If specified, the input tensor is cast to\n        :attr:`dtype` before performing the operation, and the returned tensor's type\n        will be :attr:`dtype`. Default: `None`\n\nReturns:\n    A real-valued tensor, even when :attr:`A` is complex.\n\nExamples::\n\n    >>> from torch import linalg as LA\n    >>> A = torch.arange(9, dtype=torch.float).reshape(3, 3)\n    >>> A\n    tensor([[0., 1., 2.],\n            [3., 4., 5.],\n            [6., 7., 8.]])\n    >>> LA.matrix_norm(A)\n    tensor(14.2829)\n    >>> LA.matrix_norm(A, ord=-1)\n    tensor(9.)\n    >>> B = A.expand(2, -1, -1)\n    >>> B\n    tensor([[[0., 1., 2.],\n            [3., 4., 5.],\n            [6., 7., 8.]],\n\n            [[0., 1., 2.],\n            [3., 4., 5.],\n            [6., 7., 8.]]])\n    >>> LA.matrix_norm(B)\n    tensor([14.2829, 14.2829])\n    >>> LA.matrix_norm(B, dim=(0, 2))\n    tensor([ 3.1623, 10.0000, 17.2627])\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "ord": {
              "Type": null,
              "Default": "'fro'"
            },
            "dim": {
              "Type": null,
              "Default": "(-2"
            },
            "-1)": {
              "Type": null,
              "Default": null
            },
            "keepdim": {
              "Type": null,
              "Default": "False"
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "dtype": {
              "Type": null,
              "Default": "None"
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "matrix_power": {
          "Doc": "\nmatrix_power(A, n, *, out=None) -> Tensor\n\nComputes the `n`-th power of a square matrix for an integer `n`.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\nIf :attr:`n`\\ `= 0`, it returns the identity matrix (or batch) of the same shape\nas :attr:`A`. If :attr:`n` is negative, it returns the inverse of each matrix\n(if invertible) raised to the power of `abs(n)`.\n\n.. note::\n    Consider using :func:`torch.linalg.solve` if possible for multiplying a matrix on the left by\n    a negative power as, if :attr:`n`\\ `> 0`::\n\n        matrix_power(torch.linalg.solve(A, B), n) == matrix_power(A, -n)  @ B\n\n    It is always prefered to use :func:`~solve` when possible, as it is faster and more\n    numerically stable than computing :math:`A^{-n}` explicitly.\n\n.. seealso::\n\n        :func:`torch.linalg.solve` computes :attr:`A`\\ `.inverse() @ \\ `:attr:`B` with a\n        numerically stable algorithm.\n\nArgs:\n    A (Tensor): tensor of shape `(*, m, m)` where `*` is zero or more batch dimensions.\n    n (int): the exponent.\n\nKeyword args:\n    out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.\n\nRaises:\n    RuntimeError: if :attr:`n`\\ `< 0` and the matrix :attr:`A` or any matrix in the\n                  batch of matrices :attr:`A` is not invertible.\n\nExamples::\n\n    >>> A = torch.randn(3, 3)\n    >>> torch.linalg.matrix_power(A, 0)\n    tensor([[1., 0., 0.],\n            [0., 1., 0.],\n            [0., 0., 1.]])\n    >>> torch.linalg.matrix_power(A, 3)\n    tensor([[ 1.0756,  0.4980,  0.0100],\n            [-1.6617,  1.4994, -1.9980],\n            [-0.4509,  0.2731,  0.8001]])\n    >>> torch.linalg.matrix_power(A.expand(2, -1, -1), -2)\n    tensor([[[ 0.2640,  0.4571, -0.5511],\n            [-1.0163,  0.3491, -1.5292],\n            [-0.4899,  0.0822,  0.2773]],\n            [[ 0.2640,  0.4571, -0.5511],\n            [-1.0163,  0.3491, -1.5292],\n            [-0.4899,  0.0822,  0.2773]]])\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "n": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "matrix_rank": {
          "Doc": "\nlinalg.matrix_rank(A, *, atol=None, rtol=None, hermitian=False, out=None) -> Tensor\n\nComputes the numerical rank of a matrix.\n\nThe matrix rank is computed as the number of singular values\n(or eigenvalues in absolute value when :attr:`hermitian`\\ `= True`)\nthat are greater than :math:`\\max(\\text{atol}, \\sigma_1 * \\text{rtol})` threshold,\nwhere :math:`\\sigma_1` is the largest singular value (or eigenvalue).\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\nIf :attr:`hermitian`\\ `= True`, :attr:`A` is assumed to be Hermitian if complex or\nsymmetric if real, but this is not checked internally. Instead, just the lower\ntriangular part of the matrix is used in the computations.\n\nIf :attr:`rtol` is not specified and :attr:`A` is a matrix of dimensions `(m, n)`,\nthe relative tolerance is set to be :math:`\\text{rtol} = \\max(m, n) \\varepsilon`\nand :math:`\\varepsilon` is the epsilon value for the dtype of :attr:`A` (see :class:`.finfo`).\nIf :attr:`rtol` is not specified and :attr:`atol` is specified to be larger than zero then\n:attr:`rtol` is set to zero.\n\nIf :attr:`atol` or :attr:`rtol` is a :class:`torch.Tensor`, its shape must be broadcastable to that\nof the singular values of :attr:`A` as returned by :func:`torch.linalg.svdvals`.\n\n.. note::\n    This function has NumPy compatible variant `linalg.matrix_rank(A, tol, hermitian=False)`.\n    However, use of the positional argument :attr:`tol` is deprecated in favor of :attr:`atol` and :attr:`rtol`.\n\n\n.. note:: The matrix rank is computed using a singular value decomposition\n          :func:`torch.linalg.svdvals` if :attr:`hermitian`\\ `= False` (default) and the eigenvalue\n          decomposition :func:`torch.linalg.eigvalsh` when :attr:`hermitian`\\ `= True`.\n          When inputs are on a CUDA device, this function synchronizes that device with the CPU.\n\n\nArgs:\n    A (Tensor): tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions.\n    tol (float, Tensor, optional): [NumPy Compat] Alias for :attr:`atol`. Default: `None`.\n\nKeyword args:\n    atol (float, Tensor, optional): the absolute tolerance value. When `None` it's considered to be zero.\n                                    Default: `None`.\n    rtol (float, Tensor, optional): the relative tolerance value. See above for the value it takes when `None`.\n                                    Default: `None`.\n    hermitian(bool): indicates whether :attr:`A` is Hermitian if complex\n                     or symmetric if real. Default: `False`.\n    out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.\n\nExamples::\n\n    >>> A = torch.eye(10)\n    >>> torch.linalg.matrix_rank(A)\n    tensor(10)\n    >>> B = torch.eye(10)\n    >>> B[0, 0] = 0\n    >>> torch.linalg.matrix_rank(B)\n    tensor(9)\n\n    >>> A = torch.randn(4, 3, 2)\n    >>> torch.linalg.matrix_rank(A)\n    tensor([2, 2, 2, 2])\n\n    >>> A = torch.randn(2, 4, 2, 3)\n    >>> torch.linalg.matrix_rank(A)\n    tensor([[2, 2, 2, 2],\n            [2, 2, 2, 2]])\n\n    >>> A = torch.randn(2, 4, 3, 3, dtype=torch.complex64)\n    >>> torch.linalg.matrix_rank(A)\n    tensor([[3, 3, 3, 3],\n            [3, 3, 3, 3]])\n    >>> torch.linalg.matrix_rank(A, hermitian=True)\n    tensor([[3, 3, 3, 3],\n            [3, 3, 3, 3]])\n    >>> torch.linalg.matrix_rank(A, atol=1.0, rtol=0.0)\n    tensor([[3, 2, 2, 2],\n            [1, 2, 1, 2]])\n    >>> torch.linalg.matrix_rank(A, atol=1.0, rtol=0.0, hermitian=True)\n    tensor([[2, 2, 2, 1],\n            [1, 2, 2, 2]])\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "atol": {
              "Type": null,
              "Default": "None"
            },
            "rtol": {
              "Type": null,
              "Default": "None"
            },
            "hermitian": {
              "Type": null,
              "Default": "False"
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "multi_dot": {
          "Doc": "\nlinalg.multi_dot(tensors, *, out=None)\n\nEfficiently multiplies two or more matrices by reordering the multiplications so that\nthe fewest arithmetic operations are performed.\n\nSupports inputs of float, double, cfloat and cdouble dtypes.\nThis function does not support batched inputs.\n\nEvery tensor in :attr:`tensors` must be 2D, except for the first and last which\nmay be 1D. If the first tensor is a 1D vector of shape `(n,)` it is treated as a row vector\nof shape `(1, n)`, similarly if the last tensor is a 1D vector of shape `(n,)` it is treated\nas a column vector of shape `(n, 1)`.\n\nIf the first and last tensors are matrices, the output will be a matrix.\nHowever, if either is a 1D vector, then the output will be a 1D vector.\n\nDifferences with `numpy.linalg.multi_dot`:\n\n- Unlike `numpy.linalg.multi_dot`, the first and last tensors must either be 1D or 2D\n  whereas NumPy allows them to be nD\n\n.. warning:: This function does not broadcast.\n\n.. note:: This function is implemented by chaining :func:`torch.mm` calls after\n          computing the optimal matrix multiplication order.\n\n.. note:: The cost of multiplying two matrices with shapes `(a, b)` and `(b, c)` is\n          `a * b * c`. Given matrices `A`, `B`, `C` with shapes `(10, 100)`,\n          `(100, 5)`, `(5, 50)` respectively, we can calculate the cost of different\n          multiplication orders as follows:\n\n          .. math::\n\n             \\begin{align*}\n             \\operatorname{cost}((AB)C) &= 10 \\times 100 \\times 5 + 10 \\times 5 \\times 50 = 7500 \\\\\n             \\operatorname{cost}(A(BC)) &= 10 \\times 100 \\times 50 + 100 \\times 5 \\times 50 = 75000\n             \\end{align*}\n\n          In this case, multiplying `A` and `B` first followed by `C` is 10 times faster.\n\nArgs:\n    tensors (Sequence[Tensor]): two or more tensors to multiply. The first and last\n        tensors may be 1D or 2D. Every other tensor must be 2D.\n\nKeyword args:\n    out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.\n\nExamples::\n\n    >>> from torch.linalg import multi_dot\n\n    >>> multi_dot([torch.tensor([1, 2]), torch.tensor([2, 3])])\n    tensor(8)\n    >>> multi_dot([torch.tensor([[1, 2]]), torch.tensor([2, 3])])\n    tensor([8])\n    >>> multi_dot([torch.tensor([[1, 2]]), torch.tensor([[2], [3]])])\n    tensor([[8]])\n\n    >>> A = torch.arange(2 * 3).view(2, 3)\n    >>> B = torch.arange(3 * 2).view(3, 2)\n    >>> C = torch.arange(2 * 2).view(2, 2)\n    >>> multi_dot((A, B, C))\n    tensor([[ 26,  49],\n            [ 80, 148]])\n",
          "Args": {
            "tensors": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "norm": {
          "Doc": "\nlinalg.norm(A, ord=None, dim=None, keepdim=False, *, out=None, dtype=None) -> Tensor\n\nComputes a vector or matrix norm.\n\nSupports input of float, double, cfloat and cdouble dtypes.\n\nWhether this function computes a vector or matrix norm is determined as follows:\n\n- If :attr:`dim` is an `int`, the vector norm will be computed.\n- If :attr:`dim` is a `2`-`tuple`, the matrix norm will be computed.\n- If :attr:`dim`\\ `= None` and :attr:`ord`\\ `= None`,\n  :attr:`A` will be flattened to 1D and the `2`-norm of the resulting vector will be computed.\n- If :attr:`dim`\\ `= None` and :attr:`ord` `!= None`, :attr:`A` must be 1D or 2D.\n\n:attr:`ord` defines the norm that is computed. The following norms are supported:\n\n======================     =========================  ========================================================\n:attr:`ord`                norm for matrices          norm for vectors\n======================     =========================  ========================================================\n`None` (default)           Frobenius norm             `2`-norm (see below)\n`'fro'`                    Frobenius norm             -- not supported --\n`'nuc'`                    nuclear norm               -- not supported --\n`inf`                      `max(sum(abs(x), dim=1))`  `max(abs(x))`\n`-inf`                     `min(sum(abs(x), dim=1))`  `min(abs(x))`\n`0`                        -- not supported --        `sum(x != 0)`\n`1`                        `max(sum(abs(x), dim=0))`  as below\n`-1`                       `min(sum(abs(x), dim=0))`  as below\n`2`                        largest singular value     as below\n`-2`                       smallest singular value    as below\nother `int` or `float`     -- not supported --        `sum(abs(x)^{ord})^{(1 / ord)}`\n======================     =========================  ========================================================\n\nwhere `inf` refers to `float('inf')`, NumPy's `inf` object, or any equivalent object.\n\n.. seealso::\n\n        :func:`torch.linalg.vector_norm` computes a vector norm.\n\n        :func:`torch.linalg.matrix_norm` computes a matrix norm.\n\n        The above functions are often clearer and more flexible than using :func:`torch.linalg.norm`.\n        For example, `torch.linalg.norm(A, ord=1, dim=(0, 1))` always\n        computes a matrix norm, but with `torch.linalg.vector_norm(A, ord=1, dim=(0, 1))` it is possible\n        to compute a vector norm over the two dimensions.\n\nArgs:\n    A (Tensor): tensor of shape `(*, n)` or `(*, m, n)` where `*` is zero or more batch dimensions\n    ord (int, float, inf, -inf, 'fro', 'nuc', optional): order of norm. Default: `None`\n    dim (int, Tuple[int], optional): dimensions over which to compute\n        the vector or matrix norm. See above for the behavior when :attr:`dim`\\ `= None`.\n        Default: `None`\n    keepdim (bool, optional): If set to `True`, the reduced dimensions are retained\n        in the result as dimensions with size one. Default: `False`\n\nKeyword args:\n    out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.\n    dtype (:class:`torch.dtype`, optional): If specified, the input tensor is cast to\n        :attr:`dtype` before performing the operation, and the returned tensor's type\n        will be :attr:`dtype`. Default: `None`\n\nReturns:\n    A real-valued tensor, even when :attr:`A` is complex.\n\nExamples::\n\n    >>> from torch import linalg as LA\n    >>> a = torch.arange(9, dtype=torch.float) - 4\n    >>> a\n    tensor([-4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])\n    >>> B = a.reshape((3, 3))\n    >>> B\n    tensor([[-4., -3., -2.],\n            [-1.,  0.,  1.],\n            [ 2.,  3.,  4.]])\n\n    >>> LA.norm(a)\n    tensor(7.7460)\n    >>> LA.norm(B)\n    tensor(7.7460)\n    >>> LA.norm(B, 'fro')\n    tensor(7.7460)\n    >>> LA.norm(a, float('inf'))\n    tensor(4.)\n    >>> LA.norm(B, float('inf'))\n    tensor(9.)\n    >>> LA.norm(a, -float('inf'))\n    tensor(0.)\n    >>> LA.norm(B, -float('inf'))\n    tensor(2.)\n\n    >>> LA.norm(a, 1)\n    tensor(20.)\n    >>> LA.norm(B, 1)\n    tensor(7.)\n    >>> LA.norm(a, -1)\n    tensor(0.)\n    >>> LA.norm(B, -1)\n    tensor(6.)\n    >>> LA.norm(a, 2)\n    tensor(7.7460)\n    >>> LA.norm(B, 2)\n    tensor(7.3485)\n\n    >>> LA.norm(a, -2)\n    tensor(0.)\n    >>> LA.norm(B.double(), -2)\n    tensor(1.8570e-16, dtype=torch.float64)\n    >>> LA.norm(a, 3)\n    tensor(5.8480)\n    >>> LA.norm(a, -3)\n    tensor(0.)\n\nUsing the :attr:`dim` argument to compute vector norms::\n\n    >>> c = torch.tensor([[1., 2., 3.],\n    ...                   [-1, 1, 4]])\n    >>> LA.norm(c, dim=0)\n    tensor([1.4142, 2.2361, 5.0000])\n    >>> LA.norm(c, dim=1)\n    tensor([3.7417, 4.2426])\n    >>> LA.norm(c, ord=1, dim=1)\n    tensor([6., 6.])\n\nUsing the :attr:`dim` argument to compute matrix norms::\n\n    >>> A = torch.arange(8, dtype=torch.float).reshape(2, 2, 2)\n    >>> LA.norm(A, dim=(1,2))\n    tensor([ 3.7417, 11.2250])\n    >>> LA.norm(A[0, :, :]), LA.norm(A[1, :, :])\n    (tensor(3.7417), tensor(11.2250))\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "ord": {
              "Type": null,
              "Default": "None"
            },
            "dim": {
              "Type": null,
              "Default": "None"
            },
            "keepdim": {
              "Type": null,
              "Default": "False"
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "out": {
              "Type": null,
              "Default": "None"
            },
            "dtype": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "pinv": {
          "Doc": "\nlinalg.pinv(A, *, atol=None, rtol=None, hermitian=False, out=None) -> Tensor\n\nComputes the pseudoinverse (Moore-Penrose inverse) of a matrix.\n\nThe pseudoinverse may be `defined algebraically`_\nbut it is more computationally convenient to understand it `through the SVD`_\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\nIf :attr:`hermitian`\\ `= True`, :attr:`A` is assumed to be Hermitian if complex or\nsymmetric if real, but this is not checked internally. Instead, just the lower\ntriangular part of the matrix is used in the computations.\n\nThe singular values (or the norm of the eigenvalues when :attr:`hermitian`\\ `= True`)\nthat are below :math:`\\max(\\text{atol}, \\sigma_1 \\cdot \\text{rtol})` threshold are\ntreated as zero and discarded in the computation,\nwhere :math:`\\sigma_1` is the largest singular value (or eigenvalue).\n\nIf :attr:`rtol` is not specified and :attr:`A` is a matrix of dimensions `(m, n)`,\nthe relative tolerance is set to be :math:`\\text{rtol} = \\max(m, n) \\varepsilon`\nand :math:`\\varepsilon` is the epsilon value for the dtype of :attr:`A` (see :class:`.finfo`).\nIf :attr:`rtol` is not specified and :attr:`atol` is specified to be larger than zero then\n:attr:`rtol` is set to zero.\n\nIf :attr:`atol` or :attr:`rtol` is a :class:`torch.Tensor`, its shape must be broadcastable to that\nof the singular values of :attr:`A` as returned by :func:`torch.linalg.svd`.\n\n.. note:: This function uses :func:`torch.linalg.svd` if :attr:`hermitian`\\ `= False` and\n          :func:`torch.linalg.eigh` if :attr:`hermitian`\\ `= True`.\n          For CUDA inputs, this function synchronizes that device with the CPU.\n\n.. note::\n    Consider using :func:`torch.linalg.lstsq` if possible for multiplying a matrix on the left by\n    the pseudoinverse, as::\n\n        torch.linalg.lstsq(A, B).solution == A.pinv() @ B\n\n    It is always prefered to use :func:`~lstsq` when possible, as it is faster and more\n    numerically stable than computing the pseudoinverse explicitly.\n\n.. note::\n    This function has NumPy compatible variant `linalg.pinv(A, rcond, hermitian=False)`.\n    However, use of the positional argument :attr:`rcond` is deprecated in favor of :attr:`rtol`.\n\n.. warning::\n    This function uses internally :func:`torch.linalg.svd` (or :func:`torch.linalg.eigh`\n    when :attr:`hermitian`\\ `= True`), so its derivative has the same problems as those of these\n    functions. See the warnings in :func:`torch.linalg.svd` and :func:`torch.linalg.eigh` for\n    more details.\n\n.. seealso::\n\n        :func:`torch.linalg.inv` computes the inverse of a square matrix.\n\n        :func:`torch.linalg.lstsq` computes :attr:`A`\\ `.pinv() @ \\ `:attr:`B` with a\n        numerically stable algorithm.\n\nArgs:\n    A (Tensor): tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions.\n    rcond (float, Tensor, optional): [NumPy Compat]. Alias for :attr:`rtol`. Default: `None`.\n\nKeyword args:\n    atol (float, Tensor, optional): the absolute tolerance value. When `None` it's considered to be zero.\n                                    Default: `None`.\n    rtol (float, Tensor, optional): the relative tolerance value. See above for the value it takes when `None`.\n                                    Default: `None`.\n    hermitian(bool, optional): indicates whether :attr:`A` is Hermitian if complex\n                               or symmetric if real. Default: `False`.\n    out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.\n\nExamples::\n\n    >>> A = torch.randn(3, 5)\n    >>> A\n    tensor([[ 0.5495,  0.0979, -1.4092, -0.1128,  0.4132],\n            [-1.1143, -0.3662,  0.3042,  1.6374, -0.9294],\n            [-0.3269, -0.5745, -0.0382, -0.5922, -0.6759]])\n    >>> torch.linalg.pinv(A)\n    tensor([[ 0.0600, -0.1933, -0.2090],\n            [-0.0903, -0.0817, -0.4752],\n            [-0.7124, -0.1631, -0.2272],\n            [ 0.1356,  0.3933, -0.5023],\n            [-0.0308, -0.1725, -0.5216]])\n\n    >>> A = torch.randn(2, 6, 3)\n    >>> Apinv = torch.linalg.pinv(A)\n    >>> torch.dist(Apinv @ A, torch.eye(3))\n    tensor(8.5633e-07)\n\n    >>> A = torch.randn(3, 3, dtype=torch.complex64)\n    >>> A = A + A.T.conj()  # creates a Hermitian matrix\n    >>> Apinv = torch.linalg.pinv(A, hermitian=True)\n    >>> torch.dist(Apinv @ A, torch.eye(3))\n    tensor(1.0830e-06)\n\n.. _defined algebraically:\n    https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse#Existence_and_uniqueness\n.. _through the SVD:\n    https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse#Singular_value_decomposition_(SVD)\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "atol": {
              "Type": null,
              "Default": "None"
            },
            "rtol": {
              "Type": null,
              "Default": "None"
            },
            "hermitian": {
              "Type": null,
              "Default": "False"
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "qr": {
          "Doc": "\nqr(A, mode='reduced', *, out=None) -> (Tensor, Tensor)\n\nComputes the QR decomposition of a matrix.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthe **full QR decomposition** of a matrix\n:math:`A \\in \\mathbb{K}^{m \\times n}` is defined as\n\n.. math::\n\n    A = QR\\mathrlap{\\qquad Q \\in \\mathbb{K}^{m \\times m}, R \\in \\mathbb{K}^{m \\times n}}\n\nwhere :math:`Q` is orthogonal in the real case and unitary in the complex case,\nand :math:`R` is upper triangular with real diagonal (even in the complex case).\n\nWhen `m > n` (tall matrix), as `R` is upper triangular, its last `m - n` rows are zero.\nIn this case, we can drop the last `m - n` columns of `Q` to form the\n**reduced QR decomposition**:\n\n.. math::\n\n    A = QR\\mathrlap{\\qquad Q \\in \\mathbb{K}^{m \\times n}, R \\in \\mathbb{K}^{n \\times n}}\n\nThe reduced QR decomposition agrees with the full QR decomposition when `n >= m` (wide matrix).\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\nThe parameter :attr:`mode` chooses between the full and reduced QR decomposition.\nIf :attr:`A` has shape `(*, m, n)`, denoting `k = min(m, n)`\n\n- :attr:`mode`\\ `= 'reduced'` (default): Returns `(Q, R)` of shapes `(*, m, k)`, `(*, k, n)` respectively.\n  It is always differentiable.\n- :attr:`mode`\\ `= 'complete'`: Returns `(Q, R)` of shapes `(*, m, m)`, `(*, m, n)` respectively.\n  It is differentiable for `m <= n`.\n- :attr:`mode`\\ `= 'r'`: Computes only the reduced `R`. Returns `(Q, R)` with `Q` empty and `R` of shape `(*, k, n)`.\n  It is never differentiable.\n\nDifferences with `numpy.linalg.qr`:\n\n- :attr:`mode`\\ `= 'raw'` is not implemented.\n- Unlike `numpy.linalg.qr`, this function always returns a tuple of two tensors.\n  When :attr:`mode`\\ `= 'r'`, the `Q` tensor is an empty tensor.\n\n.. warning:: The elements in the diagonal of `R` are not necessarily positive.\n             As such, the returned QR decomposition is only unique up to the sign of the diagonal of `R`.\n             Therefore, different platforms, like NumPy, or inputs on different devices,\n             may produce different valid decompositions.\n\n.. warning:: The QR decomposition is only well-defined if the first `k = min(m, n)` columns\n             of every matrix in :attr:`A` are linearly independent.\n             If this condition is not met, no error will be thrown, but the QR produced\n             may be incorrect and its autodiff may fail or produce incorrect results.\n\nArgs:\n    A (Tensor): tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions.\n    mode (str, optional): one of `'reduced'`, `'complete'`, `'r'`.\n                          Controls the shape of the returned tensors. Default: `'reduced'`.\n\nKeyword args:\n    out (tuple, optional): output tuple of two tensors. Ignored if `None`. Default: `None`.\n\nReturns:\n    A named tuple `(Q, R)`.\n\nExamples::\n\n    >>> A = torch.tensor([[12., -51, 4], [6, 167, -68], [-4, 24, -41]])\n    >>> Q, R = torch.linalg.qr(A)\n    >>> Q\n    tensor([[-0.8571,  0.3943,  0.3314],\n            [-0.4286, -0.9029, -0.0343],\n            [ 0.2857, -0.1714,  0.9429]])\n    >>> R\n    tensor([[ -14.0000,  -21.0000,   14.0000],\n            [   0.0000, -175.0000,   70.0000],\n            [   0.0000,    0.0000,  -35.0000]])\n    >>> (Q @ R).round()\n    tensor([[  12.,  -51.,    4.],\n            [   6.,  167.,  -68.],\n            [  -4.,   24.,  -41.]])\n    >>> (Q.T @ Q).round()\n    tensor([[ 1.,  0.,  0.],\n            [ 0.,  1., -0.],\n            [ 0., -0.,  1.]])\n    >>> Q2, R2 = torch.linalg.qr(A, mode='r')\n    >>> Q2\n    tensor([])\n    >>> torch.equal(R, R2)\n    True\n    >>> A = torch.randn(3, 4, 5)\n    >>> Q, R = torch.linalg.qr(A, mode='complete')\n    >>> torch.dist(Q @ R, A)\n    tensor(1.6099e-06)\n    >>> torch.dist(Q.mT @ Q, torch.eye(4))\n    tensor(6.2158e-07)\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "mode": {
              "Type": null,
              "Default": "'reduced'"
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "out": {
              "Type": null,
              "Default": "None) -> (Tensor"
            },
            "Tensor": {
              "Type": null,
              "Default": null
            }
          }
        },
        "slogdet": {
          "Doc": "\nlinalg.slogdet(A, *, out=None) -> (Tensor, Tensor)\n\nComputes the sign and natural logarithm of the absolute value of the determinant of a square matrix.\n\nFor complex :attr:`A`, it returns the angle and the natural logarithm of the modulus of the\ndeterminant, that is, a logarithmic polar decomposition of the determinant.\n\nThe determinant can be recovered as `sign * exp(logabsdet)`.\nWhen a matrix has a determinant of zero, it returns `(0, -inf)`.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\n.. seealso::\n\n        :func:`torch.linalg.det` computes the determinant of square matrices.\n\nArgs:\n    A (Tensor): tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions.\n\nKeyword args:\n    out (tuple, optional): output tuple of two tensors. Ignored if `None`. Default: `None`.\n\nReturns:\n    A named tuple `(sign, logabsdet)`.\n\n    `sign` will have the same dtype as :attr:`A`.\n\n    `logabsdet` will always be real-valued, even when :attr:`A` is complex.\n\nExamples::\n\n    >>> A = torch.randn(3, 3)\n    >>> A\n    tensor([[ 0.0032, -0.2239, -1.1219],\n            [-0.6690,  0.1161,  0.4053],\n            [-1.6218, -0.9273, -0.0082]])\n    >>> torch.linalg.det(A)\n    tensor(-0.7576)\n    >>> torch.logdet(A)\n    tensor(nan)\n    >>> torch.linalg.slogdet(A)\n    torch.return_types.linalg_slogdet(sign=tensor(-1.), logabsdet=tensor(-0.2776))\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "out": {
              "Type": null,
              "Default": "None) -> (Tensor"
            },
            "Tensor": {
              "Type": null,
              "Default": null
            }
          }
        },
        "solve": {
          "Doc": "\nlinalg.solve(A, B, *, left=True, out=None) -> Tensor\n\nComputes the solution of a square system of linear equations with a unique solution.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthis function computes the solution :math:`X \\in \\mathbb{K}^{n \\times k}` of the **linear system** associated to\n:math:`A \\in \\mathbb{K}^{n \\times n}, B \\in \\mathbb{K}^{n \\times k}`, which is defined as\n\n.. math:: AX = B\n\nIf :attr:`left`\\ `= False`, this function returns the matrix :math:`X \\in \\mathbb{K}^{n \\times k}` that solves the system\n\n.. math::\n\n    XA = B\\mathrlap{\\qquad A \\in \\mathbb{K}^{k \\times k}, B \\in \\mathbb{K}^{n \\times k}.}\n\nThis system of linear equations has one solution if and only if :math:`A` is `invertible`_.\nThis function assumes that :math:`A` is invertible.\n\nSupports inputs of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if the inputs are batches of matrices then\nthe output has the same batch dimensions.\n\nLetting `*` be zero or more batch dimensions,\n\n- If :attr:`A` has shape `(*, n, n)` and :attr:`B` has shape `(*, n)` (a batch of vectors) or shape\n  `(*, n, k)` (a batch of matrices or \"multiple right-hand sides\"), this function returns `X` of shape\n  `(*, n)` or `(*, n, k)` respectively.\n- Otherwise, if :attr:`A` has shape `(*, n, n)` and  :attr:`B` has shape `(n,)`  or `(n, k)`, :attr:`B`\n  is broadcasted to have shape `(*, n)` or `(*, n, k)` respectively.\n  This function then returns the solution of the resulting batch of systems of linear equations.\n\n.. note::\n    This function computes `X = \\ `:attr:`A`\\ `.inverse() @ \\ `:attr:`B` in a faster and\n    more numerically stable way than performing the computations separately.\n\n.. note::\n    It is possible to compute the solution of the system :math:`XA = B` by passing the inputs\n    :attr:`A` and :attr:`B` transposed and transposing the output returned by this function.\n\n\n.. note:: When inputs are on a CUDA device, this function synchronizes that device with the CPU.\n\n\n.. seealso::\n\n        :func:`torch.linalg.solve_triangular` computes the solution of a triangular system of linear\n        equations with a unique solution.\n\nArgs:\n    A (Tensor): tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions.\n    B (Tensor): right-hand side tensor of shape `(*, n)` or  `(*, n, k)` or `(n,)` or `(n, k)`\n                according to the rules described above\n\nKeyword args:\n    left (bool, optional): whether to solve the system :math:`AX=B` or :math:`XA = B`. Default: `True`.\n    out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.\n\nRaises:\n    RuntimeError: if the :attr:`A` matrix is not invertible or any matrix in a batched :attr:`A`\n                  is not invertible.\n\nExamples::\n\n    >>> A = torch.randn(3, 3)\n    >>> b = torch.randn(3)\n    >>> x = torch.linalg.solve(A, b)\n    >>> torch.allclose(A @ x, b)\n    True\n    >>> A = torch.randn(2, 3, 3)\n    >>> B = torch.randn(2, 3, 4)\n    >>> X = torch.linalg.solve(A, B)\n    >>> X.shape\n    torch.Size([2, 3, 4])\n    >>> torch.allclose(A @ X, B)\n    True\n\n    >>> A = torch.randn(2, 3, 3)\n    >>> b = torch.randn(3, 1)\n    >>> x = torch.linalg.solve(A, b) # b is broadcasted to size (2, 3, 1)\n    >>> x.shape\n    torch.Size([2, 3, 1])\n    >>> torch.allclose(A @ x, b)\n    True\n    >>> b = torch.randn(3)\n    >>> x = torch.linalg.solve(A, b) # b is broadcasted to size (2, 3)\n    >>> x.shape\n    torch.Size([2, 3])\n    >>> Ax = A @ x.unsqueeze(-1)\n    >>> torch.allclose(Ax, b.unsqueeze(-1).expand_as(Ax))\n    True\n\n.. _invertible:\n    https://en.wikipedia.org/wiki/Invertible_matrix#The_invertible_matrix_theorem\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "B": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "left": {
              "Type": null,
              "Default": "True"
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "solve_ex": {
          "Doc": "\nlinalg.solve_ex(A, B, *, left=True, check_errors=False, out=None) -> (Tensor, Tensor)\n\nA version of :func:`~solve` that does not perform error checks unless :attr:`check_errors`\\ `= True`.\nIt also returns the :attr:`info` tensor returned by `LAPACK's getrf`_.\n\n\n.. note:: When the inputs are on a CUDA device, this function synchronizes only when :attr:`check_errors`\\ `= True`.\n\n.. warning:: This function is \"experimental\" and it may change in a future PyTorch release.\n\n\nArgs:\n    A (Tensor): tensor of shape `(*, n, n)` where `*` is zero or more batch dimensions.\n\nKeyword args:\n    left (bool, optional): whether to solve the system :math:`AX=B` or :math:`XA = B`. Default: `True`.\n    check_errors (bool, optional): controls whether to check the content of ``infos`` and raise\n                                   an error if it is non-zero. Default: `False`.\n    out (tuple, optional): tuple of two tensors to write the output to. Ignored if `None`. Default: `None`.\n\nReturns:\n    A named tuple `(result, info)`.\n\nExamples::\n\n    >>> A = torch.randn(3, 3)\n    >>> Ainv, info = torch.linalg.solve_ex(A)\n    >>> torch.dist(torch.linalg.inv(A), Ainv)\n    tensor(0.)\n    >>> info\n    tensor(0, dtype=torch.int32)\n\n.. _LAPACK's getrf:\n    https://www.netlib.org/lapack/explore-html/dd/d9a/group__double_g_ecomputational_ga0019443faea08275ca60a734d0593e60.html\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "B": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "left": {
              "Type": null,
              "Default": "True"
            },
            "check_errors": {
              "Type": null,
              "Default": "False"
            },
            "out": {
              "Type": null,
              "Default": "None) -> (Tensor"
            },
            "Tensor": {
              "Type": null,
              "Default": null
            }
          }
        },
        "solve_triangular": {
          "Doc": "\nlinalg.solve_triangular(A, B, *, upper, left=True, unitriangular=False, out=None) -> Tensor\n\nComputes the solution of a triangular system of linear equations with a unique solution.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthis function computes the solution :math:`X \\in \\mathbb{K}^{n \\times k}` of the **linear system**\nassociated to the triangular matrix :math:`A \\in \\mathbb{K}^{n \\times n}` without zeros on the diagonal\n(that is, it is `invertible`_) and the rectangular matrix , :math:`B \\in \\mathbb{K}^{n \\times k}`,\nwhich is defined as\n\n.. math:: AX = B\n\nThe argument :attr:`upper` signals whether :math:`A` is upper or lower triangular.\n\nIf :attr:`left`\\ `= False`, this function returns the matrix :math:`X \\in \\mathbb{K}^{n \\times k}` that\nsolves the system\n\n.. math::\n\n    XA = B\\mathrlap{\\qquad A \\in \\mathbb{K}^{k \\times k}, B \\in \\mathbb{K}^{n \\times k}.}\n\nIf :attr:`upper`\\ `= True` (resp. `False`) just the upper (resp. lower) triangular half of :attr:`A`\nwill be accessed. The elements below the main diagonal will be considered to be zero and will not be accessed.\n\nIf :attr:`unitriangular`\\ `= True`, the diagonal of :attr:`A` is assumed to be ones and will not be accessed.\n\nThe result may contain `NaN` s if the diagonal of :attr:`A` contains zeros or elements that\nare very close to zero and :attr:`unitriangular`\\ `= False` (default) or if the input matrix\nhas very small eigenvalues.\n\nSupports inputs of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if the inputs are batches of matrices then\nthe output has the same batch dimensions.\n\n.. seealso::\n\n        :func:`torch.linalg.solve` computes the solution of a general square system of linear\n        equations with a unique solution.\n\nArgs:\n    A (Tensor): tensor of shape `(*, n, n)` (or `(*, k, k)` if :attr:`left`\\ `= True`)\n                where `*` is zero or more batch dimensions.\n    B (Tensor): right-hand side tensor of shape `(*, n, k)`.\n\nKeyword args:\n    upper (bool): whether :attr:`A` is an upper or lower triangular matrix.\n    left (bool, optional): whether to solve the system :math:`AX=B` or :math:`XA = B`. Default: `True`.\n    unitriangular (bool, optional): if `True`, the diagonal elements of :attr:`A` are assumed to be\n                                    all equal to `1`. Default: `False`.\n    out (Tensor, optional): output tensor. `B` may be passed as `out` and the result is computed in-place on `B`.\n                            Ignored if `None`. Default: `None`.\n\nExamples::\n\n    >>> A = torch.randn(3, 3).triu_()\n    >>> b = torch.randn(3, 4)\n    >>> X = torch.linalg.solve_triangular(A, B, upper=True)\n    >>> torch.allclose(A @ X, B)\n    True\n\n    >>> A = torch.randn(2, 3, 3).tril_()\n    >>> B = torch.randn(2, 3, 4)\n    >>> X = torch.linalg.solve_triangular(A, B, upper=False)\n    >>> torch.allclose(A @ X, B)\n    True\n\n    >>> A = torch.randn(2, 4, 4).tril_()\n    >>> B = torch.randn(2, 3, 4)\n    >>> X = torch.linalg.solve_triangular(A, B, upper=False, left=False)\n    >>> torch.allclose(X @ A, B)\n    True\n\n.. _invertible:\n    https://en.wikipedia.org/wiki/Invertible_matrix#The_invertible_matrix_theorem\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "B": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "upper": {
              "Type": null,
              "Default": null
            },
            "left": {
              "Type": null,
              "Default": "True"
            },
            "unitriangular": {
              "Type": null,
              "Default": "False"
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "svd": {
          "Doc": "\nlinalg.svd(A, full_matrices=True, *, driver=None, out=None) -> (Tensor, Tensor, Tensor)\n\nComputes the singular value decomposition (SVD) of a matrix.\n\nLetting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`,\nthe **full SVD** of a matrix\n:math:`A \\in \\mathbb{K}^{m \\times n}`, if `k = min(m,n)`, is defined as\n\n.. math::\n\n    A = U \\operatorname{diag}(S) V^{\\text{H}}\n    \\mathrlap{\\qquad U \\in \\mathbb{K}^{m \\times m}, S \\in \\mathbb{R}^k, V \\in \\mathbb{K}^{n \\times n}}\n\nwhere :math:`\\operatorname{diag}(S) \\in \\mathbb{K}^{m \\times n}`,\n:math:`V^{\\text{H}}` is the conjugate transpose when :math:`V` is complex, and the transpose when :math:`V` is real-valued.\nThe matrices  :math:`U`, :math:`V` (and thus :math:`V^{\\text{H}}`) are orthogonal in the real case, and unitary in the complex case.\n\nWhen `m > n` (resp. `m < n`) we can drop the last `m - n` (resp. `n - m`) columns of `U` (resp. `V`) to form the **reduced SVD**:\n\n.. math::\n\n    A = U \\operatorname{diag}(S) V^{\\text{H}}\n    \\mathrlap{\\qquad U \\in \\mathbb{K}^{m \\times k}, S \\in \\mathbb{R}^k, V \\in \\mathbb{K}^{k \\times n}}\n\nwhere :math:`\\operatorname{diag}(S) \\in \\mathbb{K}^{k \\times k}`.\nIn this case, :math:`U` and :math:`V` also have orthonormal columns.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\nThe returned decomposition is a named tuple `(U, S, Vh)`\nwhich corresponds to :math:`U`, :math:`S`, :math:`V^{\\text{H}}` above.\n\nThe singular values are returned in descending order.\n\nThe parameter :attr:`full_matrices` chooses between the full (default) and reduced SVD.\n\nThe :attr:`driver` kwarg may be used in CUDA with a cuSOLVER backend to choose the algorithm used to compute the SVD.\nThe choice of a driver is a trade-off between accuracy and speed.\n\n- If :attr:`A` is well-conditioned (its `condition number`_ is not too large), or you do not mind some precision loss.\n\n  - For a general matrix: `'gesvdj'` (Jacobi method)\n  - If :attr:`A` is tall or wide (`m >> n` or `m << n`): `'gesvda'` (Approximate method)\n\n- If :attr:`A` is not well-conditioned or precision is relevant: `'gesvd'` (QR based)\n\nBy default (:attr:`driver`\\ `= None`), we call `'gesvdj'` and, if it fails, we fallback to `'gesvd'`.\n\nDifferences with `numpy.linalg.svd`:\n\n- Unlike `numpy.linalg.svd`, this function always returns a tuple of three tensors\n  and it doesn't support `compute_uv` argument.\n  Please use :func:`torch.linalg.svdvals`, which computes only the singular values,\n  instead of `compute_uv=False`.\n\n.. note:: When :attr:`full_matrices`\\ `= True`, the gradients with respect to `U[..., :, min(m, n):]`\n          and `Vh[..., min(m, n):, :]` will be ignored, as those vectors can be arbitrary bases\n          of the corresponding subspaces.\n\n.. warning:: The returned tensors `U` and `V` are not unique, nor are they continuous with\n             respect to :attr:`A`.\n             Due to this lack of uniqueness, different hardware and software may compute\n             different singular vectors.\n\n             This non-uniqueness is caused by the fact that multiplying any pair of singular\n             vectors :math:`u_k, v_k` by `-1` in the real case or by\n             :math:`e^{i \\phi}, \\phi \\in \\mathbb{R}` in the complex case produces another two\n             valid singular vectors of the matrix.\n             For this reason, the loss function shall not depend on this :math:`e^{i \\phi}` quantity,\n             as it is not well-defined.\n             This is checked for complex inputs when computing the gradients of this function. As such,\n             when inputs are complex and are on a CUDA device, the computation of the gradients\n             of this function synchronizes that device with the CPU.\n\n.. warning:: Gradients computed using `U` or `Vh` will only be finite when\n             :attr:`A` does not have repeated singular values. If :attr:`A` is rectangular,\n             additionally, zero must also not be one of its singular values.\n             Furthermore, if the distance between any two singular values is close to zero,\n             the gradient will be numerically unstable, as it depends on the singular values\n             :math:`\\sigma_i` through the computation of\n             :math:`\\frac{1}{\\min_{i \\neq j} \\sigma_i^2 - \\sigma_j^2}`.\n             In the rectangular case, the gradient will also be numerically unstable when\n             :attr:`A` has small singular values, as it also depends on the computation of\n             :math:`\\frac{1}{\\sigma_i}`.\n\n.. seealso::\n\n        :func:`torch.linalg.svdvals` computes only the singular values.\n        Unlike :func:`torch.linalg.svd`, the gradients of :func:`~svdvals` are always\n        numerically stable.\n\n        :func:`torch.linalg.eig` for a function that computes another type of spectral\n        decomposition of a matrix. The eigendecomposition works just on square matrices.\n\n        :func:`torch.linalg.eigh` for a (faster) function that computes the eigenvalue decomposition\n        for Hermitian and symmetric matrices.\n\n        :func:`torch.linalg.qr` for another (much faster) decomposition that works on general\n        matrices.\n\nArgs:\n    A (Tensor): tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions.\n    full_matrices (bool, optional): controls whether to compute the full or reduced\n                                    SVD, and consequently,\n                                    the shape of the returned tensors\n                                    `U` and `Vh`. Default: `True`.\n\nKeyword args:\n    driver (str, optional): name of the cuSOLVER method to be used. This keyword argument only works on CUDA inputs.\n        Available options are: `None`, `gesvd`, `gesvdj`, and `gesvda`.\n        Default: `None`.\n    out (tuple, optional): output tuple of three tensors. Ignored if `None`.\n\nReturns:\n    A named tuple `(U, S, Vh)` which corresponds to :math:`U`, :math:`S`, :math:`V^{\\text{H}}` above.\n\n    `S` will always be real-valued, even when :attr:`A` is complex.\n    It will also be ordered in descending order.\n\n    `U` and `Vh` will have the same dtype as :attr:`A`. The left / right singular vectors will be given by\n    the columns of `U` and the rows of `Vh` respectively.\n\nExamples::\n\n    >>> A = torch.randn(5, 3)\n    >>> U, S, Vh = torch.linalg.svd(A, full_matrices=False)\n    >>> U.shape, S.shape, Vh.shape\n    (torch.Size([5, 3]), torch.Size([3]), torch.Size([3, 3]))\n    >>> torch.dist(A, U @ torch.diag(S) @ Vh)\n    tensor(1.0486e-06)\n\n    >>> U, S, Vh = torch.linalg.svd(A)\n    >>> U.shape, S.shape, Vh.shape\n    (torch.Size([5, 5]), torch.Size([3]), torch.Size([3, 3]))\n    >>> torch.dist(A, U[:, :3] @ torch.diag(S) @ Vh)\n    tensor(1.0486e-06)\n\n    >>> A = torch.randn(7, 5, 3)\n    >>> U, S, Vh = torch.linalg.svd(A, full_matrices=False)\n    >>> torch.dist(A, U @ torch.diag_embed(S) @ Vh)\n    tensor(3.0957e-06)\n\n.. _condition number:\n    https://pytorch.org/docs/master/linalg.html#torch.linalg.cond\n.. _the resulting vectors will span the same subspace:\n    https://en.wikipedia.org/wiki/Singular_value_decomposition#Singular_values,_singular_vectors,_and_their_relation_to_the_SVD\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "full_matrices": {
              "Type": null,
              "Default": "True"
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "driver": {
              "Type": null,
              "Default": "None"
            },
            "out": {
              "Type": null,
              "Default": "None) -> (Tensor"
            },
            "Tensor": {
              "Type": null,
              "Default": null
            }
          }
        },
        "svdvals": {
          "Doc": "\nlinalg.svdvals(A, *, driver=None, out=None) -> Tensor\n\nComputes the singular values of a matrix.\n\nSupports input of float, double, cfloat and cdouble dtypes.\nAlso supports batches of matrices, and if :attr:`A` is a batch of matrices then\nthe output has the same batch dimensions.\n\nThe singular values are returned in descending order.\n\n.. note:: This function is equivalent to NumPy's `linalg.svd(A, compute_uv=False)`.\n\n\n.. note:: When inputs are on a CUDA device, this function synchronizes that device with the CPU.\n\n\n.. seealso::\n\n        :func:`torch.linalg.svd` computes the full singular value decomposition.\n\nArgs:\n    A (Tensor): tensor of shape `(*, m, n)` where `*` is zero or more batch dimensions.\n\nKeyword args:\n    driver (str, optional): name of the cuSOLVER method to be used. This keyword argument only works on CUDA inputs.\n        Available options are: `None`, `gesvd`, `gesvdj`, and `gesvda`.\n        Check :func:`torch.linalg.svd` for details.\n        Default: `None`.\n    out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.\n\nReturns:\n    A real-valued tensor, even when :attr:`A` is complex.\n\nExamples::\n\n    >>> A = torch.randn(5, 3)\n    >>> S = torch.linalg.svdvals(A)\n    >>> S\n    tensor([2.5139, 2.1087, 1.1066])\n\n    >>> torch.dist(S, torch.linalg.svd(A, full_matrices=False).S)\n    tensor(2.4576e-07)\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "driver": {
              "Type": null,
              "Default": "None"
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "tensorinv": {
          "Doc": "\nlinalg.tensorinv(A, ind=2, *, out=None) -> Tensor\n\nComputes the multiplicative inverse of :func:`torch.tensordot`.\n\nIf `m` is the product of the first :attr:`ind` dimensions of :attr:`A` and `n` is the product of\nthe rest of the dimensions, this function expects `m` and `n` to be equal.\nIf this is the case, it computes a tensor `X` such that\n`tensordot(\\ `:attr:`A`\\ `, X, \\ `:attr:`ind`\\ `)` is the identity matrix in dimension `m`.\n`X` will have the shape of :attr:`A` but with the first :attr:`ind` dimensions pushed back to the end\n\n.. code:: text\n\n    X.shape == A.shape[ind:] + A.shape[:ind]\n\nSupports input of float, double, cfloat and cdouble dtypes.\n\n.. note:: When :attr:`A` is a `2`-dimensional tensor and :attr:`ind`\\ `= 1`,\n          this function computes the (multiplicative) inverse of :attr:`A`\n          (see :func:`torch.linalg.inv`).\n\n.. note::\n    Consider using :func:`torch.linalg.tensorsolve` if possible for multiplying a tensor on the left\n    by the tensor inverse, as::\n\n        linalg.tensorsolve(A, B) == torch.tensordot(linalg.tensorinv(A), B)  # When B is a tensor with shape A.shape[:B.ndim]\n\n    It is always prefered to use :func:`~tensorsolve` when possible, as it is faster and more\n    numerically stable than computing the pseudoinverse explicitly.\n\n.. seealso::\n\n        :func:`torch.linalg.tensorsolve` computes\n        `torch.tensordot(tensorinv(\\ `:attr:`A`\\ `), \\ `:attr:`B`\\ `)`.\n\nArgs:\n    A (Tensor): tensor to invert. Its shape must satisfy\n                    `prod(\\ `:attr:`A`\\ `.shape[:\\ `:attr:`ind`\\ `]) ==\n                    prod(\\ `:attr:`A`\\ `.shape[\\ `:attr:`ind`\\ `:])`.\n    ind (int): index at which to compute the inverse of :func:`torch.tensordot`. Default: `2`.\n\nKeyword args:\n    out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.\n\nRaises:\n    RuntimeError: if the reshaped :attr:`A` is not invertible or the product of the first\n                  :attr:`ind` dimensions is not equal to the product of the rest.\n\nExamples::\n\n    >>> A = torch.eye(4 * 6).reshape((4, 6, 8, 3))\n    >>> Ainv = torch.linalg.tensorinv(A, ind=2)\n    >>> Ainv.shape\n    torch.Size([8, 3, 4, 6])\n    >>> B = torch.randn(4, 6)\n    >>> torch.allclose(torch.tensordot(Ainv, B), torch.linalg.tensorsolve(A, B))\n    True\n\n    >>> A = torch.randn(4, 4)\n    >>> Atensorinv = torch.linalg.tensorinv(A, ind=1)\n    >>> Ainv = torch.linalg.inverse(A)\n    >>> torch.allclose(Atensorinv, Ainv)\n    True\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "ind": {
              "Type": null,
              "Default": "2"
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "tensorsolve": {
          "Doc": "\nlinalg.tensorsolve(A, B, dims=None, *, out=None) -> Tensor\n\nComputes the solution `X` to the system `torch.tensordot(A, X) = B`.\n\nIf `m` is the product of the first :attr:`B`\\ `.ndim`  dimensions of :attr:`A` and\n`n` is the product of the rest of the dimensions, this function expects `m` and `n` to be equal.\n\nThe returned tensor `x` satisfies\n`tensordot(\\ `:attr:`A`\\ `, x, dims=x.ndim) == \\ `:attr:`B`.\n`x` has shape :attr:`A`\\ `[B.ndim:]`.\n\nIf :attr:`dims` is specified, :attr:`A` will be reshaped as\n\n.. code:: text\n\n    A = movedim(A, dims, range(len(dims) - A.ndim + 1, 0))\n\nSupports inputs of float, double, cfloat and cdouble dtypes.\n\n.. seealso::\n\n        :func:`torch.linalg.tensorinv` computes the multiplicative inverse of\n        :func:`torch.tensordot`.\n\nArgs:\n    A (Tensor): tensor to solve for. Its shape must satisfy\n                    `prod(\\ `:attr:`A`\\ `.shape[:\\ `:attr:`B`\\ `.ndim]) ==\n                    prod(\\ `:attr:`A`\\ `.shape[\\ `:attr:`B`\\ `.ndim:])`.\n    B (Tensor): tensor of shape :attr:`A`\\ `.shape[:\\ `:attr:`B`\\ `.ndim]`.\n    dims (Tuple[int], optional): dimensions of :attr:`A` to be moved.\n        If `None`, no dimensions are moved. Default: `None`.\n\nKeyword args:\n    out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.\n\nRaises:\n    RuntimeError: if the reshaped :attr:`A`\\ `.view(m, m)` with `m` as above  is not\n                  invertible or the product of the first :attr:`ind` dimensions is not equal\n                  to the product of the rest of the dimensions.\n\nExamples::\n\n    >>> A = torch.eye(2 * 3 * 4).reshape((2 * 3, 4, 2, 3, 4))\n    >>> B = torch.randn(2 * 3, 4)\n    >>> X = torch.linalg.tensorsolve(A, B)\n    >>> X.shape\n    torch.Size([2, 3, 4])\n    >>> torch.allclose(torch.tensordot(A, X, dims=X.ndim), B)\n    True\n\n    >>> A = torch.randn(6, 4, 4, 3, 2)\n    >>> B = torch.randn(4, 3, 2)\n    >>> X = torch.linalg.tensorsolve(A, B, dims=(0, 2))\n    >>> X.shape\n    torch.Size([6, 4])\n    >>> A = A.permute(1, 3, 4, 0, 2)\n    >>> A.shape[B.ndim:]\n    torch.Size([6, 4])\n    >>> torch.allclose(torch.tensordot(A, X, dims=X.ndim), B, atol=1e-6)\n    True\n",
          "Args": {
            "A": {
              "Type": null,
              "Default": null
            },
            "B": {
              "Type": null,
              "Default": null
            },
            "dims": {
              "Type": null,
              "Default": "None"
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "vander": {
          "Doc": "\nvander(x, N=None) -> Tensor\n\nGenerates a Vandermonde matrix.\n\nReturns the Vandermonde matrix :math:`V`\n\n.. math::\n\n    V = \\begin{pmatrix}\n            1 & x_1 & x_1^2 & \\dots & x_1^{N-1}\\\\\n            1 & x_2 & x_2^2 & \\dots & x_2^{N-1}\\\\\n            1 & x_3 & x_3^2 & \\dots & x_3^{N-1}\\\\\n            \\vdots & \\vdots & \\vdots & \\ddots &\\vdots \\\\\n            1 & x_n & x_n^2 & \\dots & x_n^{N-1}\n        \\end{pmatrix}.\n\nfor `N > 1`.\nIf :attr:`N`\\ `= None`, then `N = x.size(-1)` so that the output is a square matrix.\n\nSupports inputs of float, double, cfloat, cdouble, and integral dtypes.\nAlso supports batches of vectors, and if :attr:`x` is a batch of vectors then\nthe output has the same batch dimensions.\n\nDifferences with `numpy.vander`:\n\n- Unlike `numpy.vander`, this function returns the powers of :attr:`x` in ascending order.\n  To get them in the reverse order call ``linalg.vander(x, N).flip(-1)``.\n\nArgs:\n    x (Tensor): tensor of shape `(*, n)` where `*` is zero or more batch dimensions\n                consisting of vectors.\n\nKeyword args:\n    N (int, optional): Number of columns in the output. Default: `x.size(-1)`\n\nExample::\n\n    >>> x = torch.tensor([1, 2, 3, 5])\n    >>> linalg.vander(x)\n    tensor([[  1,   1,   1,   1],\n            [  1,   2,   4,   8],\n            [  1,   3,   9,  27],\n            [  1,   5,  25, 125]])\n    >>> linalg.vander(x, N=3)\n    tensor([[ 1,  1,  1],\n            [ 1,  2,  4],\n            [ 1,  3,  9],\n            [ 1,  5, 25]])\n",
          "Args": {
            "x": {
              "Type": null,
              "Default": null
            },
            "N": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "vecdot": {
          "Doc": "\nlinalg.vecdot(x, y, *, dim=-1, out=None) -> Tensor\n\nComputes the dot product of two batches of vectors along a dimension.\n\nIn symbols, this function computes\n\n.. math::\n\n    \\sum_{i=1}^n \\overline{x_i}y_i.\n\nover the dimension :attr:`dim` where :math:`\\overline{x_i}` denotes the conjugate for complex\nvectors, and it is the identity for real vectors.\n\nSupports input of half, bfloat16, float, double, cfloat, cdouble and integral dtypes.\nIt also supports broadcasting.\n\nArgs:\n    x (Tensor): first batch of vectors of shape `(*, n)`.\n    y (Tensor): second batch of vectors of shape `(*, n)`.\n\nKeyword args:\n    dim (int): Dimension along which to compute the dot product. Default: `-1`.\n    out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.\n\nExamples::\n\n    >>> v1 = torch.randn(3, 2)\n    >>> v2 = torch.randn(3, 2)\n    >>> linalg.vecdot(v1, v2)\n    tensor([ 0.3223,  0.2815, -0.1944])\n    >>> torch.vdot(v1[0], v2[0])\n    tensor(0.3223)\n",
          "Args": {
            "x": {
              "Type": null,
              "Default": null
            },
            "y": {
              "Type": null,
              "Default": null
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "dim": {
              "Type": null,
              "Default": "-1"
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        },
        "vector_norm": {
          "Doc": "\nlinalg.vector_norm(x, ord=2, dim=None, keepdim=False, *, dtype=None, out=None) -> Tensor\n\nComputes a vector norm.\n\nIf :attr:`x` is complex valued, it computes the norm of :attr:`x`\\ `.abs()`\n\nSupports input of float, double, cfloat and cdouble dtypes.\n\nThis function does not necessarily treat multidimensonal :attr:`x` as a batch of\nvectors, instead:\n\n- If :attr:`dim`\\ `= None`, :attr:`x` will be flattened before the norm is computed.\n- If :attr:`dim` is an `int` or a `tuple`, the norm will be computed over these dimensions\n  and the other dimensions will be treated as batch dimensions.\n\nThis behavior is for consistency with :func:`torch.linalg.norm`.\n\n:attr:`ord` defines the vector norm that is computed. The following norms are supported:\n\n======================   ===============================\n:attr:`ord`              vector norm\n======================   ===============================\n`2` (default)            `2`-norm (see below)\n`inf`                    `max(abs(x))`\n`-inf`                   `min(abs(x))`\n`0`                      `sum(x != 0)`\nother `int` or `float`   `sum(abs(x)^{ord})^{(1 / ord)}`\n======================   ===============================\n\nwhere `inf` refers to `float('inf')`, NumPy's `inf` object, or any equivalent object.\n\n:attr:`dtype` may be used to perform the computation in a more precise dtype.\nIt is semantically equivalent to calling ``linalg.vector_norm(x.to(dtype))``\nbut it is faster in some cases.\n\n.. seealso::\n\n        :func:`torch.linalg.matrix_norm` computes a matrix norm.\n\nArgs:\n    x (Tensor): tensor, flattened by default, but this behavior can be\n        controlled using :attr:`dim`.\n    ord (int, float, inf, -inf, 'fro', 'nuc', optional): order of norm. Default: `2`\n    dim (int, Tuple[int], optional): dimensions over which to compute\n        the norm. See above for the behavior when :attr:`dim`\\ `= None`.\n        Default: `None`\n    keepdim (bool, optional): If set to `True`, the reduced dimensions are retained\n        in the result as dimensions with size one. Default: `False`\n\nKeyword args:\n    out (Tensor, optional): output tensor. Ignored if `None`. Default: `None`.\n    dtype (:class:`torch.dtype`, optional): type used to perform the accumulation and the return.\n        If specified, :attr:`x` is cast to :attr:`dtype` before performing the operation,\n        and the returned tensor\u2019s type will be :attr:`dtype` if real and of its real counterpart if complex.\n        :attr:`dtype` may be complex if :attr:`x` is complex, otherwise it must be real.\n        :attr:`x` should be convertible without narrowing to :attr:`dtype`. Default: None\n\nReturns:\n    A real-valued tensor, even when :attr:`x` is complex.\n\nExamples::\n\n    >>> from torch import linalg as LA\n    >>> a = torch.arange(9, dtype=torch.float) - 4\n    >>> a\n    tensor([-4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])\n    >>> B = a.reshape((3, 3))\n    >>> B\n    tensor([[-4., -3., -2.],\n            [-1.,  0.,  1.],\n            [ 2.,  3.,  4.]])\n    >>> LA.vector_norm(a, ord=3.5)\n    tensor(5.4345)\n    >>> LA.vector_norm(B, ord=3.5)\n    tensor(5.4345)\n",
          "Args": {
            "x": {
              "Type": null,
              "Default": null
            },
            "ord": {
              "Type": null,
              "Default": "2"
            },
            "dim": {
              "Type": null,
              "Default": "None"
            },
            "keepdim": {
              "Type": null,
              "Default": "False"
            },
            "*": {
              "Type": null,
              "Default": null
            },
            "dtype": {
              "Type": null,
              "Default": "None"
            },
            "out": {
              "Type": null,
              "Default": "None"
            }
          }
        }
      }
    },
    "nn": {
      "Doc": null,
      "Modules": {
        "common_types": {
          "Doc": null
        },
        "functional": {
          "Doc": "Functional interface",
          "Functions": {
            "adaptive_avg_pool1d": {
              "Doc": "\nadaptive_avg_pool1d(input, output_size) -> Tensor\n\nApplies a 1D adaptive average pooling over an input signal composed of\nseveral input planes.\n\nSee :class:`~torch.nn.AdaptiveAvgPool1d` for details and output shape.\n\nArgs:\n    output_size: the target output size (single integer)\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "output_size": {
                  "Type": null,
                  "Default": null
                }
              }
            },
            "adaptive_avg_pool2d": {
              "Doc": "\n    Applies a 2D adaptive average pooling over an input signal composed of\n    several input planes.\n\n    See :class:`~torch.nn.AdaptiveAvgPool2d` for details and output shape.\n\n    Args:\n        output_size: the target output size (single integer or\n            double-integer tuple)\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "output_size": {
                  "Type": "None",
                  "Default": null
                }
              }
            },
            "adaptive_avg_pool3d": {
              "Doc": "\n    Applies a 3D adaptive average pooling over an input signal composed of\n    several input planes.\n\n    See :class:`~torch.nn.AdaptiveAvgPool3d` for details and output shape.\n\n    Args:\n        output_size: the target output size (single integer or\n            triple-integer tuple)\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "output_size": {
                  "Type": "None",
                  "Default": null
                }
              }
            },
            "adaptive_max_pool1d_with_indices": {
              "Doc": "Applies a 1D adaptive max pooling over an input signal composed of\n    several input planes.\n\n    See :class:`~torch.nn.AdaptiveMaxPool1d` for details and output shape.\n\n    Args:\n        output_size: the target output size (single integer)\n        return_indices: whether to return pooling indices. Default: ``False``\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "output_size": {
                  "Type": "None",
                  "Default": null
                },
                "return_indices": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "adaptive_max_pool2d_with_indices": {
              "Doc": "Applies a 2D adaptive max pooling over an input signal composed of\n    several input planes.\n\n    See :class:`~torch.nn.AdaptiveMaxPool2d` for details and output shape.\n\n    Args:\n        output_size: the target output size (single integer or\n            double-integer tuple)\n        return_indices: whether to return pooling indices. Default: ``False``\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "output_size": {
                  "Type": "None",
                  "Default": null
                },
                "return_indices": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "adaptive_max_pool3d_with_indices": {
              "Doc": "Applies a 3D adaptive max pooling over an input signal composed of\n    several input planes.\n\n    See :class:`~torch.nn.AdaptiveMaxPool3d` for details and output shape.\n\n    Args:\n        output_size: the target output size (single integer or\n            triple-integer tuple)\n        return_indices: whether to return pooling indices. Default: ``False``\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "output_size": {
                  "Type": "None",
                  "Default": null
                },
                "return_indices": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "affine_grid": {
              "Doc": "Generates a 2D or 3D flow field (sampling grid), given a batch of\n    affine matrices :attr:`theta`.\n\n    .. note::\n        This function is often used in conjunction with :func:`grid_sample`\n        to build `Spatial Transformer Networks`_ .\n\n    Args:\n        theta (Tensor): input batch of affine matrices with shape\n            (:math:`N \\times 2 \\times 3`) for 2D or\n            (:math:`N \\times 3 \\times 4`) for 3D\n        size (torch.Size): the target output image size.\n            (:math:`N \\times C \\times H \\times W` for 2D or\n            :math:`N \\times C \\times D \\times H \\times W` for 3D)\n            Example: torch.Size((32, 3, 24, 24))\n        align_corners (bool, optional): if ``True``, consider ``-1`` and ``1``\n            to refer to the centers of the corner pixels rather than the image corners.\n            Refer to :func:`grid_sample` for a more complete description.\n            A grid generated by :func:`affine_grid` should be passed to :func:`grid_sample`\n            with the same setting for this option.\n            Default: ``False``\n\n    Returns:\n        output (Tensor): output Tensor of size (:math:`N \\times H \\times W \\times 2`)\n\n    .. _`Spatial Transformer Networks`:\n        https://arxiv.org/abs/1506.02025\n\n    .. warning::\n        When ``align_corners = True``, the grid positions depend on the pixel\n        size relative to the input image size, and so the locations sampled by\n        :func:`grid_sample` will differ for the same input given at different\n        resolutions (that is, after being upsampled or downsampled).\n        The default behavior up to version 1.2.0 was ``align_corners = True``.\n        Since then, the default behavior has been changed to ``align_corners = False``,\n        in order to bring it in line with the default for :func:`interpolate`.\n    .. warning::\n        When ``align_corners = True``, 2D affine transforms on 1D data and\n        3D affine transforms on 2D data (that is, when one of the spatial\n        dimensions has unit size) are ill-defined, and not an intended use case.\n        This is not a problem when ``align_corners = False``.\n        Up to version 1.2.0, all grid points along a unit dimension were\n        considered arbitrarily to be at ``-1``.\n        From version 1.3.0, under ``align_corners = True`` all grid points\n        along a unit dimension are considered to be at ``0``\n        (the center of the input image).\n    ",
              "Args": {
                "theta": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "size": {
                  "Type": "typing.List[int]",
                  "Default": null
                },
                "align_corners": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                }
              }
            },
            "alpha_dropout": {
              "Doc": "Applies alpha dropout to the input.\n\n    See :class:`~torch.nn.AlphaDropout` for details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "p": {
                  "Type": "<class 'float'>",
                  "Default": "0.5"
                },
                "training": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                },
                "inplace": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "assert_int_or_pair": {
              "Doc": null,
              "Args": {
                "arg": {
                  "Type": "typing.List[int]",
                  "Default": null
                },
                "arg_name": {
                  "Type": "<class 'str'>",
                  "Default": null
                },
                "message": {
                  "Type": "<class 'str'>",
                  "Default": null
                }
              }
            },
            "avg_pool1d": {
              "Doc": "\navg_pool1d(input, kernel_size, stride=None, padding=0, ceil_mode=False, count_include_pad=True) -> Tensor\n\nApplies a 1D average pooling over an input signal composed of several\ninput planes.\n\nSee :class:`~torch.nn.AvgPool1d` for details and output shape.\n\nArgs:\n    input: input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iW)`\n    kernel_size: the size of the window. Can be a single number or a\n      tuple `(kW,)`\n    stride: the stride of the window. Can be a single number or a tuple\n      `(sW,)`. Default: :attr:`kernel_size`\n    padding: implicit zero paddings on both sides of the input. Can be a\n      single number or a tuple `(padW,)`. Default: 0\n    ceil_mode: when True, will use `ceil` instead of `floor` to compute the\n        output shape. Default: ``False``\n    count_include_pad: when True, will include the zero-padding in the\n        averaging calculation. Default: ``True``\n\nExamples::\n\n    >>> # pool of square window of size=3, stride=2\n    >>> input = torch.tensor([[[1, 2, 3, 4, 5, 6, 7]]], dtype=torch.float32)\n    >>> F.avg_pool1d(input, kernel_size=3, stride=2)\n    tensor([[[ 2.,  4.,  6.]]])\n\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "kernel_size": {
                  "Type": null,
                  "Default": null
                },
                "stride": {
                  "Type": null,
                  "Default": "None"
                },
                "padding": {
                  "Type": null,
                  "Default": "0"
                },
                "ceil_mode": {
                  "Type": null,
                  "Default": "False"
                },
                "count_include_pad": {
                  "Type": null,
                  "Default": "True"
                }
              }
            },
            "avg_pool2d": {
              "Doc": "\navg_pool2d(input, kernel_size, stride=None, padding=0, ceil_mode=False, count_include_pad=True, divisor_override=None) -> Tensor\n\nApplies 2D average-pooling operation in :math:`kH \\times kW` regions by step size\n:math:`sH \\times sW` steps. The number of output features is equal to the number of\ninput planes.\n\nSee :class:`~torch.nn.AvgPool2d` for details and output shape.\n\nArgs:\n    input: input tensor :math:`(\\text{minibatch} , \\text{in\\_channels} , iH , iW)`\n    kernel_size: size of the pooling region. Can be a single number or a\n      tuple `(kH, kW)`\n    stride: stride of the pooling operation. Can be a single number or a\n      tuple `(sH, sW)`. Default: :attr:`kernel_size`\n    padding: implicit zero paddings on both sides of the input. Can be a\n      single number or a tuple `(padH, padW)`. Default: 0\n    ceil_mode: when True, will use `ceil` instead of `floor` in the formula\n        to compute the output shape. Default: ``False``\n    count_include_pad: when True, will include the zero-padding in the\n        averaging calculation. Default: ``True``\n    divisor_override: if specified, it will be used as divisor, otherwise\n         size of the pooling region will be used. Default: None\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "kernel_size": {
                  "Type": null,
                  "Default": null
                },
                "stride": {
                  "Type": null,
                  "Default": "None"
                },
                "padding": {
                  "Type": null,
                  "Default": "0"
                },
                "ceil_mode": {
                  "Type": null,
                  "Default": "False"
                },
                "count_include_pad": {
                  "Type": null,
                  "Default": "True"
                },
                "divisor_override": {
                  "Type": null,
                  "Default": "None"
                }
              }
            },
            "avg_pool3d": {
              "Doc": "\navg_pool3d(input, kernel_size, stride=None, padding=0, ceil_mode=False, count_include_pad=True, divisor_override=None) -> Tensor\n\nApplies 3D average-pooling operation in :math:`kT \\times kH \\times kW` regions by step\nsize :math:`sT \\times sH \\times sW` steps. The number of output features is equal to\n:math:`\\lfloor\\frac{\\text{input planes}}{sT}\\rfloor`.\n\nSee :class:`~torch.nn.AvgPool3d` for details and output shape.\n\nArgs:\n    input: input tensor :math:`(\\text{minibatch} , \\text{in\\_channels} , iT \\times iH , iW)`\n    kernel_size: size of the pooling region. Can be a single number or a\n      tuple `(kT, kH, kW)`\n    stride: stride of the pooling operation. Can be a single number or a\n      tuple `(sT, sH, sW)`. Default: :attr:`kernel_size`\n    padding: implicit zero paddings on both sides of the input. Can be a\n      single number or a tuple `(padT, padH, padW)`, Default: 0\n    ceil_mode: when True, will use `ceil` instead of `floor` in the formula\n        to compute the output shape\n    count_include_pad: when True, will include the zero-padding in the\n        averaging calculation\n    divisor_override: if specified, it will be used as divisor, otherwise\n        size of the pooling region will be used. Default: None\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "kernel_size": {
                  "Type": null,
                  "Default": null
                },
                "stride": {
                  "Type": null,
                  "Default": "None"
                },
                "padding": {
                  "Type": null,
                  "Default": "0"
                },
                "ceil_mode": {
                  "Type": null,
                  "Default": "False"
                },
                "count_include_pad": {
                  "Type": null,
                  "Default": "True"
                },
                "divisor_override": {
                  "Type": null,
                  "Default": "None"
                }
              }
            },
            "batch_norm": {
              "Doc": "Applies Batch Normalization for each channel across a batch of data.\n\n    See :class:`~torch.nn.BatchNorm1d`, :class:`~torch.nn.BatchNorm2d`,\n    :class:`~torch.nn.BatchNorm3d` for details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "running_mean": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": null
                },
                "running_var": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": null
                },
                "weight": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "bias": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "training": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                },
                "momentum": {
                  "Type": "<class 'float'>",
                  "Default": "0.1"
                },
                "eps": {
                  "Type": "<class 'float'>",
                  "Default": "1e-05"
                }
              }
            },
            "bilinear": {
              "Doc": "\nbilinear(input1, input2, weight, bias=None) -> Tensor\n\nApplies a bilinear transformation to the incoming data:\n:math:`y = x_1^T A x_2 + b`\n\nShape:\n\n    - input1: :math:`(N, *, H_{in1})` where :math:`H_{in1}=\\text{in1\\_features}`\n      and :math:`*` means any number of additional dimensions.\n      All but the last dimension of the inputs should be the same.\n    - input2: :math:`(N, *, H_{in2})` where :math:`H_{in2}=\\text{in2\\_features}`\n    - weight: :math:`(\\text{out\\_features}, \\text{in1\\_features},\n      \\text{in2\\_features})`\n    - bias: :math:`(\\text{out\\_features})`\n    - output: :math:`(N, *, H_{out})` where :math:`H_{out}=\\text{out\\_features}`\n      and all but the last dimension are the same shape as the input.\n",
              "Args": {
                "input1": {
                  "Type": null,
                  "Default": null
                },
                "input2": {
                  "Type": null,
                  "Default": null
                },
                "weight": {
                  "Type": null,
                  "Default": null
                },
                "bias": {
                  "Type": null,
                  "Default": "None"
                }
              }
            },
            "binary_cross_entropy": {
              "Doc": "Function that measures the Binary Cross Entropy between the target and input\n    probabilities.\n\n    See :class:`~torch.nn.BCELoss` for details.\n\n    Args:\n        input: Tensor of arbitrary shape as probabilities.\n        target: Tensor of the same shape as input with values between 0 and 1.\n        weight (Tensor, optional): a manual rescaling weight\n                if provided it's repeated to match input tensor shape\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there multiple elements per sample. If the field :attr:`size_average`\n            is set to ``False``, the losses are instead summed for each minibatch. Ignored\n            when reduce is ``False``. Default: ``True``\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: ``True``\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the sum of the output will be divided by the number of\n            elements in the output, ``'sum'``: the output will be summed. Note: :attr:`size_average`\n            and :attr:`reduce` are in the process of being deprecated, and in the meantime,\n            specifying either of those two args will override :attr:`reduction`. Default: ``'mean'``\n\n    Examples::\n\n        >>> input = torch.randn(3, 2, requires_grad=True)\n        >>> target = torch.rand(3, 2, requires_grad=False)\n        >>> loss = F.binary_cross_entropy(torch.sigmoid(input), target)\n        >>> loss.backward()\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "target": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "weight": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "size_average": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduce": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduction": {
                  "Type": "<class 'str'>",
                  "Default": "mean"
                }
              }
            },
            "binary_cross_entropy_with_logits": {
              "Doc": "Function that measures Binary Cross Entropy between target and input\n    logits.\n\n    See :class:`~torch.nn.BCEWithLogitsLoss` for details.\n\n    Args:\n        input: Tensor of arbitrary shape as unnormalized scores (often referred to as logits).\n        target: Tensor of the same shape as input with values between 0 and 1\n        weight (Tensor, optional): a manual rescaling weight\n            if provided it's repeated to match input tensor shape\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there multiple elements per sample. If the field :attr:`size_average`\n            is set to ``False``, the losses are instead summed for each minibatch. Ignored\n            when reduce is ``False``. Default: ``True``\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: ``True``\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the sum of the output will be divided by the number of\n            elements in the output, ``'sum'``: the output will be summed. Note: :attr:`size_average`\n            and :attr:`reduce` are in the process of being deprecated, and in the meantime,\n            specifying either of those two args will override :attr:`reduction`. Default: ``'mean'``\n        pos_weight (Tensor, optional): a weight of positive examples.\n                Must be a vector with length equal to the number of classes.\n\n    Examples::\n\n         >>> input = torch.randn(3, requires_grad=True)\n         >>> target = torch.empty(3).random_(2)\n         >>> loss = F.binary_cross_entropy_with_logits(input, target)\n         >>> loss.backward()\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "target": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "weight": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "size_average": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduce": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduction": {
                  "Type": "<class 'str'>",
                  "Default": "mean"
                },
                "pos_weight": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                }
              }
            },
            "boolean_dispatch": {
              "Doc": "\n    Dispatches to either of 2 script functions based on a boolean argument.\n    In TorchScript, the boolean argument must be constant so that the correct\n    function to use can be determined at compile time.\n    ",
              "Args": {
                "arg_name": {
                  "Type": null,
                  "Default": null
                },
                "arg_index": {
                  "Type": null,
                  "Default": null
                },
                "default": {
                  "Type": null,
                  "Default": null
                },
                "if_true": {
                  "Type": null,
                  "Default": null
                },
                "if_false": {
                  "Type": null,
                  "Default": null
                },
                "module_name": {
                  "Type": null,
                  "Default": null
                },
                "func_name": {
                  "Type": null,
                  "Default": null
                }
              }
            },
            "celu": {
              "Doc": "celu(input, alpha=1., inplace=False) -> Tensor\n\n    Applies element-wise,\n    :math:`\\text{CELU}(x) = \\max(0,x) + \\min(0, \\alpha * (\\exp(x/\\alpha) - 1))`.\n\n    See :class:`~torch.nn.CELU` for more details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "alpha": {
                  "Type": "<class 'float'>",
                  "Default": "1.0"
                },
                "inplace": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "channel_shuffle": {
              "Doc": "\nchannel_shuffle(input, groups) -> Tensor\n\nDivide the channels in a tensor of shape :math:`(*, C , H, W)`\ninto g groups and rearrange them as :math:`(*, C \\frac g, g, H, W)`,\nwhile keeping the original tensor shape.\n\nSee :class:`~torch.nn.ChannelShuffle` for details.\n\nArgs:\n    input (Tensor): the input tensor\n    groups (int): number of groups to divide channels in and rearrange.\n\nExamples::\n\n    >>> input = torch.randn(1, 4, 2, 2)\n    >>> print(input)\n    [[[[1, 2],\n       [3, 4]],\n      [[5, 6],\n       [7, 8]],\n      [[9, 10],\n       [11, 12]],\n      [[13, 14],\n       [15, 16]],\n     ]]\n    >>> output = torch.nn.functional.channel_shuffle(input, 2)\n    >>> print(output)\n    [[[[1, 2],\n       [3, 4]],\n      [[9, 10],\n       [11, 12]],\n      [[5, 6],\n       [7, 8]],\n      [[13, 14],\n       [15, 16]],\n     ]]\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "groups": {
                  "Type": null,
                  "Default": null
                }
              }
            },
            "conv1d": {
              "Doc": "\nconv1d(input, weight, bias=None, stride=1, padding=0, dilation=1, groups=1) -> Tensor\n\nApplies a 1D convolution over an input signal composed of several input\nplanes.\n\nThis operator supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\nSee :class:`~torch.nn.Conv1d` for details and output shape.\n\nNote:\n    In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.\n\nNote:\n    This operator supports complex data types i.e. ``complex32, complex64, complex128``.\n\n\nArgs:\n    input: input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iW)`\n    weight: filters of shape :math:`(\\text{out\\_channels} , \\frac{\\text{in\\_channels}}{\\text{groups}} , kW)`\n    bias: optional bias of shape :math:`(\\text{out\\_channels})`. Default: ``None``\n    stride: the stride of the convolving kernel. Can be a single number or\n      a one-element tuple `(sW,)`. Default: 1\n    padding: implicit paddings on both sides of the input. Can be a string {'valid', 'same'},\n      single number or a one-element tuple `(padW,)`. Default: 0\n      ``padding='valid'`` is the same as no padding. ``padding='same'`` pads\n      the input so the output has the same shape as the input. However, this mode\n      doesn't support any stride values other than 1.\n\n      .. warning::\n          For ``padding='same'``, if the ``weight`` is even-length and\n          ``dilation`` is odd in any dimension, a full :func:`pad` operation\n          may be needed internally. Lowering performance.\n    dilation: the spacing between kernel elements. Can be a single number or\n      a one-element tuple `(dW,)`. Default: 1\n    groups: split input into groups, :math:`\\text{in\\_channels}` should be divisible by\n      the number of groups. Default: 1\n\nExamples::\n\n    >>> inputs = torch.randn(33, 16, 30)\n    >>> filters = torch.randn(20, 16, 5)\n    >>> F.conv1d(inputs, filters)\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "weight": {
                  "Type": null,
                  "Default": null
                },
                "bias": {
                  "Type": null,
                  "Default": "None"
                },
                "stride": {
                  "Type": null,
                  "Default": "1"
                },
                "padding": {
                  "Type": null,
                  "Default": "0"
                },
                "dilation": {
                  "Type": null,
                  "Default": "1"
                },
                "groups": {
                  "Type": null,
                  "Default": "1"
                }
              }
            },
            "conv2d": {
              "Doc": "\nconv2d(input, weight, bias=None, stride=1, padding=0, dilation=1, groups=1) -> Tensor\n\nApplies a 2D convolution over an input image composed of several input\nplanes.\n\nThis operator supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\nSee :class:`~torch.nn.Conv2d` for details and output shape.\n\nNote:\n    In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.\n\nNote:\n    This operator supports complex data types i.e. ``complex32, complex64, complex128``.\n\n\nArgs:\n    input: input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iH , iW)`\n    weight: filters of shape :math:`(\\text{out\\_channels} , \\frac{\\text{in\\_channels}}{\\text{groups}} , kH , kW)`\n    bias: optional bias tensor of shape :math:`(\\text{out\\_channels})`. Default: ``None``\n    stride: the stride of the convolving kernel. Can be a single number or a\n      tuple `(sH, sW)`. Default: 1\n    padding: implicit paddings on both sides of the input. Can be a string {'valid', 'same'},\n      single number or a tuple `(padH, padW)`. Default: 0\n      ``padding='valid'`` is the same as no padding. ``padding='same'`` pads\n      the input so the output has the same shape as the input. However, this mode\n      doesn't support any stride values other than 1.\n\n      .. warning::\n          For ``padding='same'``, if the ``weight`` is even-length and\n          ``dilation`` is odd in any dimension, a full :func:`pad` operation\n          may be needed internally. Lowering performance.\n\n    dilation: the spacing between kernel elements. Can be a single number or\n      a tuple `(dH, dW)`. Default: 1\n    groups: split input into groups, :math:`\\text{in\\_channels}` should be divisible by the\n      number of groups. Default: 1\n\nExamples::\n\n    >>> # With square kernels and equal stride\n    >>> filters = torch.randn(8, 4, 3, 3)\n    >>> inputs = torch.randn(1, 4, 5, 5)\n    >>> F.conv2d(inputs, filters, padding=1)\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "weight": {
                  "Type": null,
                  "Default": null
                },
                "bias": {
                  "Type": null,
                  "Default": "None"
                },
                "stride": {
                  "Type": null,
                  "Default": "1"
                },
                "padding": {
                  "Type": null,
                  "Default": "0"
                },
                "dilation": {
                  "Type": null,
                  "Default": "1"
                },
                "groups": {
                  "Type": null,
                  "Default": "1"
                }
              }
            },
            "conv3d": {
              "Doc": "\nconv3d(input, weight, bias=None, stride=1, padding=0, dilation=1, groups=1) -> Tensor\n\nApplies a 3D convolution over an input image composed of several input\nplanes.\n\nThis operator supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\nSee :class:`~torch.nn.Conv3d` for details and output shape.\n\nNote:\n    In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.\n\nNote:\n    This operator supports complex data types i.e. ``complex32, complex64, complex128``.\n\n\nArgs:\n    input: input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iT , iH , iW)`\n    weight: filters of shape :math:`(\\text{out\\_channels} , \\frac{\\text{in\\_channels}}{\\text{groups}} , kT , kH , kW)`\n    bias: optional bias tensor of shape :math:`(\\text{out\\_channels})`. Default: None\n    stride: the stride of the convolving kernel. Can be a single number or a\n      tuple `(sT, sH, sW)`. Default: 1\n    padding: implicit paddings on both sides of the input. Can be a string {'valid', 'same'},\n      single number or a tuple `(padT, padH, padW)`. Default: 0\n      ``padding='valid'`` is the same as no padding. ``padding='same'`` pads\n      the input so the output has the same shape as the input. However, this mode\n      doesn't support any stride values other than 1.\n\n      .. warning::\n          For ``padding='same'``, if the ``weight`` is even-length and\n          ``dilation`` is odd in any dimension, a full :func:`pad` operation\n          may be needed internally. Lowering performance.\n\n    dilation: the spacing between kernel elements. Can be a single number or\n      a tuple `(dT, dH, dW)`. Default: 1\n    groups: split input into groups, :math:`\\text{in\\_channels}` should be divisible by\n      the number of groups. Default: 1\n\nExamples::\n\n    >>> filters = torch.randn(33, 16, 3, 3, 3)\n    >>> inputs = torch.randn(20, 16, 50, 10, 20)\n    >>> F.conv3d(inputs, filters)\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "weight": {
                  "Type": null,
                  "Default": null
                },
                "bias": {
                  "Type": null,
                  "Default": "None"
                },
                "stride": {
                  "Type": null,
                  "Default": "1"
                },
                "padding": {
                  "Type": null,
                  "Default": "0"
                },
                "dilation": {
                  "Type": null,
                  "Default": "1"
                },
                "groups": {
                  "Type": null,
                  "Default": "1"
                }
              }
            },
            "conv_tbc": {
              "Doc": "\nApplies a 1-dimensional sequence convolution over an input sequence.\nInput and output dimensions are (Time, Batch, Channels) - hence TBC.\n\nArgs:\n    input: input tensor of shape :math:`(\\text{sequence length} \\times batch \\times \\text{in\\_channels})`\n    weight: filter of shape (:math:`\\text{kernel width} \\times \\text{in\\_channels} \\times \\text{out\\_channels}`)\n    bias: bias of shape (:math:`\\text{out\\_channels}`)\n    pad: number of timesteps to pad. Default: 0\n",
              "Args": {
                "Time": {
                  "Type": null,
                  "Default": null
                },
                "Batch": {
                  "Type": null,
                  "Default": null
                },
                "Channels": {
                  "Type": null,
                  "Default": null
                }
              }
            },
            "conv_transpose1d": {
              "Doc": "\nconv_transpose1d(input, weight, bias=None, stride=1, padding=0, output_padding=0, groups=1, dilation=1) -> Tensor\n\nApplies a 1D transposed convolution operator over an input signal\ncomposed of several input planes, sometimes also called \"deconvolution\".\n\nThis operator supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\nSee :class:`~torch.nn.ConvTranspose1d` for details and output shape.\n\nNote:\n    In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.\n\n\nArgs:\n    input: input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iW)`\n    weight: filters of shape :math:`(\\text{in\\_channels} , \\frac{\\text{out\\_channels}}{\\text{groups}} , kW)`\n    bias: optional bias of shape :math:`(\\text{out\\_channels})`. Default: None\n    stride: the stride of the convolving kernel. Can be a single number or a\n      tuple ``(sW,)``. Default: 1\n    padding: ``dilation * (kernel_size - 1) - padding`` zero-padding will be added to both\n      sides of each dimension in the input. Can be a single number or a tuple\n      ``(padW,)``. Default: 0\n    output_padding: additional size added to one side of each dimension in the\n      output shape. Can be a single number or a tuple ``(out_padW)``. Default: 0\n    groups: split input into groups, :math:`\\text{in\\_channels}` should be divisible by the\n      number of groups. Default: 1\n    dilation: the spacing between kernel elements. Can be a single number or\n      a tuple ``(dW,)``. Default: 1\n\nExamples::\n\n    >>> inputs = torch.randn(20, 16, 50)\n    >>> weights = torch.randn(16, 33, 5)\n    >>> F.conv_transpose1d(inputs, weights)\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "weight": {
                  "Type": null,
                  "Default": null
                },
                "bias": {
                  "Type": null,
                  "Default": "None"
                },
                "stride": {
                  "Type": null,
                  "Default": "1"
                },
                "padding": {
                  "Type": null,
                  "Default": "0"
                },
                "output_padding": {
                  "Type": null,
                  "Default": "0"
                },
                "groups": {
                  "Type": null,
                  "Default": "1"
                },
                "dilation": {
                  "Type": null,
                  "Default": "1"
                }
              }
            },
            "conv_transpose2d": {
              "Doc": "\nconv_transpose2d(input, weight, bias=None, stride=1, padding=0, output_padding=0, groups=1, dilation=1) -> Tensor\n\nApplies a 2D transposed convolution operator over an input image\ncomposed of several input planes, sometimes also called \"deconvolution\".\n\nThis operator supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\nSee :class:`~torch.nn.ConvTranspose2d` for details and output shape.\n\nNote:\n    In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.\n\n\nArgs:\n    input: input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iH , iW)`\n    weight: filters of shape :math:`(\\text{in\\_channels} , \\frac{\\text{out\\_channels}}{\\text{groups}} , kH , kW)`\n    bias: optional bias of shape :math:`(\\text{out\\_channels})`. Default: None\n    stride: the stride of the convolving kernel. Can be a single number or a\n      tuple ``(sH, sW)``. Default: 1\n    padding: ``dilation * (kernel_size - 1) - padding`` zero-padding will be added to both\n      sides of each dimension in the input. Can be a single number or a tuple\n      ``(padH, padW)``. Default: 0\n    output_padding: additional size added to one side of each dimension in the\n      output shape. Can be a single number or a tuple ``(out_padH, out_padW)``.\n      Default: 0\n    groups: split input into groups, :math:`\\text{in\\_channels}` should be divisible by the\n      number of groups. Default: 1\n    dilation: the spacing between kernel elements. Can be a single number or\n      a tuple ``(dH, dW)``. Default: 1\n\nExamples::\n\n    >>> # With square kernels and equal stride\n    >>> inputs = torch.randn(1, 4, 5, 5)\n    >>> weights = torch.randn(4, 8, 3, 3)\n    >>> F.conv_transpose2d(inputs, weights, padding=1)\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "weight": {
                  "Type": null,
                  "Default": null
                },
                "bias": {
                  "Type": null,
                  "Default": "None"
                },
                "stride": {
                  "Type": null,
                  "Default": "1"
                },
                "padding": {
                  "Type": null,
                  "Default": "0"
                },
                "output_padding": {
                  "Type": null,
                  "Default": "0"
                },
                "groups": {
                  "Type": null,
                  "Default": "1"
                },
                "dilation": {
                  "Type": null,
                  "Default": "1"
                }
              }
            },
            "conv_transpose3d": {
              "Doc": "\nconv_transpose3d(input, weight, bias=None, stride=1, padding=0, output_padding=0, groups=1, dilation=1) -> Tensor\n\nApplies a 3D transposed convolution operator over an input image\ncomposed of several input planes, sometimes also called \"deconvolution\"\n\nThis operator supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\nSee :class:`~torch.nn.ConvTranspose3d` for details and output shape.\n\nNote:\n    In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.\n\n\nArgs:\n    input: input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iT , iH , iW)`\n    weight: filters of shape :math:`(\\text{in\\_channels} , \\frac{\\text{out\\_channels}}{\\text{groups}} , kT , kH , kW)`\n    bias: optional bias of shape :math:`(\\text{out\\_channels})`. Default: None\n    stride: the stride of the convolving kernel. Can be a single number or a\n      tuple ``(sT, sH, sW)``. Default: 1\n    padding: ``dilation * (kernel_size - 1) - padding`` zero-padding will be added to both\n      sides of each dimension in the input. Can be a single number or a tuple\n      ``(padT, padH, padW)``. Default: 0\n    output_padding: additional size added to one side of each dimension in the\n      output shape. Can be a single number or a tuple\n      ``(out_padT, out_padH, out_padW)``. Default: 0\n    groups: split input into groups, :math:`\\text{in\\_channels}` should be divisible by the\n      number of groups. Default: 1\n    dilation: the spacing between kernel elements. Can be a single number or\n      a tuple `(dT, dH, dW)`. Default: 1\n\nExamples::\n\n    >>> inputs = torch.randn(20, 16, 50, 10, 20)\n    >>> weights = torch.randn(16, 33, 3, 3, 3)\n    >>> F.conv_transpose3d(inputs, weights)\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "weight": {
                  "Type": null,
                  "Default": null
                },
                "bias": {
                  "Type": null,
                  "Default": "None"
                },
                "stride": {
                  "Type": null,
                  "Default": "1"
                },
                "padding": {
                  "Type": null,
                  "Default": "0"
                },
                "output_padding": {
                  "Type": null,
                  "Default": "0"
                },
                "groups": {
                  "Type": null,
                  "Default": "1"
                },
                "dilation": {
                  "Type": null,
                  "Default": "1"
                }
              }
            },
            "cosine_embedding_loss": {
              "Doc": "cosine_embedding_loss(input1, input2, target, margin=0, size_average=None, reduce=None, reduction='mean') -> Tensor\n\n    See :class:`~torch.nn.CosineEmbeddingLoss` for details.\n    ",
              "Args": {
                "input1": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "input2": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "target": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "margin": {
                  "Type": "<class 'float'>",
                  "Default": "0"
                },
                "size_average": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduce": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduction": {
                  "Type": "<class 'str'>",
                  "Default": "mean"
                }
              }
            },
            "cosine_similarity": {
              "Doc": "\ncosine_similarity(x1, x2, dim=1, eps=1e-8) -> Tensor\n\nReturns cosine similarity between ``x1`` and ``x2``, computed along dim. ``x1`` and ``x2`` must be broadcastable\nto a common shape. ``dim`` refers to the dimension in this common shape. Dimension ``dim`` of the output is\nsqueezed (see :func:`torch.squeeze`), resulting in the\noutput tensor having 1 fewer dimension.\n\n.. math ::\n    \\text{similarity} = \\dfrac{x_1 \\cdot x_2}{\\max(\\Vert x_1 \\Vert _2 \\cdot \\Vert x_2 \\Vert _2, \\epsilon)}\n\nSupports :ref:`type promotion <type-promotion-doc>`.\n\nArgs:\n    x1 (Tensor): First input.\n    x2 (Tensor): Second input.\n    dim (int, optional): Dimension along which cosine similarity is computed. Default: 1\n    eps (float, optional): Small value to avoid division by zero.\n        Default: 1e-8\n\nExample::\n\n    >>> input1 = torch.randn(100, 128)\n    >>> input2 = torch.randn(100, 128)\n    >>> output = F.cosine_similarity(input1, input2)\n    >>> print(output)\n",
              "Args": {
                "x1": {
                  "Type": null,
                  "Default": null
                },
                "x2": {
                  "Type": null,
                  "Default": null
                },
                "dim": {
                  "Type": null,
                  "Default": "1"
                },
                "eps": {
                  "Type": null,
                  "Default": "1e-8"
                }
              }
            },
            "cross_entropy": {
              "Doc": "This criterion computes the cross entropy loss between input logits and target.\n\n    See :class:`~torch.nn.CrossEntropyLoss` for details.\n\n    Args:\n        input (Tensor) : Predicted unnormalized logits;\n            see Shape section below for supported shapes.\n        target (Tensor) : Ground truth class indices or class probabilities;\n            see Shape section below for supported shapes.\n        weight (Tensor, optional): a manual rescaling weight given to each\n            class. If given, has to be a Tensor of size `C`\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there multiple elements per sample. If the field :attr:`size_average`\n            is set to ``False``, the losses are instead summed for each minibatch. Ignored\n            when reduce is ``False``. Default: ``True``\n        ignore_index (int, optional): Specifies a target value that is ignored\n            and does not contribute to the input gradient. When :attr:`size_average` is\n            ``True``, the loss is averaged over non-ignored targets. Note that\n            :attr:`ignore_index` is only applicable when the target contains class indices.\n            Default: -100\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: ``True``\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the sum of the output will be divided by the number of\n            elements in the output, ``'sum'``: the output will be summed. Note: :attr:`size_average`\n            and :attr:`reduce` are in the process of being deprecated, and in the meantime,\n            specifying either of those two args will override :attr:`reduction`. Default: ``'mean'``\n        label_smoothing (float, optional): A float in [0.0, 1.0]. Specifies the amount\n            of smoothing when computing the loss, where 0.0 means no smoothing. The targets\n            become a mixture of the original ground truth and a uniform distribution as described in\n            `Rethinking the Inception Architecture for Computer Vision <https://arxiv.org/abs/1512.00567>`__. Default: :math:`0.0`.\n\n    Shape:\n        - Input: Shape :math:`(C)`, :math:`(N, C)` or :math:`(N, C, d_1, d_2, ..., d_K)` with :math:`K \\geq 1`\n          in the case of `K`-dimensional loss.\n        - Target: If containing class indices, shape :math:`()`, :math:`(N)` or :math:`(N, d_1, d_2, ..., d_K)` with\n          :math:`K \\geq 1` in the case of K-dimensional loss where each value should be between :math:`[0, C)`.\n          If containing class probabilities, same shape as the input and each value should be between :math:`[0, 1]`.\n\n        where:\n\n        .. math::\n            \\begin{aligned}\n                C ={} & \\text{number of classes} \\\\\n                N ={} & \\text{batch size} \\\\\n            \\end{aligned}\n\n    Examples::\n\n        >>> # Example of target with class indices\n        >>> input = torch.randn(3, 5, requires_grad=True)\n        >>> target = torch.randint(5, (3,), dtype=torch.int64)\n        >>> loss = F.cross_entropy(input, target)\n        >>> loss.backward()\n        >>>\n        >>> # Example of target with class probabilities\n        >>> input = torch.randn(3, 5, requires_grad=True)\n        >>> target = torch.randn(3, 5).softmax(dim=1)\n        >>> loss = F.cross_entropy(input, target)\n        >>> loss.backward()\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "target": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "weight": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "size_average": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "ignore_index": {
                  "Type": "<class 'int'>",
                  "Default": "-100"
                },
                "reduce": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduction": {
                  "Type": "<class 'str'>",
                  "Default": "mean"
                },
                "label_smoothing": {
                  "Type": "<class 'float'>",
                  "Default": "0.0"
                }
              }
            },
            "ctc_loss": {
              "Doc": "The Connectionist Temporal Classification loss.\n\n    See :class:`~torch.nn.CTCLoss` for details.\n\n    Note:\n        In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.\n\n    Note:\n        This operation may produce nondeterministic gradients when given tensors on a CUDA device. See :doc:`/notes/randomness` for more information.\n\n    Args:\n        log_probs: :math:`(T, N, C)` or :math:`(T, C)` where `C = number of characters in alphabet including blank`,\n            `T = input length`, and `N = batch size`.\n            The logarithmized probabilities of the outputs\n            (e.g. obtained with :func:`torch.nn.functional.log_softmax`).\n        targets: :math:`(N, S)` or `(sum(target_lengths))`.\n            Targets cannot be blank. In the second form, the targets are assumed to be concatenated.\n        input_lengths: :math:`(N)` or :math:`()`.\n            Lengths of the inputs (must each be :math:`\\leq T`)\n        target_lengths: :math:`(N)` or :math:`()`.\n            Lengths of the targets\n        blank (int, optional):\n            Blank label. Default :math:`0`.\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the output losses will be divided by the target lengths and\n            then the mean over the batch is taken, ``'sum'``: the output will be\n            summed. Default: ``'mean'``\n        zero_infinity (bool, optional):\n            Whether to zero infinite losses and the associated gradients.\n            Default: ``False``\n            Infinite losses mainly occur when the inputs are too short\n            to be aligned to the targets.\n\n    Example::\n\n        >>> log_probs = torch.randn(50, 16, 20).log_softmax(2).detach().requires_grad_()\n        >>> targets = torch.randint(1, 20, (16, 30), dtype=torch.long)\n        >>> input_lengths = torch.full((16,), 50, dtype=torch.long)\n        >>> target_lengths = torch.randint(10,30,(16,), dtype=torch.long)\n        >>> loss = F.ctc_loss(log_probs, targets, input_lengths, target_lengths)\n        >>> loss.backward()\n    ",
              "Args": {
                "log_probs": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "targets": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "input_lengths": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "target_lengths": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "blank": {
                  "Type": "<class 'int'>",
                  "Default": "0"
                },
                "reduction": {
                  "Type": "<class 'str'>",
                  "Default": "mean"
                },
                "zero_infinity": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "dropout": {
              "Doc": "\n    During training, randomly zeroes some of the elements of the input\n    tensor with probability :attr:`p` using samples from a Bernoulli\n    distribution.\n\n    See :class:`~torch.nn.Dropout` for details.\n\n    Args:\n        p: probability of an element to be zeroed. Default: 0.5\n        training: apply dropout if is ``True``. Default: ``True``\n        inplace: If set to ``True``, will do this operation in-place. Default: ``False``\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "p": {
                  "Type": "<class 'float'>",
                  "Default": "0.5"
                },
                "training": {
                  "Type": "<class 'bool'>",
                  "Default": "True"
                },
                "inplace": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "dropout1d": {
              "Doc": "\n    Randomly zero out entire channels (a channel is a 1D feature map,\n    e.g., the :math:`j`-th channel of the :math:`i`-th sample in the\n    batched input is a 1D tensor :math:`\\text{input}[i, j]`) of the input tensor).\n    Each channel will be zeroed out independently on every forward call with\n    probability :attr:`p` using samples from a Bernoulli distribution.\n\n    See :class:`~torch.nn.Dropout1d` for details.\n\n    Args:\n        p: probability of a channel to be zeroed. Default: 0.5\n        training: apply dropout if is ``True``. Default: ``True``\n        inplace: If set to ``True``, will do this operation in-place. Default: ``False``\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "p": {
                  "Type": "<class 'float'>",
                  "Default": "0.5"
                },
                "training": {
                  "Type": "<class 'bool'>",
                  "Default": "True"
                },
                "inplace": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "dropout2d": {
              "Doc": "\n    Randomly zero out entire channels (a channel is a 2D feature map,\n    e.g., the :math:`j`-th channel of the :math:`i`-th sample in the\n    batched input is a 2D tensor :math:`\\text{input}[i, j]`) of the input tensor).\n    Each channel will be zeroed out independently on every forward call with\n    probability :attr:`p` using samples from a Bernoulli distribution.\n\n    See :class:`~torch.nn.Dropout2d` for details.\n\n    Args:\n        p: probability of a channel to be zeroed. Default: 0.5\n        training: apply dropout if is ``True``. Default: ``True``\n        inplace: If set to ``True``, will do this operation in-place. Default: ``False``\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "p": {
                  "Type": "<class 'float'>",
                  "Default": "0.5"
                },
                "training": {
                  "Type": "<class 'bool'>",
                  "Default": "True"
                },
                "inplace": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "dropout3d": {
              "Doc": "\n    Randomly zero out entire channels (a channel is a 3D feature map,\n    e.g., the :math:`j`-th channel of the :math:`i`-th sample in the\n    batched input is a 3D tensor :math:`\\text{input}[i, j]`) of the input tensor).\n    Each channel will be zeroed out independently on every forward call with\n    probability :attr:`p` using samples from a Bernoulli distribution.\n\n    See :class:`~torch.nn.Dropout3d` for details.\n\n    Args:\n        p: probability of a channel to be zeroed. Default: 0.5\n        training: apply dropout if is ``True``. Default: ``True``\n        inplace: If set to ``True``, will do this operation in-place. Default: ``False``\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "p": {
                  "Type": "<class 'float'>",
                  "Default": "0.5"
                },
                "training": {
                  "Type": "<class 'bool'>",
                  "Default": "True"
                },
                "inplace": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "elu": {
              "Doc": "Applies the Exponential Linear Unit (ELU) function element-wise.\n\n    See :class:`~torch.nn.ELU` for more details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "alpha": {
                  "Type": "<class 'float'>",
                  "Default": "1.0"
                },
                "inplace": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "embedding": {
              "Doc": "A simple lookup table that looks up embeddings in a fixed dictionary and size.\n\n    This module is often used to retrieve word embeddings using indices.\n    The input to the module is a list of indices, and the embedding matrix,\n    and the output is the corresponding word embeddings.\n\n    See :class:`torch.nn.Embedding` for more details.\n\n    Args:\n        input (LongTensor): Tensor containing indices into the embedding matrix\n        weight (Tensor): The embedding matrix with number of rows equal to the maximum possible index + 1,\n            and number of columns equal to the embedding size\n        padding_idx (int, optional): If specified, the entries at :attr:`padding_idx` do not contribute to the gradient;\n                                     therefore, the embedding vector at :attr:`padding_idx` is not updated during training,\n                                     i.e. it remains as a fixed \"pad\".\n        max_norm (float, optional): If given, each embedding vector with norm larger than :attr:`max_norm`\n                                    is renormalized to have norm :attr:`max_norm`.\n                                    Note: this will modify :attr:`weight` in-place.\n        norm_type (float, optional): The p of the p-norm to compute for the :attr:`max_norm` option. Default ``2``.\n        scale_grad_by_freq (bool, optional): If given, this will scale gradients by the inverse of frequency of\n                                                the words in the mini-batch. Default ``False``.\n        sparse (bool, optional): If ``True``, gradient w.r.t. :attr:`weight` will be a sparse tensor. See Notes under\n                                 :class:`torch.nn.Embedding` for more details regarding sparse gradients.\n\n    Shape:\n        - Input: LongTensor of arbitrary shape containing the indices to extract\n        - Weight: Embedding matrix of floating point type with shape `(V, embedding_dim)`,\n          where V = maximum index + 1 and embedding_dim = the embedding size\n        - Output: `(*, embedding_dim)`, where `*` is the input shape\n\n    Examples::\n\n        >>> # a batch of 2 samples of 4 indices each\n        >>> input = torch.tensor([[1, 2, 4, 5], [4, 3, 2, 9]])\n        >>> # an embedding matrix containing 10 tensors of size 3\n        >>> embedding_matrix = torch.rand(10, 3)\n        >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\")\n        >>> F.embedding(input, embedding_matrix)\n        tensor([[[ 0.8490,  0.9625,  0.6753],\n                 [ 0.9666,  0.7761,  0.6108],\n                 [ 0.6246,  0.9751,  0.3618],\n                 [ 0.4161,  0.2419,  0.7383]],\n\n                [[ 0.6246,  0.9751,  0.3618],\n                 [ 0.0237,  0.7794,  0.0528],\n                 [ 0.9666,  0.7761,  0.6108],\n                 [ 0.3385,  0.8612,  0.1867]]])\n\n        >>> # example with padding_idx\n        >>> weights = torch.rand(10, 3)\n        >>> weights[0, :].zero_()\n        >>> embedding_matrix = weights\n        >>> input = torch.tensor([[0,2,0,5]])\n        >>> F.embedding(input, embedding_matrix, padding_idx=0)\n        tensor([[[ 0.0000,  0.0000,  0.0000],\n                 [ 0.5609,  0.5384,  0.8720],\n                 [ 0.0000,  0.0000,  0.0000],\n                 [ 0.6262,  0.2438,  0.7471]]])\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "weight": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "padding_idx": {
                  "Type": "typing.Optional[int]",
                  "Default": "None"
                },
                "max_norm": {
                  "Type": "typing.Optional[float]",
                  "Default": "None"
                },
                "norm_type": {
                  "Type": "<class 'float'>",
                  "Default": "2.0"
                },
                "scale_grad_by_freq": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                },
                "sparse": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "embedding_bag": {
              "Doc": "Computes sums, means or maxes of `bags` of embeddings, without instantiating the\n    intermediate embeddings.\n\n    See :class:`torch.nn.EmbeddingBag` for more details.\n\n    Note:\n        This operation may produce nondeterministic gradients when given tensors on a CUDA device. See :doc:`/notes/randomness` for more information.\n\n    Args:\n        input (LongTensor): Tensor containing bags of indices into the embedding matrix\n        weight (Tensor): The embedding matrix with number of rows equal to the maximum possible index + 1,\n            and number of columns equal to the embedding size\n        offsets (LongTensor, optional): Only used when :attr:`input` is 1D. :attr:`offsets` determines\n                             the starting index position of each bag (sequence) in :attr:`input`.\n        max_norm (float, optional): If given, each embedding vector with norm larger than :attr:`max_norm`\n                                    is renormalized to have norm :attr:`max_norm`.\n                                    Note: this will modify :attr:`weight` in-place.\n        norm_type (float, optional): The ``p`` in the ``p``-norm to compute for the :attr:`max_norm` option.\n                                     Default ``2``.\n        scale_grad_by_freq (bool, optional): if given, this will scale gradients by the inverse of frequency of\n                                                the words in the mini-batch. Default ``False``.\n                                                Note: this option is not supported when ``mode=\"max\"``.\n        mode (str, optional): ``\"sum\"``, ``\"mean\"`` or ``\"max\"``. Specifies the way to reduce the bag.\n                                 Default: ``\"mean\"``\n        sparse (bool, optional): if ``True``, gradient w.r.t. :attr:`weight` will be a sparse tensor. See Notes under\n                                 :class:`torch.nn.Embedding` for more details regarding sparse gradients.\n                                 Note: this option is not supported when ``mode=\"max\"``.\n        per_sample_weights (Tensor, optional): a tensor of float / double weights, or None\n            to indicate all weights should be taken to be 1. If specified, :attr:`per_sample_weights`\n            must have exactly the same shape as input and is treated as having the same\n            :attr:`offsets`, if those are not None.\n\n        include_last_offset (bool, optional): if ``True``, the size of offsets is equal to the number of bags + 1.\n            The last element is the size of the input, or the ending index position of the last bag (sequence).\n\n        padding_idx (int, optional): If specified, the entries at :attr:`padding_idx` do not contribute to the\n                                     gradient; therefore, the embedding vector at :attr:`padding_idx` is not updated\n                                     during training, i.e. it remains as a fixed \"pad\". Note that the embedding\n                                     vector at :attr:`padding_idx` is excluded from the reduction.\n\n    Shape:\n        - :attr:`input` (LongTensor) and :attr:`offsets` (LongTensor, optional)\n\n          - If :attr:`input` is 2D of shape `(B, N)`, it will be treated as ``B`` bags (sequences)\n            each of fixed length ``N``, and this will return ``B`` values aggregated in a way\n            depending on the :attr:`mode`. :attr:`offsets` is ignored and required to be ``None`` in this case.\n\n          - If :attr:`input` is 1D of shape `(N)`, it will be treated as a concatenation of\n            multiple bags (sequences). :attr:`offsets` is required to be a 1D tensor containing\n            the starting index positions of each bag in :attr:`input`. Therefore, for :attr:`offsets`\n            of shape `(B)`, :attr:`input` will be viewed as having ``B`` bags.\n            Empty bags (i.e., having 0-length) will have returned vectors filled by zeros.\n\n        - :attr:`weight` (Tensor): the learnable weights of the module of shape `(num_embeddings, embedding_dim)`\n\n        - :attr:`per_sample_weights` (Tensor, optional). Has the same shape as :attr:`input`.\n\n        - :attr:`output`: aggregated embedding values of shape `(B, embedding_dim)`\n\n    Examples::\n\n        >>> # an Embedding module containing 10 tensors of size 3\n        >>> embedding_matrix = torch.rand(10, 3)\n        >>> # a batch of 2 samples of 4 indices each\n        >>> input = torch.tensor([1,2,4,5,4,3,2,9])\n        >>> offsets = torch.tensor([0,4])\n        >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\")\n        >>> F.embedding_bag(input, embedding_matrix, offsets)\n        tensor([[ 0.3397,  0.3552,  0.5545],\n                [ 0.5893,  0.4386,  0.5882]])\n\n        >>> # example with padding_idx\n        >>> embedding_matrix = torch.rand(10, 3)\n        >>> input = torch.tensor([2, 2, 2, 2, 4, 3, 2, 9])\n        >>> offsets = torch.tensor([0,4])\n        >>> F.embedding_bag(input, embedding_matrix, offsets, padding_idx=2, mode='sum')\n        tensor([[ 0.0000,  0.0000,  0.0000],\n                [-0.7082,  3.2145, -2.6251]])\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "weight": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "offsets": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "max_norm": {
                  "Type": "typing.Optional[float]",
                  "Default": "None"
                },
                "norm_type": {
                  "Type": "<class 'float'>",
                  "Default": "2"
                },
                "scale_grad_by_freq": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                },
                "mode": {
                  "Type": "<class 'str'>",
                  "Default": "mean"
                },
                "sparse": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                },
                "per_sample_weights": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "include_last_offset": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                },
                "padding_idx": {
                  "Type": "typing.Optional[int]",
                  "Default": "None"
                }
              }
            },
            "feature_alpha_dropout": {
              "Doc": "\n    Randomly masks out entire channels (a channel is a feature map,\n    e.g. the :math:`j`-th channel of the :math:`i`-th sample in the batch input\n    is a tensor :math:`\\text{input}[i, j]`) of the input tensor). Instead of\n    setting activations to zero, as in regular Dropout, the activations are set\n    to the negative saturation value of the SELU activation function.\n\n    Each element will be masked independently on every forward call with\n    probability :attr:`p` using samples from a Bernoulli distribution.\n    The elements to be masked are randomized on every forward call, and scaled\n    and shifted to maintain zero mean and unit variance.\n\n    See :class:`~torch.nn.FeatureAlphaDropout` for details.\n\n    Args:\n        p: dropout probability of a channel to be zeroed. Default: 0.5\n        training: apply dropout if is ``True``. Default: ``True``\n        inplace: If set to ``True``, will do this operation in-place. Default: ``False``\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "p": {
                  "Type": "<class 'float'>",
                  "Default": "0.5"
                },
                "training": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                },
                "inplace": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "fold": {
              "Doc": "Combines an array of sliding local blocks into a large containing\n    tensor.\n\n    .. warning::\n        Currently, only unbatched (3D) or batched (4D) image-like output tensors are supported.\n\n    See :class:`torch.nn.Fold` for details\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "output_size": {
                  "Type": "None",
                  "Default": null
                },
                "kernel_size": {
                  "Type": "None",
                  "Default": null
                },
                "dilation": {
                  "Type": "None",
                  "Default": "1"
                },
                "padding": {
                  "Type": "None",
                  "Default": "0"
                },
                "stride": {
                  "Type": "None",
                  "Default": "1"
                }
              }
            },
            "fractional_max_pool2d_with_indices": {
              "Doc": "Applies 2D fractional max pooling over an input signal composed of several input planes.\n\n    Fractional MaxPooling is described in detail in the paper `Fractional MaxPooling`_ by Ben Graham\n\n    The max-pooling operation is applied in :math:`kH \\times kW` regions by a stochastic\n    step size determined by the target output size.\n    The number of output features is equal to the number of input planes.\n\n    Args:\n        kernel_size: the size of the window to take a max over.\n                     Can be a single number :math:`k` (for a square kernel of :math:`k \\times k`)\n                     or a tuple `(kH, kW)`\n        output_size: the target output size of the image of the form :math:`oH \\times oW`.\n                     Can be a tuple `(oH, oW)` or a single number :math:`oH` for a square image :math:`oH \\times oH`\n        output_ratio: If one wants to have an output size as a ratio of the input size, this option can be given.\n                      This has to be a number or tuple in the range (0, 1)\n        return_indices: if ``True``, will return the indices along with the outputs.\n                        Useful to pass to :func:`~torch.nn.functional.max_unpool2d`.\n\n    Examples::\n        >>> input = torch.randn(20, 16, 50, 32)\n        >>> # pool of square window of size=3, and target output size 13x12\n        >>> F.fractional_max_pool2d(input, 3, output_size=(13, 12))\n        >>> # pool of square window and target output size being half of input image size\n        >>> F.fractional_max_pool2d(input, 3, output_ratio=(0.5, 0.5))\n\n    .. _Fractional MaxPooling:\n        http://arxiv.org/abs/1412.6071\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "kernel_size": {
                  "Type": "None",
                  "Default": null
                },
                "output_size": {
                  "Type": "<class 'NoneType'>",
                  "Default": "None"
                },
                "output_ratio": {
                  "Type": "<class 'NoneType'>",
                  "Default": "None"
                },
                "return_indices": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                },
                "_random_samples": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                }
              }
            },
            "fractional_max_pool3d_with_indices": {
              "Doc": "Applies 3D fractional max pooling over an input signal composed of several input planes.\n\n    Fractional MaxPooling is described in detail in the paper `Fractional MaxPooling`_ by Ben Graham\n\n    The max-pooling operation is applied in :math:`kT \\times kH \\times kW` regions by a stochastic\n    step size determined by the target output size.\n    The number of output features is equal to the number of input planes.\n\n    Args:\n        kernel_size: the size of the window to take a max over.\n                     Can be a single number :math:`k` (for a square kernel of :math:`k \\times k \\times k`)\n                     or a tuple `(kT, kH, kW)`\n        output_size: the target output size of the form :math:`oT \\times oH \\times oW`.\n                     Can be a tuple `(oT, oH, oW)` or a single number :math:`oH` for a cubic output\n                     :math:`oH \\times oH \\times oH`\n        output_ratio: If one wants to have an output size as a ratio of the input size, this option can be given.\n                      This has to be a number or tuple in the range (0, 1)\n        return_indices: if ``True``, will return the indices along with the outputs.\n                        Useful to pass to :func:`~torch.nn.functional.max_unpool3d`.\n\n    Shape:\n        - Input: :math:`(N, C, T_{in}, H_{in}, W_{in})` or :math:`(C, T_{in}, H_{in}, W_{in})`.\n        - Output: :math:`(N, C, T_{out}, H_{out}, W_{out})` or :math:`(C, T_{out}, H_{out}, W_{out})`, where\n          :math:`(T_{out}, H_{out}, W_{out})=\\text{output\\_size}` or\n          :math:`(T_{out}, H_{out}, W_{out})=\\text{output\\_ratio} \\times (T_{in}, H_{in}, W_{in})`\n\n    Examples::\n        >>> input = torch.randn(20, 16, 50, 32, 16)\n        >>> # pool of cubic window of size=3, and target output size 13x12x11\n        >>> F.fractional_max_pool3d(input, 3, output_size=(13, 12, 11))\n        >>> # pool of cubic window and target output size being half of input size\n        >>> F.fractional_max_pool3d(input, 3, output_ratio=(0.5, 0.5, 0.5))\n\n    .. _Fractional MaxPooling:\n        http://arxiv.org/abs/1412.6071\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "kernel_size": {
                  "Type": "None",
                  "Default": null
                },
                "output_size": {
                  "Type": "<class 'NoneType'>",
                  "Default": "None"
                },
                "output_ratio": {
                  "Type": "<class 'NoneType'>",
                  "Default": "None"
                },
                "return_indices": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                },
                "_random_samples": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                }
              }
            },
            "gaussian_nll_loss": {
              "Doc": "Gaussian negative log likelihood loss.\n\n    See :class:`~torch.nn.GaussianNLLLoss` for details.\n\n    Args:\n        input: expectation of the Gaussian distribution.\n        target: sample from the Gaussian distribution.\n        var: tensor of positive variance(s), one for each of the expectations\n            in the input (heteroscedastic), or a single one (homoscedastic).\n        full (bool, optional): include the constant term in the loss calculation. Default: ``False``.\n        eps (float, optional): value added to var, for stability. Default: 1e-6.\n        reduction (str, optional): specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the output is the average of all batch member losses,\n            ``'sum'``: the output is the sum of all batch member losses.\n            Default: ``'mean'``.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "target": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "var": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "full": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                },
                "eps": {
                  "Type": "<class 'float'>",
                  "Default": "1e-06"
                },
                "reduction": {
                  "Type": "<class 'str'>",
                  "Default": "mean"
                }
              }
            },
            "gelu": {
              "Doc": "\ngelu(input, approximate = 'none') -> Tensor\n\nWhen the approximate argument is 'none', it applies element-wise the function\n:math:`\\text{GELU}(x) = x * \\Phi(x)`\n\nwhere :math:`\\Phi(x)` is the Cumulative Distribution Function for Gaussian Distribution.\n\nWhen the approximate argument is 'tanh', Gelu is estimated with:\n    :math::  \\text{GELU}(x) = 0.5 * x * (1 + \\text{Tanh}(\\sqrt(2 / \\pi) * (x + 0.044715 * x^3)))\n\nSee `Gaussian Error Linear Units (GELUs) <https://arxiv.org/abs/1606.08415>`_.\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "approximate ": {
                  "Type": null,
                  "Default": "'none'"
                }
              }
            },
            "glu": {
              "Doc": "\n    glu(input, dim=-1) -> Tensor\n\n    The gated linear unit. Computes:\n\n    .. math ::\n        \\text{GLU}(a, b) = a \\otimes \\sigma(b)\n\n    where `input` is split in half along `dim` to form `a` and `b`, :math:`\\sigma`\n    is the sigmoid function and :math:`\\otimes` is the element-wise product between matrices.\n\n    See `Language Modeling with Gated Convolutional Networks <https://arxiv.org/abs/1612.08083>`_.\n\n    Args:\n        input (Tensor): input tensor\n        dim (int): dimension on which to split the input. Default: -1\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "dim": {
                  "Type": "<class 'int'>",
                  "Default": "-1"
                }
              }
            },
            "grid_sample": {
              "Doc": "Given an :attr:`input` and a flow-field :attr:`grid`, computes the\n    ``output`` using :attr:`input` values and pixel locations from :attr:`grid`.\n\n    Currently, only spatial (4-D) and volumetric (5-D) :attr:`input` are\n    supported.\n\n    In the spatial (4-D) case, for :attr:`input` with shape\n    :math:`(N, C, H_\\text{in}, W_\\text{in})` and :attr:`grid` with shape\n    :math:`(N, H_\\text{out}, W_\\text{out}, 2)`, the output will have shape\n    :math:`(N, C, H_\\text{out}, W_\\text{out})`.\n\n    For each output location ``output[n, :, h, w]``, the size-2 vector\n    ``grid[n, h, w]`` specifies :attr:`input` pixel locations ``x`` and ``y``,\n    which are used to interpolate the output value ``output[n, :, h, w]``.\n    In the case of 5D inputs, ``grid[n, d, h, w]`` specifies the\n    ``x``, ``y``, ``z`` pixel locations for interpolating\n    ``output[n, :, d, h, w]``. :attr:`mode` argument specifies ``nearest`` or\n    ``bilinear`` interpolation method to sample the input pixels.\n\n    :attr:`grid` specifies the sampling pixel locations normalized by the\n    :attr:`input` spatial dimensions. Therefore, it should have most values in\n    the range of ``[-1, 1]``. For example, values ``x = -1, y = -1`` is the\n    left-top pixel of :attr:`input`, and values  ``x = 1, y = 1`` is the\n    right-bottom pixel of :attr:`input`.\n\n    If :attr:`grid` has values outside the range of ``[-1, 1]``, the corresponding\n    outputs are handled as defined by :attr:`padding_mode`. Options are\n\n        * ``padding_mode=\"zeros\"``: use ``0`` for out-of-bound grid locations,\n        * ``padding_mode=\"border\"``: use border values for out-of-bound grid locations,\n        * ``padding_mode=\"reflection\"``: use values at locations reflected by\n          the border for out-of-bound grid locations. For location far away\n          from the border, it will keep being reflected until becoming in bound,\n          e.g., (normalized) pixel location ``x = -3.5`` reflects by border ``-1``\n          and becomes ``x' = 1.5``, then reflects by border ``1`` and becomes\n          ``x'' = -0.5``.\n\n    Note:\n        This function is often used in conjunction with :func:`affine_grid`\n        to build `Spatial Transformer Networks`_ .\n\n    Note:\n        When using the CUDA backend, this operation may induce nondeterministic\n        behaviour in its backward pass that is not easily switched off.\n        Please see the notes on :doc:`/notes/randomness` for background.\n\n    Note:\n        NaN values in :attr:`grid` would be interpreted as ``-1``.\n\n    Args:\n        input (Tensor): input of shape :math:`(N, C, H_\\text{in}, W_\\text{in})` (4-D case)\n                        or :math:`(N, C, D_\\text{in}, H_\\text{in}, W_\\text{in})` (5-D case)\n        grid (Tensor): flow-field of shape :math:`(N, H_\\text{out}, W_\\text{out}, 2)` (4-D case)\n                       or :math:`(N, D_\\text{out}, H_\\text{out}, W_\\text{out}, 3)` (5-D case)\n        mode (str): interpolation mode to calculate output values\n            ``'bilinear'`` | ``'nearest'`` | ``'bicubic'``. Default: ``'bilinear'``\n            Note: ``mode='bicubic'`` supports only 4-D input.\n            When ``mode='bilinear'`` and the input is 5-D, the interpolation mode\n            used internally will actually be trilinear. However, when the input is 4-D,\n            the interpolation mode will legitimately be bilinear.\n        padding_mode (str): padding mode for outside grid values\n            ``'zeros'`` | ``'border'`` | ``'reflection'``. Default: ``'zeros'``\n        align_corners (bool, optional): Geometrically, we consider the pixels of the\n            input  as squares rather than points.\n            If set to ``True``, the extrema (``-1`` and ``1``) are considered as referring\n            to the center points of the input's corner pixels. If set to ``False``, they\n            are instead considered as referring to the corner points of the input's corner\n            pixels, making the sampling more resolution agnostic.\n            This option parallels the ``align_corners`` option in\n            :func:`interpolate`, and so whichever option is used here\n            should also be used there to resize the input image before grid sampling.\n            Default: ``False``\n\n    Returns:\n        output (Tensor): output Tensor\n\n    .. _`Spatial Transformer Networks`:\n        https://arxiv.org/abs/1506.02025\n\n    .. warning::\n        When ``align_corners = True``, the grid positions depend on the pixel\n        size relative to the input image size, and so the locations sampled by\n        :func:`grid_sample` will differ for the same input given at different\n        resolutions (that is, after being upsampled or downsampled).\n        The default behavior up to version 1.2.0 was ``align_corners = True``.\n        Since then, the default behavior has been changed to ``align_corners = False``,\n        in order to bring it in line with the default for :func:`interpolate`.\n\n    .. note::\n        ``mode='bicubic'`` is implemented using the `cubic convolution algorithm`_ with :math:`\\alpha=-0.75`.\n        The constant :math:`\\alpha` might be different from packages to packages.\n        For example, `PIL`_ and `OpenCV`_ use -0.5 and -0.75 respectively.\n        This algorithm may \"overshoot\" the range of values it's interpolating.\n        For example, it may produce negative values or values greater than 255 when interpolating input in [0, 255].\n        Clamp the results with :func: `torch.clamp` to ensure they are within the valid range.\n    .. _`cubic convolution algorithm`: https://en.wikipedia.org/wiki/Bicubic_interpolation\n    .. _`PIL`: https://github.com/python-pillow/Pillow/blob/4634eafe3c695a014267eefdce830b4a825beed7/src/libImaging/Resample.c#L51\n    .. _`OpenCV`: https://github.com/opencv/opencv/blob/f345ed564a06178670750bad59526cfa4033be55/modules/imgproc/src/resize.cpp#L908\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "grid": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "mode": {
                  "Type": "<class 'str'>",
                  "Default": "bilinear"
                },
                "padding_mode": {
                  "Type": "<class 'str'>",
                  "Default": "zeros"
                },
                "align_corners": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                }
              }
            },
            "group_norm": {
              "Doc": "Applies Group Normalization for last certain number of dimensions.\n\n    See :class:`~torch.nn.GroupNorm` for details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "num_groups": {
                  "Type": "<class 'int'>",
                  "Default": null
                },
                "weight": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "bias": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "eps": {
                  "Type": "<class 'float'>",
                  "Default": "1e-05"
                }
              }
            },
            "gumbel_softmax": {
              "Doc": "\n    Samples from the Gumbel-Softmax distribution (`Link 1`_  `Link 2`_) and optionally discretizes.\n\n    Args:\n      logits: `[..., num_features]` unnormalized log probabilities\n      tau: non-negative scalar temperature\n      hard: if ``True``, the returned samples will be discretized as one-hot vectors,\n            but will be differentiated as if it is the soft sample in autograd\n      dim (int): A dimension along which softmax will be computed. Default: -1.\n\n    Returns:\n      Sampled tensor of same shape as `logits` from the Gumbel-Softmax distribution.\n      If ``hard=True``, the returned samples will be one-hot, otherwise they will\n      be probability distributions that sum to 1 across `dim`.\n\n    .. note::\n      This function is here for legacy reasons, may be removed from nn.Functional in the future.\n\n    .. note::\n      The main trick for `hard` is to do  `y_hard - y_soft.detach() + y_soft`\n\n      It achieves two things:\n      - makes the output value exactly one-hot\n      (since we add then subtract y_soft value)\n      - makes the gradient equal to y_soft gradient\n      (since we strip all other gradients)\n\n    Examples::\n        >>> logits = torch.randn(20, 32)\n        >>> # Sample soft categorical using reparametrization trick:\n        >>> F.gumbel_softmax(logits, tau=1, hard=False)\n        >>> # Sample hard categorical using \"Straight-through\" trick:\n        >>> F.gumbel_softmax(logits, tau=1, hard=True)\n\n    .. _Link 1:\n        https://arxiv.org/abs/1611.00712\n    .. _Link 2:\n        https://arxiv.org/abs/1611.01144\n    ",
              "Args": {
                "logits": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "tau": {
                  "Type": "<class 'float'>",
                  "Default": "1"
                },
                "hard": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                },
                "eps": {
                  "Type": "<class 'float'>",
                  "Default": "1e-10"
                },
                "dim": {
                  "Type": "<class 'int'>",
                  "Default": "-1"
                }
              }
            },
            "handle_torch_function": {
              "Doc": "Implement a function with checks for ``__torch_function__`` overrides.\n\n    See torch::autograd::handle_torch_function for the equivalent of this\n    function in the C++ implementation.\n\n    Arguments\n    ---------\n    public_api : function\n        Function exposed by the public torch API originally called like\n        ``public_api(*args, **kwargs)`` on which arguments are now being\n        checked.\n    relevant_args : iterable\n        Iterable of arguments to check for __torch_function__ methods.\n    args : tuple\n        Arbitrary positional arguments originally passed into ``public_api``.\n    kwargs : tuple\n        Arbitrary keyword arguments originally passed into ``public_api``.\n\n    Returns\n    -------\n    object\n        Result from calling ``implementation`` or an ``__torch_function__``\n        method, as appropriate.\n\n    Raises\n    ------\n    TypeError : if no implementation is found.\n\n    Example\n    -------\n    >>> def func(a):\n    ...     if has_torch_function_unary(a):\n    ...         return handle_torch_function(func, (a,), a)\n    ...     return a + 0\n    ",
              "Args": {
                "public_api": {
                  "Type": "typing.Callable",
                  "Default": null
                },
                "relevant_args": {
                  "Type": "typing.Iterable[typing.Any]",
                  "Default": null
                },
                "*args": {
                  "Type": null,
                  "Default": null
                },
                "**kwargs": {
                  "Type": null,
                  "Default": null
                }
              }
            },
            "hardshrink": {
              "Doc": "\nhardshrink(input, lambd=0.5) -> Tensor\n\nApplies the hard shrinkage function element-wise\n\nSee :class:`~torch.nn.Hardshrink` for more details.\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "lambd": {
                  "Type": null,
                  "Default": "0.5"
                }
              }
            },
            "hardsigmoid": {
              "Doc": "Applies the element-wise function\n\n    .. math::\n        \\text{Hardsigmoid}(x) = \\begin{cases}\n            0 & \\text{if~} x \\le -3, \\\\\n            1 & \\text{if~} x \\ge +3, \\\\\n            x / 6 + 1 / 2 & \\text{otherwise}\n        \\end{cases}\n\n    Args:\n        inplace: If set to ``True``, will do this operation in-place. Default: ``False``\n\n    See :class:`~torch.nn.Hardsigmoid` for more details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "inplace": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "hardswish": {
              "Doc": "Applies the hardswish function, element-wise, as described in the paper:\n\n    `Searching for MobileNetV3`_.\n\n    .. math::\n        \\text{Hardswish}(x) = \\begin{cases}\n            0 & \\text{if~} x \\le -3, \\\\\n            x & \\text{if~} x \\ge +3, \\\\\n            x \\cdot (x + 3) /6 & \\text{otherwise}\n        \\end{cases}\n\n    See :class:`~torch.nn.Hardswish` for more details.\n\n    .. _`Searching for MobileNetV3`:\n        https://arxiv.org/abs/1905.02244\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "inplace": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "hardtanh": {
              "Doc": "\n    hardtanh(input, min_val=-1., max_val=1., inplace=False) -> Tensor\n\n    Applies the HardTanh function element-wise. See :class:`~torch.nn.Hardtanh` for more\n    details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "min_val": {
                  "Type": "<class 'float'>",
                  "Default": "-1.0"
                },
                "max_val": {
                  "Type": "<class 'float'>",
                  "Default": "1.0"
                },
                "inplace": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "hinge_embedding_loss": {
              "Doc": "hinge_embedding_loss(input, target, margin=1.0, size_average=None, reduce=None, reduction='mean') -> Tensor\n\n    See :class:`~torch.nn.HingeEmbeddingLoss` for details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "target": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "margin": {
                  "Type": "<class 'float'>",
                  "Default": "1.0"
                },
                "size_average": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduce": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduction": {
                  "Type": "<class 'str'>",
                  "Default": "mean"
                }
              }
            },
            "huber_loss": {
              "Doc": "Function that uses a squared term if the absolute\n    element-wise error falls below delta and a delta-scaled L1 term otherwise.\n\n    See :class:`~torch.nn.HuberLoss` for details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "target": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "reduction": {
                  "Type": "<class 'str'>",
                  "Default": "mean"
                },
                "delta": {
                  "Type": "<class 'float'>",
                  "Default": "1.0"
                }
              }
            },
            "instance_norm": {
              "Doc": "Applies Instance Normalization for each channel in each data sample in a\n    batch.\n\n    See :class:`~torch.nn.InstanceNorm1d`, :class:`~torch.nn.InstanceNorm2d`,\n    :class:`~torch.nn.InstanceNorm3d` for details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "running_mean": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "running_var": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "weight": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "bias": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "use_input_stats": {
                  "Type": "<class 'bool'>",
                  "Default": "True"
                },
                "momentum": {
                  "Type": "<class 'float'>",
                  "Default": "0.1"
                },
                "eps": {
                  "Type": "<class 'float'>",
                  "Default": "1e-05"
                }
              }
            },
            "interpolate": {
              "Doc": "Down/up samples the input to either the given :attr:`size` or the given\n    :attr:`scale_factor`\n\n    The algorithm used for interpolation is determined by :attr:`mode`.\n\n    Currently temporal, spatial and volumetric sampling are supported, i.e.\n    expected inputs are 3-D, 4-D or 5-D in shape.\n\n    The input dimensions are interpreted in the form:\n    `mini-batch x channels x [optional depth] x [optional height] x width`.\n\n    The modes available for resizing are: `nearest`, `linear` (3D-only),\n    `bilinear`, `bicubic` (4D-only), `trilinear` (5D-only), `area`, `nearest-exact`\n\n    Args:\n        input (Tensor): the input tensor\n        size (int or Tuple[int] or Tuple[int, int] or Tuple[int, int, int]):\n            output spatial size.\n        scale_factor (float or Tuple[float]): multiplier for spatial size. If `scale_factor` is a tuple,\n            its length has to match the number of spatial dimensions; `input.dim() - 2`.\n        mode (str): algorithm used for upsampling:\n            ``'nearest'`` | ``'linear'`` | ``'bilinear'`` | ``'bicubic'`` |\n            ``'trilinear'`` | ``'area'`` | ``'nearest-exact'``. Default: ``'nearest'``\n        align_corners (bool, optional): Geometrically, we consider the pixels of the\n            input and output as squares rather than points.\n            If set to ``True``, the input and output tensors are aligned by the\n            center points of their corner pixels, preserving the values at the corner pixels.\n            If set to ``False``, the input and output tensors are aligned by the corner\n            points of their corner pixels, and the interpolation uses edge value padding\n            for out-of-boundary values, making this operation *independent* of input size\n            when :attr:`scale_factor` is kept the same. This only has an effect when :attr:`mode`\n            is ``'linear'``, ``'bilinear'``, ``'bicubic'`` or ``'trilinear'``.\n            Default: ``False``\n        recompute_scale_factor (bool, optional): recompute the scale_factor for use in the\n            interpolation calculation. If `recompute_scale_factor` is ``True``, then\n            `scale_factor` must be passed in and `scale_factor` is used to compute the\n            output `size`. The computed output `size` will be used to infer new scales for\n            the interpolation. Note that when `scale_factor` is floating-point, it may differ\n            from the recomputed `scale_factor` due to rounding and precision issues.\n            If `recompute_scale_factor` is ``False``, then `size` or `scale_factor` will\n            be used directly for interpolation. Default: ``None``.\n        antialias (bool, optional): flag to apply anti-aliasing. Default: ``False``. Using anti-alias\n            option together with ``align_corners=False``, interpolation result would match Pillow\n            result for downsampling operation. Supported modes: ``'bilinear'``, ``'bicubic'``.\n\n    .. note::\n        With ``mode='bicubic'``, it's possible to cause overshoot, in other words it can produce\n        negative values or values greater than 255 for images.\n        Explicitly call ``result.clamp(min=0, max=255)`` if you want to reduce the overshoot\n        when displaying the image.\n\n    .. note::\n        Mode ``mode='nearest-exact'`` matches Scikit-Image and PIL nearest neighbours interpolation\n        algorithms and fixes known issues with ``mode='nearest'``. This mode is introduced to keep\n        backward compatibility.\n        Mode ``mode='nearest'`` matches buggy OpenCV's ``INTER_NEAREST`` interpolation algorithm.\n\n    Note:\n        This operation may produce nondeterministic gradients when given tensors on a CUDA device. See :doc:`/notes/randomness` for more information.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "size": {
                  "Type": "typing.Optional[int]",
                  "Default": "None"
                },
                "scale_factor": {
                  "Type": "typing.Optional[typing.List[float]]",
                  "Default": "None"
                },
                "mode": {
                  "Type": "<class 'str'>",
                  "Default": "nearest"
                },
                "align_corners": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "recompute_scale_factor": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "antialias": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "kl_div": {
              "Doc": "The `Kullback-Leibler divergence Loss\n    <https://en.wikipedia.org/wiki/Kullback-Leibler_divergence>`__\n\n    See :class:`~torch.nn.KLDivLoss` for details.\n\n    Args:\n        input: Tensor of arbitrary shape in log-probabilities.\n        target: Tensor of the same shape as input. See :attr:`log_target` for\n            the target's interpretation.\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there multiple elements per sample. If the field :attr:`size_average`\n            is set to ``False``, the losses are instead summed for each minibatch. Ignored\n            when reduce is ``False``. Default: ``True``\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: ``True``\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'batchmean'`` | ``'sum'`` | ``'mean'``.\n            ``'none'``: no reduction will be applied\n            ``'batchmean'``: the sum of the output will be divided by the batchsize\n            ``'sum'``: the output will be summed\n            ``'mean'``: the output will be divided by the number of elements in the output\n            Default: ``'mean'``\n        log_target (bool): A flag indicating whether ``target`` is passed in the log space.\n            It is recommended to pass certain distributions (like ``softmax``)\n            in the log space to avoid numerical issues caused by explicit ``log``.\n            Default: ``False``\n\n    .. note::\n        :attr:`size_average` and :attr:`reduce` are in the process of being deprecated,\n        and in the meantime, specifying either of those two args will override :attr:`reduction`.\n\n    .. note::\n        :attr:`reduction` = ``'mean'`` doesn't return the true kl divergence value, please use\n        :attr:`reduction` = ``'batchmean'`` which aligns with KL math definition.\n        In the next major release, ``'mean'`` will be changed to be the same as 'batchmean'.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "target": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "size_average": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduce": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduction": {
                  "Type": "<class 'str'>",
                  "Default": "mean"
                },
                "log_target": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "l1_loss": {
              "Doc": "l1_loss(input, target, size_average=None, reduce=None, reduction='mean') -> Tensor\n\n    Function that takes the mean element-wise absolute value difference.\n\n    See :class:`~torch.nn.L1Loss` for details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "target": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "size_average": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduce": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduction": {
                  "Type": "<class 'str'>",
                  "Default": "mean"
                }
              }
            },
            "layer_norm": {
              "Doc": "Applies Layer Normalization for last certain number of dimensions.\n\n    See :class:`~torch.nn.LayerNorm` for details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "normalized_shape": {
                  "Type": "typing.List[int]",
                  "Default": null
                },
                "weight": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "bias": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "eps": {
                  "Type": "<class 'float'>",
                  "Default": "1e-05"
                }
              }
            },
            "leaky_relu": {
              "Doc": "\n    leaky_relu(input, negative_slope=0.01, inplace=False) -> Tensor\n\n    Applies element-wise,\n    :math:`\\text{LeakyReLU}(x) = \\max(0, x) + \\text{negative\\_slope} * \\min(0, x)`\n\n    See :class:`~torch.nn.LeakyReLU` for more details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "negative_slope": {
                  "Type": "<class 'float'>",
                  "Default": "0.01"
                },
                "inplace": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "linear": {
              "Doc": "\nlinear(input, weight, bias=None) -> Tensor\n\nApplies a linear transformation to the incoming data: :math:`y = xA^T + b`.\n\nThis opperation supports 2-D :attr:`weight` with :ref:`sparse layout<sparse-docs>`\n\n\n.. warning::\n    Sparse support is a beta feature and some layout(s)/dtype/device combinations may not be supported,\n    or may not have autograd support. If you notice missing functionality please\n    open a feature request.\n\nThis operator supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\nShape:\n\n    - Input: :math:`(*, in\\_features)` where `*` means any number of\n      additional dimensions, including none\n    - Weight: :math:`(out\\_features, in\\_features)` or :math:`(in\\_features)`\n    - Bias: :math:`(out\\_features)` or :math:`()`\n    - Output: :math:`(*, out\\_features)` or :math:`(*)`, based on the shape of the weight\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "weight": {
                  "Type": null,
                  "Default": null
                },
                "bias": {
                  "Type": null,
                  "Default": "None"
                }
              }
            },
            "local_response_norm": {
              "Doc": "Applies local response normalization over an input signal composed of\n    several input planes, where channels occupy the second dimension.\n    Applies normalization across channels.\n\n    See :class:`~torch.nn.LocalResponseNorm` for details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "size": {
                  "Type": "<class 'int'>",
                  "Default": null
                },
                "alpha": {
                  "Type": "<class 'float'>",
                  "Default": "0.0001"
                },
                "beta": {
                  "Type": "<class 'float'>",
                  "Default": "0.75"
                },
                "k": {
                  "Type": "<class 'float'>",
                  "Default": "1.0"
                }
              }
            },
            "log_softmax": {
              "Doc": "Applies a softmax followed by a logarithm.\n\n    While mathematically equivalent to log(softmax(x)), doing these two\n    operations separately is slower and numerically unstable. This function\n    uses an alternative formulation to compute the output and gradient correctly.\n\n    See :class:`~torch.nn.LogSoftmax` for more details.\n\n    Args:\n        input (Tensor): input\n        dim (int): A dimension along which log_softmax will be computed.\n        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n          If specified, the input tensor is cast to :attr:`dtype` before the operation\n          is performed. This is useful for preventing data type overflows. Default: None.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "dim": {
                  "Type": "typing.Optional[int]",
                  "Default": "None"
                },
                "_stacklevel": {
                  "Type": "<class 'int'>",
                  "Default": "3"
                },
                "dtype": {
                  "Type": "typing.Optional[int]",
                  "Default": "None"
                }
              }
            },
            "logsigmoid": {
              "Doc": "\nlogsigmoid(input) -> Tensor\n\nApplies element-wise :math:`\\text{LogSigmoid}(x_i) = \\log \\left(\\frac{1}{1 + \\exp(-x_i)}\\right)`\n\nSee :class:`~torch.nn.LogSigmoid` for more details.\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                }
              }
            },
            "lp_pool1d": {
              "Doc": "Applies a 1D power-average pooling over an input signal composed of\n    several input planes. If the sum of all inputs to the power of `p` is\n    zero, the gradient is set to zero as well.\n\n    See :class:`~torch.nn.LPPool1d` for details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "norm_type": {
                  "Type": "typing.Union[int, float]",
                  "Default": null
                },
                "kernel_size": {
                  "Type": "<class 'int'>",
                  "Default": null
                },
                "stride": {
                  "Type": "<class 'NoneType'>",
                  "Default": "None"
                },
                "ceil_mode": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "lp_pool2d": {
              "Doc": "Applies a 2D power-average pooling over an input signal composed of\n    several input planes. If the sum of all inputs to the power of `p` is\n    zero, the gradient is set to zero as well.\n\n    See :class:`~torch.nn.LPPool2d` for details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "norm_type": {
                  "Type": "typing.Union[int, float]",
                  "Default": null
                },
                "kernel_size": {
                  "Type": "None",
                  "Default": null
                },
                "stride": {
                  "Type": "<class 'NoneType'>",
                  "Default": "None"
                },
                "ceil_mode": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "margin_ranking_loss": {
              "Doc": "margin_ranking_loss(input1, input2, target, margin=0, size_average=None, reduce=None, reduction='mean') -> Tensor\n\n    See :class:`~torch.nn.MarginRankingLoss` for details.\n    ",
              "Args": {
                "input1": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "input2": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "target": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "margin": {
                  "Type": "<class 'float'>",
                  "Default": "0"
                },
                "size_average": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduce": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduction": {
                  "Type": "<class 'str'>",
                  "Default": "mean"
                }
              }
            },
            "max_pool1d_with_indices": {
              "Doc": "\n    max_pool1d(input, kernel_size, stride=None, padding=0, dilation=1, ceil_mode=False, return_indices=False)\n\n    Applies a 1D max pooling over an input signal composed of several input\n    planes.\n\n    .. note::\n        The order of :attr:`ceil_mode` and :attr:`return_indices` is different from\n        what seen in :class:`~torch.nn.MaxPool1d`, and will change in a future release.\n\n    See :class:`~torch.nn.MaxPool1d` for details.\n\n    Args:\n        input: input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iW)`, minibatch dim optional.\n        kernel_size: the size of the window. Can be a single number or a\n            tuple `(kW,)`\n        stride: the stride of the window. Can be a single number or a tuple\n            `(sW,)`. Default: :attr:`kernel_size`\n        padding: Implicit negative infinity padding to be added on both sides, must be >= 0 and <= kernel_size / 2.\n        dilation: The stride between elements within a sliding window, must be > 0.\n        ceil_mode: If ``True``, will use `ceil` instead of `floor` to compute the output shape. This\n                   ensures that every element in the input tensor is covered by a sliding window.\n        return_indices: If ``True``, will return the argmax along with the max values.\n                        Useful for :class:`torch.nn.functional.max_unpool1d` later\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "kernel_size": {
                  "Type": "None",
                  "Default": null
                },
                "stride": {
                  "Type": "<class 'NoneType'>",
                  "Default": "None"
                },
                "padding": {
                  "Type": "None",
                  "Default": "0"
                },
                "dilation": {
                  "Type": "None",
                  "Default": "1"
                },
                "ceil_mode": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                },
                "return_indices": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "max_pool2d_with_indices": {
              "Doc": "\n    max_pool2d(input, kernel_size, stride=None, padding=0, dilation=1, ceil_mode=False, return_indices=False)\n\n    Applies a 2D max pooling over an input signal composed of several input\n    planes.\n\n    .. note::\n        The order of :attr:`ceil_mode` and :attr:`return_indices` is different from\n        what seen in :class:`~torch.nn.MaxPool2d`, and will change in a future release.\n\n    See :class:`~torch.nn.MaxPool2d` for details.\n\n    Args:\n        input: input tensor :math:`(\\text{minibatch} , \\text{in\\_channels} , iH , iW)`, minibatch dim optional.\n        kernel_size: size of the pooling region. Can be a single number or a\n            tuple `(kH, kW)`\n        stride: stride of the pooling operation. Can be a single number or a\n            tuple `(sH, sW)`. Default: :attr:`kernel_size`\n        padding: Implicit negative infinity padding to be added on both sides, must be >= 0 and <= kernel_size / 2.\n        dilation: The stride between elements within a sliding window, must be > 0.\n        ceil_mode: If ``True``, will use `ceil` instead of `floor` to compute the output shape. This\n                   ensures that every element in the input tensor is covered by a sliding window.\n        return_indices: If ``True``, will return the argmax along with the max values.\n                        Useful for :class:`torch.nn.functional.max_unpool2d` later\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "kernel_size": {
                  "Type": "None",
                  "Default": null
                },
                "stride": {
                  "Type": "<class 'NoneType'>",
                  "Default": "None"
                },
                "padding": {
                  "Type": "None",
                  "Default": "0"
                },
                "dilation": {
                  "Type": "None",
                  "Default": "1"
                },
                "ceil_mode": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                },
                "return_indices": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "max_pool3d_with_indices": {
              "Doc": "\n    max_pool3d(input, kernel_size, stride=None, padding=0, dilation=1, ceil_mode=False, return_indices=False)\n\n    Applies a 3D max pooling over an input signal composed of several input\n    planes.\n\n    .. note::\n        The order of :attr:`ceil_mode` and :attr:`return_indices` is different from\n        what seen in :class:`~torch.nn.MaxPool3d`, and will change in a future release.\n\n    See :class:`~torch.nn.MaxPool3d` for details.\n\n    Args:\n        input: input tensor :math:`(\\text{minibatch} , \\text{in\\_channels} , iD, iH , iW)`, minibatch dim optional.\n        kernel_size: size of the pooling region. Can be a single number or a\n                     tuple `(kT, kH, kW)`\n        stride: stride of the pooling operation. Can be a single number or a\n                tuple `(sT, sH, sW)`. Default: :attr:`kernel_size`\n        padding: Implicit negative infinity padding to be added on both sides, must be >= 0 and <= kernel_size / 2.\n        dilation: The stride between elements within a sliding window, must be > 0.\n        ceil_mode: If ``True``, will use `ceil` instead of `floor` to compute the output shape. This\n                   ensures that every element in the input tensor is covered by a sliding window.\n        return_indices: If ``True``, will return the argmax along with the max values.\n                        Useful for :class:`torch.nn.functional.max_unpool3d` later\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "kernel_size": {
                  "Type": "None",
                  "Default": null
                },
                "stride": {
                  "Type": "<class 'NoneType'>",
                  "Default": "None"
                },
                "padding": {
                  "Type": "None",
                  "Default": "0"
                },
                "dilation": {
                  "Type": "None",
                  "Default": "1"
                },
                "ceil_mode": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                },
                "return_indices": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "max_unpool1d": {
              "Doc": "Computes a partial inverse of :class:`MaxPool1d`.\n\n    See :class:`~torch.nn.MaxUnpool1d` for details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "indices": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "kernel_size": {
                  "Type": "None",
                  "Default": null
                },
                "stride": {
                  "Type": "<class 'NoneType'>",
                  "Default": "None"
                },
                "padding": {
                  "Type": "None",
                  "Default": "0"
                },
                "output_size": {
                  "Type": "<class 'NoneType'>",
                  "Default": "None"
                }
              }
            },
            "max_unpool2d": {
              "Doc": "Computes a partial inverse of :class:`MaxPool2d`.\n\n    See :class:`~torch.nn.MaxUnpool2d` for details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "indices": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "kernel_size": {
                  "Type": "None",
                  "Default": null
                },
                "stride": {
                  "Type": "<class 'NoneType'>",
                  "Default": "None"
                },
                "padding": {
                  "Type": "None",
                  "Default": "0"
                },
                "output_size": {
                  "Type": "<class 'NoneType'>",
                  "Default": "None"
                }
              }
            },
            "max_unpool3d": {
              "Doc": "Computes a partial inverse of :class:`MaxPool3d`.\n\n    See :class:`~torch.nn.MaxUnpool3d` for details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "indices": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "kernel_size": {
                  "Type": "None",
                  "Default": null
                },
                "stride": {
                  "Type": "<class 'NoneType'>",
                  "Default": "None"
                },
                "padding": {
                  "Type": "None",
                  "Default": "0"
                },
                "output_size": {
                  "Type": "<class 'NoneType'>",
                  "Default": "None"
                }
              }
            },
            "mish": {
              "Doc": "Applies the Mish function, element-wise.\n    Mish: A Self Regularized Non-Monotonic Neural Activation Function.\n\n    .. math::\n        \\text{Mish}(x) = x * \\text{Tanh}(\\text{Softplus}(x))\n\n    .. note::\n        See `Mish: A Self Regularized Non-Monotonic Neural Activation Function <https://arxiv.org/abs/1908.08681>`_\n\n    See :class:`~torch.nn.Mish` for more details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "inplace": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "mse_loss": {
              "Doc": "mse_loss(input, target, size_average=None, reduce=None, reduction='mean') -> Tensor\n\n    Measures the element-wise mean squared error.\n\n    See :class:`~torch.nn.MSELoss` for details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "target": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "size_average": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduce": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduction": {
                  "Type": "<class 'str'>",
                  "Default": "mean"
                }
              }
            },
            "multi_head_attention_forward": {
              "Doc": "\n    Args:\n        query, key, value: map a query and a set of key-value pairs to an output.\n            See \"Attention Is All You Need\" for more details.\n        embed_dim_to_check: total dimension of the model.\n        num_heads: parallel attention heads.\n        in_proj_weight, in_proj_bias: input projection weight and bias.\n        bias_k, bias_v: bias of the key and value sequences to be added at dim=0.\n        add_zero_attn: add a new batch of zeros to the key and\n                       value sequences at dim=1.\n        dropout_p: probability of an element to be zeroed.\n        out_proj_weight, out_proj_bias: the output projection weight and bias.\n        training: apply dropout if is ``True``.\n        key_padding_mask: if provided, specified padding elements in the key will\n            be ignored by the attention. This is an binary mask. When the value is True,\n            the corresponding value on the attention layer will be filled with -inf.\n        need_weights: output attn_output_weights.\n        attn_mask: 2D or 3D mask that prevents attention to certain positions. A 2D mask will be broadcasted for all\n            the batches while a 3D mask allows to specify a different mask for the entries of each batch.\n        use_separate_proj_weight: the function accept the proj. weights for query, key,\n            and value in different forms. If false, in_proj_weight will be used, which is\n            a combination of q_proj_weight, k_proj_weight, v_proj_weight.\n        q_proj_weight, k_proj_weight, v_proj_weight, in_proj_bias: input projection weight and bias.\n        static_k, static_v: static key and value used for attention operators.\n        average_attn_weights: If true, indicates that the returned ``attn_weights`` should be averaged across heads.\n            Otherwise, ``attn_weights`` are provided separately per head. Note that this flag only has an effect\n            when ``need_weights=True.``. Default: True\n\n\n    Shape:\n        Inputs:\n        - query: :math:`(L, E)` or :math:`(L, N, E)` where L is the target sequence length, N is the batch size, E is\n          the embedding dimension.\n        - key: :math:`(S, E)` or :math:`(S, N, E)`, where S is the source sequence length, N is the batch size, E is\n          the embedding dimension.\n        - value: :math:`(S, E)` or :math:`(S, N, E)` where S is the source sequence length, N is the batch size, E is\n          the embedding dimension.\n        - key_padding_mask: :math:`(S)` or :math:`(N, S)` where N is the batch size, S is the source sequence length.\n          If a FloatTensor is provided, it will be directly added to the value.\n          If a BoolTensor is provided, the positions with the\n          value of ``True`` will be ignored while the position with the value of ``False`` will be unchanged.\n        - attn_mask: 2D mask :math:`(L, S)` where L is the target sequence length, S is the source sequence length.\n          3D mask :math:`(N*num_heads, L, S)` where N is the batch size, L is the target sequence length,\n          S is the source sequence length. attn_mask ensures that position i is allowed to attend the unmasked\n          positions. If a ByteTensor is provided, the non-zero positions are not allowed to attend\n          while the zero positions will be unchanged. If a BoolTensor is provided, positions with ``True``\n          are not allowed to attend while ``False`` values will be unchanged. If a FloatTensor\n          is provided, it will be added to the attention weight.\n        - static_k: :math:`(N*num_heads, S, E/num_heads)`, where S is the source sequence length,\n          N is the batch size, E is the embedding dimension. E/num_heads is the head dimension.\n        - static_v: :math:`(N*num_heads, S, E/num_heads)`, where S is the source sequence length,\n          N is the batch size, E is the embedding dimension. E/num_heads is the head dimension.\n\n        Outputs:\n        - attn_output: :math:`(L, E)` or :math:`(L, N, E)` where L is the target sequence length, N is the batch size,\n          E is the embedding dimension.\n        - attn_output_weights: Only returned when ``need_weights=True``. If ``average_attn_weights=True``, returns\n          attention weights averaged across heads of shape :math:`(L, S)` when input is unbatched or\n          :math:`(N, L, S)`, where :math:`N` is the batch size, :math:`L` is the target sequence length, and\n          :math:`S` is the source sequence length. If ``average_attn_weights=False``, returns attention weights per\n          head of shape :math:`(num_heads, L, S)` when input is unbatched or :math:`(N, num_heads, L, S)`.\n    ",
              "Args": {
                "query": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "key": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "value": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "embed_dim_to_check": {
                  "Type": "<class 'int'>",
                  "Default": null
                },
                "num_heads": {
                  "Type": "<class 'int'>",
                  "Default": null
                },
                "in_proj_weight": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": null
                },
                "in_proj_bias": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": null
                },
                "bias_k": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": null
                },
                "bias_v": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": null
                },
                "add_zero_attn": {
                  "Type": "<class 'bool'>",
                  "Default": null
                },
                "dropout_p": {
                  "Type": "<class 'float'>",
                  "Default": null
                },
                "out_proj_weight": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "out_proj_bias": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": null
                },
                "training": {
                  "Type": "<class 'bool'>",
                  "Default": "True"
                },
                "key_padding_mask": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "need_weights": {
                  "Type": "<class 'bool'>",
                  "Default": "True"
                },
                "attn_mask": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "use_separate_proj_weight": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                },
                "q_proj_weight": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "k_proj_weight": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "v_proj_weight": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "static_k": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "static_v": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "average_attn_weights": {
                  "Type": "<class 'bool'>",
                  "Default": "True"
                }
              }
            },
            "multi_margin_loss": {
              "Doc": "multi_margin_loss(input, target, p=1, margin=1, weight=None, size_average=None, reduce=None, reduction='mean') -> Tensor\n\n    See :class:`~torch.nn.MultiMarginLoss` for details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "target": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "p": {
                  "Type": "<class 'int'>",
                  "Default": "1"
                },
                "margin": {
                  "Type": "<class 'float'>",
                  "Default": "1.0"
                },
                "weight": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "size_average": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduce": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduction": {
                  "Type": "<class 'str'>",
                  "Default": "mean"
                }
              }
            },
            "multilabel_margin_loss": {
              "Doc": "multilabel_margin_loss(input, target, size_average=None, reduce=None, reduction='mean') -> Tensor\n\n    See :class:`~torch.nn.MultiLabelMarginLoss` for details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "target": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "size_average": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduce": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduction": {
                  "Type": "<class 'str'>",
                  "Default": "mean"
                }
              }
            },
            "multilabel_soft_margin_loss": {
              "Doc": "multilabel_soft_margin_loss(input, target, weight=None, size_average=None, reduce=None, reduction='mean') -> Tensor\n\n    See :class:`~torch.nn.MultiLabelSoftMarginLoss` for details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "target": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "weight": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "size_average": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduce": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduction": {
                  "Type": "<class 'str'>",
                  "Default": "mean"
                }
              }
            },
            "native_channel_shuffle": {
              "Doc": "\nnative_channel_shuffle(input, groups) -> Tensor\n\nNative kernel level implementation of the `channel_shuffle`.\nThis function might become private in future releases, use with caution.\n\nDivide the channels in a tensor of shape :math:`(*, C , H, W)`\ninto g groups and rearrange them as :math:`(*, C \\frac g, g, H, W)`,\nwhile keeping the original tensor shape.\n\nSee :class:`~torch.nn.ChannelShuffle` for details.\n\nArgs:\n    input (Tensor): the input tensor\n    groups (int): number of groups to divide channels in and rearrange.\n\nExamples::\n\n    >>> input = torch.randn(1, 4, 2, 2)\n    >>> print(input)\n    [[[[1, 2],\n       [3, 4]],\n      [[5, 6],\n       [7, 8]],\n      [[9, 10],\n       [11, 12]],\n      [[13, 14],\n       [15, 16]],\n     ]]\n    >>> output = torch.nn.functional.native_channel_shuffle(input, 2)\n    >>> print(output)\n    [[[[1, 2],\n       [3, 4]],\n      [[9, 10],\n       [11, 12]],\n      [[5, 6],\n       [7, 8]],\n      [[13, 14],\n       [15, 16]],\n     ]]\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "groups": {
                  "Type": null,
                  "Default": null
                }
              }
            },
            "nll_loss": {
              "Doc": "The negative log likelihood loss.\n\n    See :class:`~torch.nn.NLLLoss` for details.\n\n    Args:\n        input: :math:`(N, C)` where `C = number of classes` or :math:`(N, C, H, W)`\n            in case of 2D Loss, or :math:`(N, C, d_1, d_2, ..., d_K)` where :math:`K \\geq 1`\n            in the case of K-dimensional loss. `input` is expected to be log-probabilities.\n        target: :math:`(N)` where each value is :math:`0 \\leq \\text{targets}[i] \\leq C-1`,\n            or :math:`(N, d_1, d_2, ..., d_K)` where :math:`K \\geq 1` for\n            K-dimensional loss.\n        weight (Tensor, optional): a manual rescaling weight given to each\n            class. If given, has to be a Tensor of size `C`\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there multiple elements per sample. If the field :attr:`size_average`\n            is set to ``False``, the losses are instead summed for each minibatch. Ignored\n            when reduce is ``False``. Default: ``True``\n        ignore_index (int, optional): Specifies a target value that is ignored\n            and does not contribute to the input gradient. When :attr:`size_average` is\n            ``True``, the loss is averaged over non-ignored targets. Default: -100\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: ``True``\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the sum of the output will be divided by the number of\n            elements in the output, ``'sum'``: the output will be summed. Note: :attr:`size_average`\n            and :attr:`reduce` are in the process of being deprecated, and in the meantime,\n            specifying either of those two args will override :attr:`reduction`. Default: ``'mean'``\n\n    Example::\n\n        >>> # input is of size N x C = 3 x 5\n        >>> input = torch.randn(3, 5, requires_grad=True)\n        >>> # each element in target has to have 0 <= value < C\n        >>> target = torch.tensor([1, 0, 4])\n        >>> output = F.nll_loss(F.log_softmax(input, dim=1), target)\n        >>> output.backward()\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "target": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "weight": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                },
                "size_average": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "ignore_index": {
                  "Type": "<class 'int'>",
                  "Default": "-100"
                },
                "reduce": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduction": {
                  "Type": "<class 'str'>",
                  "Default": "mean"
                }
              }
            },
            "normalize": {
              "Doc": "Performs :math:`L_p` normalization of inputs over specified dimension.\n\n    For a tensor :attr:`input` of sizes :math:`(n_0, ..., n_{dim}, ..., n_k)`, each\n    :math:`n_{dim}` -element vector :math:`v` along dimension :attr:`dim` is transformed as\n\n    .. math::\n        v = \\frac{v}{\\max(\\lVert v \\rVert_p, \\epsilon)}.\n\n    With the default arguments it uses the Euclidean norm over vectors along dimension :math:`1` for normalization.\n\n    Args:\n        input: input tensor of any shape\n        p (float): the exponent value in the norm formulation. Default: 2\n        dim (int): the dimension to reduce. Default: 1\n        eps (float): small value to avoid division by zero. Default: 1e-12\n        out (Tensor, optional): the output tensor. If :attr:`out` is used, this\n                                operation won't be differentiable.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "p": {
                  "Type": "<class 'float'>",
                  "Default": "2.0"
                },
                "dim": {
                  "Type": "<class 'int'>",
                  "Default": "1"
                },
                "eps": {
                  "Type": "<class 'float'>",
                  "Default": "1e-12"
                },
                "out": {
                  "Type": "typing.Optional[torch.Tensor]",
                  "Default": "None"
                }
              }
            },
            "one_hot": {
              "Doc": "\none_hot(tensor, num_classes=-1) -> LongTensor\n\nTakes LongTensor with index values of shape ``(*)`` and returns a tensor\nof shape ``(*, num_classes)`` that have zeros everywhere except where the\nindex of last dimension matches the corresponding value of the input tensor,\nin which case it will be 1.\n\nSee also `One-hot on Wikipedia`_ .\n\n.. _One-hot on Wikipedia:\n    https://en.wikipedia.org/wiki/One-hot\n\nArguments:\n    tensor (LongTensor): class values of any shape.\n    num_classes (int):  Total number of classes. If set to -1, the number\n        of classes will be inferred as one greater than the largest class\n        value in the input tensor.\n\nReturns:\n    LongTensor that has one more dimension with 1 values at the\n    index of last dimension indicated by the input, and 0 everywhere\n    else.\n\nExamples:\n    >>> F.one_hot(torch.arange(0, 5) % 3)\n    tensor([[1, 0, 0],\n            [0, 1, 0],\n            [0, 0, 1],\n            [1, 0, 0],\n            [0, 1, 0]])\n    >>> F.one_hot(torch.arange(0, 5) % 3, num_classes=5)\n    tensor([[1, 0, 0, 0, 0],\n            [0, 1, 0, 0, 0],\n            [0, 0, 1, 0, 0],\n            [1, 0, 0, 0, 0],\n            [0, 1, 0, 0, 0]])\n    >>> F.one_hot(torch.arange(0, 6).view(3,2) % 3)\n    tensor([[[1, 0, 0],\n             [0, 1, 0]],\n            [[0, 0, 1],\n             [1, 0, 0]],\n            [[0, 1, 0],\n             [0, 0, 1]]])\n",
              "Args": {
                "tensor": {
                  "Type": null,
                  "Default": null
                },
                "num_classes": {
                  "Type": null,
                  "Default": "-1"
                }
              }
            },
            "pad": {
              "Doc": "\npad(input, pad, mode=\"constant\", value=None) -> Tensor\n\nPads tensor.\n\nPadding size:\n    The padding size by which to pad some dimensions of :attr:`input`\n    are described starting from the last dimension and moving forward.\n    :math:`\\left\\lfloor\\frac{\\text{len(pad)}}{2}\\right\\rfloor` dimensions\n    of ``input`` will be padded.\n    For example, to pad only the last dimension of the input tensor, then\n    :attr:`pad` has the form\n    :math:`(\\text{padding\\_left}, \\text{padding\\_right})`;\n    to pad the last 2 dimensions of the input tensor, then use\n    :math:`(\\text{padding\\_left}, \\text{padding\\_right},`\n    :math:`\\text{padding\\_top}, \\text{padding\\_bottom})`;\n    to pad the last 3 dimensions, use\n    :math:`(\\text{padding\\_left}, \\text{padding\\_right},`\n    :math:`\\text{padding\\_top}, \\text{padding\\_bottom}`\n    :math:`\\text{padding\\_front}, \\text{padding\\_back})`.\n\nPadding mode:\n    See :class:`torch.nn.ConstantPad2d`, :class:`torch.nn.ReflectionPad2d`, and\n    :class:`torch.nn.ReplicationPad2d` for concrete examples on how each of the\n    padding modes works. Constant padding is implemented for arbitrary dimensions.\n    Replicate and reflection padding are implemented for padding the last 3\n    dimensions of a 4D or 5D input tensor, the last 2 dimensions of a 3D\n    or 4D input tensor, or the last dimension of a 2D or 3D input tensor.\n\nNote:\n    When using the CUDA backend, this operation may induce nondeterministic\n    behaviour in its backward pass that is not easily switched off.\n    Please see the notes on :doc:`/notes/randomness` for background.\n\nArgs:\n    input (Tensor): N-dimensional tensor\n    pad (tuple): m-elements tuple, where\n        :math:`\\frac{m}{2} \\leq` input dimensions and :math:`m` is even.\n    mode: ``'constant'``, ``'reflect'``, ``'replicate'`` or ``'circular'``.\n        Default: ``'constant'``\n    value: fill value for ``'constant'`` padding. Default: ``0``\n\nExamples::\n\n    >>> t4d = torch.empty(3, 3, 4, 2)\n    >>> p1d = (1, 1) # pad last dim by 1 on each side\n    >>> out = F.pad(t4d, p1d, \"constant\", 0)  # effectively zero padding\n    >>> print(out.size())\n    torch.Size([3, 3, 4, 4])\n    >>> p2d = (1, 1, 2, 2) # pad last dim by (1, 1) and 2nd to last by (2, 2)\n    >>> out = F.pad(t4d, p2d, \"constant\", 0)\n    >>> print(out.size())\n    torch.Size([3, 3, 8, 4])\n    >>> t4d = torch.empty(3, 3, 4, 2)\n    >>> p3d = (0, 1, 2, 1, 3, 3) # pad by (0, 1), (2, 1), and (3, 3)\n    >>> out = F.pad(t4d, p3d, \"constant\", 0)\n    >>> print(out.size())\n    torch.Size([3, 9, 7, 3])\n\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "pad": {
                  "Type": null,
                  "Default": null
                },
                "mode": {
                  "Type": null,
                  "Default": "\"constant\""
                },
                "value": {
                  "Type": null,
                  "Default": "None"
                }
              }
            },
            "pairwise_distance": {
              "Doc": "\npairwise_distance(x1, x2, p=2.0, eps=1e-6, keepdim=False) -> Tensor\n\nSee :class:`torch.nn.PairwiseDistance` for details\n",
              "Args": {
                "x1": {
                  "Type": null,
                  "Default": null
                },
                "x2": {
                  "Type": null,
                  "Default": null
                },
                "p": {
                  "Type": null,
                  "Default": "2.0"
                },
                "eps": {
                  "Type": null,
                  "Default": "1e-6"
                },
                "keepdim": {
                  "Type": null,
                  "Default": "False"
                }
              }
            },
            "pdist": {
              "Doc": "\npdist(input, p=2) -> Tensor\n\nComputes the p-norm distance between every pair of row vectors in the input.\nThis is identical to the upper triangular portion, excluding the diagonal, of\n`torch.norm(input[:, None] - input, dim=2, p=p)`. This function will be faster\nif the rows are contiguous.\n\nIf input has shape :math:`N \\times M` then the output will have shape\n:math:`\\frac{1}{2} N (N - 1)`.\n\nThis function is equivalent to ``scipy.spatial.distance.pdist(input,\n'minkowski', p=p)`` if :math:`p \\in (0, \\infty)`. When :math:`p = 0` it is\nequivalent to ``scipy.spatial.distance.pdist(input, 'hamming') * M``.\nWhen :math:`p = \\infty`, the closest scipy function is\n``scipy.spatial.distance.pdist(xn, lambda x, y: np.abs(x - y).max())``.\n\nArgs:\n    input: input tensor of shape :math:`N \\times M`.\n    p: p value for the p-norm distance to calculate between each vector pair\n        :math:`\\in [0, \\infty]`.\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "p": {
                  "Type": null,
                  "Default": "2"
                }
              }
            },
            "pixel_shuffle": {
              "Doc": "\npixel_shuffle(input, upscale_factor) -> Tensor\n\nRearranges elements in a tensor of shape :math:`(*, C \\times r^2, H, W)` to a\ntensor of shape :math:`(*, C, H \\times r, W \\times r)`, where r is the :attr:`upscale_factor`.\n\nSee :class:`~torch.nn.PixelShuffle` for details.\n\nArgs:\n    input (Tensor): the input tensor\n    upscale_factor (int): factor to increase spatial resolution by\n\nExamples::\n\n    >>> input = torch.randn(1, 9, 4, 4)\n    >>> output = torch.nn.functional.pixel_shuffle(input, 3)\n    >>> print(output.size())\n    torch.Size([1, 1, 12, 12])\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "upscale_factor": {
                  "Type": null,
                  "Default": null
                }
              }
            },
            "pixel_unshuffle": {
              "Doc": "\npixel_unshuffle(input, downscale_factor) -> Tensor\n\nReverses the :class:`~torch.nn.PixelShuffle` operation by rearranging elements in a\ntensor of shape :math:`(*, C, H \\times r, W \\times r)` to a tensor of shape\n:math:`(*, C \\times r^2, H, W)`, where r is the :attr:`downscale_factor`.\n\nSee :class:`~torch.nn.PixelUnshuffle` for details.\n\nArgs:\n    input (Tensor): the input tensor\n    downscale_factor (int): factor to increase spatial resolution by\n\nExamples::\n\n    >>> input = torch.randn(1, 1, 12, 12)\n    >>> output = torch.nn.functional.pixel_unshuffle(input, 3)\n    >>> print(output.size())\n    torch.Size([1, 9, 4, 4])\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "downscale_factor": {
                  "Type": null,
                  "Default": null
                }
              }
            },
            "poisson_nll_loss": {
              "Doc": "Poisson negative log likelihood loss.\n\n    See :class:`~torch.nn.PoissonNLLLoss` for details.\n\n    Args:\n        input: expectation of underlying Poisson distribution.\n        target: random sample :math:`target \\sim \\text{Poisson}(input)`.\n        log_input: if ``True`` the loss is computed as\n            :math:`\\exp(\\text{input}) - \\text{target} * \\text{input}`, if ``False`` then loss is\n            :math:`\\text{input} - \\text{target} * \\log(\\text{input}+\\text{eps})`. Default: ``True``\n        full: whether to compute full loss, i. e. to add the Stirling\n            approximation term. Default: ``False``\n            :math:`\\text{target} * \\log(\\text{target}) - \\text{target} + 0.5 * \\log(2 * \\pi * \\text{target})`.\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there multiple elements per sample. If the field :attr:`size_average`\n            is set to ``False``, the losses are instead summed for each minibatch. Ignored\n            when reduce is ``False``. Default: ``True``\n        eps (float, optional): Small value to avoid evaluation of :math:`\\log(0)` when\n            :attr:`log_input`\\ =\\ ``False``. Default: 1e-8\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: ``True``\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the sum of the output will be divided by the number of\n            elements in the output, ``'sum'``: the output will be summed. Note: :attr:`size_average`\n            and :attr:`reduce` are in the process of being deprecated, and in the meantime,\n            specifying either of those two args will override :attr:`reduction`. Default: ``'mean'``\n\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "target": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "log_input": {
                  "Type": "<class 'bool'>",
                  "Default": "True"
                },
                "full": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                },
                "size_average": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "eps": {
                  "Type": "<class 'float'>",
                  "Default": "1e-08"
                },
                "reduce": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduction": {
                  "Type": "<class 'str'>",
                  "Default": "mean"
                }
              }
            },
            "prelu": {
              "Doc": "prelu(input, weight) -> Tensor\n\nApplies element-wise the function\n:math:`\\text{PReLU}(x) = \\max(0,x) + \\text{weight} * \\min(0,x)` where weight is a\nlearnable parameter.\n\n.. note::\n    `weight` is expected to be a scalar or 1-D tensor. If `weight` is 1-D,\n    its size must match the number of input channels, determined by\n    `input.size(1)` when `input.dim() >= 2`, otherwise 1.\n    In the 1-D case, note that when `input` has dim > 2, `weight` can be expanded\n    to the shape of `input` in a way that is not possible using normal\n    :ref:`broadcasting semantics<broadcasting-semantics>`.\n\nSee :class:`~torch.nn.PReLU` for more details.\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "weight": {
                  "Type": null,
                  "Default": null
                }
              }
            },
            "relu": {
              "Doc": "relu(input, inplace=False) -> Tensor\n\n    Applies the rectified linear unit function element-wise. See\n    :class:`~torch.nn.ReLU` for more details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "inplace": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "relu6": {
              "Doc": "relu6(input, inplace=False) -> Tensor\n\n    Applies the element-wise function :math:`\\text{ReLU6}(x) = \\min(\\max(0,x), 6)`.\n\n    See :class:`~torch.nn.ReLU6` for more details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "inplace": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "rrelu": {
              "Doc": "rrelu(input, lower=1./8, upper=1./3, training=False, inplace=False) -> Tensor\n\n    Randomized leaky ReLU.\n\n    See :class:`~torch.nn.RReLU` for more details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "lower": {
                  "Type": "<class 'float'>",
                  "Default": "0.125"
                },
                "upper": {
                  "Type": "<class 'float'>",
                  "Default": "0.3333333333333333"
                },
                "training": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                },
                "inplace": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "selu": {
              "Doc": "selu(input, inplace=False) -> Tensor\n\n    Applies element-wise,\n    :math:`\\text{SELU}(x) = scale * (\\max(0,x) + \\min(0, \\alpha * (\\exp(x) - 1)))`,\n    with :math:`\\alpha=1.6732632423543772848170429916717` and\n    :math:`scale=1.0507009873554804934193349852946`.\n\n    See :class:`~torch.nn.SELU` for more details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "inplace": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "sigmoid": {
              "Doc": "sigmoid(input) -> Tensor\n\n    Applies the element-wise function :math:`\\text{Sigmoid}(x) = \\frac{1}{1 + \\exp(-x)}`\n\n    See :class:`~torch.nn.Sigmoid` for more details.\n    ",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                }
              }
            },
            "silu": {
              "Doc": "Applies the Sigmoid Linear Unit (SiLU) function, element-wise.\n    The SiLU function is also known as the swish function.\n\n    .. math::\n        \\text{silu}(x) = x * \\sigma(x), \\text{where } \\sigma(x) \\text{ is the logistic sigmoid.}\n\n    .. note::\n        See `Gaussian Error Linear Units (GELUs) <https://arxiv.org/abs/1606.08415>`_\n        where the SiLU (Sigmoid Linear Unit) was originally coined, and see\n        `Sigmoid-Weighted Linear Units for Neural Network Function Approximation\n        in Reinforcement Learning <https://arxiv.org/abs/1702.03118>`_ and `Swish:\n        a Self-Gated Activation Function <https://arxiv.org/abs/1710.05941v1>`_\n        where the SiLU was experimented with later.\n\n    See :class:`~torch.nn.SiLU` for more details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "inplace": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "smooth_l1_loss": {
              "Doc": "Function that uses a squared term if the absolute\n    element-wise error falls below beta and an L1 term otherwise.\n\n    See :class:`~torch.nn.SmoothL1Loss` for details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "target": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "size_average": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduce": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduction": {
                  "Type": "<class 'str'>",
                  "Default": "mean"
                },
                "beta": {
                  "Type": "<class 'float'>",
                  "Default": "1.0"
                }
              }
            },
            "soft_margin_loss": {
              "Doc": "soft_margin_loss(input, target, size_average=None, reduce=None, reduction='mean') -> Tensor\n\n    See :class:`~torch.nn.SoftMarginLoss` for details.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "target": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "size_average": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduce": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduction": {
                  "Type": "<class 'str'>",
                  "Default": "mean"
                }
              }
            },
            "softmax": {
              "Doc": "Applies a softmax function.\n\n    Softmax is defined as:\n\n    :math:`\\text{Softmax}(x_{i}) = \\frac{\\exp(x_i)}{\\sum_j \\exp(x_j)}`\n\n    It is applied to all slices along dim, and will re-scale them so that the elements\n    lie in the range `[0, 1]` and sum to 1.\n\n    See :class:`~torch.nn.Softmax` for more details.\n\n    Args:\n        input (Tensor): input\n        dim (int): A dimension along which softmax will be computed.\n        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n          If specified, the input tensor is casted to :attr:`dtype` before the operation\n          is performed. This is useful for preventing data type overflows. Default: None.\n\n    .. note::\n        This function doesn't work directly with NLLLoss,\n        which expects the Log to be computed between the Softmax and itself.\n        Use log_softmax instead (it's faster and has better numerical properties).\n\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "dim": {
                  "Type": "typing.Optional[int]",
                  "Default": "None"
                },
                "_stacklevel": {
                  "Type": "<class 'int'>",
                  "Default": "3"
                },
                "dtype": {
                  "Type": "typing.Optional[int]",
                  "Default": "None"
                }
              }
            },
            "softmin": {
              "Doc": "Applies a softmin function.\n\n    Note that :math:`\\text{Softmin}(x) = \\text{Softmax}(-x)`. See softmax definition for mathematical formula.\n\n    See :class:`~torch.nn.Softmin` for more details.\n\n    Args:\n        input (Tensor): input\n        dim (int): A dimension along which softmin will be computed (so every slice\n            along dim will sum to 1).\n        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n          If specified, the input tensor is casted to :attr:`dtype` before the operation\n          is performed. This is useful for preventing data type overflows. Default: None.\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "dim": {
                  "Type": "typing.Optional[int]",
                  "Default": "None"
                },
                "_stacklevel": {
                  "Type": "<class 'int'>",
                  "Default": "3"
                },
                "dtype": {
                  "Type": "typing.Optional[int]",
                  "Default": "None"
                }
              }
            },
            "softplus": {
              "Doc": "\nsoftplus(input, beta=1, threshold=20) -> Tensor\n\nApplies element-wise, the function :math:`\\text{Softplus}(x) = \\frac{1}{\\beta} * \\log(1 + \\exp(\\beta * x))`.\n\nFor numerical stability the implementation reverts to the linear function\nwhen :math:`input \\times \\beta > threshold`.\n\nSee :class:`~torch.nn.Softplus` for more details.\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "beta": {
                  "Type": null,
                  "Default": "1"
                },
                "threshold": {
                  "Type": null,
                  "Default": "20"
                }
              }
            },
            "softshrink": {
              "Doc": "\nsoftshrink(input, lambd=0.5) -> Tensor\n\nApplies the soft shrinkage function elementwise\n\nSee :class:`~torch.nn.Softshrink` for more details.\n",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "lambd": {
                  "Type": null,
                  "Default": "0.5"
                }
              }
            },
            "softsign": {
              "Doc": "softsign(input) -> Tensor\n\n    Applies element-wise, the function :math:`\\text{SoftSign}(x) = \\frac{x}{1 + |x|}`\n\n    See :class:`~torch.nn.Softsign` for more details.\n    ",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                }
              }
            },
            "tanh": {
              "Doc": "tanh(input) -> Tensor\n\n    Applies element-wise,\n    :math:`\\text{Tanh}(x) = \\tanh(x) = \\frac{\\exp(x) - \\exp(-x)}{\\exp(x) + \\exp(-x)}`\n\n    See :class:`~torch.nn.Tanh` for more details.\n    ",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                }
              }
            },
            "tanhshrink": {
              "Doc": "tanhshrink(input) -> Tensor\n\n    Applies element-wise, :math:`\\text{Tanhshrink}(x) = x - \\text{Tanh}(x)`\n\n    See :class:`~torch.nn.Tanhshrink` for more details.\n    ",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                }
              }
            },
            "triplet_margin_loss": {
              "Doc": "\n    See :class:`~torch.nn.TripletMarginLoss` for details\n    ",
              "Args": {
                "anchor": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "positive": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "negative": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "margin": {
                  "Type": "<class 'float'>",
                  "Default": "1.0"
                },
                "p": {
                  "Type": "<class 'float'>",
                  "Default": "2"
                },
                "eps": {
                  "Type": "<class 'float'>",
                  "Default": "1e-06"
                },
                "swap": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                },
                "size_average": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduce": {
                  "Type": "typing.Optional[bool]",
                  "Default": "None"
                },
                "reduction": {
                  "Type": "<class 'str'>",
                  "Default": "mean"
                }
              }
            },
            "triplet_margin_with_distance_loss": {
              "Doc": "\n    See :class:`~torch.nn.TripletMarginWithDistanceLoss` for details.\n    ",
              "Args": {
                "anchor": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "positive": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "negative": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "distance_function": {
                  "Type": "typing.Optional[typing.Callable[[torch.Tensor, torch.Tensor], torch.Tensor]]",
                  "Default": "None"
                },
                "margin": {
                  "Type": "<class 'float'>",
                  "Default": "1.0"
                },
                "swap": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                },
                "reduction": {
                  "Type": "<class 'str'>",
                  "Default": "mean"
                }
              }
            },
            "unfold": {
              "Doc": "Extracts sliding local blocks from a batched input tensor.\n\n    .. warning::\n        Currently, only 4-D input tensors (batched image-like tensors) are\n        supported.\n\n    .. warning::\n\n        More than one element of the unfolded tensor may refer to a single\n        memory location. As a result, in-place operations (especially ones that\n        are vectorized) may result in incorrect behavior. If you need to write\n        to the tensor, please clone it first.\n\n\n    See :class:`torch.nn.Unfold` for details\n    ",
              "Args": {
                "input": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "kernel_size": {
                  "Type": "None",
                  "Default": null
                },
                "dilation": {
                  "Type": "None",
                  "Default": "1"
                },
                "padding": {
                  "Type": "None",
                  "Default": "0"
                },
                "stride": {
                  "Type": "None",
                  "Default": "1"
                }
              }
            },
            "upsample": {
              "Doc": "Upsamples the input to either the given :attr:`size` or the given\n    :attr:`scale_factor`\n\n    .. warning::\n        This function is deprecated in favor of :func:`torch.nn.functional.interpolate`.\n        This is equivalent with ``nn.functional.interpolate(...)``.\n\n    Note:\n        This operation may produce nondeterministic gradients when given tensors on a CUDA device. See :doc:`/notes/randomness` for more information.\n\n    The algorithm used for upsampling is determined by :attr:`mode`.\n\n    Currently temporal, spatial and volumetric upsampling are supported, i.e.\n    expected inputs are 3-D, 4-D or 5-D in shape.\n\n    The input dimensions are interpreted in the form:\n    `mini-batch x channels x [optional depth] x [optional height] x width`.\n\n    The modes available for upsampling are: `nearest`, `linear` (3D-only),\n    `bilinear`, `bicubic` (4D-only), `trilinear` (5D-only)\n\n    Args:\n        input (Tensor): the input tensor\n        size (int or Tuple[int] or Tuple[int, int] or Tuple[int, int, int]):\n            output spatial size.\n        scale_factor (float or Tuple[float]): multiplier for spatial size. Has to match input size if it is a tuple.\n        mode (str): algorithm used for upsampling:\n            ``'nearest'`` | ``'linear'`` | ``'bilinear'`` | ``'bicubic'`` |\n            ``'trilinear'``. Default: ``'nearest'``\n        align_corners (bool, optional): Geometrically, we consider the pixels of the\n            input and output as squares rather than points.\n            If set to ``True``, the input and output tensors are aligned by the\n            center points of their corner pixels, preserving the values at the corner pixels.\n            If set to ``False``, the input and output tensors are aligned by the corner\n            points of their corner pixels, and the interpolation uses edge value padding\n            for out-of-boundary values, making this operation *independent* of input size\n            when :attr:`scale_factor` is kept the same. This only has an effect when :attr:`mode`\n            is ``'linear'``, ``'bilinear'``, ``'bicubic'`` or ``'trilinear'``.\n            Default: ``False``\n\n    .. note::\n        With ``mode='bicubic'``, it's possible to cause overshoot, in other words it can produce\n        negative values or values greater than 255 for images.\n        Explicitly call ``result.clamp(min=0, max=255)`` if you want to reduce the overshoot\n        when displaying the image.\n\n    .. warning::\n        With ``align_corners = True``, the linearly interpolating modes\n        (`linear`, `bilinear`, and `trilinear`) don't proportionally align the\n        output and input pixels, and thus the output values can depend on the\n        input size. This was the default behavior for these modes up to version\n        0.3.1. Since then, the default behavior is ``align_corners = False``.\n        See :class:`~torch.nn.Upsample` for concrete examples on how this\n        affects the outputs.\n\n    ",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "size": {
                  "Type": null,
                  "Default": "None"
                },
                "scale_factor": {
                  "Type": null,
                  "Default": "None"
                },
                "mode": {
                  "Type": null,
                  "Default": "nearest"
                },
                "align_corners": {
                  "Type": null,
                  "Default": "None"
                }
              }
            },
            "upsample_bilinear": {
              "Doc": "Upsamples the input, using bilinear upsampling.\n\n    .. warning::\n        This function is deprecated in favor of :func:`torch.nn.functional.interpolate`.\n        This is equivalent with\n        ``nn.functional.interpolate(..., mode='bilinear', align_corners=True)``.\n\n    Expected inputs are spatial (4 dimensional). Use `upsample_trilinear` fo\n    volumetric (5 dimensional) inputs.\n\n    Args:\n        input (Tensor): input\n        size (int or Tuple[int, int]): output spatial size.\n        scale_factor (int or Tuple[int, int]): multiplier for spatial size\n\n    Note:\n        This operation may produce nondeterministic gradients when given tensors on a CUDA device. See :doc:`/notes/randomness` for more information.\n    ",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "size": {
                  "Type": null,
                  "Default": "None"
                },
                "scale_factor": {
                  "Type": null,
                  "Default": "None"
                }
              }
            },
            "upsample_nearest": {
              "Doc": "Upsamples the input, using nearest neighbours' pixel values.\n\n    .. warning::\n        This function is deprecated in favor of :func:`torch.nn.functional.interpolate`.\n        This is equivalent with ``nn.functional.interpolate(..., mode='nearest')``.\n\n    Currently spatial and volumetric upsampling are supported (i.e. expected\n    inputs are 4 or 5 dimensional).\n\n    Args:\n        input (Tensor): input\n        size (int or Tuple[int, int] or Tuple[int, int, int]): output spatia\n            size.\n        scale_factor (int): multiplier for spatial size. Has to be an integer.\n\n    Note:\n        This operation may produce nondeterministic gradients when given tensors on a CUDA device. See :doc:`/notes/randomness` for more information.\n    ",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "size": {
                  "Type": null,
                  "Default": "None"
                },
                "scale_factor": {
                  "Type": null,
                  "Default": "None"
                }
              }
            }
          }
        },
        "grad": {
          "Doc": "Gradient interface",
          "Functions": {
            "conv1d_input": {
              "Doc": "\n    Computes the gradient of conv1d with respect to the input of the convolution.\n    This is same as the 1D transposed convolution operator under the hood but requires\n    the shape of the gradient w.r.t. input to be specified explicitly.\n\n    Args:\n        input_size : Shape of the input gradient tensor\n        weight: weight tensor (out_channels x in_channels/groups x kW)\n        grad_output : output gradient tensor (minibatch x out_channels x oW)\n        stride (int or tuple, optional): Stride of the convolution. Default: 1\n        padding (int or tuple, optional): Zero-padding added to both sides of the input. Default: 0\n        dilation (int or tuple, optional): Spacing between kernel elements. Default: 1\n        groups (int, optional): Number of blocked connections from input channels to output channels. Default: 1\n\n    Examples::\n\n        >>> input = torch.randn(1,1,3, requires_grad=True)\n        >>> weight = torch.randn(1,1,1, requires_grad=True)\n        >>> output = F.conv1d(input, weight)\n        >>> grad_output = torch.randn(output.shape)\n        >>> grad_input = torch.autograd.grad(output, input, grad_output)\n        >>> F.grad.conv1d_input(input.shape, weight, grad_output)\n\n    ",
              "Args": {
                "input_size": {
                  "Type": null,
                  "Default": null
                },
                "weight": {
                  "Type": null,
                  "Default": null
                },
                "grad_output": {
                  "Type": null,
                  "Default": null
                },
                "stride": {
                  "Type": null,
                  "Default": "1"
                },
                "padding": {
                  "Type": null,
                  "Default": "0"
                },
                "dilation": {
                  "Type": null,
                  "Default": "1"
                },
                "groups": {
                  "Type": null,
                  "Default": "1"
                }
              }
            },
            "conv1d_weight": {
              "Doc": "\n    Computes the gradient of conv1d with respect to the weight of the convolution.\n\n    Args:\n        input: input tensor of shape (minibatch x in_channels x iW)\n        weight_size : Shape of the weight gradient tensor\n        grad_output : output gradient tensor (minibatch x out_channels x oW)\n        stride (int or tuple, optional): Stride of the convolution. Default: 1\n        padding (int or tuple, optional): Zero-padding added to both sides of the input. Default: 0\n        dilation (int or tuple, optional): Spacing between kernel elements. Default: 1\n        groups (int, optional): Number of blocked connections from input channels to output channels. Default: 1\n\n    Examples::\n\n        >>> input = torch.randn(1,1,3, requires_grad=True)\n        >>> weight = torch.randn(1,1,1, requires_grad=True)\n        >>> output = F.conv1d(input, weight)\n        >>> grad_output = torch.randn(output.shape)\n        >>> # xdoctest: +SKIP\n        >>> grad_weight = torch.autograd.grad(output, filter, grad_output)\n        >>> F.grad.conv1d_weight(input, weight.shape, grad_output)\n\n    ",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "weight_size": {
                  "Type": null,
                  "Default": null
                },
                "grad_output": {
                  "Type": null,
                  "Default": null
                },
                "stride": {
                  "Type": null,
                  "Default": "1"
                },
                "padding": {
                  "Type": null,
                  "Default": "0"
                },
                "dilation": {
                  "Type": null,
                  "Default": "1"
                },
                "groups": {
                  "Type": null,
                  "Default": "1"
                }
              }
            },
            "conv2d_input": {
              "Doc": "\n    Computes the gradient of conv2d with respect to the input of the convolution.\n    This is same as the 2D transposed convolution operator under the hood but requires\n    the shape of the gradient w.r.t. input to be specified explicitly.\n\n    Args:\n        input_size : Shape of the input gradient tensor\n        weight: weight tensor (out_channels x in_channels/groups x kH x kW)\n        grad_output : output gradient tensor (minibatch x out_channels x oH x oW)\n        stride (int or tuple, optional): Stride of the convolution. Default: 1\n        padding (int or tuple, optional): Zero-padding added to both sides of the input. Default: 0\n        dilation (int or tuple, optional): Spacing between kernel elements. Default: 1\n        groups (int, optional): Number of blocked connections from input channels to output channels. Default: 1\n\n    Examples::\n\n        >>> input = torch.randn(1,1,3,3, requires_grad=True)\n        >>> weight = torch.randn(1,1,1,2, requires_grad=True)\n        >>> output = F.conv2d(input, weight)\n        >>> grad_output = torch.randn(output.shape)\n        >>> grad_input = torch.autograd.grad(output, input, grad_output)\n        >>> F.grad.conv2d_input(input.shape, weight, grad_output)\n\n    ",
              "Args": {
                "input_size": {
                  "Type": null,
                  "Default": null
                },
                "weight": {
                  "Type": null,
                  "Default": null
                },
                "grad_output": {
                  "Type": null,
                  "Default": null
                },
                "stride": {
                  "Type": null,
                  "Default": "1"
                },
                "padding": {
                  "Type": null,
                  "Default": "0"
                },
                "dilation": {
                  "Type": null,
                  "Default": "1"
                },
                "groups": {
                  "Type": null,
                  "Default": "1"
                }
              }
            },
            "conv2d_weight": {
              "Doc": "\n    Computes the gradient of conv2d with respect to the weight of the convolution.\n\n    Args:\n        input: input tensor of shape (minibatch x in_channels x iH x iW)\n        weight_size : Shape of the weight gradient tensor\n        grad_output : output gradient tensor (minibatch x out_channels x oH x oW)\n        stride (int or tuple, optional): Stride of the convolution. Default: 1\n        padding (int or tuple, optional): Zero-padding added to both sides of the input. Default: 0\n        dilation (int or tuple, optional): Spacing between kernel elements. Default: 1\n        groups (int, optional): Number of blocked connections from input channels to output channels. Default: 1\n\n    Examples::\n\n        >>> input = torch.randn(1,1,3,3, requires_grad=True)\n        >>> weight = torch.randn(1,1,1,2, requires_grad=True)\n        >>> output = F.conv2d(input, weight)\n        >>> grad_output = torch.randn(output.shape)\n        >>> # xdoctest: +SKIP\n        >>> grad_weight = torch.autograd.grad(output, filter, grad_output)\n        >>> F.grad.conv2d_weight(input, weight.shape, grad_output)\n\n    ",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "weight_size": {
                  "Type": null,
                  "Default": null
                },
                "grad_output": {
                  "Type": null,
                  "Default": null
                },
                "stride": {
                  "Type": null,
                  "Default": "1"
                },
                "padding": {
                  "Type": null,
                  "Default": "0"
                },
                "dilation": {
                  "Type": null,
                  "Default": "1"
                },
                "groups": {
                  "Type": null,
                  "Default": "1"
                }
              }
            },
            "conv3d_input": {
              "Doc": "\n    Computes the gradient of conv3d with respect to the input of the convolution.\n    This is same as the 3D transposed convolution operator under the hood but requires\n    the shape of the gradient w.r.t. input to be specified explicitly.\n\n    Args:\n        input_size : Shape of the input gradient tensor\n        weight: weights tensor (out_channels x in_channels/groups x kT x kH x kW)\n        grad_output : output gradient tensor (minibatch x out_channels x oT x oH x oW)\n        stride (int or tuple, optional): Stride of the convolution. Default: 1\n        padding (int or tuple, optional): Zero-padding added to both sides of the input. Default: 0\n        dilation (int or tuple, optional): Spacing between kernel elements. Default: 1\n        groups (int, optional): Number of blocked connections from input channels to output channels. Default: 1\n\n    Examples::\n\n        >>> input = torch.randn(2, 8, 10, 10, 20, requires_grad=True)\n        >>> weight = torch.randn(4, 8, 2, 3, 3, requires_grad=True)\n        >>> output = F.conv3d(input, weight)\n        >>> grad_output = torch.randn(output.shape)\n        >>> grad_input = torch.autograd.grad(output, input, grad_output)\n        >>> F.grad.conv3d_input(input.shape, weight, grad_output)\n\n    ",
              "Args": {
                "input_size": {
                  "Type": null,
                  "Default": null
                },
                "weight": {
                  "Type": null,
                  "Default": null
                },
                "grad_output": {
                  "Type": null,
                  "Default": null
                },
                "stride": {
                  "Type": null,
                  "Default": "1"
                },
                "padding": {
                  "Type": null,
                  "Default": "0"
                },
                "dilation": {
                  "Type": null,
                  "Default": "1"
                },
                "groups": {
                  "Type": null,
                  "Default": "1"
                }
              }
            },
            "conv3d_weight": {
              "Doc": "\n    Computes the gradient of conv3d with respect to the weight of the convolution.\n\n    Args:\n        input: input tensor of shape (minibatch x in_channels x iT x iH x iW)\n        weight_size : Shape of the weight gradient tensor\n        grad_output : output gradient tensor (minibatch x out_channels x oT x oH x oW)\n        stride (int or tuple, optional): Stride of the convolution. Default: 1\n        padding (int or tuple, optional): Zero-padding added to both sides of the input. Default: 0\n        dilation (int or tuple, optional): Spacing between kernel elements. Default: 1\n        groups (int, optional): Number of blocked connections from input channels to output channels. Default: 1\n\n    Examples::\n\n        >>> input = torch.randn(2, 8, 10, 10, 20, requires_grad=True)\n        >>> weight = torch.randn(4, 8, 2, 3, 3, requires_grad=True)\n        >>> output = F.conv3d(input, weight)\n        >>> grad_output = torch.randn(output.shape)\n        >>> grad_weight = torch.autograd.grad(output, weight, grad_output)\n        >>> F.grad.conv3d_weight(input, weight.shape, grad_output)\n\n    ",
              "Args": {
                "input": {
                  "Type": null,
                  "Default": null
                },
                "weight_size": {
                  "Type": null,
                  "Default": null
                },
                "grad_output": {
                  "Type": null,
                  "Default": null
                },
                "stride": {
                  "Type": null,
                  "Default": "1"
                },
                "padding": {
                  "Type": null,
                  "Default": "0"
                },
                "dilation": {
                  "Type": null,
                  "Default": "1"
                },
                "groups": {
                  "Type": null,
                  "Default": "1"
                }
              }
            }
          }
        },
        "init": {
          "Doc": null,
          "Functions": {
            "calculate_gain": {
              "Doc": "Return the recommended gain value for the given nonlinearity function.\n    The values are as follows:\n\n    ================= ====================================================\n    nonlinearity      gain\n    ================= ====================================================\n    Linear / Identity :math:`1`\n    Conv{1,2,3}D      :math:`1`\n    Sigmoid           :math:`1`\n    Tanh              :math:`\\frac{5}{3}`\n    ReLU              :math:`\\sqrt{2}`\n    Leaky Relu        :math:`\\sqrt{\\frac{2}{1 + \\text{negative\\_slope}^2}}`\n    SELU              :math:`\\frac{3}{4}`\n    ================= ====================================================\n\n    .. warning::\n        In order to implement `Self-Normalizing Neural Networks`_ ,\n        you should use ``nonlinearity='linear'`` instead of ``nonlinearity='selu'``.\n        This gives the initial weights a variance of ``1 / N``,\n        which is necessary to induce a stable fixed point in the forward pass.\n        In contrast, the default gain for ``SELU`` sacrifices the normalisation\n        effect for more stable gradient flow in rectangular layers.\n\n    Args:\n        nonlinearity: the non-linear function (`nn.functional` name)\n        param: optional parameter for the non-linear function\n\n    Examples:\n        >>> gain = nn.init.calculate_gain('leaky_relu', 0.2)  # leaky_relu with negative_slope=0.2\n\n    .. _Self-Normalizing Neural Networks: https://papers.nips.cc/paper/2017/hash/5d44ee6f2c3f71b73125876103c8f6c4-Abstract.html\n    ",
              "Args": {
                "nonlinearity": {
                  "Type": null,
                  "Default": null
                },
                "param": {
                  "Type": null,
                  "Default": "None"
                }
              }
            }
          }
        },
        "modules": {
          "Doc": null,
          "Modules": {
            "activation": {
              "Doc": null,
              "Classes": {
                "CELU": {
                  "Doc": "Applies the element-wise function:\n\n    .. math::\n        \\text{CELU}(x) = \\max(0,x) + \\min(0, \\alpha * (\\exp(x/\\alpha) - 1))\n\n    More details can be found in the paper `Continuously Differentiable Exponential Linear Units`_ .\n\n    Args:\n        alpha: the :math:`\\alpha` value for the CELU formulation. Default: 1.0\n        inplace: can optionally do the operation in-place. Default: ``False``\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    .. image:: ../scripts/activation_images/CELU.png\n\n    Examples::\n\n        >>> m = nn.CELU()\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n\n    .. _`Continuously Differentiable Exponential Linear Units`:\n        https://arxiv.org/abs/1704.07483\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "alpha": {
                          "Type": "<class 'float'>",
                          "Default": "1.0"
                        },
                        "inplace": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "ELU": {
                  "Doc": "Applies the Exponential Linear Unit (ELU) function, element-wise, as described\n    in the paper: `Fast and Accurate Deep Network Learning by Exponential Linear\n    Units (ELUs) <https://arxiv.org/abs/1511.07289>`__.\n\n    ELU is defined as:\n\n    .. math::\n        \\text{ELU}(x) = \\begin{cases}\n        x, & \\text{ if } x > 0\\\\\n        \\alpha * (\\exp(x) - 1), & \\text{ if } x \\leq 0\n        \\end{cases}\n\n    Args:\n        alpha: the :math:`\\alpha` value for the ELU formulation. Default: 1.0\n        inplace: can optionally do the operation in-place. Default: ``False``\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    .. image:: ../scripts/activation_images/ELU.png\n\n    Examples::\n\n        >>> m = nn.ELU()\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "alpha": {
                          "Type": "<class 'float'>",
                          "Default": "1.0"
                        },
                        "inplace": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "GELU": {
                  "Doc": "Applies the Gaussian Error Linear Units function:\n\n    .. math:: \\text{GELU}(x) = x * \\Phi(x)\n\n    where :math:`\\Phi(x)` is the Cumulative Distribution Function for Gaussian Distribution.\n\n    When the approximate argument is 'tanh', Gelu is estimated with:\n\n    .. math:: \\text{GELU}(x) = 0.5 * x * (1 + \\text{Tanh}(\\sqrt(2 / \\pi) * (x + 0.044715 * x^3)))\n\n    Args:\n        approximate (str, optional): the gelu approximation algorithm to use:\n            ``'none'`` | ``'tanh'``. Default: ``'none'``\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    .. image:: ../scripts/activation_images/GELU.png\n\n    Examples::\n\n        >>> m = nn.GELU()\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "approximate": {
                          "Type": "<class 'str'>",
                          "Default": "none"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "GLU": {
                  "Doc": "Applies the gated linear unit function\n    :math:`{GLU}(a, b)= a \\otimes \\sigma(b)` where :math:`a` is the first half\n    of the input matrices and :math:`b` is the second half.\n\n    Args:\n        dim (int): the dimension on which to split the input. Default: -1\n\n    Shape:\n        - Input: :math:`(\\ast_1, N, \\ast_2)` where `*` means, any number of additional\n          dimensions\n        - Output: :math:`(\\ast_1, M, \\ast_2)` where :math:`M=N/2`\n\n    Examples::\n\n        >>> m = nn.GLU()\n        >>> input = torch.randn(4, 2)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "dim": {
                          "Type": "<class 'int'>",
                          "Default": "-1"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Hardshrink": {
                  "Doc": "Applies the Hard Shrinkage (Hardshrink) function element-wise.\n\n    Hardshrink is defined as:\n\n    .. math::\n        \\text{HardShrink}(x) =\n        \\begin{cases}\n        x, & \\text{ if } x > \\lambda \\\\\n        x, & \\text{ if } x < -\\lambda \\\\\n        0, & \\text{ otherwise }\n        \\end{cases}\n\n    Args:\n        lambd: the :math:`\\lambda` value for the Hardshrink formulation. Default: 0.5\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    .. image:: ../scripts/activation_images/Hardshrink.png\n\n    Examples::\n\n        >>> m = nn.Hardshrink()\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "lambd": {
                          "Type": "<class 'float'>",
                          "Default": "0.5"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Hardsigmoid": {
                  "Doc": "Applies the Hardsigmoid function element-wise.\n\n    Hardsigmoid is defined as:\n\n    .. math::\n        \\text{Hardsigmoid}(x) = \\begin{cases}\n            0 & \\text{if~} x \\le -3, \\\\\n            1 & \\text{if~} x \\ge +3, \\\\\n            x / 6 + 1 / 2 & \\text{otherwise}\n        \\end{cases}\n\n    Args:\n        inplace: can optionally do the operation in-place. Default: ``False``\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    .. image:: ../scripts/activation_images/Hardsigmoid.png\n\n    Examples::\n\n        >>> m = nn.Hardsigmoid()\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "inplace": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Hardswish": {
                  "Doc": "Applies the Hardswish function, element-wise, as described in the paper:\n    `Searching for MobileNetV3 <https://arxiv.org/abs/1905.02244>`_.\n\n    Hardswish is defined as:\n\n    .. math::\n        \\text{Hardswish}(x) = \\begin{cases}\n            0 & \\text{if~} x \\le -3, \\\\\n            x & \\text{if~} x \\ge +3, \\\\\n            x \\cdot (x + 3) /6 & \\text{otherwise}\n        \\end{cases}\n\n    Args:\n        inplace: can optionally do the operation in-place. Default: ``False``\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    .. image:: ../scripts/activation_images/Hardswish.png\n\n    Examples::\n\n        >>> m = nn.Hardswish()\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "inplace": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Hardtanh": {
                  "Doc": "Applies the HardTanh function element-wise.\n\n    HardTanh is defined as:\n\n    .. math::\n        \\text{HardTanh}(x) = \\begin{cases}\n            \\text{max\\_val} & \\text{ if } x > \\text{ max\\_val } \\\\\n            \\text{min\\_val} & \\text{ if } x < \\text{ min\\_val } \\\\\n            x & \\text{ otherwise } \\\\\n        \\end{cases}\n\n    Args:\n        min_val: minimum value of the linear region range. Default: -1\n        max_val: maximum value of the linear region range. Default: 1\n        inplace: can optionally do the operation in-place. Default: ``False``\n\n    Keyword arguments :attr:`min_value` and :attr:`max_value`\n    have been deprecated in favor of :attr:`min_val` and :attr:`max_val`.\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    .. image:: ../scripts/activation_images/Hardtanh.png\n\n    Examples::\n\n        >>> m = nn.Hardtanh(-2, 2)\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "min_val": {
                          "Type": "<class 'float'>",
                          "Default": "-1.0"
                        },
                        "max_val": {
                          "Type": "<class 'float'>",
                          "Default": "1.0"
                        },
                        "inplace": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "min_value": {
                          "Type": "typing.Optional[float]",
                          "Default": "None"
                        },
                        "max_value": {
                          "Type": "typing.Optional[float]",
                          "Default": "None"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "LeakyReLU": {
                  "Doc": "Applies the element-wise function:\n\n    .. math::\n        \\text{LeakyReLU}(x) = \\max(0, x) + \\text{negative\\_slope} * \\min(0, x)\n\n\n    or\n\n    .. math::\n        \\text{LeakyReLU}(x) =\n        \\begin{cases}\n        x, & \\text{ if } x \\geq 0 \\\\\n        \\text{negative\\_slope} \\times x, & \\text{ otherwise }\n        \\end{cases}\n\n    Args:\n        negative_slope: Controls the angle of the negative slope. Default: 1e-2\n        inplace: can optionally do the operation in-place. Default: ``False``\n\n    Shape:\n        - Input: :math:`(*)` where `*` means, any number of additional\n          dimensions\n        - Output: :math:`(*)`, same shape as the input\n\n    .. image:: ../scripts/activation_images/LeakyReLU.png\n\n    Examples::\n\n        >>> m = nn.LeakyReLU(0.1)\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "negative_slope": {
                          "Type": "<class 'float'>",
                          "Default": "0.01"
                        },
                        "inplace": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "LogSigmoid": {
                  "Doc": "Applies the element-wise function:\n\n    .. math::\n        \\text{LogSigmoid}(x) = \\log\\left(\\frac{ 1 }{ 1 + \\exp(-x)}\\right)\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    .. image:: ../scripts/activation_images/LogSigmoid.png\n\n    Examples::\n\n        >>> m = nn.LogSigmoid()\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "LogSoftmax": {
                  "Doc": "Applies the :math:`\\log(\\text{Softmax}(x))` function to an n-dimensional\n    input Tensor. The LogSoftmax formulation can be simplified as:\n\n    .. math::\n        \\text{LogSoftmax}(x_{i}) = \\log\\left(\\frac{\\exp(x_i) }{ \\sum_j \\exp(x_j)} \\right)\n\n    Shape:\n        - Input: :math:`(*)` where `*` means, any number of additional\n          dimensions\n        - Output: :math:`(*)`, same shape as the input\n\n    Args:\n        dim (int): A dimension along which LogSoftmax will be computed.\n\n    Returns:\n        a Tensor of the same dimension and shape as the input with\n        values in the range [-inf, 0)\n\n    Examples::\n\n        >>> m = nn.LogSoftmax(dim=1)\n        >>> input = torch.randn(2, 3)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "dim": {
                          "Type": "typing.Optional[int]",
                          "Default": "None"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Mish": {
                  "Doc": "Applies the Mish function, element-wise.\n    Mish: A Self Regularized Non-Monotonic Neural Activation Function.\n\n    .. math::\n        \\text{Mish}(x) = x * \\text{Tanh}(\\text{Softplus}(x))\n\n    .. note::\n        See `Mish: A Self Regularized Non-Monotonic Neural Activation Function <https://arxiv.org/abs/1908.08681>`_\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    .. image:: ../scripts/activation_images/Mish.png\n\n    Examples::\n\n        >>> m = nn.Mish()\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "inplace": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "MultiheadAttention": {
                  "Doc": "Allows the model to jointly attend to information\n    from different representation subspaces as described in the paper:\n    `Attention Is All You Need <https://arxiv.org/abs/1706.03762>`_.\n\n    Multi-Head Attention is defined as:\n\n    .. math::\n        \\text{MultiHead}(Q, K, V) = \\text{Concat}(head_1,\\dots,head_h)W^O\n\n    where :math:`head_i = \\text{Attention}(QW_i^Q, KW_i^K, VW_i^V)`.\n\n    ``forward()`` will use a special optimized implementation if all of the following\n    conditions are met:\n\n    - self attention is being computed (i.e., ``query``, ``key``, and ``value`` are the same tensor. This\n      restriction will be loosened in the future.)\n    - Either autograd is disabled (using ``torch.inference_mode`` or ``torch.no_grad``) or no tensor argument ``requires_grad``\n    - training is disabled (using ``.eval()``)\n    - dropout is 0\n    - ``add_bias_kv`` is ``False``\n    - ``add_zero_attn`` is ``False``\n    - ``batch_first`` is ``True`` and the input is batched\n    - ``kdim`` and ``vdim`` are equal to ``embed_dim``\n    - at most one of ``key_padding_mask`` or ``attn_mask`` is passed\n    - if a `NestedTensor <https://pytorch.org/docs/stable/nested.html>`_ is passed, neither ``key_padding_mask``\n      nor ``attn_mask`` is passed\n\n    If the optimized implementation is in use, a\n    `NestedTensor <https://pytorch.org/docs/stable/nested.html>`_ can be passed for\n    ``query``/``key``/``value`` to represent padding more efficiently than using a\n    padding mask. In this case, a `NestedTensor <https://pytorch.org/docs/stable/nested.html>`_\n    will be returned, and an additional speedup proportional to the fraction of the input\n    that is padding can be expected.\n\n    Args:\n        embed_dim: Total dimension of the model.\n        num_heads: Number of parallel attention heads. Note that ``embed_dim`` will be split\n            across ``num_heads`` (i.e. each head will have dimension ``embed_dim // num_heads``).\n        dropout: Dropout probability on ``attn_output_weights``. Default: ``0.0`` (no dropout).\n        bias: If specified, adds bias to input / output projection layers. Default: ``True``.\n        add_bias_kv: If specified, adds bias to the key and value sequences at dim=0. Default: ``False``.\n        add_zero_attn: If specified, adds a new batch of zeros to the key and value sequences at dim=1.\n            Default: ``False``.\n        kdim: Total number of features for keys. Default: ``None`` (uses ``kdim=embed_dim``).\n        vdim: Total number of features for values. Default: ``None`` (uses ``vdim=embed_dim``).\n        batch_first: If ``True``, then the input and output tensors are provided\n            as (batch, seq, feature). Default: ``False`` (seq, batch, feature).\n\n    Examples::\n\n        >>> # xdoctest: +SKIP\n        >>> multihead_attn = nn.MultiheadAttention(embed_dim, num_heads)\n        >>> attn_output, attn_output_weights = multihead_attn(query, key, value)\n\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "embed_dim": {
                          "Type": null,
                          "Default": null
                        },
                        "num_heads": {
                          "Type": null,
                          "Default": null
                        },
                        "dropout": {
                          "Type": null,
                          "Default": "0.0"
                        },
                        "bias": {
                          "Type": null,
                          "Default": "True"
                        },
                        "add_bias_kv": {
                          "Type": null,
                          "Default": "False"
                        },
                        "add_zero_attn": {
                          "Type": null,
                          "Default": "False"
                        },
                        "kdim": {
                          "Type": null,
                          "Default": "None"
                        },
                        "vdim": {
                          "Type": null,
                          "Default": "None"
                        },
                        "batch_first": {
                          "Type": null,
                          "Default": "False"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "forward": {
                      "Doc": "\n    Args:\n        query: Query embeddings of shape :math:`(L, E_q)` for unbatched input, :math:`(L, N, E_q)` when ``batch_first=False``\n            or :math:`(N, L, E_q)` when ``batch_first=True``, where :math:`L` is the target sequence length,\n            :math:`N` is the batch size, and :math:`E_q` is the query embedding dimension ``embed_dim``.\n            Queries are compared against key-value pairs to produce the output.\n            See \"Attention Is All You Need\" for more details.\n        key: Key embeddings of shape :math:`(S, E_k)` for unbatched input, :math:`(S, N, E_k)` when ``batch_first=False``\n            or :math:`(N, S, E_k)` when ``batch_first=True``, where :math:`S` is the source sequence length,\n            :math:`N` is the batch size, and :math:`E_k` is the key embedding dimension ``kdim``.\n            See \"Attention Is All You Need\" for more details.\n        value: Value embeddings of shape :math:`(S, E_v)` for unbatched input, :math:`(S, N, E_v)` when\n            ``batch_first=False`` or :math:`(N, S, E_v)` when ``batch_first=True``, where :math:`S` is the source\n            sequence length, :math:`N` is the batch size, and :math:`E_v` is the value embedding dimension ``vdim``.\n            See \"Attention Is All You Need\" for more details.\n        key_padding_mask: If specified, a mask of shape :math:`(N, S)` indicating which elements within ``key``\n            to ignore for the purpose of attention (i.e. treat as \"padding\"). For unbatched `query`, shape should be :math:`(S)`.\n            Binary and byte masks are supported.\n            For a binary mask, a ``True`` value indicates that the corresponding ``key`` value will be ignored for\n            the purpose of attention. For a float mask, it will be directly added to the corresponding ``key`` value.\n        need_weights: If specified, returns ``attn_output_weights`` in addition to ``attn_outputs``.\n            Default: ``True``.\n        attn_mask: If specified, a 2D or 3D mask preventing attention to certain positions. Must be of shape\n            :math:`(L, S)` or :math:`(N\\cdot\\text{num\\_heads}, L, S)`, where :math:`N` is the batch size,\n            :math:`L` is the target sequence length, and :math:`S` is the source sequence length. A 2D mask will be\n            broadcasted across the batch while a 3D mask allows for a different mask for each entry in the batch.\n            Binary, byte, and float masks are supported. For a binary mask, a ``True`` value indicates that the\n            corresponding position is not allowed to attend. For a byte mask, a non-zero value indicates that the\n            corresponding position is not allowed to attend. For a float mask, the mask values will be added to\n            the attention weight.\n        average_attn_weights: If true, indicates that the returned ``attn_weights`` should be averaged across\n            heads. Otherwise, ``attn_weights`` are provided separately per head. Note that this flag only has an\n            effect when ``need_weights=True``. Default: ``True`` (i.e. average weights across heads)\n\n    Outputs:\n        - **attn_output** - Attention outputs of shape :math:`(L, E)` when input is unbatched,\n          :math:`(L, N, E)` when ``batch_first=False`` or :math:`(N, L, E)` when ``batch_first=True``,\n          where :math:`L` is the target sequence length, :math:`N` is the batch size, and :math:`E` is the\n          embedding dimension ``embed_dim``.\n        - **attn_output_weights** - Only returned when ``need_weights=True``. If ``average_attn_weights=True``,\n          returns attention weights averaged across heads of shape :math:`(L, S)` when input is unbatched or\n          :math:`(N, L, S)`, where :math:`N` is the batch size, :math:`L` is the target sequence length, and\n          :math:`S` is the source sequence length. If ``average_attn_weights=False``, returns attention weights per\n          head of shape :math:`(\\text{num\\_heads}, L, S)` when input is unbatched or :math:`(N, \\text{num\\_heads}, L, S)`.\n\n        .. note::\n            `batch_first` argument is ignored for unbatched inputs.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "query": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "key": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "value": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "key_padding_mask": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "need_weights": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "attn_mask": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "average_attn_weights": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        }
                      }
                    }
                  }
                },
                "PReLU": {
                  "Doc": "Applies the element-wise function:\n\n    .. math::\n        \\text{PReLU}(x) = \\max(0,x) + a * \\min(0,x)\n\n    or\n\n    .. math::\n        \\text{PReLU}(x) =\n        \\begin{cases}\n        x, & \\text{ if } x \\geq 0 \\\\\n        ax, & \\text{ otherwise }\n        \\end{cases}\n\n    Here :math:`a` is a learnable parameter. When called without arguments, `nn.PReLU()` uses a single\n    parameter :math:`a` across all input channels. If called with `nn.PReLU(nChannels)`,\n    a separate :math:`a` is used for each input channel.\n\n\n    .. note::\n        weight decay should not be used when learning :math:`a` for good performance.\n\n    .. note::\n        Channel dim is the 2nd dim of input. When input has dims < 2, then there is\n        no channel dim and the number of channels = 1.\n\n    Args:\n        num_parameters (int): number of :math:`a` to learn.\n            Although it takes an int as input, there is only two values are legitimate:\n            1, or the number of channels at input. Default: 1\n        init (float): the initial value of :math:`a`. Default: 0.25\n\n    Shape:\n        - Input: :math:`( *)` where `*` means, any number of additional\n          dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    Attributes:\n        weight (Tensor): the learnable weights of shape (:attr:`num_parameters`).\n\n    .. image:: ../scripts/activation_images/PReLU.png\n\n    Examples::\n\n        >>> m = nn.PReLU()\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "num_parameters": {
                          "Type": "<class 'int'>",
                          "Default": "1"
                        },
                        "init": {
                          "Type": "<class 'float'>",
                          "Default": "0.25"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "RReLU": {
                  "Doc": "Applies the randomized leaky rectified liner unit function, element-wise,\n    as described in the paper:\n\n    `Empirical Evaluation of Rectified Activations in Convolutional Network`_.\n\n    The function is defined as:\n\n    .. math::\n        \\text{RReLU}(x) =\n        \\begin{cases}\n            x & \\text{if } x \\geq 0 \\\\\n            ax & \\text{ otherwise }\n        \\end{cases}\n\n    where :math:`a` is randomly sampled from uniform distribution\n    :math:`\\mathcal{U}(\\text{lower}, \\text{upper})`.\n\n     See: https://arxiv.org/pdf/1505.00853.pdf\n\n    Args:\n        lower: lower bound of the uniform distribution. Default: :math:`\\frac{1}{8}`\n        upper: upper bound of the uniform distribution. Default: :math:`\\frac{1}{3}`\n        inplace: can optionally do the operation in-place. Default: ``False``\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    .. image:: ../scripts/activation_images/RReLU.png\n\n    Examples::\n\n        >>> m = nn.RReLU(0.1, 0.3)\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n\n    .. _`Empirical Evaluation of Rectified Activations in Convolutional Network`:\n        https://arxiv.org/abs/1505.00853\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "lower": {
                          "Type": "<class 'float'>",
                          "Default": "0.125"
                        },
                        "upper": {
                          "Type": "<class 'float'>",
                          "Default": "0.3333333333333333"
                        },
                        "inplace": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "ReLU": {
                  "Doc": "Applies the rectified linear unit function element-wise:\n\n    :math:`\\text{ReLU}(x) = (x)^+ = \\max(0, x)`\n\n    Args:\n        inplace: can optionally do the operation in-place. Default: ``False``\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    .. image:: ../scripts/activation_images/ReLU.png\n\n    Examples::\n\n        >>> m = nn.ReLU()\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n\n\n      An implementation of CReLU - https://arxiv.org/abs/1603.05201\n\n        >>> m = nn.ReLU()\n        >>> input = torch.randn(2).unsqueeze(0)\n        >>> output = torch.cat((m(input),m(-input)))\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "inplace": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "ReLU6": {
                  "Doc": "Applies the element-wise function:\n\n    .. math::\n        \\text{ReLU6}(x) = \\min(\\max(0,x), 6)\n\n    Args:\n        inplace: can optionally do the operation in-place. Default: ``False``\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    .. image:: ../scripts/activation_images/ReLU6.png\n\n    Examples::\n\n        >>> m = nn.ReLU6()\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "inplace": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "SELU": {
                  "Doc": "Applied element-wise, as:\n\n    .. math::\n        \\text{SELU}(x) = \\text{scale} * (\\max(0,x) + \\min(0, \\alpha * (\\exp(x) - 1)))\n\n    with :math:`\\alpha = 1.6732632423543772848170429916717` and\n    :math:`\\text{scale} = 1.0507009873554804934193349852946`.\n\n    .. warning::\n        When using ``kaiming_normal`` or ``kaiming_normal_`` for initialisation,\n        ``nonlinearity='linear'`` should be used instead of ``nonlinearity='selu'``\n        in order to get `Self-Normalizing Neural Networks`_.\n        See :func:`torch.nn.init.calculate_gain` for more information.\n\n    More details can be found in the paper `Self-Normalizing Neural Networks`_ .\n\n    Args:\n        inplace (bool, optional): can optionally do the operation in-place. Default: ``False``\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    .. image:: ../scripts/activation_images/SELU.png\n\n    Examples::\n\n        >>> m = nn.SELU()\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n\n    .. _Self-Normalizing Neural Networks: https://arxiv.org/abs/1706.02515\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "inplace": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "SiLU": {
                  "Doc": "Applies the Sigmoid Linear Unit (SiLU) function, element-wise.\n    The SiLU function is also known as the swish function.\n\n    .. math::\n        \\text{silu}(x) = x * \\sigma(x), \\text{where } \\sigma(x) \\text{ is the logistic sigmoid.}\n\n    .. note::\n        See `Gaussian Error Linear Units (GELUs) <https://arxiv.org/abs/1606.08415>`_\n        where the SiLU (Sigmoid Linear Unit) was originally coined, and see\n        `Sigmoid-Weighted Linear Units for Neural Network Function Approximation\n        in Reinforcement Learning <https://arxiv.org/abs/1702.03118>`_ and `Swish:\n        a Self-Gated Activation Function <https://arxiv.org/abs/1710.05941v1>`_\n        where the SiLU was experimented with later.\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    .. image:: ../scripts/activation_images/SiLU.png\n\n    Examples::\n\n        >>> m = nn.SiLU()\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "inplace": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Sigmoid": {
                  "Doc": "Applies the element-wise function:\n\n    .. math::\n        \\text{Sigmoid}(x) = \\sigma(x) = \\frac{1}{1 + \\exp(-x)}\n\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    .. image:: ../scripts/activation_images/Sigmoid.png\n\n    Examples::\n\n        >>> m = nn.Sigmoid()\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Softmax": {
                  "Doc": "Applies the Softmax function to an n-dimensional input Tensor\n    rescaling them so that the elements of the n-dimensional output Tensor\n    lie in the range [0,1] and sum to 1.\n\n    Softmax is defined as:\n\n    .. math::\n        \\text{Softmax}(x_{i}) = \\frac{\\exp(x_i)}{\\sum_j \\exp(x_j)}\n\n    When the input Tensor is a sparse tensor then the unspecifed\n    values are treated as ``-inf``.\n\n    Shape:\n        - Input: :math:`(*)` where `*` means, any number of additional\n          dimensions\n        - Output: :math:`(*)`, same shape as the input\n\n    Returns:\n        a Tensor of the same dimension and shape as the input with\n        values in the range [0, 1]\n\n    Args:\n        dim (int): A dimension along which Softmax will be computed (so every slice\n            along dim will sum to 1).\n\n    .. note::\n        This module doesn't work directly with NLLLoss,\n        which expects the Log to be computed between the Softmax and itself.\n        Use `LogSoftmax` instead (it's faster and has better numerical properties).\n\n    Examples::\n\n        >>> m = nn.Softmax(dim=1)\n        >>> input = torch.randn(2, 3)\n        >>> output = m(input)\n\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "dim": {
                          "Type": "typing.Optional[int]",
                          "Default": "None"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Softmax2d": {
                  "Doc": "Applies SoftMax over features to each spatial location.\n\n    When given an image of ``Channels x Height x Width``, it will\n    apply `Softmax` to each location :math:`(Channels, h_i, w_j)`\n\n    Shape:\n        - Input: :math:`(N, C, H, W)` or :math:`(C, H, W)`.\n        - Output: :math:`(N, C, H, W)` or :math:`(C, H, W)` (same shape as input)\n\n    Returns:\n        a Tensor of the same dimension and shape as the input with\n        values in the range [0, 1]\n\n    Examples::\n\n        >>> m = nn.Softmax2d()\n        >>> # you softmax over the 2nd dimension\n        >>> input = torch.randn(2, 3, 12, 13)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Softmin": {
                  "Doc": "Applies the Softmin function to an n-dimensional input Tensor\n    rescaling them so that the elements of the n-dimensional output Tensor\n    lie in the range `[0, 1]` and sum to 1.\n\n    Softmin is defined as:\n\n    .. math::\n        \\text{Softmin}(x_{i}) = \\frac{\\exp(-x_i)}{\\sum_j \\exp(-x_j)}\n\n    Shape:\n        - Input: :math:`(*)` where `*` means, any number of additional\n          dimensions\n        - Output: :math:`(*)`, same shape as the input\n\n    Args:\n        dim (int): A dimension along which Softmin will be computed (so every slice\n            along dim will sum to 1).\n\n    Returns:\n        a Tensor of the same dimension and shape as the input, with\n        values in the range [0, 1]\n\n    Examples::\n\n        >>> m = nn.Softmin(dim=1)\n        >>> input = torch.randn(2, 3)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "dim": {
                          "Type": "typing.Optional[int]",
                          "Default": "None"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Softplus": {
                  "Doc": "Applies the Softplus function :math:`\\text{Softplus}(x) = \\frac{1}{\\beta} *\n    \\log(1 + \\exp(\\beta * x))` element-wise.\n\n    SoftPlus is a smooth approximation to the ReLU function and can be used\n    to constrain the output of a machine to always be positive.\n\n    For numerical stability the implementation reverts to the linear function\n    when :math:`input \\times \\beta > threshold`.\n\n    Args:\n        beta: the :math:`\\beta` value for the Softplus formulation. Default: 1\n        threshold: values above this revert to a linear function. Default: 20\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    .. image:: ../scripts/activation_images/Softplus.png\n\n    Examples::\n\n        >>> m = nn.Softplus()\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "beta": {
                          "Type": "<class 'int'>",
                          "Default": "1"
                        },
                        "threshold": {
                          "Type": "<class 'int'>",
                          "Default": "20"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Softshrink": {
                  "Doc": "Applies the soft shrinkage function elementwise:\n\n    .. math::\n        \\text{SoftShrinkage}(x) =\n        \\begin{cases}\n        x - \\lambda, & \\text{ if } x > \\lambda \\\\\n        x + \\lambda, & \\text{ if } x < -\\lambda \\\\\n        0, & \\text{ otherwise }\n        \\end{cases}\n\n    Args:\n        lambd: the :math:`\\lambda` (must be no less than zero) value for the Softshrink formulation. Default: 0.5\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    .. image:: ../scripts/activation_images/Softshrink.png\n\n    Examples::\n\n        >>> m = nn.Softshrink()\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "lambd": {
                          "Type": "<class 'float'>",
                          "Default": "0.5"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Softsign": {
                  "Doc": "Applies the element-wise function:\n\n    .. math::\n        \\text{SoftSign}(x) = \\frac{x}{ 1 + |x|}\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    .. image:: ../scripts/activation_images/Softsign.png\n\n    Examples::\n\n        >>> m = nn.Softsign()\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Tanh": {
                  "Doc": "Applies the Hyperbolic Tangent (Tanh) function element-wise.\n\n    Tanh is defined as:\n\n    .. math::\n        \\text{Tanh}(x) = \\tanh(x) = \\frac{\\exp(x) - \\exp(-x)} {\\exp(x) + \\exp(-x)}\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    .. image:: ../scripts/activation_images/Tanh.png\n\n    Examples::\n\n        >>> m = nn.Tanh()\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Tanhshrink": {
                  "Doc": "Applies the element-wise function:\n\n    .. math::\n        \\text{Tanhshrink}(x) = x - \\tanh(x)\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    .. image:: ../scripts/activation_images/Tanhshrink.png\n\n    Examples::\n\n        >>> m = nn.Tanhshrink()\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Threshold": {
                  "Doc": "Thresholds each element of the input Tensor.\n\n    Threshold is defined as:\n\n    .. math::\n        y =\n        \\begin{cases}\n        x, &\\text{ if } x > \\text{threshold} \\\\\n        \\text{value}, &\\text{ otherwise }\n        \\end{cases}\n\n    Args:\n        threshold: The value to threshold at\n        value: The value to replace with\n        inplace: can optionally do the operation in-place. Default: ``False``\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    Examples::\n\n        >>> m = nn.Threshold(0.1, 20)\n        >>> input = torch.randn(2)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "threshold": {
                          "Type": "<class 'float'>",
                          "Default": null
                        },
                        "value": {
                          "Type": "<class 'float'>",
                          "Default": null
                        },
                        "inplace": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                }
              }
            },
            "adaptive": {
              "Doc": null,
              "Classes": {
                "AdaptiveLogSoftmaxWithLoss": {
                  "Doc": "Efficient softmax approximation as described in\n    `Efficient softmax approximation for GPUs by Edouard Grave, Armand Joulin,\n    Moustapha Ciss\u00e9, David Grangier, and Herv\u00e9 J\u00e9gou\n    <https://arxiv.org/abs/1609.04309>`__.\n\n    Adaptive softmax is an approximate strategy for training models with large\n    output spaces. It is most effective when the label distribution is highly\n    imbalanced, for example in natural language modelling, where the word\n    frequency distribution approximately follows the `Zipf's law`_.\n\n    Adaptive softmax partitions the labels into several clusters, according to\n    their frequency. These clusters may contain different number of targets\n    each.\n    Additionally, clusters containing less frequent labels assign lower\n    dimensional embeddings to those labels, which speeds up the computation.\n    For each minibatch, only clusters for which at least one target is\n    present are evaluated.\n\n    The idea is that the clusters which are accessed frequently\n    (like the first one, containing most frequent labels), should also be cheap\n    to compute -- that is, contain a small number of assigned labels.\n\n    We highly recommend taking a look at the original paper for more details.\n\n    * :attr:`cutoffs` should be an ordered Sequence of integers sorted\n      in the increasing order.\n      It controls number of clusters and the partitioning of targets into\n      clusters. For example setting ``cutoffs = [10, 100, 1000]``\n      means that first `10` targets will be assigned\n      to the 'head' of the adaptive softmax, targets `11, 12, ..., 100` will be\n      assigned to the first cluster, and targets `101, 102, ..., 1000` will be\n      assigned to the second cluster, while targets\n      `1001, 1002, ..., n_classes - 1` will be assigned\n      to the last, third cluster.\n\n    * :attr:`div_value` is used to compute the size of each additional cluster,\n      which is given as\n      :math:`\\left\\lfloor\\frac{\\texttt{in\\_features}}{\\texttt{div\\_value}^{idx}}\\right\\rfloor`,\n      where :math:`idx` is the cluster index (with clusters\n      for less frequent words having larger indices,\n      and indices starting from :math:`1`).\n\n    * :attr:`head_bias` if set to True, adds a bias term to the 'head' of the\n      adaptive softmax. See paper for details. Set to False in the official\n      implementation.\n\n    .. warning::\n        Labels passed as inputs to this module should be sorted according to\n        their frequency. This means that the most frequent label should be\n        represented by the index `0`, and the least frequent\n        label should be represented by the index `n_classes - 1`.\n\n    .. note::\n        This module returns a ``NamedTuple`` with ``output``\n        and ``loss`` fields. See further documentation for details.\n\n    .. note::\n        To compute log-probabilities for all classes, the ``log_prob``\n        method can be used.\n\n    Args:\n        in_features (int): Number of features in the input tensor\n        n_classes (int): Number of classes in the dataset\n        cutoffs (Sequence): Cutoffs used to assign targets to their buckets\n        div_value (float, optional): value used as an exponent to compute sizes\n            of the clusters. Default: 4.0\n        head_bias (bool, optional): If ``True``, adds a bias term to the 'head' of the\n            adaptive softmax. Default: ``False``\n\n    Returns:\n        ``NamedTuple`` with ``output`` and ``loss`` fields:\n            * **output** is a Tensor of size ``N`` containing computed target\n              log probabilities for each example\n            * **loss** is a Scalar representing the computed negative\n              log likelihood loss\n\n    Shape:\n        - input: :math:`(N, \\texttt{in\\_features})` or :math:`(\\texttt{in\\_features})`\n        - target: :math:`(N)` or :math:`()` where each value satisfies :math:`0 <= \\texttt{target[i]} <= \\texttt{n\\_classes}`\n        - output1: :math:`(N)` or :math:`()`\n        - output2: ``Scalar``\n\n    .. _Zipf's law: https://en.wikipedia.org/wiki/Zipf%27s_law\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "in_features": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "n_classes": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "cutoffs": {
                          "Type": "typing.Sequence[int]",
                          "Default": null
                        },
                        "div_value": {
                          "Type": "<class 'float'>",
                          "Default": "4.0"
                        },
                        "head_bias": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input_": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "target_": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    },
                    "log_prob": {
                      "Doc": " Computes log probabilities for all :math:`\\texttt{n\\_classes}`\n\n        Args:\n            input (Tensor): a minibatch of examples\n\n        Returns:\n            log-probabilities of for each class :math:`c`\n            in range :math:`0 <= c <= \\texttt{n\\_classes}`, where :math:`\\texttt{n\\_classes}` is a\n            parameter passed to ``AdaptiveLogSoftmaxWithLoss`` constructor.\n\n        Shape:\n            - Input: :math:`(N, \\texttt{in\\_features})`\n            - Output: :math:`(N, \\texttt{n\\_classes})`\n\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    },
                    "predict": {
                      "Doc": " This is equivalent to `self.log_prob(input).argmax(dim=1)`,\n        but is more efficient in some cases.\n\n        Args:\n            input (Tensor): a minibatch of examples\n\n        Returns:\n            output (Tensor): a class with the highest probability for each example\n\n        Shape:\n            - Input: :math:`(N, \\texttt{in\\_features})`\n            - Output: :math:`(N)`\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    },
                    "reset_parameters": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    }
                  }
                }
              },
              "Functions": {
                "log_softmax": {
                  "Doc": "Applies a softmax followed by a logarithm.\n\n    While mathematically equivalent to log(softmax(x)), doing these two\n    operations separately is slower and numerically unstable. This function\n    uses an alternative formulation to compute the output and gradient correctly.\n\n    See :class:`~torch.nn.LogSoftmax` for more details.\n\n    Args:\n        input (Tensor): input\n        dim (int): A dimension along which log_softmax will be computed.\n        dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.\n          If specified, the input tensor is cast to :attr:`dtype` before the operation\n          is performed. This is useful for preventing data type overflows. Default: None.\n    ",
                  "Args": {
                    "input": {
                      "Type": "<class 'torch.Tensor'>",
                      "Default": null
                    },
                    "dim": {
                      "Type": "typing.Optional[int]",
                      "Default": "None"
                    },
                    "_stacklevel": {
                      "Type": "<class 'int'>",
                      "Default": "3"
                    },
                    "dtype": {
                      "Type": "typing.Optional[int]",
                      "Default": "None"
                    }
                  }
                },
                "namedtuple": {
                  "Doc": "Returns a new subclass of tuple with named fields.\n\n    >>> Point = namedtuple('Point', ['x', 'y'])\n    >>> Point.__doc__                   # docstring for the new class\n    'Point(x, y)'\n    >>> p = Point(11, y=22)             # instantiate with positional args or keywords\n    >>> p[0] + p[1]                     # indexable like a plain tuple\n    33\n    >>> x, y = p                        # unpack like a regular tuple\n    >>> x, y\n    (11, 22)\n    >>> p.x + p.y                       # fields also accessible by name\n    33\n    >>> d = p._asdict()                 # convert to a dictionary\n    >>> d['x']\n    11\n    >>> Point(**d)                      # convert from a dictionary\n    Point(x=11, y=22)\n    >>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\n    Point(x=100, y=22)\n\n    ",
                  "Args": {
                    "typename": {
                      "Type": null,
                      "Default": null
                    },
                    "field_names": {
                      "Type": null,
                      "Default": null
                    },
                    "rename": {
                      "Type": null,
                      "Default": "False"
                    },
                    "defaults": {
                      "Type": null,
                      "Default": "None"
                    },
                    "module": {
                      "Type": null,
                      "Default": "None"
                    }
                  }
                }
              }
            },
            "batchnorm": {
              "Doc": null,
              "Classes": {
                "BatchNorm1d": {
                  "Doc": "Applies Batch Normalization over a 2D or 3D input as described in the paper\n    `Batch Normalization: Accelerating Deep Network Training by Reducing\n    Internal Covariate Shift <https://arxiv.org/abs/1502.03167>`__ .\n\n    .. math::\n\n        y = \\frac{x - \\mathrm{E}[x]}{\\sqrt{\\mathrm{Var}[x] + \\epsilon}} * \\gamma + \\beta\n\n    The mean and standard-deviation are calculated per-dimension over\n    the mini-batches and :math:`\\gamma` and :math:`\\beta` are learnable parameter vectors\n    of size `C` (where `C` is the number of features or channels of the input). By default, the\n    elements of :math:`\\gamma` are set to 1 and the elements of :math:`\\beta` are set to 0. The\n    standard-deviation is calculated via the biased estimator, equivalent to `torch.var(input, unbiased=False)`.\n\n    Also by default, during training this layer keeps running estimates of its\n    computed mean and variance, which are then used for normalization during\n    evaluation. The running estimates are kept with a default :attr:`momentum`\n    of 0.1.\n\n    If :attr:`track_running_stats` is set to ``False``, this layer then does not\n    keep running estimates, and batch statistics are instead used during\n    evaluation time as well.\n\n    .. note::\n        This :attr:`momentum` argument is different from one used in optimizer\n        classes and the conventional notion of momentum. Mathematically, the\n        update rule for running statistics here is\n        :math:`\\hat{x}_\\text{new} = (1 - \\text{momentum}) \\times \\hat{x} + \\text{momentum} \\times x_t`,\n        where :math:`\\hat{x}` is the estimated statistic and :math:`x_t` is the\n        new observed value.\n\n    Because the Batch Normalization is done over the `C` dimension, computing statistics\n    on `(N, L)` slices, it's common terminology to call this Temporal Batch Normalization.\n\n    Args:\n        num_features: number of features or channels :math:`C` of the input\n        eps: a value added to the denominator for numerical stability.\n            Default: 1e-5\n        momentum: the value used for the running_mean and running_var\n            computation. Can be set to ``None`` for cumulative moving average\n            (i.e. simple average). Default: 0.1\n        affine: a boolean value that when set to ``True``, this module has\n            learnable affine parameters. Default: ``True``\n        track_running_stats: a boolean value that when set to ``True``, this\n            module tracks the running mean and variance, and when set to ``False``,\n            this module does not track such statistics, and initializes statistics\n            buffers :attr:`running_mean` and :attr:`running_var` as ``None``.\n            When these buffers are ``None``, this module always uses batch statistics.\n            in both training and eval modes. Default: ``True``\n\n    Shape:\n        - Input: :math:`(N, C)` or :math:`(N, C, L)`, where :math:`N` is the batch size,\n          :math:`C` is the number of features or channels, and :math:`L` is the sequence length\n        - Output: :math:`(N, C)` or :math:`(N, C, L)` (same shape as input)\n\n    Examples::\n\n        >>> # With Learnable Parameters\n        >>> m = nn.BatchNorm1d(100)\n        >>> # Without Learnable Parameters\n        >>> m = nn.BatchNorm1d(100, affine=False)\n        >>> input = torch.randn(20, 100)\n        >>> output = m(input)\n    "
                },
                "BatchNorm2d": {
                  "Doc": "Applies Batch Normalization over a 4D input (a mini-batch of 2D inputs\n    with additional channel dimension) as described in the paper\n    `Batch Normalization: Accelerating Deep Network Training by Reducing\n    Internal Covariate Shift <https://arxiv.org/abs/1502.03167>`__ .\n\n    .. math::\n\n        y = \\frac{x - \\mathrm{E}[x]}{ \\sqrt{\\mathrm{Var}[x] + \\epsilon}} * \\gamma + \\beta\n\n    The mean and standard-deviation are calculated per-dimension over\n    the mini-batches and :math:`\\gamma` and :math:`\\beta` are learnable parameter vectors\n    of size `C` (where `C` is the input size). By default, the elements of :math:`\\gamma` are set\n    to 1 and the elements of :math:`\\beta` are set to 0. The standard-deviation is calculated\n    via the biased estimator, equivalent to `torch.var(input, unbiased=False)`.\n\n    Also by default, during training this layer keeps running estimates of its\n    computed mean and variance, which are then used for normalization during\n    evaluation. The running estimates are kept with a default :attr:`momentum`\n    of 0.1.\n\n    If :attr:`track_running_stats` is set to ``False``, this layer then does not\n    keep running estimates, and batch statistics are instead used during\n    evaluation time as well.\n\n    .. note::\n        This :attr:`momentum` argument is different from one used in optimizer\n        classes and the conventional notion of momentum. Mathematically, the\n        update rule for running statistics here is\n        :math:`\\hat{x}_\\text{new} = (1 - \\text{momentum}) \\times \\hat{x} + \\text{momentum} \\times x_t`,\n        where :math:`\\hat{x}` is the estimated statistic and :math:`x_t` is the\n        new observed value.\n\n    Because the Batch Normalization is done over the `C` dimension, computing statistics\n    on `(N, H, W)` slices, it's common terminology to call this Spatial Batch Normalization.\n\n    Args:\n        num_features: :math:`C` from an expected input of size\n            :math:`(N, C, H, W)`\n        eps: a value added to the denominator for numerical stability.\n            Default: 1e-5\n        momentum: the value used for the running_mean and running_var\n            computation. Can be set to ``None`` for cumulative moving average\n            (i.e. simple average). Default: 0.1\n        affine: a boolean value that when set to ``True``, this module has\n            learnable affine parameters. Default: ``True``\n        track_running_stats: a boolean value that when set to ``True``, this\n            module tracks the running mean and variance, and when set to ``False``,\n            this module does not track such statistics, and initializes statistics\n            buffers :attr:`running_mean` and :attr:`running_var` as ``None``.\n            When these buffers are ``None``, this module always uses batch statistics.\n            in both training and eval modes. Default: ``True``\n\n    Shape:\n        - Input: :math:`(N, C, H, W)`\n        - Output: :math:`(N, C, H, W)` (same shape as input)\n\n    Examples::\n\n        >>> # With Learnable Parameters\n        >>> m = nn.BatchNorm2d(100)\n        >>> # Without Learnable Parameters\n        >>> m = nn.BatchNorm2d(100, affine=False)\n        >>> input = torch.randn(20, 100, 35, 45)\n        >>> output = m(input)\n    "
                },
                "BatchNorm3d": {
                  "Doc": "Applies Batch Normalization over a 5D input (a mini-batch of 3D inputs\n    with additional channel dimension) as described in the paper\n    `Batch Normalization: Accelerating Deep Network Training by Reducing\n    Internal Covariate Shift <https://arxiv.org/abs/1502.03167>`__ .\n\n    .. math::\n\n        y = \\frac{x - \\mathrm{E}[x]}{ \\sqrt{\\mathrm{Var}[x] + \\epsilon}} * \\gamma + \\beta\n\n    The mean and standard-deviation are calculated per-dimension over\n    the mini-batches and :math:`\\gamma` and :math:`\\beta` are learnable parameter vectors\n    of size `C` (where `C` is the input size). By default, the elements of :math:`\\gamma` are set\n    to 1 and the elements of :math:`\\beta` are set to 0. The standard-deviation is calculated\n    via the biased estimator, equivalent to `torch.var(input, unbiased=False)`.\n\n    Also by default, during training this layer keeps running estimates of its\n    computed mean and variance, which are then used for normalization during\n    evaluation. The running estimates are kept with a default :attr:`momentum`\n    of 0.1.\n\n    If :attr:`track_running_stats` is set to ``False``, this layer then does not\n    keep running estimates, and batch statistics are instead used during\n    evaluation time as well.\n\n    .. note::\n        This :attr:`momentum` argument is different from one used in optimizer\n        classes and the conventional notion of momentum. Mathematically, the\n        update rule for running statistics here is\n        :math:`\\hat{x}_\\text{new} = (1 - \\text{momentum}) \\times \\hat{x} + \\text{momentum} \\times x_t`,\n        where :math:`\\hat{x}` is the estimated statistic and :math:`x_t` is the\n        new observed value.\n\n    Because the Batch Normalization is done over the `C` dimension, computing statistics\n    on `(N, D, H, W)` slices, it's common terminology to call this Volumetric Batch Normalization\n    or Spatio-temporal Batch Normalization.\n\n    Args:\n        num_features: :math:`C` from an expected input of size\n            :math:`(N, C, D, H, W)`\n        eps: a value added to the denominator for numerical stability.\n            Default: 1e-5\n        momentum: the value used for the running_mean and running_var\n            computation. Can be set to ``None`` for cumulative moving average\n            (i.e. simple average). Default: 0.1\n        affine: a boolean value that when set to ``True``, this module has\n            learnable affine parameters. Default: ``True``\n        track_running_stats: a boolean value that when set to ``True``, this\n            module tracks the running mean and variance, and when set to ``False``,\n            this module does not track such statistics, and initializes statistics\n            buffers :attr:`running_mean` and :attr:`running_var` as ``None``.\n            When these buffers are ``None``, this module always uses batch statistics.\n            in both training and eval modes. Default: ``True``\n\n    Shape:\n        - Input: :math:`(N, C, D, H, W)`\n        - Output: :math:`(N, C, D, H, W)` (same shape as input)\n\n    Examples::\n\n        >>> # With Learnable Parameters\n        >>> m = nn.BatchNorm3d(100)\n        >>> # Without Learnable Parameters\n        >>> m = nn.BatchNorm3d(100, affine=False)\n        >>> input = torch.randn(20, 100, 35, 45, 10)\n        >>> output = m(input)\n    "
                },
                "LazyBatchNorm1d": {
                  "Doc": "A :class:`torch.nn.BatchNorm1d` module with lazy initialization of\n    the ``num_features`` argument of the :class:`BatchNorm1d` that is inferred\n    from the ``input.size(1)``.\n    The attributes that will be lazily initialized are `weight`, `bias`,\n    `running_mean` and `running_var`.\n\n    Check the :class:`torch.nn.modules.lazy.LazyModuleMixin` for further documentation\n    on lazy modules and their limitations.\n\n    Args:\n        eps: a value added to the denominator for numerical stability.\n            Default: 1e-5\n        momentum: the value used for the running_mean and running_var\n            computation. Can be set to ``None`` for cumulative moving average\n            (i.e. simple average). Default: 0.1\n        affine: a boolean value that when set to ``True``, this module has\n            learnable affine parameters. Default: ``True``\n        track_running_stats: a boolean value that when set to ``True``, this\n            module tracks the running mean and variance, and when set to ``False``,\n            this module does not track such statistics, and initializes statistics\n            buffers :attr:`running_mean` and :attr:`running_var` as ``None``.\n            When these buffers are ``None``, this module always uses batch statistics.\n            in both training and eval modes. Default: ``True``\n    "
                },
                "LazyBatchNorm2d": {
                  "Doc": "A :class:`torch.nn.BatchNorm2d` module with lazy initialization of\n    the ``num_features`` argument of the :class:`BatchNorm2d` that is inferred\n    from the ``input.size(1)``.\n    The attributes that will be lazily initialized are `weight`, `bias`,\n    `running_mean` and `running_var`.\n\n    Check the :class:`torch.nn.modules.lazy.LazyModuleMixin` for further documentation\n    on lazy modules and their limitations.\n\n    Args:\n        eps: a value added to the denominator for numerical stability.\n            Default: 1e-5\n        momentum: the value used for the running_mean and running_var\n            computation. Can be set to ``None`` for cumulative moving average\n            (i.e. simple average). Default: 0.1\n        affine: a boolean value that when set to ``True``, this module has\n            learnable affine parameters. Default: ``True``\n        track_running_stats: a boolean value that when set to ``True``, this\n            module tracks the running mean and variance, and when set to ``False``,\n            this module does not track such statistics, and initializes statistics\n            buffers :attr:`running_mean` and :attr:`running_var` as ``None``.\n            When these buffers are ``None``, this module always uses batch statistics.\n            in both training and eval modes. Default: ``True``\n    "
                },
                "LazyBatchNorm3d": {
                  "Doc": "A :class:`torch.nn.BatchNorm3d` module with lazy initialization of\n    the ``num_features`` argument of the :class:`BatchNorm3d` that is inferred\n    from the ``input.size(1)``.\n    The attributes that will be lazily initialized are `weight`, `bias`,\n    `running_mean` and `running_var`.\n\n    Check the :class:`torch.nn.modules.lazy.LazyModuleMixin` for further documentation\n    on lazy modules and their limitations.\n\n    Args:\n        eps: a value added to the denominator for numerical stability.\n            Default: 1e-5\n        momentum: the value used for the running_mean and running_var\n            computation. Can be set to ``None`` for cumulative moving average\n            (i.e. simple average). Default: 0.1\n        affine: a boolean value that when set to ``True``, this module has\n            learnable affine parameters. Default: ``True``\n        track_running_stats: a boolean value that when set to ``True``, this\n            module tracks the running mean and variance, and when set to ``False``,\n            this module does not track such statistics, and initializes statistics\n            buffers :attr:`running_mean` and :attr:`running_var` as ``None``.\n            When these buffers are ``None``, this module always uses batch statistics.\n            in both training and eval modes. Default: ``True``\n    "
                },
                "SyncBatchNorm": {
                  "Doc": "Applies Batch Normalization over a N-Dimensional input (a mini-batch of [N-2]D inputs\n    with additional channel dimension) as described in the paper\n    `Batch Normalization: Accelerating Deep Network Training by Reducing\n    Internal Covariate Shift <https://arxiv.org/abs/1502.03167>`__ .\n\n    .. math::\n\n        y = \\frac{x - \\mathrm{E}[x]}{ \\sqrt{\\mathrm{Var}[x] + \\epsilon}} * \\gamma + \\beta\n\n    The mean and standard-deviation are calculated per-dimension over all\n    mini-batches of the same process groups. :math:`\\gamma` and :math:`\\beta`\n    are learnable parameter vectors of size `C` (where `C` is the input size).\n    By default, the elements of :math:`\\gamma` are sampled from\n    :math:`\\mathcal{U}(0, 1)` and the elements of :math:`\\beta` are set to 0.\n    The standard-deviation is calculated via the biased estimator, equivalent to\n    `torch.var(input, unbiased=False)`.\n\n    Also by default, during training this layer keeps running estimates of its\n    computed mean and variance, which are then used for normalization during\n    evaluation. The running estimates are kept with a default :attr:`momentum`\n    of 0.1.\n\n    If :attr:`track_running_stats` is set to ``False``, this layer then does not\n    keep running estimates, and batch statistics are instead used during\n    evaluation time as well.\n\n    .. note::\n        This :attr:`momentum` argument is different from one used in optimizer\n        classes and the conventional notion of momentum. Mathematically, the\n        update rule for running statistics here is\n        :math:`\\hat{x}_\\text{new} = (1 - \\text{momentum}) \\times \\hat{x} + \\text{momentum} \\times x_t`,\n        where :math:`\\hat{x}` is the estimated statistic and :math:`x_t` is the\n        new observed value.\n\n    Because the Batch Normalization is done for each channel in the ``C`` dimension, computing\n    statistics on ``(N, +)`` slices, it's common terminology to call this Volumetric Batch\n    Normalization or Spatio-temporal Batch Normalization.\n\n    Currently :class:`SyncBatchNorm` only supports\n    :class:`~torch.nn.DistributedDataParallel` (DDP) with single GPU per process. Use\n    :meth:`torch.nn.SyncBatchNorm.convert_sync_batchnorm()` to convert\n    :attr:`BatchNorm*D` layer to :class:`SyncBatchNorm` before wrapping\n    Network with DDP.\n\n    Args:\n        num_features: :math:`C` from an expected input of size\n            :math:`(N, C, +)`\n        eps: a value added to the denominator for numerical stability.\n            Default: ``1e-5``\n        momentum: the value used for the running_mean and running_var\n            computation. Can be set to ``None`` for cumulative moving average\n            (i.e. simple average). Default: 0.1\n        affine: a boolean value that when set to ``True``, this module has\n            learnable affine parameters. Default: ``True``\n        track_running_stats: a boolean value that when set to ``True``, this\n            module tracks the running mean and variance, and when set to ``False``,\n            this module does not track such statistics, and initializes statistics\n            buffers :attr:`running_mean` and :attr:`running_var` as ``None``.\n            When these buffers are ``None``, this module always uses batch statistics.\n            in both training and eval modes. Default: ``True``\n        process_group: synchronization of stats happen within each process group\n            individually. Default behavior is synchronization across the whole\n            world\n\n    Shape:\n        - Input: :math:`(N, C, +)`\n        - Output: :math:`(N, C, +)` (same shape as input)\n\n    .. note::\n        Synchronization of batchnorm statistics occurs only while training, i.e.\n        synchronization is disabled when ``model.eval()`` is set or if\n        ``self.training`` is otherwise ``False``.\n\n    Examples::\n\n        >>> # With Learnable Parameters\n        >>> m = nn.SyncBatchNorm(100)\n        >>> # creating process group (optional)\n        >>> # ranks is a list of int identifying rank ids.\n        >>> ranks = list(range(8))\n        >>> r1, r2 = ranks[:4], ranks[4:]\n        >>> # Note: every rank calls into new_group for every\n        >>> # process group created, even if that rank is not\n        >>> # part of the group.\n        >>> # xdoctest: +SKIP\n        >>> process_groups = [torch.distributed.new_group(pids) for pids in [r1, r2]]\n        >>> process_group = process_groups[0 if dist.get_rank() <= 3 else 1]\n        >>> # Without Learnable Parameters\n        >>> m = nn.BatchNorm3d(100, affine=False, process_group=process_group)\n        >>> input = torch.randn(20, 100, 35, 45, 10)\n        >>> output = m(input)\n\n        >>> # network is nn.BatchNorm layer\n        >>> sync_bn_network = nn.SyncBatchNorm.convert_sync_batchnorm(network, process_group)\n        >>> # only single gpu per process is currently supported\n        >>> ddp_sync_bn_network = torch.nn.parallel.DistributedDataParallel(\n        >>>                         sync_bn_network,\n        >>>                         device_ids=[args.local_rank],\n        >>>                         output_device=args.local_rank)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "num_features": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "eps": {
                          "Type": "<class 'float'>",
                          "Default": "1e-05"
                        },
                        "momentum": {
                          "Type": "<class 'float'>",
                          "Default": "0.1"
                        },
                        "affine": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "track_running_stats": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "process_group": {
                          "Type": "typing.Optional[typing.Any]",
                          "Default": "None"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "convert_sync_batchnorm": {
                      "Doc": "Helper function to convert all :attr:`BatchNorm*D` layers in the model to\n        :class:`torch.nn.SyncBatchNorm` layers.\n\n        Args:\n            module (nn.Module): module containing one or more :attr:`BatchNorm*D` layers\n            process_group (optional): process group to scope synchronization,\n                default is the whole world\n\n        Returns:\n            The original :attr:`module` with the converted :class:`torch.nn.SyncBatchNorm`\n            layers. If the original :attr:`module` is a :attr:`BatchNorm*D` layer,\n            a new :class:`torch.nn.SyncBatchNorm` layer object will be returned\n            instead.\n\n        Example::\n\n            >>> # Network with nn.BatchNorm layer\n            >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA)\n            >>> module = torch.nn.Sequential(\n            >>>            torch.nn.Linear(20, 100),\n            >>>            torch.nn.BatchNorm1d(100),\n            >>>          ).cuda()\n            >>> # creating process group (optional)\n            >>> # ranks is a list of int identifying rank ids.\n            >>> ranks = list(range(8))\n            >>> r1, r2 = ranks[:4], ranks[4:]\n            >>> # Note: every rank calls into new_group for every\n            >>> # process group created, even if that rank is not\n            >>> # part of the group.\n            >>> # xdoctest: +SKIP(\"distributed\")\n            >>> process_groups = [torch.distributed.new_group(pids) for pids in [r1, r2]]\n            >>> process_group = process_groups[0 if dist.get_rank() <= 3 else 1]\n            >>> sync_bn_module = torch.nn.SyncBatchNorm.convert_sync_batchnorm(module, process_group)\n\n        ",
                      "Args": {
                        "cls": {
                          "Type": null,
                          "Default": null
                        },
                        "module": {
                          "Type": null,
                          "Default": null
                        },
                        "process_group": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                }
              }
            },
            "channelshuffle": {
              "Doc": null,
              "Classes": {
                "ChannelShuffle": {
                  "Doc": "Divide the channels in a tensor of shape :math:`(*, C , H, W)`\n    into g groups and rearrange them as :math:`(*, C \\frac g, g, H, W)`,\n    while keeping the original tensor shape.\n\n    Args:\n        groups (int): number of groups to divide channels in.\n\n    Examples::\n\n        >>> # xdoctest: +IGNORE_WANT(\"FIXME: incorrect want\")\n        >>> channel_shuffle = nn.ChannelShuffle(2)\n        >>> input = torch.randn(1, 4, 2, 2)\n        >>> print(input)\n        [[[[1, 2],\n           [3, 4]],\n          [[5, 6],\n           [7, 8]],\n          [[9, 10],\n           [11, 12]],\n          [[13, 14],\n           [15, 16]],\n         ]]\n        >>> output = channel_shuffle(input)\n        >>> print(output)\n        [[[[1, 2],\n           [3, 4]],\n          [[9, 10],\n           [11, 12]],\n          [[5, 6],\n           [7, 8]],\n          [[13, 14],\n           [15, 16]],\n         ]]\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "groups": {
                          "Type": "<class 'int'>",
                          "Default": null
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                }
              }
            },
            "container": {
              "Doc": null,
              "Classes": {
                "Container": {
                  "Doc": null,
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "**kwargs": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "ModuleDict": {
                  "Doc": "Holds submodules in a dictionary.\n\n    :class:`~torch.nn.ModuleDict` can be indexed like a regular Python dictionary,\n    but modules it contains are properly registered, and will be visible by all\n    :class:`~torch.nn.Module` methods.\n\n    :class:`~torch.nn.ModuleDict` is an **ordered** dictionary that respects\n\n    * the order of insertion, and\n\n    * in :meth:`~torch.nn.ModuleDict.update`, the order of the merged\n      ``OrderedDict``, ``dict`` (started from Python 3.6) or another\n      :class:`~torch.nn.ModuleDict` (the argument to\n      :meth:`~torch.nn.ModuleDict.update`).\n\n    Note that :meth:`~torch.nn.ModuleDict.update` with other unordered mapping\n    types (e.g., Python's plain ``dict`` before Python version 3.6) does not\n    preserve the order of the merged mapping.\n\n    Args:\n        modules (iterable, optional): a mapping (dictionary) of (string: module)\n            or an iterable of key-value pairs of type (string, module)\n\n    Example::\n\n        class MyModule(nn.Module):\n            def __init__(self):\n                super(MyModule, self).__init__()\n                self.choices = nn.ModuleDict({\n                        'conv': nn.Conv2d(10, 10, 3),\n                        'pool': nn.MaxPool2d(3)\n                })\n                self.activations = nn.ModuleDict([\n                        ['lrelu', nn.LeakyReLU()],\n                        ['prelu', nn.PReLU()]\n                ])\n\n            def forward(self, x, choice, act):\n                x = self.choices[choice](x)\n                x = self.activations[act](x)\n                return x\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "modules": {
                          "Type": "typing.Optional[typing.Mapping[str, torch.nn.modules.module.Module]]",
                          "Default": "None"
                        }
                      }
                    },
                    "clear": {
                      "Doc": "Remove all items from the ModuleDict.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "items": {
                      "Doc": "Return an iterable of the ModuleDict key/value pairs.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "keys": {
                      "Doc": "Return an iterable of the ModuleDict keys.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "pop": {
                      "Doc": "Remove key from the ModuleDict and return its module.\n\n        Args:\n            key (str): key to pop from the ModuleDict\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "key": {
                          "Type": "<class 'str'>",
                          "Default": null
                        }
                      }
                    },
                    "update": {
                      "Doc": "Update the :class:`~torch.nn.ModuleDict` with the key-value pairs from a\n        mapping or an iterable, overwriting existing keys.\n\n        .. note::\n            If :attr:`modules` is an ``OrderedDict``, a :class:`~torch.nn.ModuleDict`, or\n            an iterable of key-value pairs, the order of new elements in it is preserved.\n\n        Args:\n            modules (iterable): a mapping (dictionary) from string to :class:`~torch.nn.Module`,\n                or an iterable of key-value pairs of type (string, :class:`~torch.nn.Module`)\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "modules": {
                          "Type": "typing.Mapping[str, torch.nn.modules.module.Module]",
                          "Default": null
                        }
                      }
                    },
                    "values": {
                      "Doc": "Return an iterable of the ModuleDict values.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "ModuleList": {
                  "Doc": "Holds submodules in a list.\n\n    :class:`~torch.nn.ModuleList` can be indexed like a regular Python list, but\n    modules it contains are properly registered, and will be visible by all\n    :class:`~torch.nn.Module` methods.\n\n    Args:\n        modules (iterable, optional): an iterable of modules to add\n\n    Example::\n\n        class MyModule(nn.Module):\n            def __init__(self):\n                super(MyModule, self).__init__()\n                self.linears = nn.ModuleList([nn.Linear(10, 10) for i in range(10)])\n\n            def forward(self, x):\n                # ModuleList can act as an iterable, or be indexed using ints\n                for i, l in enumerate(self.linears):\n                    x = self.linears[i // 2](x) + l(x)\n                return x\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "modules": {
                          "Type": "typing.Optional[typing.Iterable[torch.nn.modules.module.Module]]",
                          "Default": "None"
                        }
                      }
                    },
                    "append": {
                      "Doc": "Appends a given module to the end of the list.\n\n        Args:\n            module (nn.Module): module to append\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "module": {
                          "Type": "<class 'torch.nn.modules.module.Module'>",
                          "Default": null
                        }
                      }
                    },
                    "extend": {
                      "Doc": "Appends modules from a Python iterable to the end of the list.\n\n        Args:\n            modules (iterable): iterable of modules to append\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "modules": {
                          "Type": "typing.Iterable[torch.nn.modules.module.Module]",
                          "Default": null
                        }
                      }
                    },
                    "insert": {
                      "Doc": "Insert a given module before a given index in the list.\n\n        Args:\n            index (int): index to insert.\n            module (nn.Module): module to insert\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "index": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "module": {
                          "Type": "<class 'torch.nn.modules.module.Module'>",
                          "Default": null
                        }
                      }
                    },
                    "pop": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "key": {
                          "Type": "typing.Union[int, slice]",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "ParameterDict": {
                  "Doc": "Holds parameters in a dictionary.\n\n    ParameterDict can be indexed like a regular Python dictionary, but Parameters it\n    contains are properly registered, and will be visible by all Module methods.\n    Other objects are treated as would be done by a regular Python dictionary\n\n    :class:`~torch.nn.ParameterDict` is an **ordered** dictionary.\n    :meth:`~torch.nn.ParameterDict.update` with other unordered mapping\n    types (e.g., Python's plain ``dict``) does not preserve the order of the\n    merged mapping. On the other hand, ``OrderedDict`` or another :class:`~torch.nn.ParameterDict`\n    will preserve their ordering.\n\n    Note that the constructor, assigning an element of the dictionary and the\n    :meth:`~torch.nn.ParameterDict.update` method will convert any :class:`~torch.Tensor` into\n    :class:`~torch.nn.Parameter`.\n\n    Args:\n        values (iterable, optional): a mapping (dictionary) of\n            (string : Any) or an iterable of key-value pairs\n            of type (string, Any)\n\n    Example::\n\n        class MyModule(nn.Module):\n            def __init__(self):\n                super(MyModule, self).__init__()\n                self.params = nn.ParameterDict({\n                        'left': nn.Parameter(torch.randn(5, 10)),\n                        'right': nn.Parameter(torch.randn(5, 10))\n                })\n\n            def forward(self, x, choice):\n                x = self.params[choice].mm(x)\n                return x\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "parameters": {
                          "Type": "typing.Any",
                          "Default": "None"
                        }
                      }
                    },
                    "clear": {
                      "Doc": "Remove all items from the ParameterDict.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "copy": {
                      "Doc": "Returns a copy of this :class:`~torch.nn.ParameterDict` instance.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "fromkeys": {
                      "Doc": "Return a new ParameterDict with the keys provided\n\n        Args:\n            keys (iterable, string): keys to make the new ParameterDict from\n            default (Parameter, optional): value to set for all keys\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "keys": {
                          "Type": "typing.Iterable[str]",
                          "Default": null
                        },
                        "default": {
                          "Type": "typing.Optional[typing.Any]",
                          "Default": "None"
                        }
                      }
                    },
                    "get": {
                      "Doc": "Return the parameter associated with key if present.\n        Otherwise return default if provided, None if not.\n\n        Args:\n            key (str): key to get from the ParameterDict\n            default (Parameter, optional): value to return if key not present\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "key": {
                          "Type": "<class 'str'>",
                          "Default": null
                        },
                        "default": {
                          "Type": "typing.Optional[typing.Any]",
                          "Default": "None"
                        }
                      }
                    },
                    "items": {
                      "Doc": "Return an iterable of the ParameterDict key/value pairs.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "keys": {
                      "Doc": "Return an iterable of the ParameterDict keys.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "pop": {
                      "Doc": "Remove key from the ParameterDict and return its parameter.\n\n        Args:\n            key (str): key to pop from the ParameterDict\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "key": {
                          "Type": "<class 'str'>",
                          "Default": null
                        }
                      }
                    },
                    "popitem": {
                      "Doc": "Remove and return the last inserted `(key, parameter)` pair\n        from the ParameterDict\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "setdefault": {
                      "Doc": "If key is in the ParameterDict, return its value.\n        If not, insert `key` with a parameter `default` and return `default`.\n        `default` defaults to `None`.\n\n        Args:\n            key (str): key to set default for\n            default (Any): the parameter set to the key\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "key": {
                          "Type": "<class 'str'>",
                          "Default": null
                        },
                        "default": {
                          "Type": "typing.Optional[typing.Any]",
                          "Default": "None"
                        }
                      }
                    },
                    "update": {
                      "Doc": "Update the :class:`~torch.nn.ParameterDict` with the key-value pairs from a\n        mapping or an iterable, overwriting existing keys.\n\n        .. note::\n            If :attr:`parameters` is an ``OrderedDict``, a :class:`~torch.nn.ParameterDict`, or\n            an iterable of key-value pairs, the order of new elements in it is preserved.\n\n        Args:\n            parameters (iterable): a mapping (dictionary) from string to\n                :class:`~torch.nn.Parameter`, or an iterable of\n                key-value pairs of type (string, :class:`~torch.nn.Parameter`)\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "parameters": {
                          "Type": "typing.Union[typing.Mapping[str, typing.Any], ForwardRef('ParameterDict')]",
                          "Default": null
                        }
                      }
                    },
                    "values": {
                      "Doc": "Return an iterable of the ParameterDict values.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "ParameterList": {
                  "Doc": "Holds parameters in a list.\n\n    :class:`~torch.nn.ParameterList` can be used like a regular Python\n    list, but Tensors that are :class:`~torch.nn.Parameter` are properly registered,\n    and will be visible by all :class:`~torch.nn.Module` methods.\n\n    Note that the constructor, assigning an element of the list, the\n    :meth:`~torch.nn.ParameterDict.append` method and the :meth:`~torch.nn.ParameterDict.extend`\n    method will convert any :class:`~torch.Tensor` into :class:`~torch.nn.Parameter`.\n\n    Args:\n        parameters (iterable, optional): an iterable of elements to add to the list.\n\n    Example::\n\n        class MyModule(nn.Module):\n            def __init__(self):\n                super(MyModule, self).__init__()\n                self.params = nn.ParameterList([nn.Parameter(torch.randn(10, 10)) for i in range(10)])\n\n            def forward(self, x):\n                # ParameterList can act as an iterable, or be indexed using ints\n                for i, p in enumerate(self.params):\n                    x = self.params[i // 2].mm(x) + p.mm(x)\n                return x\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "values": {
                          "Type": "typing.Optional[typing.Iterable[typing.Any]]",
                          "Default": "None"
                        }
                      }
                    },
                    "append": {
                      "Doc": "Appends a given value at the end of the list.\n\n        Args:\n            value (Any): value to append\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "value": {
                          "Type": "typing.Any",
                          "Default": null
                        }
                      }
                    },
                    "extend": {
                      "Doc": "Appends values from a Python iterable to the end of the list.\n\n        Args:\n            values (iterable): iterable of values to append\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "values": {
                          "Type": "typing.Iterable[typing.Any]",
                          "Default": null
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Sequential": {
                  "Doc": "A sequential container.\n    Modules will be added to it in the order they are passed in the\n    constructor. Alternatively, an ``OrderedDict`` of modules can be\n    passed in. The ``forward()`` method of ``Sequential`` accepts any\n    input and forwards it to the first module it contains. It then\n    \"chains\" outputs to inputs sequentially for each subsequent module,\n    finally returning the output of the last module.\n\n    The value a ``Sequential`` provides over manually calling a sequence\n    of modules is that it allows treating the whole container as a\n    single module, such that performing a transformation on the\n    ``Sequential`` applies to each of the modules it stores (which are\n    each a registered submodule of the ``Sequential``).\n\n    What's the difference between a ``Sequential`` and a\n    :class:`torch.nn.ModuleList`? A ``ModuleList`` is exactly what it\n    sounds like--a list for storing ``Module`` s! On the other hand,\n    the layers in a ``Sequential`` are connected in a cascading way.\n\n    Example::\n\n        # Using Sequential to create a small model. When `model` is run,\n        # input will first be passed to `Conv2d(1,20,5)`. The output of\n        # `Conv2d(1,20,5)` will be used as the input to the first\n        # `ReLU`; the output of the first `ReLU` will become the input\n        # for `Conv2d(20,64,5)`. Finally, the output of\n        # `Conv2d(20,64,5)` will be used as input to the second `ReLU`\n        model = nn.Sequential(\n                  nn.Conv2d(1,20,5),\n                  nn.ReLU(),\n                  nn.Conv2d(20,64,5),\n                  nn.ReLU()\n                )\n\n        # Using Sequential with OrderedDict. This is functionally the\n        # same as the above code\n        model = nn.Sequential(OrderedDict([\n                  ('conv1', nn.Conv2d(1,20,5)),\n                  ('relu1', nn.ReLU()),\n                  ('conv2', nn.Conv2d(20,64,5)),\n                  ('relu2', nn.ReLU())\n                ]))\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "*args": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "append": {
                      "Doc": "Appends a given module to the end.\n\n        Args:\n            module (nn.Module): module to append\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "module": {
                          "Type": "<class 'torch.nn.modules.module.Module'>",
                          "Default": null
                        }
                      }
                    },
                    "extend": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "sequential": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "insert": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "index": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "module": {
                          "Type": "<class 'torch.nn.modules.module.Module'>",
                          "Default": null
                        }
                      }
                    },
                    "pop": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "key": {
                          "Type": "typing.Union[int, slice]",
                          "Default": null
                        }
                      }
                    }
                  }
                }
              },
              "Functions": {
                "overload": {
                  "Doc": "Decorator for overloaded functions/methods.\n\n    In a stub file, place two or more stub definitions for the same\n    function in a row, each decorated with @overload.  For example:\n\n      @overload\n      def utf8(value: None) -> None: ...\n      @overload\n      def utf8(value: bytes) -> bytes: ...\n      @overload\n      def utf8(value: str) -> bytes: ...\n\n    In a non-stub file (i.e. a regular .py file), do the same but\n    follow it with an implementation.  The implementation should *not*\n    be decorated with @overload.  For example:\n\n      @overload\n      def utf8(value: None) -> None: ...\n      @overload\n      def utf8(value: bytes) -> bytes: ...\n      @overload\n      def utf8(value: str) -> bytes: ...\n      def utf8(value):\n          # implementation goes here\n    ",
                  "Args": {
                    "func": {
                      "Type": null,
                      "Default": null
                    }
                  }
                }
              }
            },
            "conv": {
              "Doc": null,
              "Classes": {
                "Conv1d": {
                  "Doc": "Applies a 1D convolution over an input signal composed of several input\n    planes.\n\n    In the simplest case, the output value of the layer with input size\n    :math:`(N, C_{\\text{in}}, L)` and output :math:`(N, C_{\\text{out}}, L_{\\text{out}})` can be\n    precisely described as:\n\n    .. math::\n        \\text{out}(N_i, C_{\\text{out}_j}) = \\text{bias}(C_{\\text{out}_j}) +\n        \\sum_{k = 0}^{C_{in} - 1} \\text{weight}(C_{\\text{out}_j}, k)\n        \\star \\text{input}(N_i, k)\n\n    where :math:`\\star` is the valid `cross-correlation`_ operator,\n    :math:`N` is a batch size, :math:`C` denotes a number of channels,\n    :math:`L` is a length of signal sequence.\n    \n\n    This module supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\n    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.\n\n    * :attr:`stride` controls the stride for the cross-correlation, a single\n      number or a one-element tuple.\n\n    * :attr:`padding` controls the amount of padding applied to the input. It\n      can be either a string {'valid', 'same'} or a tuple of ints giving the\n      amount of implicit padding applied on both sides.\n\n    * :attr:`dilation` controls the spacing between the kernel points; also\n      known as the \u00e0 trous algorithm. It is harder to describe, but this `link`_\n      has a nice visualization of what :attr:`dilation` does.\n\n    * :attr:`groups` controls the connections between inputs and outputs.\n      :attr:`in_channels` and :attr:`out_channels` must both be divisible by\n      :attr:`groups`. For example,\n\n        * At groups=1, all inputs are convolved to all outputs.\n        * At groups=2, the operation becomes equivalent to having two conv\n          layers side by side, each seeing half the input channels\n          and producing half the output channels, and both subsequently\n          concatenated.\n        * At groups= :attr:`in_channels`, each input channel is convolved with\n          its own set of filters (of size\n          :math:`\\frac{\\text{out\\_channels}}{\\text{in\\_channels}}`).\n\n    Note:\n        When `groups == in_channels` and `out_channels == K * in_channels`,\n        where `K` is a positive integer, this operation is also known as a \"depthwise convolution\".\n\n        In other words, for an input of size :math:`(N, C_{in}, L_{in})`,\n        a depthwise convolution with a depthwise multiplier `K` can be performed with the arguments\n        :math:`(C_\\text{in}=C_\\text{in}, C_\\text{out}=C_\\text{in} \\times \\text{K}, ..., \\text{groups}=C_\\text{in})`.\n    Note:\n        In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.\n\n    Note:\n        ``padding='valid'`` is the same as no padding. ``padding='same'`` pads\n        the input so the output has the shape as the input. However, this mode\n        doesn't support any stride values other than 1.\n\n    Note:\n        This module supports complex data types i.e. ``complex32, complex64, complex128``.\n\n    Args:\n        in_channels (int): Number of channels in the input image\n        out_channels (int): Number of channels produced by the convolution\n        kernel_size (int or tuple): Size of the convolving kernel\n        stride (int or tuple, optional): Stride of the convolution. Default: 1\n        padding (int, tuple or str, optional): Padding added to both sides of\n            the input. Default: 0\n        padding_mode (str, optional): ``'zeros'``, ``'reflect'``,\n            ``'replicate'`` or ``'circular'``. Default: ``'zeros'``\n        dilation (int or tuple, optional): Spacing between kernel\n            elements. Default: 1\n        groups (int, optional): Number of blocked connections from input\n            channels to output channels. Default: 1\n        bias (bool, optional): If ``True``, adds a learnable bias to the\n            output. Default: ``True``\n\n    \n\n    Shape:\n        - Input: :math:`(N, C_{in}, L_{in})` or :math:`(C_{in}, L_{in})`\n        - Output: :math:`(N, C_{out}, L_{out})` or :math:`(C_{out}, L_{out})`, where\n\n          .. math::\n              L_{out} = \\left\\lfloor\\frac{L_{in} + 2 \\times \\text{padding} - \\text{dilation}\n                        \\times (\\text{kernel\\_size} - 1) - 1}{\\text{stride}} + 1\\right\\rfloor\n\n    Attributes:\n        weight (Tensor): the learnable weights of the module of shape\n            :math:`(\\text{out\\_channels},\n            \\frac{\\text{in\\_channels}}{\\text{groups}}, \\text{kernel\\_size})`.\n            The values of these weights are sampled from\n            :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})` where\n            :math:`k = \\frac{groups}{C_\\text{in} * \\text{kernel\\_size}}`\n        bias (Tensor):   the learnable bias of the module of shape\n            (out_channels). If :attr:`bias` is ``True``, then the values of these weights are\n            sampled from :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})` where\n            :math:`k = \\frac{groups}{C_\\text{in} * \\text{kernel\\_size}}`\n\n    Examples::\n\n        >>> m = nn.Conv1d(16, 33, 3, stride=2)\n        >>> input = torch.randn(20, 16, 50)\n        >>> output = m(input)\n\n    .. _cross-correlation:\n        https://en.wikipedia.org/wiki/Cross-correlation\n\n    .. _link:\n        https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "in_channels": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "out_channels": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "kernel_size": {
                          "Type": "typing.Union[int, typing.Tuple[int]]",
                          "Default": null
                        },
                        "stride": {
                          "Type": "typing.Union[int, typing.Tuple[int]]",
                          "Default": "1"
                        },
                        "padding": {
                          "Type": "typing.Union[str, int, typing.Tuple[int]]",
                          "Default": "0"
                        },
                        "dilation": {
                          "Type": "typing.Union[int, typing.Tuple[int]]",
                          "Default": "1"
                        },
                        "groups": {
                          "Type": "<class 'int'>",
                          "Default": "1"
                        },
                        "bias": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "padding_mode": {
                          "Type": "<class 'str'>",
                          "Default": "zeros"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Conv2d": {
                  "Doc": "Applies a 2D convolution over an input signal composed of several input\n    planes.\n\n    In the simplest case, the output value of the layer with input size\n    :math:`(N, C_{\\text{in}}, H, W)` and output :math:`(N, C_{\\text{out}}, H_{\\text{out}}, W_{\\text{out}})`\n    can be precisely described as:\n\n    .. math::\n        \\text{out}(N_i, C_{\\text{out}_j}) = \\text{bias}(C_{\\text{out}_j}) +\n        \\sum_{k = 0}^{C_{\\text{in}} - 1} \\text{weight}(C_{\\text{out}_j}, k) \\star \\text{input}(N_i, k)\n\n\n    where :math:`\\star` is the valid 2D `cross-correlation`_ operator,\n    :math:`N` is a batch size, :math:`C` denotes a number of channels,\n    :math:`H` is a height of input planes in pixels, and :math:`W` is\n    width in pixels.\n    \n\n    This module supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\n    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.\n\n    * :attr:`stride` controls the stride for the cross-correlation, a single\n      number or a tuple.\n\n    * :attr:`padding` controls the amount of padding applied to the input. It\n      can be either a string {'valid', 'same'} or a tuple of ints giving the\n      amount of implicit padding applied on both sides.\n\n    * :attr:`dilation` controls the spacing between the kernel points; also\n      known as the \u00e0 trous algorithm. It is harder to describe, but this `link`_\n      has a nice visualization of what :attr:`dilation` does.\n\n    * :attr:`groups` controls the connections between inputs and outputs.\n      :attr:`in_channels` and :attr:`out_channels` must both be divisible by\n      :attr:`groups`. For example,\n\n        * At groups=1, all inputs are convolved to all outputs.\n        * At groups=2, the operation becomes equivalent to having two conv\n          layers side by side, each seeing half the input channels\n          and producing half the output channels, and both subsequently\n          concatenated.\n        * At groups= :attr:`in_channels`, each input channel is convolved with\n          its own set of filters (of size\n          :math:`\\frac{\\text{out\\_channels}}{\\text{in\\_channels}}`).\n\n    The parameters :attr:`kernel_size`, :attr:`stride`, :attr:`padding`, :attr:`dilation` can either be:\n\n        - a single ``int`` -- in which case the same value is used for the height and width dimension\n        - a ``tuple`` of two ints -- in which case, the first `int` is used for the height dimension,\n          and the second `int` for the width dimension\n\n    Note:\n        When `groups == in_channels` and `out_channels == K * in_channels`,\n        where `K` is a positive integer, this operation is also known as a \"depthwise convolution\".\n\n        In other words, for an input of size :math:`(N, C_{in}, L_{in})`,\n        a depthwise convolution with a depthwise multiplier `K` can be performed with the arguments\n        :math:`(C_\\text{in}=C_\\text{in}, C_\\text{out}=C_\\text{in} \\times \\text{K}, ..., \\text{groups}=C_\\text{in})`.\n\n    Note:\n        In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.\n\n    Note:\n        ``padding='valid'`` is the same as no padding. ``padding='same'`` pads\n        the input so the output has the shape as the input. However, this mode\n        doesn't support any stride values other than 1.\n\n    Note:\n        This module supports complex data types i.e. ``complex32, complex64, complex128``.\n\n    Args:\n        in_channels (int): Number of channels in the input image\n        out_channels (int): Number of channels produced by the convolution\n        kernel_size (int or tuple): Size of the convolving kernel\n        stride (int or tuple, optional): Stride of the convolution. Default: 1\n        padding (int, tuple or str, optional): Padding added to all four sides of\n            the input. Default: 0\n        padding_mode (str, optional): ``'zeros'``, ``'reflect'``,\n            ``'replicate'`` or ``'circular'``. Default: ``'zeros'``\n        dilation (int or tuple, optional): Spacing between kernel elements. Default: 1\n        groups (int, optional): Number of blocked connections from input\n            channels to output channels. Default: 1\n        bias (bool, optional): If ``True``, adds a learnable bias to the\n            output. Default: ``True``\n    \n\n    Shape:\n        - Input: :math:`(N, C_{in}, H_{in}, W_{in})` or :math:`(C_{in}, H_{in}, W_{in})`\n        - Output: :math:`(N, C_{out}, H_{out}, W_{out})` or :math:`(C_{out}, H_{out}, W_{out})`, where\n\n          .. math::\n              H_{out} = \\left\\lfloor\\frac{H_{in}  + 2 \\times \\text{padding}[0] - \\text{dilation}[0]\n                        \\times (\\text{kernel\\_size}[0] - 1) - 1}{\\text{stride}[0]} + 1\\right\\rfloor\n\n          .. math::\n              W_{out} = \\left\\lfloor\\frac{W_{in}  + 2 \\times \\text{padding}[1] - \\text{dilation}[1]\n                        \\times (\\text{kernel\\_size}[1] - 1) - 1}{\\text{stride}[1]} + 1\\right\\rfloor\n\n    Attributes:\n        weight (Tensor): the learnable weights of the module of shape\n            :math:`(\\text{out\\_channels}, \\frac{\\text{in\\_channels}}{\\text{groups}},`\n            :math:`\\text{kernel\\_size[0]}, \\text{kernel\\_size[1]})`.\n            The values of these weights are sampled from\n            :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})` where\n            :math:`k = \\frac{groups}{C_\\text{in} * \\prod_{i=0}^{1}\\text{kernel\\_size}[i]}`\n        bias (Tensor):   the learnable bias of the module of shape\n            (out_channels). If :attr:`bias` is ``True``,\n            then the values of these weights are\n            sampled from :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})` where\n            :math:`k = \\frac{groups}{C_\\text{in} * \\prod_{i=0}^{1}\\text{kernel\\_size}[i]}`\n\n    Examples:\n\n        >>> # With square kernels and equal stride\n        >>> m = nn.Conv2d(16, 33, 3, stride=2)\n        >>> # non-square kernels and unequal stride and with padding\n        >>> m = nn.Conv2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2))\n        >>> # non-square kernels and unequal stride and with padding and dilation\n        >>> m = nn.Conv2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2), dilation=(3, 1))\n        >>> input = torch.randn(20, 16, 50, 100)\n        >>> output = m(input)\n\n    .. _cross-correlation:\n        https://en.wikipedia.org/wiki/Cross-correlation\n\n    .. _link:\n        https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "in_channels": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "out_channels": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "kernel_size": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": null
                        },
                        "stride": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": "1"
                        },
                        "padding": {
                          "Type": "typing.Union[str, int, typing.Tuple[int, int]]",
                          "Default": "0"
                        },
                        "dilation": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": "1"
                        },
                        "groups": {
                          "Type": "<class 'int'>",
                          "Default": "1"
                        },
                        "bias": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "padding_mode": {
                          "Type": "<class 'str'>",
                          "Default": "zeros"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Conv3d": {
                  "Doc": "Applies a 3D convolution over an input signal composed of several input\n    planes.\n\n    In the simplest case, the output value of the layer with input size :math:`(N, C_{in}, D, H, W)`\n    and output :math:`(N, C_{out}, D_{out}, H_{out}, W_{out})` can be precisely described as:\n\n    .. math::\n        out(N_i, C_{out_j}) = bias(C_{out_j}) +\n                                \\sum_{k = 0}^{C_{in} - 1} weight(C_{out_j}, k) \\star input(N_i, k)\n\n    where :math:`\\star` is the valid 3D `cross-correlation`_ operator\n    \n\n    This module supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\n    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.\n\n    * :attr:`stride` controls the stride for the cross-correlation.\n\n    * :attr:`padding` controls the amount of padding applied to the input. It\n      can be either a string {'valid', 'same'} or a tuple of ints giving the\n      amount of implicit padding applied on both sides.\n\n    * :attr:`dilation` controls the spacing between the kernel points; also known as the \u00e0 trous algorithm.\n      It is harder to describe, but this `link`_ has a nice visualization of what :attr:`dilation` does.\n\n    * :attr:`groups` controls the connections between inputs and outputs.\n      :attr:`in_channels` and :attr:`out_channels` must both be divisible by\n      :attr:`groups`. For example,\n\n        * At groups=1, all inputs are convolved to all outputs.\n        * At groups=2, the operation becomes equivalent to having two conv\n          layers side by side, each seeing half the input channels\n          and producing half the output channels, and both subsequently\n          concatenated.\n        * At groups= :attr:`in_channels`, each input channel is convolved with\n          its own set of filters (of size\n          :math:`\\frac{\\text{out\\_channels}}{\\text{in\\_channels}}`).\n\n    The parameters :attr:`kernel_size`, :attr:`stride`, :attr:`padding`, :attr:`dilation` can either be:\n\n        - a single ``int`` -- in which case the same value is used for the depth, height and width dimension\n        - a ``tuple`` of three ints -- in which case, the first `int` is used for the depth dimension,\n          the second `int` for the height dimension and the third `int` for the width dimension\n\n    Note:\n        When `groups == in_channels` and `out_channels == K * in_channels`,\n        where `K` is a positive integer, this operation is also known as a \"depthwise convolution\".\n\n        In other words, for an input of size :math:`(N, C_{in}, L_{in})`,\n        a depthwise convolution with a depthwise multiplier `K` can be performed with the arguments\n        :math:`(C_\\text{in}=C_\\text{in}, C_\\text{out}=C_\\text{in} \\times \\text{K}, ..., \\text{groups}=C_\\text{in})`.\n\n    Note:\n        In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.\n\n    Note:\n        ``padding='valid'`` is the same as no padding. ``padding='same'`` pads\n        the input so the output has the shape as the input. However, this mode\n        doesn't support any stride values other than 1.\n\n    Note:\n        This module supports complex data types i.e. ``complex32, complex64, complex128``.\n\n    Args:\n        in_channels (int): Number of channels in the input image\n        out_channels (int): Number of channels produced by the convolution\n        kernel_size (int or tuple): Size of the convolving kernel\n        stride (int or tuple, optional): Stride of the convolution. Default: 1\n        padding (int, tuple or str, optional): Padding added to all six sides of\n            the input. Default: 0\n        padding_mode (str, optional): ``'zeros'``, ``'reflect'``, ``'replicate'`` or ``'circular'``. Default: ``'zeros'``\n        dilation (int or tuple, optional): Spacing between kernel elements. Default: 1\n        groups (int, optional): Number of blocked connections from input channels to output channels. Default: 1\n        bias (bool, optional): If ``True``, adds a learnable bias to the output. Default: ``True``\n    \n\n    Shape:\n        - Input: :math:`(N, C_{in}, D_{in}, H_{in}, W_{in})` or :math:`(C_{in}, D_{in}, H_{in}, W_{in})`\n        - Output: :math:`(N, C_{out}, D_{out}, H_{out}, W_{out})` or :math:`(C_{out}, D_{out}, H_{out}, W_{out})`,\n          where\n\n          .. math::\n              D_{out} = \\left\\lfloor\\frac{D_{in} + 2 \\times \\text{padding}[0] - \\text{dilation}[0]\n                    \\times (\\text{kernel\\_size}[0] - 1) - 1}{\\text{stride}[0]} + 1\\right\\rfloor\n\n          .. math::\n              H_{out} = \\left\\lfloor\\frac{H_{in} + 2 \\times \\text{padding}[1] - \\text{dilation}[1]\n                    \\times (\\text{kernel\\_size}[1] - 1) - 1}{\\text{stride}[1]} + 1\\right\\rfloor\n\n          .. math::\n              W_{out} = \\left\\lfloor\\frac{W_{in} + 2 \\times \\text{padding}[2] - \\text{dilation}[2]\n                    \\times (\\text{kernel\\_size}[2] - 1) - 1}{\\text{stride}[2]} + 1\\right\\rfloor\n\n    Attributes:\n        weight (Tensor): the learnable weights of the module of shape\n                         :math:`(\\text{out\\_channels}, \\frac{\\text{in\\_channels}}{\\text{groups}},`\n                         :math:`\\text{kernel\\_size[0]}, \\text{kernel\\_size[1]}, \\text{kernel\\_size[2]})`.\n                         The values of these weights are sampled from\n                         :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})` where\n                         :math:`k = \\frac{groups}{C_\\text{in} * \\prod_{i=0}^{2}\\text{kernel\\_size}[i]}`\n        bias (Tensor):   the learnable bias of the module of shape (out_channels). If :attr:`bias` is ``True``,\n                         then the values of these weights are\n                         sampled from :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})` where\n                         :math:`k = \\frac{groups}{C_\\text{in} * \\prod_{i=0}^{2}\\text{kernel\\_size}[i]}`\n\n    Examples::\n\n        >>> # With square kernels and equal stride\n        >>> m = nn.Conv3d(16, 33, 3, stride=2)\n        >>> # non-square kernels and unequal stride and with padding\n        >>> m = nn.Conv3d(16, 33, (3, 5, 2), stride=(2, 1, 1), padding=(4, 2, 0))\n        >>> input = torch.randn(20, 16, 10, 50, 100)\n        >>> output = m(input)\n\n    .. _cross-correlation:\n        https://en.wikipedia.org/wiki/Cross-correlation\n\n    .. _link:\n        https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "in_channels": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "out_channels": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "kernel_size": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int]]",
                          "Default": null
                        },
                        "stride": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int]]",
                          "Default": "1"
                        },
                        "padding": {
                          "Type": "typing.Union[str, int, typing.Tuple[int, int, int]]",
                          "Default": "0"
                        },
                        "dilation": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int]]",
                          "Default": "1"
                        },
                        "groups": {
                          "Type": "<class 'int'>",
                          "Default": "1"
                        },
                        "bias": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "padding_mode": {
                          "Type": "<class 'str'>",
                          "Default": "zeros"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "ConvTranspose1d": {
                  "Doc": "Applies a 1D transposed convolution operator over an input image\n    composed of several input planes.\n\n    This module can be seen as the gradient of Conv1d with respect to its input.\n    It is also known as a fractionally-strided convolution or\n    a deconvolution (although it is not an actual deconvolution operation as it does\n    not compute a true inverse of convolution). For more information, see the visualizations\n    `here`_ and the `Deconvolutional Networks`_ paper.\n\n    This module supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\n    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.\n\n    * :attr:`stride` controls the stride for the cross-correlation.\n\n    * :attr:`padding` controls the amount of implicit zero padding on both\n      sides for ``dilation * (kernel_size - 1) - padding`` number of points. See note\n      below for details.\n\n    * :attr:`output_padding` controls the additional size added to one side\n      of the output shape. See note below for details.\n\n    * :attr:`dilation` controls the spacing between the kernel points; also known as the \u00e0 trous algorithm.\n      It is harder to describe, but the link `here`_ has a nice visualization of what :attr:`dilation` does.\n\n    * :attr:`groups` controls the connections between inputs and outputs.\n      :attr:`in_channels` and :attr:`out_channels` must both be divisible by\n      :attr:`groups`. For example,\n\n        * At groups=1, all inputs are convolved to all outputs.\n        * At groups=2, the operation becomes equivalent to having two conv\n          layers side by side, each seeing half the input channels\n          and producing half the output channels, and both subsequently\n          concatenated.\n        * At groups= :attr:`in_channels`, each input channel is convolved with\n          its own set of filters (of size\n          :math:`\\frac{\\text{out\\_channels}}{\\text{in\\_channels}}`).\n\n    Note:\n        The :attr:`padding` argument effectively adds ``dilation * (kernel_size - 1) - padding``\n        amount of zero padding to both sizes of the input. This is set so that\n        when a :class:`~torch.nn.Conv1d` and a :class:`~torch.nn.ConvTranspose1d`\n        are initialized with same parameters, they are inverses of each other in\n        regard to the input and output shapes. However, when ``stride > 1``,\n        :class:`~torch.nn.Conv1d` maps multiple input shapes to the same output\n        shape. :attr:`output_padding` is provided to resolve this ambiguity by\n        effectively increasing the calculated output shape on one side. Note\n        that :attr:`output_padding` is only used to find output shape, but does\n        not actually add zero-padding to output.\n\n    Note:\n        In some circumstances when using the CUDA backend with CuDNN, this operator\n        may select a nondeterministic algorithm to increase performance. If this is\n        undesirable, you can try to make the operation deterministic (potentially at\n        a performance cost) by setting ``torch.backends.cudnn.deterministic =\n        True``.\n        Please see the notes on :doc:`/notes/randomness` for background.\n\n\n    Args:\n        in_channels (int): Number of channels in the input image\n        out_channels (int): Number of channels produced by the convolution\n        kernel_size (int or tuple): Size of the convolving kernel\n        stride (int or tuple, optional): Stride of the convolution. Default: 1\n        padding (int or tuple, optional): ``dilation * (kernel_size - 1) - padding`` zero-padding\n            will be added to both sides of the input. Default: 0\n        output_padding (int or tuple, optional): Additional size added to one side\n            of the output shape. Default: 0\n        groups (int, optional): Number of blocked connections from input channels to output channels. Default: 1\n        bias (bool, optional): If ``True``, adds a learnable bias to the output. Default: ``True``\n        dilation (int or tuple, optional): Spacing between kernel elements. Default: 1\n    \n\n    Shape:\n        - Input: :math:`(N, C_{in}, L_{in})` or :math:`(C_{in}, L_{in})`\n        - Output: :math:`(N, C_{out}, L_{out})` or :math:`(C_{out}, L_{out})`, where\n\n          .. math::\n              L_{out} = (L_{in} - 1) \\times \\text{stride} - 2 \\times \\text{padding} + \\text{dilation}\n                        \\times (\\text{kernel\\_size} - 1) + \\text{output\\_padding} + 1\n\n    Attributes:\n        weight (Tensor): the learnable weights of the module of shape\n                         :math:`(\\text{in\\_channels}, \\frac{\\text{out\\_channels}}{\\text{groups}},`\n                         :math:`\\text{kernel\\_size})`.\n                         The values of these weights are sampled from\n                         :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})` where\n                         :math:`k = \\frac{groups}{C_\\text{out} * \\text{kernel\\_size}}`\n        bias (Tensor):   the learnable bias of the module of shape (out_channels).\n                         If :attr:`bias` is ``True``, then the values of these weights are\n                         sampled from :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})` where\n                         :math:`k = \\frac{groups}{C_\\text{out} * \\text{kernel\\_size}}`\n\n    .. _`here`:\n        https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md\n\n    .. _`Deconvolutional Networks`:\n        https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "in_channels": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "out_channels": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "kernel_size": {
                          "Type": "typing.Union[int, typing.Tuple[int]]",
                          "Default": null
                        },
                        "stride": {
                          "Type": "typing.Union[int, typing.Tuple[int]]",
                          "Default": "1"
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int]]",
                          "Default": "0"
                        },
                        "output_padding": {
                          "Type": "typing.Union[int, typing.Tuple[int]]",
                          "Default": "0"
                        },
                        "groups": {
                          "Type": "<class 'int'>",
                          "Default": "1"
                        },
                        "bias": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "dilation": {
                          "Type": "typing.Union[int, typing.Tuple[int]]",
                          "Default": "1"
                        },
                        "padding_mode": {
                          "Type": "<class 'str'>",
                          "Default": "zeros"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "output_size": {
                          "Type": "typing.Optional[typing.List[int]]",
                          "Default": "None"
                        }
                      }
                    }
                  }
                },
                "ConvTranspose2d": {
                  "Doc": "Applies a 2D transposed convolution operator over an input image\n    composed of several input planes.\n\n    This module can be seen as the gradient of Conv2d with respect to its input.\n    It is also known as a fractionally-strided convolution or\n    a deconvolution (although it is not an actual deconvolution operation as it does\n    not compute a true inverse of convolution). For more information, see the visualizations\n    `here`_ and the `Deconvolutional Networks`_ paper.\n\n    This module supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\n    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.\n\n    * :attr:`stride` controls the stride for the cross-correlation.\n\n    * :attr:`padding` controls the amount of implicit zero padding on both\n      sides for ``dilation * (kernel_size - 1) - padding`` number of points. See note\n      below for details.\n\n    * :attr:`output_padding` controls the additional size added to one side\n      of the output shape. See note below for details.\n\n    * :attr:`dilation` controls the spacing between the kernel points; also known as the \u00e0 trous algorithm.\n      It is harder to describe, but the link `here`_ has a nice visualization of what :attr:`dilation` does.\n\n    * :attr:`groups` controls the connections between inputs and outputs.\n      :attr:`in_channels` and :attr:`out_channels` must both be divisible by\n      :attr:`groups`. For example,\n\n        * At groups=1, all inputs are convolved to all outputs.\n        * At groups=2, the operation becomes equivalent to having two conv\n          layers side by side, each seeing half the input channels\n          and producing half the output channels, and both subsequently\n          concatenated.\n        * At groups= :attr:`in_channels`, each input channel is convolved with\n          its own set of filters (of size\n          :math:`\\frac{\\text{out\\_channels}}{\\text{in\\_channels}}`).\n\n    The parameters :attr:`kernel_size`, :attr:`stride`, :attr:`padding`, :attr:`output_padding`\n    can either be:\n\n        - a single ``int`` -- in which case the same value is used for the height and width dimensions\n        - a ``tuple`` of two ints -- in which case, the first `int` is used for the height dimension,\n          and the second `int` for the width dimension\n\n    Note:\n        The :attr:`padding` argument effectively adds ``dilation * (kernel_size - 1) - padding``\n        amount of zero padding to both sizes of the input. This is set so that\n        when a :class:`~torch.nn.Conv2d` and a :class:`~torch.nn.ConvTranspose2d`\n        are initialized with same parameters, they are inverses of each other in\n        regard to the input and output shapes. However, when ``stride > 1``,\n        :class:`~torch.nn.Conv2d` maps multiple input shapes to the same output\n        shape. :attr:`output_padding` is provided to resolve this ambiguity by\n        effectively increasing the calculated output shape on one side. Note\n        that :attr:`output_padding` is only used to find output shape, but does\n        not actually add zero-padding to output.\n\n    Note:\n        In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.\n\n    Args:\n        in_channels (int): Number of channels in the input image\n        out_channels (int): Number of channels produced by the convolution\n        kernel_size (int or tuple): Size of the convolving kernel\n        stride (int or tuple, optional): Stride of the convolution. Default: 1\n        padding (int or tuple, optional): ``dilation * (kernel_size - 1) - padding`` zero-padding\n            will be added to both sides of each dimension in the input. Default: 0\n        output_padding (int or tuple, optional): Additional size added to one side\n            of each dimension in the output shape. Default: 0\n        groups (int, optional): Number of blocked connections from input channels to output channels. Default: 1\n        bias (bool, optional): If ``True``, adds a learnable bias to the output. Default: ``True``\n        dilation (int or tuple, optional): Spacing between kernel elements. Default: 1\n    \n\n    Shape:\n        - Input: :math:`(N, C_{in}, H_{in}, W_{in})` or :math:`(C_{in}, H_{in}, W_{in})`\n        - Output: :math:`(N, C_{out}, H_{out}, W_{out})` or :math:`(C_{out}, H_{out}, W_{out})`, where\n\n        .. math::\n              H_{out} = (H_{in} - 1) \\times \\text{stride}[0] - 2 \\times \\text{padding}[0] + \\text{dilation}[0]\n                        \\times (\\text{kernel\\_size}[0] - 1) + \\text{output\\_padding}[0] + 1\n        .. math::\n              W_{out} = (W_{in} - 1) \\times \\text{stride}[1] - 2 \\times \\text{padding}[1] + \\text{dilation}[1]\n                        \\times (\\text{kernel\\_size}[1] - 1) + \\text{output\\_padding}[1] + 1\n\n    Attributes:\n        weight (Tensor): the learnable weights of the module of shape\n                         :math:`(\\text{in\\_channels}, \\frac{\\text{out\\_channels}}{\\text{groups}},`\n                         :math:`\\text{kernel\\_size[0]}, \\text{kernel\\_size[1]})`.\n                         The values of these weights are sampled from\n                         :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})` where\n                         :math:`k = \\frac{groups}{C_\\text{out} * \\prod_{i=0}^{1}\\text{kernel\\_size}[i]}`\n        bias (Tensor):   the learnable bias of the module of shape (out_channels)\n                         If :attr:`bias` is ``True``, then the values of these weights are\n                         sampled from :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})` where\n                         :math:`k = \\frac{groups}{C_\\text{out} * \\prod_{i=0}^{1}\\text{kernel\\_size}[i]}`\n\n    Examples::\n\n        >>> # With square kernels and equal stride\n        >>> m = nn.ConvTranspose2d(16, 33, 3, stride=2)\n        >>> # non-square kernels and unequal stride and with padding\n        >>> m = nn.ConvTranspose2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2))\n        >>> input = torch.randn(20, 16, 50, 100)\n        >>> output = m(input)\n        >>> # exact output size can be also specified as an argument\n        >>> input = torch.randn(1, 16, 12, 12)\n        >>> downsample = nn.Conv2d(16, 16, 3, stride=2, padding=1)\n        >>> upsample = nn.ConvTranspose2d(16, 16, 3, stride=2, padding=1)\n        >>> h = downsample(input)\n        >>> h.size()\n        torch.Size([1, 16, 6, 6])\n        >>> output = upsample(h, output_size=input.size())\n        >>> output.size()\n        torch.Size([1, 16, 12, 12])\n\n    .. _`here`:\n        https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md\n\n    .. _`Deconvolutional Networks`:\n        https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "in_channels": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "out_channels": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "kernel_size": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": null
                        },
                        "stride": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": "1"
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": "0"
                        },
                        "output_padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": "0"
                        },
                        "groups": {
                          "Type": "<class 'int'>",
                          "Default": "1"
                        },
                        "bias": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "dilation": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": "1"
                        },
                        "padding_mode": {
                          "Type": "<class 'str'>",
                          "Default": "zeros"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "output_size": {
                          "Type": "typing.Optional[typing.List[int]]",
                          "Default": "None"
                        }
                      }
                    }
                  }
                },
                "ConvTranspose3d": {
                  "Doc": "Applies a 3D transposed convolution operator over an input image composed of several input\n    planes.\n    The transposed convolution operator multiplies each input value element-wise by a learnable kernel,\n    and sums over the outputs from all input feature planes.\n\n    This module can be seen as the gradient of Conv3d with respect to its input.\n    It is also known as a fractionally-strided convolution or\n    a deconvolution (although it is not an actual deconvolution operation as it does\n    not compute a true inverse of convolution). For more information, see the visualizations\n    `here`_ and the `Deconvolutional Networks`_ paper.\n\n    This module supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\n    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.\n\n    * :attr:`stride` controls the stride for the cross-correlation.\n\n    * :attr:`padding` controls the amount of implicit zero padding on both\n      sides for ``dilation * (kernel_size - 1) - padding`` number of points. See note\n      below for details.\n\n    * :attr:`output_padding` controls the additional size added to one side\n      of the output shape. See note below for details.\n\n    * :attr:`dilation` controls the spacing between the kernel points; also known as the \u00e0 trous algorithm.\n      It is harder to describe, but the link `here`_ has a nice visualization of what :attr:`dilation` does.\n\n    * :attr:`groups` controls the connections between inputs and outputs.\n      :attr:`in_channels` and :attr:`out_channels` must both be divisible by\n      :attr:`groups`. For example,\n\n        * At groups=1, all inputs are convolved to all outputs.\n        * At groups=2, the operation becomes equivalent to having two conv\n          layers side by side, each seeing half the input channels\n          and producing half the output channels, and both subsequently\n          concatenated.\n        * At groups= :attr:`in_channels`, each input channel is convolved with\n          its own set of filters (of size\n          :math:`\\frac{\\text{out\\_channels}}{\\text{in\\_channels}}`).\n\n    The parameters :attr:`kernel_size`, :attr:`stride`, :attr:`padding`, :attr:`output_padding`\n    can either be:\n\n        - a single ``int`` -- in which case the same value is used for the depth, height and width dimensions\n        - a ``tuple`` of three ints -- in which case, the first `int` is used for the depth dimension,\n          the second `int` for the height dimension and the third `int` for the width dimension\n\n    Note:\n        The :attr:`padding` argument effectively adds ``dilation * (kernel_size - 1) - padding``\n        amount of zero padding to both sizes of the input. This is set so that\n        when a :class:`~torch.nn.Conv3d` and a :class:`~torch.nn.ConvTranspose3d`\n        are initialized with same parameters, they are inverses of each other in\n        regard to the input and output shapes. However, when ``stride > 1``,\n        :class:`~torch.nn.Conv3d` maps multiple input shapes to the same output\n        shape. :attr:`output_padding` is provided to resolve this ambiguity by\n        effectively increasing the calculated output shape on one side. Note\n        that :attr:`output_padding` is only used to find output shape, but does\n        not actually add zero-padding to output.\n\n    Note:\n        In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting ``torch.backends.cudnn.deterministic = True``. See :doc:`/notes/randomness` for more information.\n\n    Args:\n        in_channels (int): Number of channels in the input image\n        out_channels (int): Number of channels produced by the convolution\n        kernel_size (int or tuple): Size of the convolving kernel\n        stride (int or tuple, optional): Stride of the convolution. Default: 1\n        padding (int or tuple, optional): ``dilation * (kernel_size - 1) - padding`` zero-padding\n            will be added to both sides of each dimension in the input. Default: 0\n        output_padding (int or tuple, optional): Additional size added to one side\n            of each dimension in the output shape. Default: 0\n        groups (int, optional): Number of blocked connections from input channels to output channels. Default: 1\n        bias (bool, optional): If ``True``, adds a learnable bias to the output. Default: ``True``\n        dilation (int or tuple, optional): Spacing between kernel elements. Default: 1\n    \n\n    Shape:\n        - Input: :math:`(N, C_{in}, D_{in}, H_{in}, W_{in})` or :math:`(C_{in}, D_{in}, H_{in}, W_{in})`\n        - Output: :math:`(N, C_{out}, D_{out}, H_{out}, W_{out})` or\n          :math:`(C_{out}, D_{out}, H_{out}, W_{out})`, where\n\n        .. math::\n              D_{out} = (D_{in} - 1) \\times \\text{stride}[0] - 2 \\times \\text{padding}[0] + \\text{dilation}[0]\n                        \\times (\\text{kernel\\_size}[0] - 1) + \\text{output\\_padding}[0] + 1\n        .. math::\n              H_{out} = (H_{in} - 1) \\times \\text{stride}[1] - 2 \\times \\text{padding}[1] + \\text{dilation}[1]\n                        \\times (\\text{kernel\\_size}[1] - 1) + \\text{output\\_padding}[1] + 1\n        .. math::\n              W_{out} = (W_{in} - 1) \\times \\text{stride}[2] - 2 \\times \\text{padding}[2] + \\text{dilation}[2]\n                        \\times (\\text{kernel\\_size}[2] - 1) + \\text{output\\_padding}[2] + 1\n\n\n    Attributes:\n        weight (Tensor): the learnable weights of the module of shape\n                         :math:`(\\text{in\\_channels}, \\frac{\\text{out\\_channels}}{\\text{groups}},`\n                         :math:`\\text{kernel\\_size[0]}, \\text{kernel\\_size[1]}, \\text{kernel\\_size[2]})`.\n                         The values of these weights are sampled from\n                         :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})` where\n                         :math:`k = \\frac{groups}{C_\\text{out} * \\prod_{i=0}^{2}\\text{kernel\\_size}[i]}`\n        bias (Tensor):   the learnable bias of the module of shape (out_channels)\n                         If :attr:`bias` is ``True``, then the values of these weights are\n                         sampled from :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})` where\n                         :math:`k = \\frac{groups}{C_\\text{out} * \\prod_{i=0}^{2}\\text{kernel\\_size}[i]}`\n\n    Examples::\n\n        >>> # With square kernels and equal stride\n        >>> m = nn.ConvTranspose3d(16, 33, 3, stride=2)\n        >>> # non-square kernels and unequal stride and with padding\n        >>> m = nn.ConvTranspose3d(16, 33, (3, 5, 2), stride=(2, 1, 1), padding=(0, 4, 2))\n        >>> input = torch.randn(20, 16, 10, 50, 100)\n        >>> output = m(input)\n\n    .. _`here`:\n        https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md\n\n    .. _`Deconvolutional Networks`:\n        https://www.matthewzeiler.com/mattzeiler/deconvolutionalnetworks.pdf\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "in_channels": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "out_channels": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "kernel_size": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int]]",
                          "Default": null
                        },
                        "stride": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int]]",
                          "Default": "1"
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int]]",
                          "Default": "0"
                        },
                        "output_padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int]]",
                          "Default": "0"
                        },
                        "groups": {
                          "Type": "<class 'int'>",
                          "Default": "1"
                        },
                        "bias": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "dilation": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int]]",
                          "Default": "1"
                        },
                        "padding_mode": {
                          "Type": "<class 'str'>",
                          "Default": "zeros"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "output_size": {
                          "Type": "typing.Optional[typing.List[int]]",
                          "Default": "None"
                        }
                      }
                    }
                  }
                },
                "LazyConv1d": {
                  "Doc": "A :class:`torch.nn.Conv1d` module with lazy initialization of\n    the ``in_channels`` argument of the :class:`Conv1d` that is inferred from\n    the ``input.size(1)``.\n    The attributes that will be lazily initialized are `weight` and `bias`.\n\n    Check the :class:`torch.nn.modules.lazy.LazyModuleMixin` for further documentation\n    on lazy modules and their limitations.\n\n    Args:\n        out_channels (int): Number of channels produced by the convolution\n        kernel_size (int or tuple): Size of the convolving kernel\n        stride (int or tuple, optional): Stride of the convolution. Default: 1\n        padding (int or tuple, optional): Zero-padding added to both sides of\n            the input. Default: 0\n        padding_mode (str, optional): ``'zeros'``, ``'reflect'``,\n            ``'replicate'`` or ``'circular'``. Default: ``'zeros'``\n        dilation (int or tuple, optional): Spacing between kernel\n            elements. Default: 1\n        groups (int, optional): Number of blocked connections from input\n            channels to output channels. Default: 1\n        bias (bool, optional): If ``True``, adds a learnable bias to the\n            output. Default: ``True``\n\n    .. seealso:: :class:`torch.nn.Conv1d` and :class:`torch.nn.modules.lazy.LazyModuleMixin`\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "out_channels": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "kernel_size": {
                          "Type": "typing.Union[int, typing.Tuple[int]]",
                          "Default": null
                        },
                        "stride": {
                          "Type": "typing.Union[int, typing.Tuple[int]]",
                          "Default": "1"
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int]]",
                          "Default": "0"
                        },
                        "dilation": {
                          "Type": "typing.Union[int, typing.Tuple[int]]",
                          "Default": "1"
                        },
                        "groups": {
                          "Type": "<class 'int'>",
                          "Default": "1"
                        },
                        "bias": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "padding_mode": {
                          "Type": "<class 'str'>",
                          "Default": "zeros"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    }
                  }
                },
                "LazyConv2d": {
                  "Doc": "A :class:`torch.nn.Conv2d` module with lazy initialization of\n    the ``in_channels`` argument of the :class:`Conv2d` that is inferred from\n    the ``input.size(1)``.\n    The attributes that will be lazily initialized are `weight` and `bias`.\n\n    Check the :class:`torch.nn.modules.lazy.LazyModuleMixin` for further documentation\n    on lazy modules and their limitations.\n\n    Args:\n        out_channels (int): Number of channels produced by the convolution\n        kernel_size (int or tuple): Size of the convolving kernel\n        stride (int or tuple, optional): Stride of the convolution. Default: 1\n        padding (int or tuple, optional): Zero-padding added to both sides of\n            the input. Default: 0\n        padding_mode (str, optional): ``'zeros'``, ``'reflect'``,\n            ``'replicate'`` or ``'circular'``. Default: ``'zeros'``\n        dilation (int or tuple, optional): Spacing between kernel\n            elements. Default: 1\n        groups (int, optional): Number of blocked connections from input\n            channels to output channels. Default: 1\n        bias (bool, optional): If ``True``, adds a learnable bias to the\n            output. Default: ``True``\n\n    .. seealso:: :class:`torch.nn.Conv2d` and :class:`torch.nn.modules.lazy.LazyModuleMixin`\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "out_channels": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "kernel_size": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": null
                        },
                        "stride": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": "1"
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": "0"
                        },
                        "dilation": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": "1"
                        },
                        "groups": {
                          "Type": "<class 'int'>",
                          "Default": "1"
                        },
                        "bias": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "padding_mode": {
                          "Type": "<class 'str'>",
                          "Default": "zeros"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    }
                  }
                },
                "LazyConv3d": {
                  "Doc": "A :class:`torch.nn.Conv3d` module with lazy initialization of\n    the ``in_channels`` argument of the :class:`Conv3d` that is inferred from\n    the ``input.size(1)``.\n    The attributes that will be lazily initialized are `weight` and `bias`.\n\n    Check the :class:`torch.nn.modules.lazy.LazyModuleMixin` for further documentation\n    on lazy modules and their limitations.\n\n    Args:\n        out_channels (int): Number of channels produced by the convolution\n        kernel_size (int or tuple): Size of the convolving kernel\n        stride (int or tuple, optional): Stride of the convolution. Default: 1\n        padding (int or tuple, optional): Zero-padding added to both sides of\n            the input. Default: 0\n        padding_mode (str, optional): ``'zeros'``, ``'reflect'``,\n            ``'replicate'`` or ``'circular'``. Default: ``'zeros'``\n        dilation (int or tuple, optional): Spacing between kernel\n            elements. Default: 1\n        groups (int, optional): Number of blocked connections from input\n            channels to output channels. Default: 1\n        bias (bool, optional): If ``True``, adds a learnable bias to the\n            output. Default: ``True``\n\n    .. seealso:: :class:`torch.nn.Conv3d` and :class:`torch.nn.modules.lazy.LazyModuleMixin`\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "out_channels": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "kernel_size": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int]]",
                          "Default": null
                        },
                        "stride": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int]]",
                          "Default": "1"
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int]]",
                          "Default": "0"
                        },
                        "dilation": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int]]",
                          "Default": "1"
                        },
                        "groups": {
                          "Type": "<class 'int'>",
                          "Default": "1"
                        },
                        "bias": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "padding_mode": {
                          "Type": "<class 'str'>",
                          "Default": "zeros"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    }
                  }
                },
                "LazyConvTranspose1d": {
                  "Doc": "A :class:`torch.nn.ConvTranspose1d` module with lazy initialization of\n    the ``in_channels`` argument of the :class:`ConvTranspose1d` that is inferred from\n    the ``input.size(1)``.\n    The attributes that will be lazily initialized are `weight` and `bias`.\n\n    Check the :class:`torch.nn.modules.lazy.LazyModuleMixin` for further documentation\n    on lazy modules and their limitations.\n\n    Args:\n        out_channels (int): Number of channels produced by the convolution\n        kernel_size (int or tuple): Size of the convolving kernel\n        stride (int or tuple, optional): Stride of the convolution. Default: 1\n        padding (int or tuple, optional): ``dilation * (kernel_size - 1) - padding`` zero-padding\n            will be added to both sides of the input. Default: 0\n        output_padding (int or tuple, optional): Additional size added to one side\n            of the output shape. Default: 0\n        groups (int, optional): Number of blocked connections from input channels to output channels. Default: 1\n        bias (bool, optional): If ``True``, adds a learnable bias to the output. Default: ``True``\n        dilation (int or tuple, optional): Spacing between kernel elements. Default: 1\n\n    .. seealso:: :class:`torch.nn.ConvTranspose1d` and :class:`torch.nn.modules.lazy.LazyModuleMixin`\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "out_channels": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "kernel_size": {
                          "Type": "typing.Union[int, typing.Tuple[int]]",
                          "Default": null
                        },
                        "stride": {
                          "Type": "typing.Union[int, typing.Tuple[int]]",
                          "Default": "1"
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int]]",
                          "Default": "0"
                        },
                        "output_padding": {
                          "Type": "typing.Union[int, typing.Tuple[int]]",
                          "Default": "0"
                        },
                        "groups": {
                          "Type": "<class 'int'>",
                          "Default": "1"
                        },
                        "bias": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "dilation": {
                          "Type": "typing.Union[int, typing.Tuple[int]]",
                          "Default": "1"
                        },
                        "padding_mode": {
                          "Type": "<class 'str'>",
                          "Default": "zeros"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    }
                  }
                },
                "LazyConvTranspose2d": {
                  "Doc": "A :class:`torch.nn.ConvTranspose2d` module with lazy initialization of\n    the ``in_channels`` argument of the :class:`ConvTranspose2d` that is inferred from\n    the ``input.size(1)``.\n    The attributes that will be lazily initialized are `weight` and `bias`.\n\n    Check the :class:`torch.nn.modules.lazy.LazyModuleMixin` for further documentation\n    on lazy modules and their limitations.\n\n    Args:\n        out_channels (int): Number of channels produced by the convolution\n        kernel_size (int or tuple): Size of the convolving kernel\n        stride (int or tuple, optional): Stride of the convolution. Default: 1\n        padding (int or tuple, optional): ``dilation * (kernel_size - 1) - padding`` zero-padding\n            will be added to both sides of each dimension in the input. Default: 0\n        output_padding (int or tuple, optional): Additional size added to one side\n            of each dimension in the output shape. Default: 0\n        groups (int, optional): Number of blocked connections from input channels to output channels. Default: 1\n        bias (bool, optional): If ``True``, adds a learnable bias to the output. Default: ``True``\n        dilation (int or tuple, optional): Spacing between kernel elements. Default: 1\n\n    .. seealso:: :class:`torch.nn.ConvTranspose2d` and :class:`torch.nn.modules.lazy.LazyModuleMixin`\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "out_channels": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "kernel_size": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": null
                        },
                        "stride": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": "1"
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": "0"
                        },
                        "output_padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": "0"
                        },
                        "groups": {
                          "Type": "<class 'int'>",
                          "Default": "1"
                        },
                        "bias": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "dilation": {
                          "Type": "<class 'int'>",
                          "Default": "1"
                        },
                        "padding_mode": {
                          "Type": "<class 'str'>",
                          "Default": "zeros"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    }
                  }
                },
                "LazyConvTranspose3d": {
                  "Doc": "A :class:`torch.nn.ConvTranspose3d` module with lazy initialization of\n    the ``in_channels`` argument of the :class:`ConvTranspose3d` that is inferred from\n    the ``input.size(1)``.\n    The attributes that will be lazily initialized are `weight` and `bias`.\n\n    Check the :class:`torch.nn.modules.lazy.LazyModuleMixin` for further documentation\n    on lazy modules and their limitations.\n\n    Args:\n        out_channels (int): Number of channels produced by the convolution\n        kernel_size (int or tuple): Size of the convolving kernel\n        stride (int or tuple, optional): Stride of the convolution. Default: 1\n        padding (int or tuple, optional): ``dilation * (kernel_size - 1) - padding`` zero-padding\n            will be added to both sides of each dimension in the input. Default: 0\n        output_padding (int or tuple, optional): Additional size added to one side\n            of each dimension in the output shape. Default: 0\n        groups (int, optional): Number of blocked connections from input channels to output channels. Default: 1\n        bias (bool, optional): If ``True``, adds a learnable bias to the output. Default: ``True``\n        dilation (int or tuple, optional): Spacing between kernel elements. Default: 1\n\n    .. seealso:: :class:`torch.nn.ConvTranspose3d` and :class:`torch.nn.modules.lazy.LazyModuleMixin`\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "out_channels": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "kernel_size": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int]]",
                          "Default": null
                        },
                        "stride": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int]]",
                          "Default": "1"
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int]]",
                          "Default": "0"
                        },
                        "output_padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int]]",
                          "Default": "0"
                        },
                        "groups": {
                          "Type": "<class 'int'>",
                          "Default": "1"
                        },
                        "bias": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "dilation": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int]]",
                          "Default": "1"
                        },
                        "padding_mode": {
                          "Type": "<class 'str'>",
                          "Default": "zeros"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    }
                  }
                }
              }
            },
            "distance": {
              "Doc": null,
              "Classes": {
                "CosineSimilarity": {
                  "Doc": "Returns cosine similarity between :math:`x_1` and :math:`x_2`, computed along `dim`.\n\n    .. math ::\n        \\text{similarity} = \\dfrac{x_1 \\cdot x_2}{\\max(\\Vert x_1 \\Vert _2 \\cdot \\Vert x_2 \\Vert _2, \\epsilon)}.\n\n    Args:\n        dim (int, optional): Dimension where cosine similarity is computed. Default: 1\n        eps (float, optional): Small value to avoid division by zero.\n            Default: 1e-8\n    Shape:\n        - Input1: :math:`(\\ast_1, D, \\ast_2)` where D is at position `dim`\n        - Input2: :math:`(\\ast_1, D, \\ast_2)`, same number of dimensions as x1, matching x1 size at dimension `dim`,\n              and broadcastable with x1 at other dimensions.\n        - Output: :math:`(\\ast_1, \\ast_2)`\n    Examples::\n        >>> input1 = torch.randn(100, 128)\n        >>> input2 = torch.randn(100, 128)\n        >>> cos = nn.CosineSimilarity(dim=1, eps=1e-6)\n        >>> output = cos(input1, input2)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "dim": {
                          "Type": "<class 'int'>",
                          "Default": "1"
                        },
                        "eps": {
                          "Type": "<class 'float'>",
                          "Default": "1e-08"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "x1": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "x2": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "PairwiseDistance": {
                  "Doc": "\n    Computes the pairwise distance between input vectors, or between columns of input matrices.\n\n    Distances are computed using ``p``-norm, with constant ``eps`` added to avoid division by zero\n    if ``p`` is negative, i.e.:\n\n    .. math ::\n        \\mathrm{dist}\\left(x, y\\right) = \\left\\Vert x-y + \\epsilon e \\right\\Vert_p,\n\n    where :math:`e` is the vector of ones and the ``p``-norm is given by.\n\n    .. math ::\n        \\Vert x \\Vert _p = \\left( \\sum_{i=1}^n  \\vert x_i \\vert ^ p \\right) ^ {1/p}.\n\n    Args:\n        p (real, optional): the norm degree. Can be negative. Default: 2\n        eps (float, optional): Small value to avoid division by zero.\n            Default: 1e-6\n        keepdim (bool, optional): Determines whether or not to keep the vector dimension.\n            Default: False\n    Shape:\n        - Input1: :math:`(N, D)` or :math:`(D)` where `N = batch dimension` and `D = vector dimension`\n        - Input2: :math:`(N, D)` or :math:`(D)`, same shape as the Input1\n        - Output: :math:`(N)` or :math:`()` based on input dimension.\n          If :attr:`keepdim` is ``True``, then :math:`(N, 1)` or :math:`(1)` based on input dimension.\n\n    Examples::\n        >>> pdist = nn.PairwiseDistance(p=2)\n        >>> input1 = torch.randn(100, 128)\n        >>> input2 = torch.randn(100, 128)\n        >>> output = pdist(input1, input2)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "p": {
                          "Type": "<class 'float'>",
                          "Default": "2.0"
                        },
                        "eps": {
                          "Type": "<class 'float'>",
                          "Default": "1e-06"
                        },
                        "keepdim": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "x1": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "x2": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                }
              }
            },
            "dropout": {
              "Doc": null,
              "Classes": {
                "AlphaDropout": {
                  "Doc": "Applies Alpha Dropout over the input.\n\n    Alpha Dropout is a type of Dropout that maintains the self-normalizing\n    property.\n    For an input with zero mean and unit standard deviation, the output of\n    Alpha Dropout maintains the original mean and standard deviation of the\n    input.\n    Alpha Dropout goes hand-in-hand with SELU activation function, which ensures\n    that the outputs have zero mean and unit standard deviation.\n\n    During training, it randomly masks some of the elements of the input\n    tensor with probability *p* using samples from a bernoulli distribution.\n    The elements to masked are randomized on every forward call, and scaled\n    and shifted to maintain zero mean and unit standard deviation.\n\n    During evaluation the module simply computes an identity function.\n\n    More details can be found in the paper `Self-Normalizing Neural Networks`_ .\n\n    Args:\n        p (float): probability of an element to be dropped. Default: 0.5\n        inplace (bool, optional): If set to ``True``, will do this operation\n            in-place\n\n    Shape:\n        - Input: :math:`(*)`. Input can be of any shape\n        - Output: :math:`(*)`. Output is of the same shape as input\n\n    Examples::\n\n        >>> m = nn.AlphaDropout(p=0.2)\n        >>> input = torch.randn(20, 16)\n        >>> output = m(input)\n\n    .. _Self-Normalizing Neural Networks: https://arxiv.org/abs/1706.02515\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Dropout": {
                  "Doc": "During training, randomly zeroes some of the elements of the input\n    tensor with probability :attr:`p` using samples from a Bernoulli\n    distribution. Each channel will be zeroed out independently on every forward\n    call.\n\n    This has proven to be an effective technique for regularization and\n    preventing the co-adaptation of neurons as described in the paper\n    `Improving neural networks by preventing co-adaptation of feature\n    detectors`_ .\n\n    Furthermore, the outputs are scaled by a factor of :math:`\\frac{1}{1-p}` during\n    training. This means that during evaluation the module simply computes an\n    identity function.\n\n    Args:\n        p: probability of an element to be zeroed. Default: 0.5\n        inplace: If set to ``True``, will do this operation in-place. Default: ``False``\n\n    Shape:\n        - Input: :math:`(*)`. Input can be of any shape\n        - Output: :math:`(*)`. Output is of the same shape as input\n\n    Examples::\n\n        >>> m = nn.Dropout(p=0.2)\n        >>> input = torch.randn(20, 16)\n        >>> output = m(input)\n\n    .. _Improving neural networks by preventing co-adaptation of feature\n        detectors: https://arxiv.org/abs/1207.0580\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Dropout1d": {
                  "Doc": "Randomly zero out entire channels (a channel is a 1D feature map,\n    e.g., the :math:`j`-th channel of the :math:`i`-th sample in the\n    batched input is a 1D tensor :math:`\\text{input}[i, j]`).\n    Each channel will be zeroed out independently on every forward call with\n    probability :attr:`p` using samples from a Bernoulli distribution.\n\n    Usually the input comes from :class:`nn.Conv1d` modules.\n\n    As described in the paper\n    `Efficient Object Localization Using Convolutional Networks`_ ,\n    if adjacent pixels within feature maps are strongly correlated\n    (as is normally the case in early convolution layers) then i.i.d. dropout\n    will not regularize the activations and will otherwise just result\n    in an effective learning rate decrease.\n\n    In this case, :func:`nn.Dropout1d` will help promote independence between\n    feature maps and should be used instead.\n\n    Args:\n        p (float, optional): probability of an element to be zero-ed.\n        inplace (bool, optional): If set to ``True``, will do this operation\n            in-place\n\n    Shape:\n        - Input: :math:`(N, C, L)` or :math:`(C, L)`.\n        - Output: :math:`(N, C, L)` or :math:`(C, L)` (same shape as input).\n\n    Examples::\n\n        >>> m = nn.Dropout1d(p=0.2)\n        >>> input = torch.randn(20, 16, 32)\n        >>> output = m(input)\n\n    .. _Efficient Object Localization Using Convolutional Networks:\n       https://arxiv.org/abs/1411.4280\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Dropout2d": {
                  "Doc": "Randomly zero out entire channels (a channel is a 2D feature map,\n    e.g., the :math:`j`-th channel of the :math:`i`-th sample in the\n    batched input is a 2D tensor :math:`\\text{input}[i, j]`).\n    Each channel will be zeroed out independently on every forward call with\n    probability :attr:`p` using samples from a Bernoulli distribution.\n\n    Usually the input comes from :class:`nn.Conv2d` modules.\n\n    As described in the paper\n    `Efficient Object Localization Using Convolutional Networks`_ ,\n    if adjacent pixels within feature maps are strongly correlated\n    (as is normally the case in early convolution layers) then i.i.d. dropout\n    will not regularize the activations and will otherwise just result\n    in an effective learning rate decrease.\n\n    In this case, :func:`nn.Dropout2d` will help promote independence between\n    feature maps and should be used instead.\n\n    Args:\n        p (float, optional): probability of an element to be zero-ed.\n        inplace (bool, optional): If set to ``True``, will do this operation\n            in-place\n\n    .. warning ::\n        Due to historical reasons, this class will perform 1D channel-wise dropout\n        for 3D inputs (as done by :class:`nn.Dropout1d`). Thus, it currently does NOT\n        support inputs without a batch dimension of shape :math:`(C, H, W)`. This\n        behavior will change in a future release to interpret 3D inputs as no-batch-dim\n        inputs. To maintain the old behavior, switch to :class:`nn.Dropout1d`.\n\n    Shape:\n        - Input: :math:`(N, C, H, W)` or :math:`(N, C, L)`.\n        - Output: :math:`(N, C, H, W)` or :math:`(N, C, L)` (same shape as input).\n\n    Examples::\n\n        >>> m = nn.Dropout2d(p=0.2)\n        >>> input = torch.randn(20, 16, 32, 32)\n        >>> output = m(input)\n\n    .. _Efficient Object Localization Using Convolutional Networks:\n       https://arxiv.org/abs/1411.4280\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Dropout3d": {
                  "Doc": "Randomly zero out entire channels (a channel is a 3D feature map,\n    e.g., the :math:`j`-th channel of the :math:`i`-th sample in the\n    batched input is a 3D tensor :math:`\\text{input}[i, j]`).\n    Each channel will be zeroed out independently on every forward call with\n    probability :attr:`p` using samples from a Bernoulli distribution.\n\n    Usually the input comes from :class:`nn.Conv3d` modules.\n\n    As described in the paper\n    `Efficient Object Localization Using Convolutional Networks`_ ,\n    if adjacent pixels within feature maps are strongly correlated\n    (as is normally the case in early convolution layers) then i.i.d. dropout\n    will not regularize the activations and will otherwise just result\n    in an effective learning rate decrease.\n\n    In this case, :func:`nn.Dropout3d` will help promote independence between\n    feature maps and should be used instead.\n\n    Args:\n        p (float, optional): probability of an element to be zeroed.\n        inplace (bool, optional): If set to ``True``, will do this operation\n            in-place\n\n    Shape:\n        - Input: :math:`(N, C, D, H, W)` or :math:`(C, D, H, W)`.\n        - Output: :math:`(N, C, D, H, W)` or :math:`(C, D, H, W)` (same shape as input).\n\n    Examples::\n\n        >>> m = nn.Dropout3d(p=0.2)\n        >>> input = torch.randn(20, 16, 4, 32, 32)\n        >>> output = m(input)\n\n    .. _Efficient Object Localization Using Convolutional Networks:\n       https://arxiv.org/abs/1411.4280\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "FeatureAlphaDropout": {
                  "Doc": "Randomly masks out entire channels (a channel is a feature map,\n    e.g. the :math:`j`-th channel of the :math:`i`-th sample in the batch input\n    is a tensor :math:`\\text{input}[i, j]`) of the input tensor). Instead of\n    setting activations to zero, as in regular Dropout, the activations are set\n    to the negative saturation value of the SELU activation function. More details\n    can be found in the paper `Self-Normalizing Neural Networks`_ .\n\n    Each element will be masked independently for each sample on every forward\n    call with probability :attr:`p` using samples from a Bernoulli distribution.\n    The elements to be masked are randomized on every forward call, and scaled\n    and shifted to maintain zero mean and unit variance.\n\n    Usually the input comes from :class:`nn.AlphaDropout` modules.\n\n    As described in the paper\n    `Efficient Object Localization Using Convolutional Networks`_ ,\n    if adjacent pixels within feature maps are strongly correlated\n    (as is normally the case in early convolution layers) then i.i.d. dropout\n    will not regularize the activations and will otherwise just result\n    in an effective learning rate decrease.\n\n    In this case, :func:`nn.AlphaDropout` will help promote independence between\n    feature maps and should be used instead.\n\n    Args:\n        p (float, optional): probability of an element to be zeroed. Default: 0.5\n        inplace (bool, optional): If set to ``True``, will do this operation\n            in-place\n\n    Shape:\n        - Input: :math:`(N, C, D, H, W)` or :math:`(C, D, H, W)`.\n        - Output: :math:`(N, C, D, H, W)` or :math:`(C, D, H, W)` (same shape as input).\n\n    Examples::\n\n        >>> m = nn.FeatureAlphaDropout(p=0.2)\n        >>> input = torch.randn(20, 16, 4, 32, 32)\n        >>> output = m(input)\n\n    .. _Self-Normalizing Neural Networks: https://arxiv.org/abs/1706.02515\n    .. _Efficient Object Localization Using Convolutional Networks:\n       https://arxiv.org/abs/1411.4280\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                }
              }
            },
            "flatten": {
              "Doc": null,
              "Classes": {
                "Flatten": {
                  "Doc": "\n    Flattens a contiguous range of dims into a tensor. For use with :class:`~nn.Sequential`.\n\n    Shape:\n        - Input: :math:`(*, S_{\\text{start}},..., S_{i}, ..., S_{\\text{end}}, *)`,'\n          where :math:`S_{i}` is the size at dimension :math:`i` and :math:`*` means any\n          number of dimensions including none.\n        - Output: :math:`(*, \\prod_{i=\\text{start}}^{\\text{end}} S_{i}, *)`.\n\n    Args:\n        start_dim: first dim to flatten (default = 1).\n        end_dim: last dim to flatten (default = -1).\n\n    Examples::\n        >>> input = torch.randn(32, 1, 5, 5)\n        >>> # With default parameters\n        >>> m = nn.Flatten()\n        >>> output = m(input)\n        >>> output.size()\n        torch.Size([32, 25])\n        >>> # With non-default parameters\n        >>> m = nn.Flatten(0, 2)\n        >>> output = m(input)\n        >>> output.size()\n        torch.Size([160, 5])\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "start_dim": {
                          "Type": "<class 'int'>",
                          "Default": "1"
                        },
                        "end_dim": {
                          "Type": "<class 'int'>",
                          "Default": "-1"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Unflatten": {
                  "Doc": "\n    Unflattens a tensor dim expanding it to a desired shape. For use with :class:`~nn.Sequential`.\n\n    * :attr:`dim` specifies the dimension of the input tensor to be unflattened, and it can\n      be either `int` or `str` when `Tensor` or `NamedTensor` is used, respectively.\n\n    * :attr:`unflattened_size` is the new shape of the unflattened dimension of the tensor and it can be\n      a `tuple` of ints or a `list` of ints or `torch.Size` for `Tensor` input;  a `NamedShape`\n      (tuple of `(name, size)` tuples) for `NamedTensor` input.\n\n    Shape:\n        - Input: :math:`(*, S_{\\text{dim}}, *)`, where :math:`S_{\\text{dim}}` is the size at\n          dimension :attr:`dim` and :math:`*` means any number of dimensions including none.\n        - Output: :math:`(*, U_1, ..., U_n, *)`, where :math:`U` = :attr:`unflattened_size` and\n          :math:`\\prod_{i=1}^n U_i = S_{\\text{dim}}`.\n\n    Args:\n        dim (Union[int, str]): Dimension to be unflattened\n        unflattened_size (Union[torch.Size, Tuple, List, NamedShape]): New shape of the unflattened dimension\n\n    Examples:\n        >>> input = torch.randn(2, 50)\n        >>> # With tuple of ints\n        >>> m = nn.Sequential(\n        >>>     nn.Linear(50, 50),\n        >>>     nn.Unflatten(1, (2, 5, 5))\n        >>> )\n        >>> output = m(input)\n        >>> output.size()\n        torch.Size([2, 2, 5, 5])\n        >>> # With torch.Size\n        >>> m = nn.Sequential(\n        >>>     nn.Linear(50, 50),\n        >>>     nn.Unflatten(1, torch.Size([2, 5, 5]))\n        >>> )\n        >>> output = m(input)\n        >>> output.size()\n        torch.Size([2, 2, 5, 5])\n        >>> # With namedshape (tuple of tuples)\n        >>> input = torch.randn(2, 50, names=('N', 'features'))\n        >>> unflatten = nn.Unflatten('features', (('C', 2), ('H', 5), ('W', 5)))\n        >>> output = unflatten(input)\n        >>> output.size()\n        torch.Size([2, 2, 5, 5])\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "dim": {
                          "Type": "typing.Union[int, str]",
                          "Default": null
                        },
                        "unflattened_size": {
                          "Type": "typing.Union[torch.Size, typing.List[int], typing.Tuple[int, ...], typing.Tuple[typing.Tuple[str, int]]]",
                          "Default": null
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                }
              }
            },
            "fold": {
              "Doc": null,
              "Classes": {
                "Fold": {
                  "Doc": "Combines an array of sliding local blocks into a large containing\n    tensor.\n\n    Consider a batched :attr:`input` tensor containing sliding local blocks,\n    e.g., patches of images, of shape :math:`(N, C \\times  \\prod(\\text{kernel\\_size}), L)`,\n    where :math:`N` is batch dimension, :math:`C \\times \\prod(\\text{kernel\\_size})`\n    is the number of values within a block (a block has :math:`\\prod(\\text{kernel\\_size})`\n    spatial locations each containing a :math:`C`-channeled vector), and\n    :math:`L` is the total number of blocks. (This is exactly the\n    same specification as the output shape of :class:`~torch.nn.Unfold`.) This\n    operation combines these local blocks into the large :attr:`output` tensor\n    of shape :math:`(N, C, \\text{output\\_size}[0], \\text{output\\_size}[1], \\dots)`\n    by summing the overlapping values. Similar to :class:`~torch.nn.Unfold`, the\n    arguments must satisfy\n\n    .. math::\n        L = \\prod_d \\left\\lfloor\\frac{\\text{output\\_size}[d] + 2 \\times \\text{padding}[d] %\n            - \\text{dilation}[d] \\times (\\text{kernel\\_size}[d] - 1) - 1}{\\text{stride}[d]} + 1\\right\\rfloor,\n\n    where :math:`d` is over all spatial dimensions.\n\n    * :attr:`output_size` describes the spatial shape of the large containing\n      tensor of the sliding local blocks. It is useful to resolve the ambiguity\n      when multiple input shapes map to same number of sliding blocks, e.g.,\n      with ``stride > 0``.\n\n    The :attr:`padding`, :attr:`stride` and :attr:`dilation` arguments specify\n    how the sliding blocks are retrieved.\n\n    * :attr:`stride` controls the stride for the sliding blocks.\n\n    * :attr:`padding` controls the amount of implicit zero-paddings on both\n      sides for :attr:`padding` number of points for each dimension before\n      reshaping.\n\n    * :attr:`dilation` controls the spacing between the kernel points; also known as the \u00e0 trous algorithm.\n      It is harder to describe, but this `link`_ has a nice visualization of what :attr:`dilation` does.\n\n    Args:\n        output_size (int or tuple): the shape of the spatial dimensions of the\n                                    output (i.e., ``output.sizes()[2:]``)\n        kernel_size (int or tuple): the size of the sliding blocks\n        stride (int or tuple): the stride of the sliding blocks in the input\n                               spatial dimensions. Default: 1\n        padding (int or tuple, optional): implicit zero padding to be added on\n                                          both sides of input. Default: 0\n        dilation (int or tuple, optional): a parameter that controls the\n                                           stride of elements within the\n                                           neighborhood. Default: 1\n\n    * If :attr:`output_size`, :attr:`kernel_size`, :attr:`dilation`,\n      :attr:`padding` or :attr:`stride` is an int or a tuple of length 1 then\n      their values will be replicated across all spatial dimensions.\n\n    * For the case of two output spatial dimensions this operation is sometimes\n      called ``col2im``.\n\n    .. note::\n        :class:`~torch.nn.Fold` calculates each combined value in the resulting\n        large tensor by summing all values from all containing blocks.\n        :class:`~torch.nn.Unfold` extracts the values in the local blocks by\n        copying from the large tensor. So, if the blocks overlap, they are not\n        inverses of each other.\n\n        In general, folding and unfolding operations are related as\n        follows. Consider :class:`~torch.nn.Fold` and\n        :class:`~torch.nn.Unfold` instances created with the same\n        parameters:\n\n        >>> fold_params = dict(kernel_size=..., dilation=..., padding=..., stride=...)\n        >>> fold = nn.Fold(output_size=..., **fold_params)\n        >>> unfold = nn.Unfold(**fold_params)\n\n        Then for any (supported) ``input`` tensor the following\n        equality holds:\n\n        ::\n\n            fold(unfold(input)) == divisor * input\n\n        where ``divisor`` is a tensor that depends only on the shape\n        and dtype of the ``input``:\n\n        >>> # xdoctest: +SKIP\n        >>> input_ones = torch.ones(input.shape, dtype=input.dtype)\n        >>> divisor = fold(unfold(input_ones))\n\n        When the ``divisor`` tensor contains no zero elements, then\n        ``fold`` and ``unfold`` operations are inverses of each\n        other (up to constant divisor).\n\n    .. warning::\n        Currently, only unbatched (3D) or batched (4D) image-like output tensors are supported.\n\n    Shape:\n        - Input: :math:`(N, C \\times \\prod(\\text{kernel\\_size}), L)` or :math:`(C \\times \\prod(\\text{kernel\\_size}), L)`\n        - Output: :math:`(N, C, \\text{output\\_size}[0], \\text{output\\_size}[1], \\dots)`\n          or :math:`(C, \\text{output\\_size}[0], \\text{output\\_size}[1], \\dots)` as described above\n\n    Examples::\n\n        >>> fold = nn.Fold(output_size=(4, 5), kernel_size=(2, 2))\n        >>> input = torch.randn(1, 3 * 2 * 2, 12)\n        >>> output = fold(input)\n        >>> output.size()\n        torch.Size([1, 3, 4, 5])\n\n    .. _link:\n        https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md\n\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "output_size": {
                          "Type": "typing.Union[int, typing.Tuple[int, ...]]",
                          "Default": null
                        },
                        "kernel_size": {
                          "Type": "typing.Union[int, typing.Tuple[int, ...]]",
                          "Default": null
                        },
                        "dilation": {
                          "Type": "typing.Union[int, typing.Tuple[int, ...]]",
                          "Default": "1"
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, ...]]",
                          "Default": "0"
                        },
                        "stride": {
                          "Type": "typing.Union[int, typing.Tuple[int, ...]]",
                          "Default": "1"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Unfold": {
                  "Doc": "Extracts sliding local blocks from a batched input tensor.\n\n    Consider a batched :attr:`input` tensor of shape :math:`(N, C, *)`,\n    where :math:`N` is the batch dimension, :math:`C` is the channel dimension,\n    and :math:`*` represent arbitrary spatial dimensions. This operation flattens\n    each sliding :attr:`kernel_size`-sized block within the spatial dimensions\n    of :attr:`input` into a column (i.e., last dimension) of a 3-D :attr:`output`\n    tensor of shape :math:`(N, C \\times \\prod(\\text{kernel\\_size}), L)`, where\n    :math:`C \\times \\prod(\\text{kernel\\_size})` is the total number of values\n    within each block (a block has :math:`\\prod(\\text{kernel\\_size})` spatial\n    locations each containing a :math:`C`-channeled vector), and :math:`L` is\n    the total number of such blocks:\n\n    .. math::\n        L = \\prod_d \\left\\lfloor\\frac{\\text{spatial\\_size}[d] + 2 \\times \\text{padding}[d] %\n            - \\text{dilation}[d] \\times (\\text{kernel\\_size}[d] - 1) - 1}{\\text{stride}[d]} + 1\\right\\rfloor,\n\n    where :math:`\\text{spatial\\_size}` is formed by the spatial dimensions\n    of :attr:`input` (:math:`*` above), and :math:`d` is over all spatial\n    dimensions.\n\n    Therefore, indexing :attr:`output` at the last dimension (column dimension)\n    gives all values within a certain block.\n\n    The :attr:`padding`, :attr:`stride` and :attr:`dilation` arguments specify\n    how the sliding blocks are retrieved.\n\n    * :attr:`stride` controls the stride for the sliding blocks.\n\n    * :attr:`padding` controls the amount of implicit zero-paddings on both\n      sides for :attr:`padding` number of points for each dimension before\n      reshaping.\n\n    * :attr:`dilation` controls the spacing between the kernel points; also known as the \u00e0 trous algorithm.\n      It is harder to describe, but this `link`_ has a nice visualization of what :attr:`dilation` does.\n\n    Args:\n        kernel_size (int or tuple): the size of the sliding blocks\n        stride (int or tuple, optional): the stride of the sliding blocks in the input\n                                         spatial dimensions. Default: 1\n        padding (int or tuple, optional): implicit zero padding to be added on\n                                          both sides of input. Default: 0\n        dilation (int or tuple, optional): a parameter that controls the\n                                           stride of elements within the\n                                           neighborhood. Default: 1\n\n    * If :attr:`kernel_size`, :attr:`dilation`, :attr:`padding` or\n      :attr:`stride` is an int or a tuple of length 1, their values will be\n      replicated across all spatial dimensions.\n\n    * For the case of two input spatial dimensions this operation is sometimes\n      called ``im2col``.\n\n    .. note::\n        :class:`~torch.nn.Fold` calculates each combined value in the resulting\n        large tensor by summing all values from all containing blocks.\n        :class:`~torch.nn.Unfold` extracts the values in the local blocks by\n        copying from the large tensor. So, if the blocks overlap, they are not\n        inverses of each other.\n\n        In general, folding and unfolding operations are related as\n        follows. Consider :class:`~torch.nn.Fold` and\n        :class:`~torch.nn.Unfold` instances created with the same\n        parameters:\n\n        >>> fold_params = dict(kernel_size=..., dilation=..., padding=..., stride=...)\n        >>> fold = nn.Fold(output_size=..., **fold_params)\n        >>> unfold = nn.Unfold(**fold_params)\n\n        Then for any (supported) ``input`` tensor the following\n        equality holds:\n\n        ::\n\n            fold(unfold(input)) == divisor * input\n\n        where ``divisor`` is a tensor that depends only on the shape\n        and dtype of the ``input``:\n\n        >>> # xdoctest: +SKIP\n        >>> input_ones = torch.ones(input.shape, dtype=input.dtype)\n        >>> divisor = fold(unfold(input_ones))\n\n        When the ``divisor`` tensor contains no zero elements, then\n        ``fold`` and ``unfold`` operations are inverses of each\n        other (up to constant divisor).\n\n    .. warning::\n        Currently, only 4-D input tensors (batched image-like tensors) are\n        supported.\n\n    Shape:\n        - Input: :math:`(N, C, *)`\n        - Output: :math:`(N, C \\times \\prod(\\text{kernel\\_size}), L)` as described above\n\n    Examples::\n\n        >>> unfold = nn.Unfold(kernel_size=(2, 3))\n        >>> input = torch.randn(2, 5, 3, 4)\n        >>> output = unfold(input)\n        >>> # each patch contains 30 values (2x3=6 vectors, each of 5 channels)\n        >>> # 4 blocks (2x3 kernels) in total in the 3x4 input\n        >>> output.size()\n        torch.Size([2, 30, 4])\n\n        >>> # xdoctest: +IGNORE_WANT\n        >>> # Convolution is equivalent with Unfold + Matrix Multiplication + Fold (or view to output shape)\n        >>> inp = torch.randn(1, 3, 10, 12)\n        >>> w = torch.randn(2, 3, 4, 5)\n        >>> inp_unf = torch.nn.functional.unfold(inp, (4, 5))\n        >>> out_unf = inp_unf.transpose(1, 2).matmul(w.view(w.size(0), -1).t()).transpose(1, 2)\n        >>> out = torch.nn.functional.fold(out_unf, (7, 8), (1, 1))\n        >>> # or equivalently (and avoiding a copy),\n        >>> # out = out_unf.view(1, 2, 7, 8)\n        >>> (torch.nn.functional.conv2d(inp, w) - out).abs().max()\n        tensor(1.9073e-06)\n\n    .. _link:\n        https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md\n\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "kernel_size": {
                          "Type": "typing.Union[int, typing.Tuple[int, ...]]",
                          "Default": null
                        },
                        "dilation": {
                          "Type": "typing.Union[int, typing.Tuple[int, ...]]",
                          "Default": "1"
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, ...]]",
                          "Default": "0"
                        },
                        "stride": {
                          "Type": "typing.Union[int, typing.Tuple[int, ...]]",
                          "Default": "1"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                }
              }
            },
            "instancenorm": {
              "Doc": null,
              "Classes": {
                "InstanceNorm1d": {
                  "Doc": "Applies Instance Normalization over a 2D (unbatched) or 3D (batched) input\n    as described in the paper\n    `Instance Normalization: The Missing Ingredient for Fast Stylization\n    <https://arxiv.org/abs/1607.08022>`__.\n\n    .. math::\n\n        y = \\frac{x - \\mathrm{E}[x]}{ \\sqrt{\\mathrm{Var}[x] + \\epsilon}} * \\gamma + \\beta\n\n    The mean and standard-deviation are calculated per-dimension separately\n    for each object in a mini-batch. :math:`\\gamma` and :math:`\\beta` are learnable parameter vectors\n    of size `C` (where `C` is the number of features or channels of the input) if :attr:`affine` is ``True``.\n    The standard-deviation is calculated via the biased estimator, equivalent to\n    `torch.var(input, unbiased=False)`.\n\n    By default, this layer uses instance statistics computed from input data in\n    both training and evaluation modes.\n\n    If :attr:`track_running_stats` is set to ``True``, during training this\n    layer keeps running estimates of its computed mean and variance, which are\n    then used for normalization during evaluation. The running estimates are\n    kept with a default :attr:`momentum` of 0.1.\n\n    .. note::\n        This :attr:`momentum` argument is different from one used in optimizer\n        classes and the conventional notion of momentum. Mathematically, the\n        update rule for running statistics here is\n        :math:`\\hat{x}_\\text{new} = (1 - \\text{momentum}) \\times \\hat{x} + \\text{momentum} \\times x_t`,\n        where :math:`\\hat{x}` is the estimated statistic and :math:`x_t` is the\n        new observed value.\n\n    .. note::\n        :class:`InstanceNorm1d` and :class:`LayerNorm` are very similar, but\n        have some subtle differences. :class:`InstanceNorm1d` is applied\n        on each channel of channeled data like multidimensional time series, but\n        :class:`LayerNorm` is usually applied on entire sample and often in NLP\n        tasks. Additionally, :class:`LayerNorm` applies elementwise affine\n        transform, while :class:`InstanceNorm1d` usually don't apply affine\n        transform.\n\n    Args:\n        num_features: number of features or channels :math:`C` of the input\n        eps: a value added to the denominator for numerical stability. Default: 1e-5\n        momentum: the value used for the running_mean and running_var computation. Default: 0.1\n        affine: a boolean value that when set to ``True``, this module has\n            learnable affine parameters, initialized the same way as done for batch normalization.\n            Default: ``False``.\n        track_running_stats: a boolean value that when set to ``True``, this\n            module tracks the running mean and variance, and when set to ``False``,\n            this module does not track such statistics and always uses batch\n            statistics in both training and eval modes. Default: ``False``\n\n    Shape:\n        - Input: :math:`(N, C, L)` or :math:`(C, L)`\n        - Output: :math:`(N, C, L)` or :math:`(C, L)` (same shape as input)\n\n    Examples::\n\n        >>> # Without Learnable Parameters\n        >>> m = nn.InstanceNorm1d(100)\n        >>> # With Learnable Parameters\n        >>> m = nn.InstanceNorm1d(100, affine=True)\n        >>> input = torch.randn(20, 100, 40)\n        >>> output = m(input)\n    "
                },
                "InstanceNorm2d": {
                  "Doc": "Applies Instance Normalization over a 4D input (a mini-batch of 2D inputs\n    with additional channel dimension) as described in the paper\n    `Instance Normalization: The Missing Ingredient for Fast Stylization\n    <https://arxiv.org/abs/1607.08022>`__.\n\n    .. math::\n\n        y = \\frac{x - \\mathrm{E}[x]}{ \\sqrt{\\mathrm{Var}[x] + \\epsilon}} * \\gamma + \\beta\n\n    The mean and standard-deviation are calculated per-dimension separately\n    for each object in a mini-batch. :math:`\\gamma` and :math:`\\beta` are learnable parameter vectors\n    of size `C` (where `C` is the input size) if :attr:`affine` is ``True``.\n    The standard-deviation is calculated via the biased estimator, equivalent to\n    `torch.var(input, unbiased=False)`.\n\n    By default, this layer uses instance statistics computed from input data in\n    both training and evaluation modes.\n\n    If :attr:`track_running_stats` is set to ``True``, during training this\n    layer keeps running estimates of its computed mean and variance, which are\n    then used for normalization during evaluation. The running estimates are\n    kept with a default :attr:`momentum` of 0.1.\n\n    .. note::\n        This :attr:`momentum` argument is different from one used in optimizer\n        classes and the conventional notion of momentum. Mathematically, the\n        update rule for running statistics here is\n        :math:`\\hat{x}_\\text{new} = (1 - \\text{momentum}) \\times \\hat{x} + \\text{momentum} \\times x_t`,\n        where :math:`\\hat{x}` is the estimated statistic and :math:`x_t` is the\n        new observed value.\n\n    .. note::\n        :class:`InstanceNorm2d` and :class:`LayerNorm` are very similar, but\n        have some subtle differences. :class:`InstanceNorm2d` is applied\n        on each channel of channeled data like RGB images, but\n        :class:`LayerNorm` is usually applied on entire sample and often in NLP\n        tasks. Additionally, :class:`LayerNorm` applies elementwise affine\n        transform, while :class:`InstanceNorm2d` usually don't apply affine\n        transform.\n\n    Args:\n        num_features: :math:`C` from an expected input of size\n            :math:`(N, C, H, W)` or :math:`(C, H, W)`\n        eps: a value added to the denominator for numerical stability. Default: 1e-5\n        momentum: the value used for the running_mean and running_var computation. Default: 0.1\n        affine: a boolean value that when set to ``True``, this module has\n            learnable affine parameters, initialized the same way as done for batch normalization.\n            Default: ``False``.\n        track_running_stats: a boolean value that when set to ``True``, this\n            module tracks the running mean and variance, and when set to ``False``,\n            this module does not track such statistics and always uses batch\n            statistics in both training and eval modes. Default: ``False``\n\n    Shape:\n        - Input: :math:`(N, C, H, W)` or :math:`(C, H, W)`\n        - Output: :math:`(N, C, H, W)` or :math:`(C, H, W)` (same shape as input)\n\n    Examples::\n\n        >>> # Without Learnable Parameters\n        >>> m = nn.InstanceNorm2d(100)\n        >>> # With Learnable Parameters\n        >>> m = nn.InstanceNorm2d(100, affine=True)\n        >>> input = torch.randn(20, 100, 35, 45)\n        >>> output = m(input)\n    "
                },
                "InstanceNorm3d": {
                  "Doc": "Applies Instance Normalization over a 5D input (a mini-batch of 3D inputs\n    with additional channel dimension) as described in the paper\n    `Instance Normalization: The Missing Ingredient for Fast Stylization\n    <https://arxiv.org/abs/1607.08022>`__.\n\n    .. math::\n\n        y = \\frac{x - \\mathrm{E}[x]}{ \\sqrt{\\mathrm{Var}[x] + \\epsilon}} * \\gamma + \\beta\n\n    The mean and standard-deviation are calculated per-dimension separately\n    for each object in a mini-batch. :math:`\\gamma` and :math:`\\beta` are learnable parameter vectors\n    of size C (where C is the input size) if :attr:`affine` is ``True``.\n    The standard-deviation is calculated via the biased estimator, equivalent to\n    `torch.var(input, unbiased=False)`.\n\n    By default, this layer uses instance statistics computed from input data in\n    both training and evaluation modes.\n\n    If :attr:`track_running_stats` is set to ``True``, during training this\n    layer keeps running estimates of its computed mean and variance, which are\n    then used for normalization during evaluation. The running estimates are\n    kept with a default :attr:`momentum` of 0.1.\n\n    .. note::\n        This :attr:`momentum` argument is different from one used in optimizer\n        classes and the conventional notion of momentum. Mathematically, the\n        update rule for running statistics here is\n        :math:`\\hat{x}_\\text{new} = (1 - \\text{momentum}) \\times \\hat{x} + \\text{momentum} \\times x_t`,\n        where :math:`\\hat{x}` is the estimated statistic and :math:`x_t` is the\n        new observed value.\n\n    .. note::\n        :class:`InstanceNorm3d` and :class:`LayerNorm` are very similar, but\n        have some subtle differences. :class:`InstanceNorm3d` is applied\n        on each channel of channeled data like 3D models with RGB color, but\n        :class:`LayerNorm` is usually applied on entire sample and often in NLP\n        tasks. Additionally, :class:`LayerNorm` applies elementwise affine\n        transform, while :class:`InstanceNorm3d` usually don't apply affine\n        transform.\n\n    Args:\n        num_features: :math:`C` from an expected input of size\n            :math:`(N, C, D, H, W)` or :math:`(C, D, H, W)`\n        eps: a value added to the denominator for numerical stability. Default: 1e-5\n        momentum: the value used for the running_mean and running_var computation. Default: 0.1\n        affine: a boolean value that when set to ``True``, this module has\n            learnable affine parameters, initialized the same way as done for batch normalization.\n            Default: ``False``.\n        track_running_stats: a boolean value that when set to ``True``, this\n            module tracks the running mean and variance, and when set to ``False``,\n            this module does not track such statistics and always uses batch\n            statistics in both training and eval modes. Default: ``False``\n\n    Shape:\n        - Input: :math:`(N, C, D, H, W)` or :math:`(C, D, H, W)`\n        - Output: :math:`(N, C, D, H, W)` or :math:`(C, D, H, W)` (same shape as input)\n\n    Examples::\n\n        >>> # Without Learnable Parameters\n        >>> m = nn.InstanceNorm3d(100)\n        >>> # With Learnable Parameters\n        >>> m = nn.InstanceNorm3d(100, affine=True)\n        >>> input = torch.randn(20, 100, 35, 45, 10)\n        >>> output = m(input)\n    "
                },
                "LazyInstanceNorm1d": {
                  "Doc": "A :class:`torch.nn.InstanceNorm1d` module with lazy initialization of\n    the ``num_features`` argument of the :class:`InstanceNorm1d` that is inferred\n    from the ``input.size(1)``.\n    The attributes that will be lazily initialized are `weight`, `bias`,\n    `running_mean` and `running_var`.\n\n    Check the :class:`torch.nn.modules.lazy.LazyModuleMixin` for further documentation\n    on lazy modules and their limitations.\n\n    Args:\n        num_features: :math:`C` from an expected input of size\n            :math:`(N, C, L)` or :math:`(C, L)`\n        eps: a value added to the denominator for numerical stability. Default: 1e-5\n        momentum: the value used for the running_mean and running_var computation. Default: 0.1\n        affine: a boolean value that when set to ``True``, this module has\n            learnable affine parameters, initialized the same way as done for batch normalization.\n            Default: ``False``.\n        track_running_stats: a boolean value that when set to ``True``, this\n            module tracks the running mean and variance, and when set to ``False``,\n            this module does not track such statistics and always uses batch\n            statistics in both training and eval modes. Default: ``False``\n\n    Shape:\n        - Input: :math:`(N, C, L)` or :math:`(C, L)`\n        - Output: :math:`(N, C, L)` or :math:`(C, L)` (same shape as input)\n    "
                },
                "LazyInstanceNorm2d": {
                  "Doc": "A :class:`torch.nn.InstanceNorm2d` module with lazy initialization of\n    the ``num_features`` argument of the :class:`InstanceNorm2d` that is inferred\n    from the ``input.size(1)``.\n    The attributes that will be lazily initialized are `weight`, `bias`,\n    `running_mean` and `running_var`.\n\n    Check the :class:`torch.nn.modules.lazy.LazyModuleMixin` for further documentation\n    on lazy modules and their limitations.\n\n    Args:\n        num_features: :math:`C` from an expected input of size\n            :math:`(N, C, H, W)` or :math:`(C, H, W)`\n        eps: a value added to the denominator for numerical stability. Default: 1e-5\n        momentum: the value used for the running_mean and running_var computation. Default: 0.1\n        affine: a boolean value that when set to ``True``, this module has\n            learnable affine parameters, initialized the same way as done for batch normalization.\n            Default: ``False``.\n        track_running_stats: a boolean value that when set to ``True``, this\n            module tracks the running mean and variance, and when set to ``False``,\n            this module does not track such statistics and always uses batch\n            statistics in both training and eval modes. Default: ``False``\n\n    Shape:\n        - Input: :math:`(N, C, H, W)` or :math:`(C, H, W)`\n        - Output: :math:`(N, C, H, W)` or :math:`(C, H, W)` (same shape as input)\n    "
                },
                "LazyInstanceNorm3d": {
                  "Doc": "A :class:`torch.nn.InstanceNorm3d` module with lazy initialization of\n    the ``num_features`` argument of the :class:`InstanceNorm3d` that is inferred\n    from the ``input.size(1)``.\n    The attributes that will be lazily initialized are `weight`, `bias`,\n    `running_mean` and `running_var`.\n\n    Check the :class:`torch.nn.modules.lazy.LazyModuleMixin` for further documentation\n    on lazy modules and their limitations.\n\n    Args:\n        num_features: :math:`C` from an expected input of size\n            :math:`(N, C, D, H, W)` or :math:`(C, D, H, W)`\n        eps: a value added to the denominator for numerical stability. Default: 1e-5\n        momentum: the value used for the running_mean and running_var computation. Default: 0.1\n        affine: a boolean value that when set to ``True``, this module has\n            learnable affine parameters, initialized the same way as done for batch normalization.\n            Default: ``False``.\n        track_running_stats: a boolean value that when set to ``True``, this\n            module tracks the running mean and variance, and when set to ``False``,\n            this module does not track such statistics and always uses batch\n            statistics in both training and eval modes. Default: ``False``\n\n    Shape:\n        - Input: :math:`(N, C, D, H, W)` or :math:`(C, D, H, W)`\n        - Output: :math:`(N, C, D, H, W)` or :math:`(C, D, H, W)` (same shape as input)\n    "
                }
              }
            },
            "lazy": {
              "Doc": null,
              "Classes": {
                "LazyModuleMixin": {
                  "Doc": "A mixin for modules that lazily initialize parameters, also known as \"lazy modules.\"\n\n    .. warning:\n        Lazy modules are an experimental new feature under active development,\n        and their API is likely to change.\n\n    Modules that lazily initialize parameters, or \"lazy modules\",\n    derive the shapes of their parameters from the first input(s)\n    to their forward method. Until that first forward they contain\n    :class:`torch.nn.UninitializedParameter` s that should not be accessed\n    or used, and afterward they contain regular :class:`torch.nn.Parameter` s.\n    Lazy modules are convenient since they don't require computing some\n    module arguments, like the :attr:`in_features` argument of a\n    typical :class:`torch.nn.Linear`.\n\n    After construction, networks with lazy modules should first\n    be converted to the desired dtype and placed on the expected device.\n    This is because lazy modules only perform shape inference so the usual dtype\n    and device placement behavior applies.\n    The lazy modules should then perform \"dry runs\" to initialize all the components in the module.\n    These \"dry runs\" send inputs of the correct size, dtype, and device through\n    the network and to each one of its lazy modules. After this the network can be used as usual.\n\n    >>> # xdoctest: +SKIP\n    >>> class LazyMLP(torch.nn.Module):\n    ...    def __init__(self):\n    ...        super().__init__()\n    ...        self.fc1 = torch.nn.LazyLinear(10)\n    ...        self.relu1 = torch.nn.ReLU()\n    ...        self.fc2 = torch.nn.LazyLinear(1)\n    ...        self.relu2 = torch.nn.ReLU()\n    ...\n    ...    def forward(self, input):\n    ...        x = self.relu1(self.fc1(input))\n    ...        y = self.relu2(self.fc2(x))\n    ...        return y\n    >>> # constructs a network with lazy modules\n    >>> lazy_mlp = LazyMLP()\n    >>> # transforms the network's device and dtype\n    >>> # NOTE: these transforms can and should be applied after construction and before any 'dry runs'\n    >>> lazy_mlp = lazy_mlp.cuda().double()\n    >>> lazy_mlp\n    LazyMLP( (fc1): LazyLinear(in_features=0, out_features=10, bias=True)\n      (relu1): ReLU()\n      (fc2): LazyLinear(in_features=0, out_features=1, bias=True)\n      (relu2): ReLU()\n    )\n    >>> # performs a dry run to initialize the network's lazy modules\n    >>> lazy_mlp(torch.ones(10,10).cuda())\n    >>> # after initialization, LazyLinear modules become regular Linear modules\n    >>> lazy_mlp\n    LazyMLP(\n      (fc1): Linear(in_features=10, out_features=10, bias=True)\n      (relu1): ReLU()\n      (fc2): Linear(in_features=10, out_features=1, bias=True)\n      (relu2): ReLU()\n    )\n    >>> # attaches an optimizer, since parameters can now be used as usual\n    >>> optim = torch.optim.SGD(mlp.parameters(), lr=0.01)\n\n    A final caveat when using lazy modules is that the order of initialization of a network's\n    parameters may change, since the lazy modules are always initialized after other modules.\n    For example, if the LazyMLP class defined above had a :class:`torch.nn.LazyLinear` module\n    first and then a regular :class:`torch.nn.Linear` second, the second module would be\n    initialized on construction and the first module would be initialized during the first dry run.\n    This can cause the parameters of a network using lazy modules to be initialized differently\n    than the parameters of a network without lazy modules as the order of parameter initializations,\n    which often depends on a stateful random number generator, is different.\n    Check :doc:`/notes/randomness` for more details.\n\n    Lazy modules can be serialized with a state dict like other modules. For example:\n\n    >>> lazy_mlp = LazyMLP()\n    >>> # The state dict shows the uninitialized parameters\n    >>> lazy_mlp.state_dict()\n    OrderedDict([('fc1.weight', Uninitialized parameter),\n                 ('fc1.bias',\n                  tensor([-1.8832e+25,  4.5636e-41, -1.8832e+25,  4.5636e-41, -6.1598e-30,\n                           4.5637e-41, -1.8788e+22,  4.5636e-41, -2.0042e-31,  4.5637e-41])),\n                 ('fc2.weight', Uninitialized parameter),\n                 ('fc2.bias', tensor([0.0019]))])\n\n\n    Lazy modules can load regular :class:`torch.nn.Parameter` s (i.e. you can serialize/deserialize\n    initialized LazyModules and they will remain initialized)\n\n\n    >>> full_mlp = LazyMLP()\n    >>> # Dry run to initialize another module\n    >>> full_mlp.forward(torch.ones(10, 1))\n    >>> # Load an initialized state into a lazy module\n    >>> lazy_mlp.load_state_dict(full_mlp.state_dict())\n    >>> # The state dict now holds valid values\n    >>> lazy_mlp.state_dict()\n    OrderedDict([('fc1.weight',\n                  tensor([[-0.3837],\n                          [ 0.0907],\n                          [ 0.6708],\n                          [-0.5223],\n                          [-0.9028],\n                          [ 0.2851],\n                          [-0.4537],\n                          [ 0.6813],\n                          [ 0.5766],\n                          [-0.8678]])),\n                 ('fc1.bias',\n                  tensor([-1.8832e+25,  4.5636e-41, -1.8832e+25,  4.5636e-41, -6.1598e-30,\n                           4.5637e-41, -1.8788e+22,  4.5636e-41, -2.0042e-31,  4.5637e-41])),\n                 ('fc2.weight',\n                  tensor([[ 0.1320,  0.2938,  0.0679,  0.2793,  0.1088, -0.1795, -0.2301,  0.2807,\n                            0.2479,  0.1091]])),\n                 ('fc2.bias', tensor([0.0019]))])\n\n    Note, however, that the loaded parameters will not be replaced when doing a \"dry run\" if they are initialized\n    when the state is loaded. This prevents using initialized modules in different contexts.\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": "<class 'torch.nn.modules.lazy._LazyProtocol'>",
                          "Default": null
                        },
                        "*args": {
                          "Type": null,
                          "Default": null
                        },
                        "**kwargs": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "has_uninitialized_params": {
                      "Doc": "Check if a module has parameters that are not initialized\n        ",
                      "Args": {
                        "self": {
                          "Type": "<class 'torch.nn.modules.lazy._LazyProtocol'>",
                          "Default": null
                        }
                      }
                    },
                    "initialize_parameters": {
                      "Doc": "Initialize parameters according to the input batch properties.\n        This adds an interface to isolate parameter initialization from the\n        forward pass when doing parameter shape inference.\n        ",
                      "Args": {
                        "self": {
                          "Type": "<class 'torch.nn.modules.lazy._LazyProtocol'>",
                          "Default": null
                        },
                        "*args": {
                          "Type": null,
                          "Default": null
                        },
                        "**kwargs": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    }
                  }
                }
              },
              "Functions": {
                "is_lazy": {
                  "Doc": null,
                  "Args": {
                    "param": {
                      "Type": null,
                      "Default": null
                    }
                  }
                }
              }
            },
            "linear": {
              "Doc": null,
              "Classes": {
                "Bilinear": {
                  "Doc": "Applies a bilinear transformation to the incoming data:\n    :math:`y = x_1^T A x_2 + b`\n\n    Args:\n        in1_features: size of each first input sample\n        in2_features: size of each second input sample\n        out_features: size of each output sample\n        bias: If set to False, the layer will not learn an additive bias.\n            Default: ``True``\n\n    Shape:\n        - Input1: :math:`(*, H_{in1})` where :math:`H_{in1}=\\text{in1\\_features}` and\n          :math:`*` means any number of additional dimensions including none. All but the last dimension\n          of the inputs should be the same.\n        - Input2: :math:`(*, H_{in2})` where :math:`H_{in2}=\\text{in2\\_features}`.\n        - Output: :math:`(*, H_{out})` where :math:`H_{out}=\\text{out\\_features}`\n          and all but the last dimension are the same shape as the input.\n\n    Attributes:\n        weight: the learnable weights of the module of shape\n            :math:`(\\text{out\\_features}, \\text{in1\\_features}, \\text{in2\\_features})`.\n            The values are initialized from :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})`, where\n            :math:`k = \\frac{1}{\\text{in1\\_features}}`\n        bias:   the learnable bias of the module of shape :math:`(\\text{out\\_features})`.\n                If :attr:`bias` is ``True``, the values are initialized from\n                :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})`, where\n                :math:`k = \\frac{1}{\\text{in1\\_features}}`\n\n    Examples::\n\n        >>> m = nn.Bilinear(20, 30, 40)\n        >>> input1 = torch.randn(128, 20)\n        >>> input2 = torch.randn(128, 30)\n        >>> output = m(input1, input2)\n        >>> print(output.size())\n        torch.Size([128, 40])\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "in1_features": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "in2_features": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "out_features": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "bias": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input1": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "input2": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    },
                    "reset_parameters": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Identity": {
                  "Doc": "A placeholder identity operator that is argument-insensitive.\n\n    Args:\n        args: any argument (unused)\n        kwargs: any keyword argument (unused)\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Output: :math:`(*)`, same shape as the input.\n\n    Examples::\n\n        >>> m = nn.Identity(54, unused_argument1=0.1, unused_argument2=False)\n        >>> input = torch.randn(128, 20)\n        >>> output = m(input)\n        >>> print(output.size())\n        torch.Size([128, 20])\n\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "*args": {
                          "Type": null,
                          "Default": null
                        },
                        "**kwargs": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "LazyLinear": {
                  "Doc": "A :class:`torch.nn.Linear` module where `in_features` is inferred.\n\n    In this module, the `weight` and `bias` are of :class:`torch.nn.UninitializedParameter`\n    class. They will be initialized after the first call to ``forward`` is done and the\n    module will become a regular :class:`torch.nn.Linear` module. The ``in_features`` argument\n    of the :class:`Linear` is inferred from the ``input.shape[-1]``.\n\n    Check the :class:`torch.nn.modules.lazy.LazyModuleMixin` for further documentation\n    on lazy modules and their limitations.\n\n    Args:\n        out_features: size of each output sample\n        bias: If set to ``False``, the layer will not learn an additive bias.\n            Default: ``True``\n\n    Attributes:\n        weight: the learnable weights of the module of shape\n            :math:`(\\text{out\\_features}, \\text{in\\_features})`. The values are\n            initialized from :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})`, where\n            :math:`k = \\frac{1}{\\text{in\\_features}}`\n        bias:   the learnable bias of the module of shape :math:`(\\text{out\\_features})`.\n                If :attr:`bias` is ``True``, the values are initialized from\n                :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})` where\n                :math:`k = \\frac{1}{\\text{in\\_features}}`\n\n\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "out_features": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "bias": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "initialize_parameters": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "reset_parameters": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "Linear": {
                  "Doc": "Applies a linear transformation to the incoming data: :math:`y = xA^T + b`\n\n    This module supports :ref:`TensorFloat32<tf32_on_ampere>`.\n\n    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.\n\n    Args:\n        in_features: size of each input sample\n        out_features: size of each output sample\n        bias: If set to ``False``, the layer will not learn an additive bias.\n            Default: ``True``\n\n    Shape:\n        - Input: :math:`(*, H_{in})` where :math:`*` means any number of\n          dimensions including none and :math:`H_{in} = \\text{in\\_features}`.\n        - Output: :math:`(*, H_{out})` where all but the last dimension\n          are the same shape as the input and :math:`H_{out} = \\text{out\\_features}`.\n\n    Attributes:\n        weight: the learnable weights of the module of shape\n            :math:`(\\text{out\\_features}, \\text{in\\_features})`. The values are\n            initialized from :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})`, where\n            :math:`k = \\frac{1}{\\text{in\\_features}}`\n        bias:   the learnable bias of the module of shape :math:`(\\text{out\\_features})`.\n                If :attr:`bias` is ``True``, the values are initialized from\n                :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})` where\n                :math:`k = \\frac{1}{\\text{in\\_features}}`\n\n    Examples::\n\n        >>> m = nn.Linear(20, 30)\n        >>> input = torch.randn(128, 20)\n        >>> output = m(input)\n        >>> print(output.size())\n        torch.Size([128, 30])\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "in_features": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "out_features": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "bias": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    },
                    "reset_parameters": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "NonDynamicallyQuantizableLinear": {
                  "Doc": null,
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "in_features": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "out_features": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "bias": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    }
                  }
                }
              }
            },
            "loss": {
              "Doc": null,
              "Classes": {
                "BCELoss": {
                  "Doc": "Creates a criterion that measures the Binary Cross Entropy between the target and\n    the input probabilities:\n\n    The unreduced (i.e. with :attr:`reduction` set to ``'none'``) loss can be described as:\n\n    .. math::\n        \\ell(x, y) = L = \\{l_1,\\dots,l_N\\}^\\top, \\quad\n        l_n = - w_n \\left[ y_n \\cdot \\log x_n + (1 - y_n) \\cdot \\log (1 - x_n) \\right],\n\n    where :math:`N` is the batch size. If :attr:`reduction` is not ``'none'``\n    (default ``'mean'``), then\n\n    .. math::\n        \\ell(x, y) = \\begin{cases}\n            \\operatorname{mean}(L), & \\text{if reduction} = \\text{`mean';}\\\\\n            \\operatorname{sum}(L),  & \\text{if reduction} = \\text{`sum'.}\n        \\end{cases}\n\n    This is used for measuring the error of a reconstruction in for example\n    an auto-encoder. Note that the targets :math:`y` should be numbers\n    between 0 and 1.\n\n    Notice that if :math:`x_n` is either 0 or 1, one of the log terms would be\n    mathematically undefined in the above loss equation. PyTorch chooses to set\n    :math:`\\log (0) = -\\infty`, since :math:`\\lim_{x\\to 0} \\log (x) = -\\infty`.\n    However, an infinite term in the loss equation is not desirable for several reasons.\n\n    For one, if either :math:`y_n = 0` or :math:`(1 - y_n) = 0`, then we would be\n    multiplying 0 with infinity. Secondly, if we have an infinite loss value, then\n    we would also have an infinite term in our gradient, since\n    :math:`\\lim_{x\\to 0} \\frac{d}{dx} \\log (x) = \\infty`.\n    This would make BCELoss's backward method nonlinear with respect to :math:`x_n`,\n    and using it for things like linear regression would not be straight-forward.\n\n    Our solution is that BCELoss clamps its log function outputs to be greater than\n    or equal to -100. This way, we can always have a finite loss value and a linear\n    backward method.\n\n\n    Args:\n        weight (Tensor, optional): a manual rescaling weight given to the loss\n            of each batch element. If given, has to be a Tensor of size `nbatch`.\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there are multiple elements per sample. If the field :attr:`size_average`\n            is set to ``False``, the losses are instead summed for each minibatch. Ignored\n            when :attr:`reduce` is ``False``. Default: ``True``\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: ``True``\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the sum of the output will be divided by the number of\n            elements in the output, ``'sum'``: the output will be summed. Note: :attr:`size_average`\n            and :attr:`reduce` are in the process of being deprecated, and in the meantime,\n            specifying either of those two args will override :attr:`reduction`. Default: ``'mean'``\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Target: :math:`(*)`, same shape as the input.\n        - Output: scalar. If :attr:`reduction` is ``'none'``, then :math:`(*)`, same\n          shape as input.\n\n    Examples::\n\n        >>> m = nn.Sigmoid()\n        >>> loss = nn.BCELoss()\n        >>> input = torch.randn(3, requires_grad=True)\n        >>> target = torch.empty(3).random_(2)\n        >>> output = loss(m(input), target)\n        >>> output.backward()\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "weight": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "size_average": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduce": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduction": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "target": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "BCEWithLogitsLoss": {
                  "Doc": "This loss combines a `Sigmoid` layer and the `BCELoss` in one single\n    class. This version is more numerically stable than using a plain `Sigmoid`\n    followed by a `BCELoss` as, by combining the operations into one layer,\n    we take advantage of the log-sum-exp trick for numerical stability.\n\n    The unreduced (i.e. with :attr:`reduction` set to ``'none'``) loss can be described as:\n\n    .. math::\n        \\ell(x, y) = L = \\{l_1,\\dots,l_N\\}^\\top, \\quad\n        l_n = - w_n \\left[ y_n \\cdot \\log \\sigma(x_n)\n        + (1 - y_n) \\cdot \\log (1 - \\sigma(x_n)) \\right],\n\n    where :math:`N` is the batch size. If :attr:`reduction` is not ``'none'``\n    (default ``'mean'``), then\n\n    .. math::\n        \\ell(x, y) = \\begin{cases}\n            \\operatorname{mean}(L), & \\text{if reduction} = \\text{`mean';}\\\\\n            \\operatorname{sum}(L),  & \\text{if reduction} = \\text{`sum'.}\n        \\end{cases}\n\n    This is used for measuring the error of a reconstruction in for example\n    an auto-encoder. Note that the targets `t[i]` should be numbers\n    between 0 and 1.\n\n    It's possible to trade off recall and precision by adding weights to positive examples.\n    In the case of multi-label classification the loss can be described as:\n\n    .. math::\n        \\ell_c(x, y) = L_c = \\{l_{1,c},\\dots,l_{N,c}\\}^\\top, \\quad\n        l_{n,c} = - w_{n,c} \\left[ p_c y_{n,c} \\cdot \\log \\sigma(x_{n,c})\n        + (1 - y_{n,c}) \\cdot \\log (1 - \\sigma(x_{n,c})) \\right],\n\n    where :math:`c` is the class number (:math:`c > 1` for multi-label binary classification,\n    :math:`c = 1` for single-label binary classification),\n    :math:`n` is the number of the sample in the batch and\n    :math:`p_c` is the weight of the positive answer for the class :math:`c`.\n\n    :math:`p_c > 1` increases the recall, :math:`p_c < 1` increases the precision.\n\n    For example, if a dataset contains 100 positive and 300 negative examples of a single class,\n    then `pos_weight` for the class should be equal to :math:`\\frac{300}{100}=3`.\n    The loss would act as if the dataset contains :math:`3\\times 100=300` positive examples.\n\n    Examples::\n\n        >>> target = torch.ones([10, 64], dtype=torch.float32)  # 64 classes, batch size = 10\n        >>> output = torch.full([10, 64], 1.5)  # A prediction (logit)\n        >>> pos_weight = torch.ones([64])  # All weights are equal to 1\n        >>> criterion = torch.nn.BCEWithLogitsLoss(pos_weight=pos_weight)\n        >>> criterion(output, target)  # -log(sigmoid(1.5))\n        tensor(0.20...)\n\n    Args:\n        weight (Tensor, optional): a manual rescaling weight given to the loss\n            of each batch element. If given, has to be a Tensor of size `nbatch`.\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there are multiple elements per sample. If the field :attr:`size_average`\n            is set to ``False``, the losses are instead summed for each minibatch. Ignored\n            when :attr:`reduce` is ``False``. Default: ``True``\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: ``True``\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the sum of the output will be divided by the number of\n            elements in the output, ``'sum'``: the output will be summed. Note: :attr:`size_average`\n            and :attr:`reduce` are in the process of being deprecated, and in the meantime,\n            specifying either of those two args will override :attr:`reduction`. Default: ``'mean'``\n        pos_weight (Tensor, optional): a weight of positive examples.\n                Must be a vector with length equal to the number of classes.\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Target: :math:`(*)`, same shape as the input.\n        - Output: scalar. If :attr:`reduction` is ``'none'``, then :math:`(*)`, same\n          shape as input.\n\n     Examples::\n\n        >>> loss = nn.BCEWithLogitsLoss()\n        >>> input = torch.randn(3, requires_grad=True)\n        >>> target = torch.empty(3).random_(2)\n        >>> output = loss(input, target)\n        >>> output.backward()\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "weight": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "size_average": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduce": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduction": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        },
                        "pos_weight": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "target": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "CTCLoss": {
                  "Doc": "The Connectionist Temporal Classification loss.\n\n    Calculates loss between a continuous (unsegmented) time series and a target sequence. CTCLoss sums over the\n    probability of possible alignments of input to target, producing a loss value which is differentiable\n    with respect to each input node. The alignment of input to target is assumed to be \"many-to-one\", which\n    limits the length of the target sequence such that it must be :math:`\\leq` the input length.\n\n    Args:\n        blank (int, optional): blank label. Default :math:`0`.\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the output losses will be divided by the target lengths and\n            then the mean over the batch is taken. Default: ``'mean'``\n        zero_infinity (bool, optional):\n            Whether to zero infinite losses and the associated gradients.\n            Default: ``False``\n            Infinite losses mainly occur when the inputs are too short\n            to be aligned to the targets.\n\n    Shape:\n        - Log_probs: Tensor of size :math:`(T, N, C)` or :math:`(T, C)`,\n          where :math:`T = \\text{input length}`,\n          :math:`N = \\text{batch size}`, and\n          :math:`C = \\text{number of classes (including blank)}`.\n          The logarithmized probabilities of the outputs (e.g. obtained with\n          :func:`torch.nn.functional.log_softmax`).\n        - Targets: Tensor of size :math:`(N, S)` or\n          :math:`(\\operatorname{sum}(\\text{target\\_lengths}))`,\n          where :math:`N = \\text{batch size}` and\n          :math:`S = \\text{max target length, if shape is } (N, S)`.\n          It represent the target sequences. Each element in the target\n          sequence is a class index. And the target index cannot be blank (default=0).\n          In the :math:`(N, S)` form, targets are padded to the\n          length of the longest sequence, and stacked.\n          In the :math:`(\\operatorname{sum}(\\text{target\\_lengths}))` form,\n          the targets are assumed to be un-padded and\n          concatenated within 1 dimension.\n        - Input_lengths: Tuple or tensor of size :math:`(N)` or :math:`()`,\n          where :math:`N = \\text{batch size}`. It represent the lengths of the\n          inputs (must each be :math:`\\leq T`). And the lengths are specified\n          for each sequence to achieve masking under the assumption that sequences\n          are padded to equal lengths.\n        - Target_lengths: Tuple or tensor of size :math:`(N)` or :math:`()`,\n          where :math:`N = \\text{batch size}`. It represent lengths of the targets.\n          Lengths are specified for each sequence to achieve masking under the\n          assumption that sequences are padded to equal lengths. If target shape is\n          :math:`(N,S)`, target_lengths are effectively the stop index\n          :math:`s_n` for each target sequence, such that ``target_n = targets[n,0:s_n]`` for\n          each target in a batch. Lengths must each be :math:`\\leq S`\n          If the targets are given as a 1d tensor that is the concatenation of individual\n          targets, the target_lengths must add up to the total length of the tensor.\n        - Output: scalar. If :attr:`reduction` is ``'none'``, then\n          :math:`(N)` if input is batched or :math:`()` if input is unbatched, where :math:`N = \\text{batch size}`.\n\n    Examples::\n\n        >>> # Target are to be padded\n        >>> T = 50      # Input sequence length\n        >>> C = 20      # Number of classes (including blank)\n        >>> N = 16      # Batch size\n        >>> S = 30      # Target sequence length of longest target in batch (padding length)\n        >>> S_min = 10  # Minimum target length, for demonstration purposes\n        >>>\n        >>> # Initialize random batch of input vectors, for *size = (T,N,C)\n        >>> input = torch.randn(T, N, C).log_softmax(2).detach().requires_grad_()\n        >>>\n        >>> # Initialize random batch of targets (0 = blank, 1:C = classes)\n        >>> target = torch.randint(low=1, high=C, size=(N, S), dtype=torch.long)\n        >>>\n        >>> input_lengths = torch.full(size=(N,), fill_value=T, dtype=torch.long)\n        >>> target_lengths = torch.randint(low=S_min, high=S, size=(N,), dtype=torch.long)\n        >>> ctc_loss = nn.CTCLoss()\n        >>> loss = ctc_loss(input, target, input_lengths, target_lengths)\n        >>> loss.backward()\n        >>>\n        >>>\n        >>> # Target are to be un-padded\n        >>> T = 50      # Input sequence length\n        >>> C = 20      # Number of classes (including blank)\n        >>> N = 16      # Batch size\n        >>>\n        >>> # Initialize random batch of input vectors, for *size = (T,N,C)\n        >>> input = torch.randn(T, N, C).log_softmax(2).detach().requires_grad_()\n        >>> input_lengths = torch.full(size=(N,), fill_value=T, dtype=torch.long)\n        >>>\n        >>> # Initialize random batch of targets (0 = blank, 1:C = classes)\n        >>> target_lengths = torch.randint(low=1, high=T, size=(N,), dtype=torch.long)\n        >>> target = torch.randint(low=1, high=C, size=(sum(target_lengths),), dtype=torch.long)\n        >>> ctc_loss = nn.CTCLoss()\n        >>> loss = ctc_loss(input, target, input_lengths, target_lengths)\n        >>> loss.backward()\n        >>>\n        >>>\n        >>> # Target are to be un-padded and unbatched (effectively N=1)\n        >>> T = 50      # Input sequence length\n        >>> C = 20      # Number of classes (including blank)\n        >>>\n        >>> # Initialize random batch of input vectors, for *size = (T,C)\n        >>> # xdoctest: +SKIP(\"FIXME: error in doctest\")\n        >>> input = torch.randn(T, C).log_softmax(2).detach().requires_grad_()\n        >>> input_lengths = torch.tensor(T, dtype=torch.long)\n        >>>\n        >>> # Initialize random batch of targets (0 = blank, 1:C = classes)\n        >>> target_lengths = torch.randint(low=1, high=T, size=(), dtype=torch.long)\n        >>> target = torch.randint(low=1, high=C, size=(target_lengths,), dtype=torch.long)\n        >>> ctc_loss = nn.CTCLoss()\n        >>> loss = ctc_loss(input, target, input_lengths, target_lengths)\n        >>> loss.backward()\n\n    Reference:\n        A. Graves et al.: Connectionist Temporal Classification:\n        Labelling Unsegmented Sequence Data with Recurrent Neural Networks:\n        https://www.cs.toronto.edu/~graves/icml_2006.pdf\n\n    Note:\n        In order to use CuDNN, the following must be satisfied: :attr:`targets` must be\n        in concatenated format, all :attr:`input_lengths` must be `T`.  :math:`blank=0`,\n        :attr:`target_lengths` :math:`\\leq 256`, the integer arguments must be of\n        dtype :attr:`torch.int32`.\n\n        The regular implementation uses the (more common in PyTorch) `torch.long` dtype.\n\n\n    Note:\n        In some circumstances when using the CUDA backend with CuDNN, this operator\n        may select a nondeterministic algorithm to increase performance. If this is\n        undesirable, you can try to make the operation deterministic (potentially at\n        a performance cost) by setting ``torch.backends.cudnn.deterministic =\n        True``.\n        Please see the notes on :doc:`/notes/randomness` for background.\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "blank": {
                          "Type": "<class 'int'>",
                          "Default": "0"
                        },
                        "reduction": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        },
                        "zero_infinity": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "log_probs": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "targets": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "input_lengths": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "target_lengths": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "CosineEmbeddingLoss": {
                  "Doc": "Creates a criterion that measures the loss given input tensors\n    :math:`x_1`, :math:`x_2` and a `Tensor` label :math:`y` with values 1 or -1.\n    This is used for measuring whether two inputs are similar or dissimilar,\n    using the cosine similarity, and is typically used for learning nonlinear\n    embeddings or semi-supervised learning.\n\n    The loss function for each sample is:\n\n    .. math::\n        \\text{loss}(x, y) =\n        \\begin{cases}\n        1 - \\cos(x_1, x_2), & \\text{if } y = 1 \\\\\n        \\max(0, \\cos(x_1, x_2) - \\text{margin}), & \\text{if } y = -1\n        \\end{cases}\n\n    Args:\n        margin (float, optional): Should be a number from :math:`-1` to :math:`1`,\n            :math:`0` to :math:`0.5` is suggested. If :attr:`margin` is missing, the\n            default value is :math:`0`.\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there are multiple elements per sample. If the field :attr:`size_average`\n            is set to ``False``, the losses are instead summed for each minibatch. Ignored\n            when :attr:`reduce` is ``False``. Default: ``True``\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: ``True``\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the sum of the output will be divided by the number of\n            elements in the output, ``'sum'``: the output will be summed. Note: :attr:`size_average`\n            and :attr:`reduce` are in the process of being deprecated, and in the meantime,\n            specifying either of those two args will override :attr:`reduction`. Default: ``'mean'``\n\n    Shape:\n        - Input1: :math:`(N, D)` or :math:`(D)`, where `N` is the batch size and `D` is the embedding dimension.\n        - Input2: :math:`(N, D)` or :math:`(D)`, same shape as Input1.\n        - Target: :math:`(N)` or :math:`()`.\n        - Output: If :attr:`reduction` is ``'none'``, then :math:`(N)`, otherwise scalar.\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "margin": {
                          "Type": "<class 'float'>",
                          "Default": "0.0"
                        },
                        "size_average": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduce": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduction": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input1": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "input2": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "target": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "CrossEntropyLoss": {
                  "Doc": "This criterion computes the cross entropy loss between input logits\n    and target.\n\n    It is useful when training a classification problem with `C` classes.\n    If provided, the optional argument :attr:`weight` should be a 1D `Tensor`\n    assigning weight to each of the classes.\n    This is particularly useful when you have an unbalanced training set.\n\n    The `input` is expected to contain the unnormalized logits for each class (which do `not` need\n    to be positive or sum to 1, in general).\n    `input` has to be a Tensor of size :math:`(C)` for unbatched input,\n    :math:`(minibatch, C)` or :math:`(minibatch, C, d_1, d_2, ..., d_K)` with :math:`K \\geq 1` for the\n    `K`-dimensional case. The last being useful for higher dimension inputs, such\n    as computing cross entropy loss per-pixel for 2D images.\n\n    The `target` that this criterion expects should contain either:\n\n    - Class indices in the range :math:`[0, C)` where :math:`C` is the number of classes; if\n      `ignore_index` is specified, this loss also accepts this class index (this index\n      may not necessarily be in the class range). The unreduced (i.e. with :attr:`reduction`\n      set to ``'none'``) loss for this case can be described as:\n\n      .. math::\n          \\ell(x, y) = L = \\{l_1,\\dots,l_N\\}^\\top, \\quad\n          l_n = - w_{y_n} \\log \\frac{\\exp(x_{n,y_n})}{\\sum_{c=1}^C \\exp(x_{n,c})}\n          \\cdot \\mathbb{1}\\{y_n \\not= \\text{ignore\\_index}\\}\n\n      where :math:`x` is the input, :math:`y` is the target, :math:`w` is the weight,\n      :math:`C` is the number of classes, and :math:`N` spans the minibatch dimension as well as\n      :math:`d_1, ..., d_k` for the `K`-dimensional case. If\n      :attr:`reduction` is not ``'none'`` (default ``'mean'``), then\n\n      .. math::\n          \\ell(x, y) = \\begin{cases}\n              \\sum_{n=1}^N \\frac{1}{\\sum_{n=1}^N w_{y_n} \\cdot \\mathbb{1}\\{y_n \\not= \\text{ignore\\_index}\\}} l_n, &\n               \\text{if reduction} = \\text{`mean';}\\\\\n                \\sum_{n=1}^N l_n,  &\n                \\text{if reduction} = \\text{`sum'.}\n            \\end{cases}\n\n      Note that this case is equivalent to the combination of :class:`~torch.nn.LogSoftmax` and\n      :class:`~torch.nn.NLLLoss`.\n\n    - Probabilities for each class; useful when labels beyond a single class per minibatch item\n      are required, such as for blended labels, label smoothing, etc. The unreduced (i.e. with\n      :attr:`reduction` set to ``'none'``) loss for this case can be described as:\n\n      .. math::\n          \\ell(x, y) = L = \\{l_1,\\dots,l_N\\}^\\top, \\quad\n          l_n = - \\sum_{c=1}^C w_c \\log \\frac{\\exp(x_{n,c})}{\\sum_{i=1}^C \\exp(x_{n,i})} y_{n,c}\n\n      where :math:`x` is the input, :math:`y` is the target, :math:`w` is the weight,\n      :math:`C` is the number of classes, and :math:`N` spans the minibatch dimension as well as\n      :math:`d_1, ..., d_k` for the `K`-dimensional case. If\n      :attr:`reduction` is not ``'none'`` (default ``'mean'``), then\n\n      .. math::\n          \\ell(x, y) = \\begin{cases}\n              \\frac{\\sum_{n=1}^N l_n}{N}, &\n               \\text{if reduction} = \\text{`mean';}\\\\\n                \\sum_{n=1}^N l_n,  &\n                \\text{if reduction} = \\text{`sum'.}\n            \\end{cases}\n\n    .. note::\n        The performance of this criterion is generally better when `target` contains class\n        indices, as this allows for optimized computation. Consider providing `target` as\n        class probabilities only when a single class label per minibatch item is too restrictive.\n\n    Args:\n        weight (Tensor, optional): a manual rescaling weight given to each class.\n            If given, has to be a Tensor of size `C`\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there are multiple elements per sample. If the field :attr:`size_average`\n            is set to ``False``, the losses are instead summed for each minibatch. Ignored\n            when :attr:`reduce` is ``False``. Default: ``True``\n        ignore_index (int, optional): Specifies a target value that is ignored\n            and does not contribute to the input gradient. When :attr:`size_average` is\n            ``True``, the loss is averaged over non-ignored targets. Note that\n            :attr:`ignore_index` is only applicable when the target contains class indices.\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: ``True``\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will\n            be applied, ``'mean'``: the weighted mean of the output is taken,\n            ``'sum'``: the output will be summed. Note: :attr:`size_average`\n            and :attr:`reduce` are in the process of being deprecated, and in\n            the meantime, specifying either of those two args will override\n            :attr:`reduction`. Default: ``'mean'``\n        label_smoothing (float, optional): A float in [0.0, 1.0]. Specifies the amount\n            of smoothing when computing the loss, where 0.0 means no smoothing. The targets\n            become a mixture of the original ground truth and a uniform distribution as described in\n            `Rethinking the Inception Architecture for Computer Vision <https://arxiv.org/abs/1512.00567>`__. Default: :math:`0.0`.\n\n    Shape:\n        - Input: Shape :math:`(C)`, :math:`(N, C)` or :math:`(N, C, d_1, d_2, ..., d_K)` with :math:`K \\geq 1`\n          in the case of `K`-dimensional loss.\n        - Target: If containing class indices, shape :math:`()`, :math:`(N)` or :math:`(N, d_1, d_2, ..., d_K)` with\n          :math:`K \\geq 1` in the case of K-dimensional loss where each value should be between :math:`[0, C)`.\n          If containing class probabilities, same shape as the input and each value should be between :math:`[0, 1]`.\n        - Output: If reduction is 'none', shape :math:`()`, :math:`(N)` or :math:`(N, d_1, d_2, ..., d_K)` with :math:`K \\geq 1`\n          in the case of K-dimensional loss, depending on the shape of the input. Otherwise, scalar.\n\n\n        where:\n\n        .. math::\n            \\begin{aligned}\n                C ={} & \\text{number of classes} \\\\\n                N ={} & \\text{batch size} \\\\\n            \\end{aligned}\n\n    Examples::\n\n        >>> # Example of target with class indices\n        >>> loss = nn.CrossEntropyLoss()\n        >>> input = torch.randn(3, 5, requires_grad=True)\n        >>> target = torch.empty(3, dtype=torch.long).random_(5)\n        >>> output = loss(input, target)\n        >>> output.backward()\n        >>>\n        >>> # Example of target with class probabilities\n        >>> input = torch.randn(3, 5, requires_grad=True)\n        >>> target = torch.randn(3, 5).softmax(dim=1)\n        >>> output = loss(input, target)\n        >>> output.backward()\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "weight": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "size_average": {
                          "Type": null,
                          "Default": "None"
                        },
                        "ignore_index": {
                          "Type": "<class 'int'>",
                          "Default": "-100"
                        },
                        "reduce": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduction": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        },
                        "label_smoothing": {
                          "Type": "<class 'float'>",
                          "Default": "0.0"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "target": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "GaussianNLLLoss": {
                  "Doc": "Gaussian negative log likelihood loss.\n\n    The targets are treated as samples from Gaussian distributions with\n    expectations and variances predicted by the neural network. For a\n    ``target`` tensor modelled as having Gaussian distribution with a tensor\n    of expectations ``input`` and a tensor of positive variances ``var`` the loss is:\n\n    .. math::\n        \\text{loss} = \\frac{1}{2}\\left(\\log\\left(\\text{max}\\left(\\text{var},\n        \\ \\text{eps}\\right)\\right) + \\frac{\\left(\\text{input} - \\text{target}\\right)^2}\n        {\\text{max}\\left(\\text{var}, \\ \\text{eps}\\right)}\\right) + \\text{const.}\n\n    where :attr:`eps` is used for stability. By default, the constant term of\n    the loss function is omitted unless :attr:`full` is ``True``. If ``var`` is not the same\n    size as ``input`` (due to a homoscedastic assumption), it must either have a final dimension\n    of 1 or have one fewer dimension (with all other sizes being the same) for correct broadcasting.\n\n    Args:\n        full (bool, optional): include the constant term in the loss\n            calculation. Default: ``False``.\n        eps (float, optional): value used to clamp ``var`` (see note below), for\n            stability. Default: 1e-6.\n        reduction (str, optional): specifies the reduction to apply to the\n            output:``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction\n            will be applied, ``'mean'``: the output is the average of all batch\n            member losses, ``'sum'``: the output is the sum of all batch member\n            losses. Default: ``'mean'``.\n\n    Shape:\n        - Input: :math:`(N, *)` or :math:`(*)` where :math:`*` means any number of additional\n          dimensions\n        - Target: :math:`(N, *)` or :math:`(*)`, same shape as the input, or same shape as the input\n          but with one dimension equal to 1 (to allow for broadcasting)\n        - Var: :math:`(N, *)` or :math:`(*)`, same shape as the input, or same shape as the input but\n          with one dimension equal to 1, or same shape as the input but with one fewer\n          dimension (to allow for broadcasting)\n        - Output: scalar if :attr:`reduction` is ``'mean'`` (default) or\n          ``'sum'``. If :attr:`reduction` is ``'none'``, then :math:`(N, *)`, same\n          shape as the input\n\n    Examples::\n        >>> loss = nn.GaussianNLLLoss()\n        >>> input = torch.randn(5, 2, requires_grad=True)\n        >>> target = torch.randn(5, 2)\n        >>> var = torch.ones(5, 2, requires_grad=True) #heteroscedastic\n        >>> output = loss(input, target, var)\n        >>> output.backward()\n\n        >>> loss = nn.GaussianNLLLoss()\n        >>> input = torch.randn(5, 2, requires_grad=True)\n        >>> target = torch.randn(5, 2)\n        >>> var = torch.ones(5, 1, requires_grad=True) #homoscedastic\n        >>> output = loss(input, target, var)\n        >>> output.backward()\n\n    Note:\n        The clamping of ``var`` is ignored with respect to autograd, and so the\n        gradients are unaffected by it.\n\n    Reference:\n        Nix, D. A. and Weigend, A. S., \"Estimating the mean and variance of the\n        target probability distribution\", Proceedings of 1994 IEEE International\n        Conference on Neural Networks (ICNN'94), Orlando, FL, USA, 1994, pp. 55-60\n        vol.1, doi: 10.1109/ICNN.1994.374138.\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "full": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "eps": {
                          "Type": "<class 'float'>",
                          "Default": "1e-06"
                        },
                        "reduction": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "target": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "var": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "HingeEmbeddingLoss": {
                  "Doc": "Measures the loss given an input tensor :math:`x` and a labels tensor :math:`y`\n    (containing 1 or -1).\n    This is usually used for measuring whether two inputs are similar or\n    dissimilar, e.g. using the L1 pairwise distance as :math:`x`, and is typically\n    used for learning nonlinear embeddings or semi-supervised learning.\n\n    The loss function for :math:`n`-th sample in the mini-batch is\n\n    .. math::\n        l_n = \\begin{cases}\n            x_n, & \\text{if}\\; y_n = 1,\\\\\n            \\max \\{0, \\Delta - x_n\\}, & \\text{if}\\; y_n = -1,\n        \\end{cases}\n\n    and the total loss functions is\n\n    .. math::\n        \\ell(x, y) = \\begin{cases}\n            \\operatorname{mean}(L), & \\text{if reduction} = \\text{`mean';}\\\\\n            \\operatorname{sum}(L),  & \\text{if reduction} = \\text{`sum'.}\n        \\end{cases}\n\n    where :math:`L = \\{l_1,\\dots,l_N\\}^\\top`.\n\n    Args:\n        margin (float, optional): Has a default value of `1`.\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there are multiple elements per sample. If the field :attr:`size_average`\n            is set to ``False``, the losses are instead summed for each minibatch. Ignored\n            when :attr:`reduce` is ``False``. Default: ``True``\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: ``True``\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the sum of the output will be divided by the number of\n            elements in the output, ``'sum'``: the output will be summed. Note: :attr:`size_average`\n            and :attr:`reduce` are in the process of being deprecated, and in the meantime,\n            specifying either of those two args will override :attr:`reduction`. Default: ``'mean'``\n\n    Shape:\n        - Input: :math:`(*)` where :math:`*` means, any number of dimensions. The sum operation\n          operates over all the elements.\n        - Target: :math:`(*)`, same shape as the input\n        - Output: scalar. If :attr:`reduction` is ``'none'``, then same shape as the input\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "margin": {
                          "Type": "<class 'float'>",
                          "Default": "1.0"
                        },
                        "size_average": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduce": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduction": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "target": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "HuberLoss": {
                  "Doc": "Creates a criterion that uses a squared term if the absolute\n    element-wise error falls below delta and a delta-scaled L1 term otherwise.\n    This loss combines advantages of both :class:`L1Loss` and :class:`MSELoss`; the\n    delta-scaled L1 region makes the loss less sensitive to outliers than :class:`MSELoss`,\n    while the L2 region provides smoothness over :class:`L1Loss` near 0. See\n    `Huber loss <https://en.wikipedia.org/wiki/Huber_loss>`_ for more information.\n\n    For a batch of size :math:`N`, the unreduced loss can be described as:\n\n    .. math::\n        \\ell(x, y) = L = \\{l_1, ..., l_N\\}^T\n\n    with\n\n    .. math::\n        l_n = \\begin{cases}\n        0.5 (x_n - y_n)^2, & \\text{if } |x_n - y_n| < delta \\\\\n        delta * (|x_n - y_n| - 0.5 * delta), & \\text{otherwise }\n        \\end{cases}\n\n    If `reduction` is not `none`, then:\n\n    .. math::\n        \\ell(x, y) =\n        \\begin{cases}\n            \\operatorname{mean}(L), &  \\text{if reduction} = \\text{`mean';}\\\\\n            \\operatorname{sum}(L),  &  \\text{if reduction} = \\text{`sum'.}\n        \\end{cases}\n\n    .. note::\n        When delta is set to 1, this loss is equivalent to :class:`SmoothL1Loss`.\n        In general, this loss differs from :class:`SmoothL1Loss` by a factor of delta (AKA beta\n        in Smooth L1).\n        See :class:`SmoothL1Loss` for additional discussion on the differences in behavior\n        between the two losses.\n\n    Args:\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the sum of the output will be divided by the number of\n            elements in the output, ``'sum'``: the output will be summed. Default: ``'mean'``\n        delta (float, optional): Specifies the threshold at which to change between delta-scaled L1 and L2 loss.\n            The value must be positive.  Default: 1.0\n\n    Shape:\n        - Input: :math:`(*)` where :math:`*` means any number of dimensions.\n        - Target: :math:`(*)`, same shape as the input.\n        - Output: scalar. If :attr:`reduction` is ``'none'``, then :math:`(*)`, same shape as the input.\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "reduction": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        },
                        "delta": {
                          "Type": "<class 'float'>",
                          "Default": "1.0"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "target": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "KLDivLoss": {
                  "Doc": "The Kullback-Leibler divergence loss.\n\n    For tensors of the same shape :math:`y_{\\text{pred}},\\ y_{\\text{true}}`,\n    where :math:`y_{\\text{pred}}` is the :attr:`input` and :math:`y_{\\text{true}}` is the\n    :attr:`target`, we define the **pointwise KL-divergence** as\n\n    .. math::\n\n        L(y_{\\text{pred}},\\ y_{\\text{true}})\n            = y_{\\text{true}} \\cdot \\log \\frac{y_{\\text{true}}}{y_{\\text{pred}}}\n            = y_{\\text{true}} \\cdot (\\log y_{\\text{true}} - \\log y_{\\text{pred}})\n\n    To avoid underflow issues when computing this quantity, this loss expects the argument\n    :attr:`input` in the log-space. The argument :attr:`target` may also be provided in the\n    log-space if :attr:`log_target`\\ `= True`.\n\n    To summarise, this function is roughly equivalent to computing\n\n    .. code-block:: python\n\n        if not log_target: # default\n            loss_pointwise = target * (target.log() - input)\n        else:\n            loss_pointwise = target.exp() * (target - input)\n\n    and then reducing this result depending on the argument :attr:`reduction` as\n\n    .. code-block:: python\n\n        if reduction == \"mean\":  # default\n            loss = loss_pointwise.mean()\n        elif reduction == \"batchmean\":  # mathematically correct\n            loss = loss_pointwise.sum() / input.size(0)\n        elif reduction == \"sum\":\n            loss = loss_pointwise.sum()\n        else:  # reduction == \"none\"\n            loss = loss_pointwise\n\n    .. note::\n        As all the other losses in PyTorch, this function expects the first argument,\n        :attr:`input`, to be the output of the model (e.g. the neural network)\n        and the second, :attr:`target`, to be the observations in the dataset.\n        This differs from the standard mathematical notation :math:`KL(P\\ ||\\ Q)` where\n        :math:`P` denotes the distribution of the observations and :math:`Q` denotes the model.\n\n    .. warning::\n        :attr:`reduction`\\ `= \"mean\"` doesn't return the true KL divergence value, please use\n        :attr:`reduction`\\ `= \"batchmean\"` which aligns with the mathematical definition.\n        In a future release, `\"mean\"` will be changed to be the same as `\"batchmean\"`.\n\n    Args:\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there are multiple elements per sample. If the field :attr:`size_average`\n            is set to `False`, the losses are instead summed for each minibatch. Ignored\n            when :attr:`reduce` is `False`. Default: `True`\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is `False`, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: `True`\n        reduction (str, optional): Specifies the reduction to apply to the output. Default: `\"mean\"`\n        log_target (bool, optional): Specifies whether `target` is the log space. Default: `False`\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Target: :math:`(*)`, same shape as the input.\n        - Output: scalar by default. If :attr:`reduction` is `'none'`, then :math:`(*)`,\n          same shape as the input.\n\n    Examples::\n\n        >>> import torch.nn.functional as F\n        >>> kl_loss = nn.KLDivLoss(reduction=\"batchmean\")\n        >>> # input should be a distribution in the log space\n        >>> input = F.log_softmax(torch.randn(3, 5, requires_grad=True), dim=1)\n        >>> # Sample a batch of distributions. Usually this would come from the dataset\n        >>> target = F.softmax(torch.rand(3, 5), dim=1)\n        >>> output = kl_loss(input, target)\n\n        >>> kl_loss = nn.KLDivLoss(reduction=\"batchmean\", log_target=True)\n        >>> log_target = F.log_softmax(torch.rand(3, 5), dim=1)\n        >>> output = kl_loss(input, log_target)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "size_average": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduce": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduction": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        },
                        "log_target": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "target": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "L1Loss": {
                  "Doc": "Creates a criterion that measures the mean absolute error (MAE) between each element in\n    the input :math:`x` and target :math:`y`.\n\n    The unreduced (i.e. with :attr:`reduction` set to ``'none'``) loss can be described as:\n\n    .. math::\n        \\ell(x, y) = L = \\{l_1,\\dots,l_N\\}^\\top, \\quad\n        l_n = \\left| x_n - y_n \\right|,\n\n    where :math:`N` is the batch size. If :attr:`reduction` is not ``'none'``\n    (default ``'mean'``), then:\n\n    .. math::\n        \\ell(x, y) =\n        \\begin{cases}\n            \\operatorname{mean}(L), & \\text{if reduction} = \\text{`mean';}\\\\\n            \\operatorname{sum}(L),  & \\text{if reduction} = \\text{`sum'.}\n        \\end{cases}\n\n    :math:`x` and :math:`y` are tensors of arbitrary shapes with a total\n    of :math:`n` elements each.\n\n    The sum operation still operates over all the elements, and divides by :math:`n`.\n\n    The division by :math:`n` can be avoided if one sets ``reduction = 'sum'``.\n\n    Supports real-valued and complex-valued inputs.\n\n    Args:\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there are multiple elements per sample. If the field :attr:`size_average`\n            is set to ``False``, the losses are instead summed for each minibatch. Ignored\n            when :attr:`reduce` is ``False``. Default: ``True``\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: ``True``\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the sum of the output will be divided by the number of\n            elements in the output, ``'sum'``: the output will be summed. Note: :attr:`size_average`\n            and :attr:`reduce` are in the process of being deprecated, and in the meantime,\n            specifying either of those two args will override :attr:`reduction`. Default: ``'mean'``\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Target: :math:`(*)`, same shape as the input.\n        - Output: scalar. If :attr:`reduction` is ``'none'``, then\n          :math:`(*)`, same shape as the input.\n\n    Examples::\n\n        >>> loss = nn.L1Loss()\n        >>> input = torch.randn(3, 5, requires_grad=True)\n        >>> target = torch.randn(3, 5)\n        >>> output = loss(input, target)\n        >>> output.backward()\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "size_average": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduce": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduction": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "target": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "MSELoss": {
                  "Doc": "Creates a criterion that measures the mean squared error (squared L2 norm) between\n    each element in the input :math:`x` and target :math:`y`.\n\n    The unreduced (i.e. with :attr:`reduction` set to ``'none'``) loss can be described as:\n\n    .. math::\n        \\ell(x, y) = L = \\{l_1,\\dots,l_N\\}^\\top, \\quad\n        l_n = \\left( x_n - y_n \\right)^2,\n\n    where :math:`N` is the batch size. If :attr:`reduction` is not ``'none'``\n    (default ``'mean'``), then:\n\n    .. math::\n        \\ell(x, y) =\n        \\begin{cases}\n            \\operatorname{mean}(L), &  \\text{if reduction} = \\text{`mean';}\\\\\n            \\operatorname{sum}(L),  &  \\text{if reduction} = \\text{`sum'.}\n        \\end{cases}\n\n    :math:`x` and :math:`y` are tensors of arbitrary shapes with a total\n    of :math:`n` elements each.\n\n    The mean operation still operates over all the elements, and divides by :math:`n`.\n\n    The division by :math:`n` can be avoided if one sets ``reduction = 'sum'``.\n\n    Args:\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there are multiple elements per sample. If the field :attr:`size_average`\n            is set to ``False``, the losses are instead summed for each minibatch. Ignored\n            when :attr:`reduce` is ``False``. Default: ``True``\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: ``True``\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the sum of the output will be divided by the number of\n            elements in the output, ``'sum'``: the output will be summed. Note: :attr:`size_average`\n            and :attr:`reduce` are in the process of being deprecated, and in the meantime,\n            specifying either of those two args will override :attr:`reduction`. Default: ``'mean'``\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Target: :math:`(*)`, same shape as the input.\n\n    Examples::\n\n        >>> loss = nn.MSELoss()\n        >>> input = torch.randn(3, 5, requires_grad=True)\n        >>> target = torch.randn(3, 5)\n        >>> output = loss(input, target)\n        >>> output.backward()\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "size_average": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduce": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduction": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "target": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "MarginRankingLoss": {
                  "Doc": "Creates a criterion that measures the loss given\n    inputs :math:`x1`, :math:`x2`, two 1D mini-batch or 0D `Tensors`,\n    and a label 1D mini-batch or 0D `Tensor` :math:`y` (containing 1 or -1).\n\n    If :math:`y = 1` then it assumed the first input should be ranked higher\n    (have a larger value) than the second input, and vice-versa for :math:`y = -1`.\n\n    The loss function for each pair of samples in the mini-batch is:\n\n    .. math::\n        \\text{loss}(x1, x2, y) = \\max(0, -y * (x1 - x2) + \\text{margin})\n\n    Args:\n        margin (float, optional): Has a default value of :math:`0`.\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there are multiple elements per sample. If the field :attr:`size_average`\n            is set to ``False``, the losses are instead summed for each minibatch. Ignored\n            when :attr:`reduce` is ``False``. Default: ``True``\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: ``True``\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the sum of the output will be divided by the number of\n            elements in the output, ``'sum'``: the output will be summed. Note: :attr:`size_average`\n            and :attr:`reduce` are in the process of being deprecated, and in the meantime,\n            specifying either of those two args will override :attr:`reduction`. Default: ``'mean'``\n\n    Shape:\n        - Input1: :math:`(N)` or :math:`()` where `N` is the batch size.\n        - Input2: :math:`(N)` or :math:`()`, same shape as the Input1.\n        - Target: :math:`(N)` or :math:`()`, same shape as the inputs.\n        - Output: scalar. If :attr:`reduction` is ``'none'`` and Input size is not :math:`()`, then :math:`(N)`.\n\n    Examples::\n\n        >>> loss = nn.MarginRankingLoss()\n        >>> input1 = torch.randn(3, requires_grad=True)\n        >>> input2 = torch.randn(3, requires_grad=True)\n        >>> target = torch.randn(3).sign()\n        >>> output = loss(input1, input2, target)\n        >>> output.backward()\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "margin": {
                          "Type": "<class 'float'>",
                          "Default": "0.0"
                        },
                        "size_average": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduce": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduction": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input1": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "input2": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "target": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "MultiLabelMarginLoss": {
                  "Doc": "Creates a criterion that optimizes a multi-class multi-classification\n    hinge loss (margin-based loss) between input :math:`x` (a 2D mini-batch `Tensor`)\n    and output :math:`y` (which is a 2D `Tensor` of target class indices).\n    For each sample in the mini-batch:\n\n    .. math::\n        \\text{loss}(x, y) = \\sum_{ij}\\frac{\\max(0, 1 - (x[y[j]] - x[i]))}{\\text{x.size}(0)}\n\n    where :math:`x \\in \\left\\{0, \\; \\cdots , \\; \\text{x.size}(0) - 1\\right\\}`, \\\n    :math:`y \\in \\left\\{0, \\; \\cdots , \\; \\text{y.size}(0) - 1\\right\\}`, \\\n    :math:`0 \\leq y[j] \\leq \\text{x.size}(0)-1`, \\\n    and :math:`i \\neq y[j]` for all :math:`i` and :math:`j`.\n\n    :math:`y` and :math:`x` must have the same size.\n\n    The criterion only considers a contiguous block of non-negative targets that\n    starts at the front.\n\n    This allows for different samples to have variable amounts of target classes.\n\n    Args:\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there are multiple elements per sample. If the field :attr:`size_average`\n            is set to ``False``, the losses are instead summed for each minibatch. Ignored\n            when :attr:`reduce` is ``False``. Default: ``True``\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: ``True``\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the sum of the output will be divided by the number of\n            elements in the output, ``'sum'``: the output will be summed. Note: :attr:`size_average`\n            and :attr:`reduce` are in the process of being deprecated, and in the meantime,\n            specifying either of those two args will override :attr:`reduction`. Default: ``'mean'``\n\n    Shape:\n        - Input: :math:`(C)` or :math:`(N, C)` where `N` is the batch size and `C`\n          is the number of classes.\n        - Target: :math:`(C)` or :math:`(N, C)`, label targets padded by -1 ensuring same shape as the input.\n        - Output: scalar. If :attr:`reduction` is ``'none'``, then :math:`(N)`.\n\n    Examples::\n\n        >>> loss = nn.MultiLabelMarginLoss()\n        >>> x = torch.FloatTensor([[0.1, 0.2, 0.4, 0.8]])\n        >>> # for target y, only consider labels 3 and 0, not after label -1\n        >>> y = torch.LongTensor([[3, 0, -1, 1]])\n        >>> # 0.25 * ((1-(0.1-0.2)) + (1-(0.1-0.4)) + (1-(0.8-0.2)) + (1-(0.8-0.4)))\n        >>> loss(x, y)\n        tensor(0.85...)\n\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "size_average": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduce": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduction": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "target": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "MultiLabelSoftMarginLoss": {
                  "Doc": "Creates a criterion that optimizes a multi-label one-versus-all\n    loss based on max-entropy, between input :math:`x` and target :math:`y` of size\n    :math:`(N, C)`.\n    For each sample in the minibatch:\n\n    .. math::\n        loss(x, y) = - \\frac{1}{C} * \\sum_i y[i] * \\log((1 + \\exp(-x[i]))^{-1})\n                         + (1-y[i]) * \\log\\left(\\frac{\\exp(-x[i])}{(1 + \\exp(-x[i]))}\\right)\n\n    where :math:`i \\in \\left\\{0, \\; \\cdots , \\; \\text{x.nElement}() - 1\\right\\}`,\n    :math:`y[i] \\in \\left\\{0, \\; 1\\right\\}`.\n\n    Args:\n        weight (Tensor, optional): a manual rescaling weight given to each\n            class. If given, it has to be a Tensor of size `C`. Otherwise, it is\n            treated as if having all ones.\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there are multiple elements per sample. If the field :attr:`size_average`\n            is set to ``False``, the losses are instead summed for each minibatch. Ignored\n            when :attr:`reduce` is ``False``. Default: ``True``\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: ``True``\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the sum of the output will be divided by the number of\n            elements in the output, ``'sum'``: the output will be summed. Note: :attr:`size_average`\n            and :attr:`reduce` are in the process of being deprecated, and in the meantime,\n            specifying either of those two args will override :attr:`reduction`. Default: ``'mean'``\n\n    Shape:\n        - Input: :math:`(N, C)` where `N` is the batch size and `C` is the number of classes.\n        - Target: :math:`(N, C)`, label targets padded by -1 ensuring same shape as the input.\n        - Output: scalar. If :attr:`reduction` is ``'none'``, then :math:`(N)`.\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "weight": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "size_average": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduce": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduction": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "target": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "MultiMarginLoss": {
                  "Doc": "Creates a criterion that optimizes a multi-class classification hinge\n    loss (margin-based loss) between input :math:`x` (a 2D mini-batch `Tensor`) and\n    output :math:`y` (which is a 1D tensor of target class indices,\n    :math:`0 \\leq y \\leq \\text{x.size}(1)-1`):\n\n    For each mini-batch sample, the loss in terms of the 1D input :math:`x` and scalar\n    output :math:`y` is:\n\n    .. math::\n        \\text{loss}(x, y) = \\frac{\\sum_i \\max(0, \\text{margin} - x[y] + x[i])^p}{\\text{x.size}(0)}\n\n    where :math:`i \\in \\left\\{0, \\; \\cdots , \\; \\text{x.size}(0) - 1\\right\\}`\n    and :math:`i \\neq y`.\n\n    Optionally, you can give non-equal weighting on the classes by passing\n    a 1D :attr:`weight` tensor into the constructor.\n\n    The loss function then becomes:\n\n    .. math::\n        \\text{loss}(x, y) = \\frac{\\sum_i \\max(0, w[y] * (\\text{margin} - x[y] + x[i]))^p}{\\text{x.size}(0)}\n\n    Args:\n        p (int, optional): Has a default value of :math:`1`. :math:`1` and :math:`2`\n            are the only supported values.\n        margin (float, optional): Has a default value of :math:`1`.\n        weight (Tensor, optional): a manual rescaling weight given to each\n            class. If given, it has to be a Tensor of size `C`. Otherwise, it is\n            treated as if having all ones.\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there are multiple elements per sample. If the field :attr:`size_average`\n            is set to ``False``, the losses are instead summed for each minibatch. Ignored\n            when :attr:`reduce` is ``False``. Default: ``True``\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: ``True``\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the sum of the output will be divided by the number of\n            elements in the output, ``'sum'``: the output will be summed. Note: :attr:`size_average`\n            and :attr:`reduce` are in the process of being deprecated, and in the meantime,\n            specifying either of those two args will override :attr:`reduction`. Default: ``'mean'``\n\n    Shape:\n        - Input: :math:`(N, C)` or :math:`(C)`, where :math:`N` is the batch size and :math:`C` is the number of classes.\n        - Target: :math:`(N)` or :math:`()`, where each value is :math:`0 \\leq \\text{targets}[i] \\leq C-1`.\n        - Output: scalar. If :attr:`reduction` is ``'none'``, then same shape as the target.\n\n    Examples::\n\n        >>> loss = nn.MultiMarginLoss()\n        >>> x = torch.tensor([[0.1, 0.2, 0.4, 0.8]])\n        >>> y = torch.tensor([3])\n        >>> # 0.25 * ((1-(0.8-0.1)) + (1-(0.8-0.2)) + (1-(0.8-0.4)))\n        >>> loss(x, y)\n        tensor(0.32...)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "p": {
                          "Type": "<class 'int'>",
                          "Default": "1"
                        },
                        "margin": {
                          "Type": "<class 'float'>",
                          "Default": "1.0"
                        },
                        "weight": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "size_average": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduce": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduction": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "target": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "NLLLoss": {
                  "Doc": "The negative log likelihood loss. It is useful to train a classification\n    problem with `C` classes.\n\n    If provided, the optional argument :attr:`weight` should be a 1D Tensor assigning\n    weight to each of the classes. This is particularly useful when you have an\n    unbalanced training set.\n\n    The `input` given through a forward call is expected to contain\n    log-probabilities of each class. `input` has to be a Tensor of size either\n    :math:`(minibatch, C)` or :math:`(minibatch, C, d_1, d_2, ..., d_K)`\n    with :math:`K \\geq 1` for the `K`-dimensional case. The latter is useful for\n    higher dimension inputs, such as computing NLL loss per-pixel for 2D images.\n\n    Obtaining log-probabilities in a neural network is easily achieved by\n    adding a  `LogSoftmax`  layer in the last layer of your network.\n    You may use `CrossEntropyLoss` instead, if you prefer not to add an extra\n    layer.\n\n    The `target` that this loss expects should be a class index in the range :math:`[0, C-1]`\n    where `C = number of classes`; if `ignore_index` is specified, this loss also accepts\n    this class index (this index may not necessarily be in the class range).\n\n    The unreduced (i.e. with :attr:`reduction` set to ``'none'``) loss can be described as:\n\n    .. math::\n        \\ell(x, y) = L = \\{l_1,\\dots,l_N\\}^\\top, \\quad\n        l_n = - w_{y_n} x_{n,y_n}, \\quad\n        w_{c} = \\text{weight}[c] \\cdot \\mathbb{1}\\{c \\not= \\text{ignore\\_index}\\},\n\n    where :math:`x` is the input, :math:`y` is the target, :math:`w` is the weight, and\n    :math:`N` is the batch size. If :attr:`reduction` is not ``'none'``\n    (default ``'mean'``), then\n\n    .. math::\n        \\ell(x, y) = \\begin{cases}\n            \\sum_{n=1}^N \\frac{1}{\\sum_{n=1}^N w_{y_n}} l_n, &\n            \\text{if reduction} = \\text{`mean';}\\\\\n            \\sum_{n=1}^N l_n,  &\n            \\text{if reduction} = \\text{`sum'.}\n        \\end{cases}\n\n    Args:\n        weight (Tensor, optional): a manual rescaling weight given to each\n            class. If given, it has to be a Tensor of size `C`. Otherwise, it is\n            treated as if having all ones.\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there are multiple elements per sample. If the field :attr:`size_average`\n            is set to ``False``, the losses are instead summed for each minibatch. Ignored\n            when :attr:`reduce` is ``False``. Default: ``None``\n        ignore_index (int, optional): Specifies a target value that is ignored\n            and does not contribute to the input gradient. When\n            :attr:`size_average` is ``True``, the loss is averaged over\n            non-ignored targets.\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: ``None``\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will\n            be applied, ``'mean'``: the weighted mean of the output is taken,\n            ``'sum'``: the output will be summed. Note: :attr:`size_average`\n            and :attr:`reduce` are in the process of being deprecated, and in\n            the meantime, specifying either of those two args will override\n            :attr:`reduction`. Default: ``'mean'``\n\n    Shape:\n        - Input: :math:`(N, C)` or :math:`(C)`, where `C = number of classes`, or\n          :math:`(N, C, d_1, d_2, ..., d_K)` with :math:`K \\geq 1`\n          in the case of `K`-dimensional loss.\n        - Target: :math:`(N)` or :math:`()`, where each value is\n          :math:`0 \\leq \\text{targets}[i] \\leq C-1`, or\n          :math:`(N, d_1, d_2, ..., d_K)` with :math:`K \\geq 1` in the case of\n          K-dimensional loss.\n        - Output: If :attr:`reduction` is ``'none'``, shape :math:`(N)` or\n          :math:`(N, d_1, d_2, ..., d_K)` with :math:`K \\geq 1` in the case of K-dimensional loss.\n          Otherwise, scalar.\n\n    Examples::\n\n        >>> m = nn.LogSoftmax(dim=1)\n        >>> loss = nn.NLLLoss()\n        >>> # input is of size N x C = 3 x 5\n        >>> input = torch.randn(3, 5, requires_grad=True)\n        >>> # each element in target has to have 0 <= value < C\n        >>> target = torch.tensor([1, 0, 4])\n        >>> output = loss(m(input), target)\n        >>> output.backward()\n        >>>\n        >>>\n        >>> # 2D loss example (used, for example, with image inputs)\n        >>> N, C = 5, 4\n        >>> loss = nn.NLLLoss()\n        >>> # input is of size N x C x height x width\n        >>> data = torch.randn(N, 16, 10, 10)\n        >>> conv = nn.Conv2d(16, C, (3, 3))\n        >>> m = nn.LogSoftmax(dim=1)\n        >>> # each element in target has to have 0 <= value < C\n        >>> target = torch.empty(N, 8, 8, dtype=torch.long).random_(0, C)\n        >>> output = loss(m(conv(data)), target)\n        >>> output.backward()\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "weight": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "size_average": {
                          "Type": null,
                          "Default": "None"
                        },
                        "ignore_index": {
                          "Type": "<class 'int'>",
                          "Default": "-100"
                        },
                        "reduce": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduction": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "target": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "NLLLoss2d": {
                  "Doc": null,
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "weight": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "size_average": {
                          "Type": null,
                          "Default": "None"
                        },
                        "ignore_index": {
                          "Type": "<class 'int'>",
                          "Default": "-100"
                        },
                        "reduce": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduction": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        }
                      }
                    }
                  }
                },
                "PoissonNLLLoss": {
                  "Doc": "Negative log likelihood loss with Poisson distribution of target.\n\n    The loss can be described as:\n\n    .. math::\n        \\text{target} \\sim \\mathrm{Poisson}(\\text{input})\n\n        \\text{loss}(\\text{input}, \\text{target}) = \\text{input} - \\text{target} * \\log(\\text{input})\n                                    + \\log(\\text{target!})\n\n    The last term can be omitted or approximated with Stirling formula. The\n    approximation is used for target values more than 1. For targets less or\n    equal to 1 zeros are added to the loss.\n\n    Args:\n        log_input (bool, optional): if ``True`` the loss is computed as\n            :math:`\\exp(\\text{input}) - \\text{target}*\\text{input}`, if ``False`` the loss is\n            :math:`\\text{input} - \\text{target}*\\log(\\text{input}+\\text{eps})`.\n        full (bool, optional): whether to compute full loss, i. e. to add the\n            Stirling approximation term\n\n            .. math::\n                \\text{target}*\\log(\\text{target}) - \\text{target} + 0.5 * \\log(2\\pi\\text{target}).\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there are multiple elements per sample. If the field :attr:`size_average`\n            is set to ``False``, the losses are instead summed for each minibatch. Ignored\n            when :attr:`reduce` is ``False``. Default: ``True``\n        eps (float, optional): Small value to avoid evaluation of :math:`\\log(0)` when\n            :attr:`log_input = False`. Default: 1e-8\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: ``True``\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the sum of the output will be divided by the number of\n            elements in the output, ``'sum'``: the output will be summed. Note: :attr:`size_average`\n            and :attr:`reduce` are in the process of being deprecated, and in the meantime,\n            specifying either of those two args will override :attr:`reduction`. Default: ``'mean'``\n\n    Examples::\n\n        >>> loss = nn.PoissonNLLLoss()\n        >>> log_input = torch.randn(5, 2, requires_grad=True)\n        >>> target = torch.randn(5, 2)\n        >>> output = loss(log_input, target)\n        >>> output.backward()\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Target: :math:`(*)`, same shape as the input.\n        - Output: scalar by default. If :attr:`reduction` is ``'none'``, then :math:`(*)`,\n          the same shape as the input.\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "log_input": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "full": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "size_average": {
                          "Type": null,
                          "Default": "None"
                        },
                        "eps": {
                          "Type": "<class 'float'>",
                          "Default": "1e-08"
                        },
                        "reduce": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduction": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "log_input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "target": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "SmoothL1Loss": {
                  "Doc": "Creates a criterion that uses a squared term if the absolute\n    element-wise error falls below beta and an L1 term otherwise.\n    It is less sensitive to outliers than :class:`torch.nn.MSELoss` and in some cases\n    prevents exploding gradients (e.g. see the paper `Fast R-CNN`_ by Ross Girshick).\n\n    For a batch of size :math:`N`, the unreduced loss can be described as:\n\n    .. math::\n        \\ell(x, y) = L = \\{l_1, ..., l_N\\}^T\n\n    with\n\n    .. math::\n        l_n = \\begin{cases}\n        0.5 (x_n - y_n)^2 / beta, & \\text{if } |x_n - y_n| < beta \\\\\n        |x_n - y_n| - 0.5 * beta, & \\text{otherwise }\n        \\end{cases}\n\n    If `reduction` is not `none`, then:\n\n    .. math::\n        \\ell(x, y) =\n        \\begin{cases}\n            \\operatorname{mean}(L), &  \\text{if reduction} = \\text{`mean';}\\\\\n            \\operatorname{sum}(L),  &  \\text{if reduction} = \\text{`sum'.}\n        \\end{cases}\n\n    .. note::\n        Smooth L1 loss can be seen as exactly :class:`L1Loss`, but with the :math:`|x - y| < beta`\n        portion replaced with a quadratic function such that its slope is 1 at :math:`|x - y| = beta`.\n        The quadratic segment smooths the L1 loss near :math:`|x - y| = 0`.\n\n    .. note::\n        Smooth L1 loss is closely related to :class:`HuberLoss`, being\n        equivalent to :math:`huber(x, y) / beta` (note that Smooth L1's beta hyper-parameter is\n        also known as delta for Huber). This leads to the following differences:\n\n        * As beta -> 0, Smooth L1 loss converges to :class:`L1Loss`, while :class:`HuberLoss`\n          converges to a constant 0 loss. When beta is 0, Smooth L1 loss is equivalent to L1 loss.\n        * As beta -> :math:`+\\infty`, Smooth L1 loss converges to a constant 0 loss, while\n          :class:`HuberLoss` converges to :class:`MSELoss`.\n        * For Smooth L1 loss, as beta varies, the L1 segment of the loss has a constant slope of 1.\n          For :class:`HuberLoss`, the slope of the L1 segment is beta.\n\n    .. _`Fast R-CNN`: https://arxiv.org/abs/1504.08083\n\n    Args:\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there are multiple elements per sample. If the field :attr:`size_average`\n            is set to ``False``, the losses are instead summed for each minibatch. Ignored\n            when :attr:`reduce` is ``False``. Default: ``True``\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: ``True``\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the sum of the output will be divided by the number of\n            elements in the output, ``'sum'``: the output will be summed. Note: :attr:`size_average`\n            and :attr:`reduce` are in the process of being deprecated, and in the meantime,\n            specifying either of those two args will override :attr:`reduction`. Default: ``'mean'``\n        beta (float, optional): Specifies the threshold at which to change between L1 and L2 loss.\n            The value must be non-negative. Default: 1.0\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Target: :math:`(*)`, same shape as the input.\n        - Output: scalar. If :attr:`reduction` is ``'none'``, then :math:`(*)`, same shape as the input.\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "size_average": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduce": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduction": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        },
                        "beta": {
                          "Type": "<class 'float'>",
                          "Default": "1.0"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "target": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "SoftMarginLoss": {
                  "Doc": "Creates a criterion that optimizes a two-class classification\n    logistic loss between input tensor :math:`x` and target tensor :math:`y`\n    (containing 1 or -1).\n\n    .. math::\n        \\text{loss}(x, y) = \\sum_i \\frac{\\log(1 + \\exp(-y[i]*x[i]))}{\\text{x.nelement}()}\n\n    Args:\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there are multiple elements per sample. If the field :attr:`size_average`\n            is set to ``False``, the losses are instead summed for each minibatch. Ignored\n            when :attr:`reduce` is ``False``. Default: ``True``\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: ``True``\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the sum of the output will be divided by the number of\n            elements in the output, ``'sum'``: the output will be summed. Note: :attr:`size_average`\n            and :attr:`reduce` are in the process of being deprecated, and in the meantime,\n            specifying either of those two args will override :attr:`reduction`. Default: ``'mean'``\n\n    Shape:\n        - Input: :math:`(*)`, where :math:`*` means any number of dimensions.\n        - Target: :math:`(*)`, same shape as the input.\n        - Output: scalar. If :attr:`reduction` is ``'none'``, then :math:`(*)`, same\n          shape as input.\n\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "size_average": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduce": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduction": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "target": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "TripletMarginLoss": {
                  "Doc": "Creates a criterion that measures the triplet loss given an input\n    tensors :math:`x1`, :math:`x2`, :math:`x3` and a margin with a value greater than :math:`0`.\n    This is used for measuring a relative similarity between samples. A triplet\n    is composed by `a`, `p` and `n` (i.e., `anchor`, `positive examples` and `negative\n    examples` respectively). The shapes of all input tensors should be\n    :math:`(N, D)`.\n\n    The distance swap is described in detail in the paper `Learning shallow\n    convolutional feature descriptors with triplet losses`_ by\n    V. Balntas, E. Riba et al.\n\n    The loss function for each sample in the mini-batch is:\n\n    .. math::\n        L(a, p, n) = \\max \\{d(a_i, p_i) - d(a_i, n_i) + {\\rm margin}, 0\\}\n\n\n    where\n\n    .. math::\n        d(x_i, y_i) = \\left\\lVert {\\bf x}_i - {\\bf y}_i \\right\\rVert_p\n\n    See also :class:`~torch.nn.TripletMarginWithDistanceLoss`, which computes the\n    triplet margin loss for input tensors using a custom distance function.\n\n    Args:\n        margin (float, optional): Default: :math:`1`.\n        p (int, optional): The norm degree for pairwise distance. Default: :math:`2`.\n        swap (bool, optional): The distance swap is described in detail in the paper\n            `Learning shallow convolutional feature descriptors with triplet losses` by\n            V. Balntas, E. Riba et al. Default: ``False``.\n        size_average (bool, optional): Deprecated (see :attr:`reduction`). By default,\n            the losses are averaged over each loss element in the batch. Note that for\n            some losses, there are multiple elements per sample. If the field :attr:`size_average`\n            is set to ``False``, the losses are instead summed for each minibatch. Ignored\n            when :attr:`reduce` is ``False``. Default: ``True``\n        reduce (bool, optional): Deprecated (see :attr:`reduction`). By default, the\n            losses are averaged or summed over observations for each minibatch depending\n            on :attr:`size_average`. When :attr:`reduce` is ``False``, returns a loss per\n            batch element instead and ignores :attr:`size_average`. Default: ``True``\n        reduction (str, optional): Specifies the reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the sum of the output will be divided by the number of\n            elements in the output, ``'sum'``: the output will be summed. Note: :attr:`size_average`\n            and :attr:`reduce` are in the process of being deprecated, and in the meantime,\n            specifying either of those two args will override :attr:`reduction`. Default: ``'mean'``\n\n    Shape:\n        - Input: :math:`(N, D)` or :math:`(D)` where :math:`D` is the vector dimension.\n        - Output: A Tensor of shape :math:`(N)` if :attr:`reduction` is ``'none'`` and\n          input shape is :math:`(N, D)`; a scalar otherwise.\n\n    Examples::\n\n    >>> triplet_loss = nn.TripletMarginLoss(margin=1.0, p=2)\n    >>> anchor = torch.randn(100, 128, requires_grad=True)\n    >>> positive = torch.randn(100, 128, requires_grad=True)\n    >>> negative = torch.randn(100, 128, requires_grad=True)\n    >>> output = triplet_loss(anchor, positive, negative)\n    >>> output.backward()\n\n    .. _Learning shallow convolutional feature descriptors with triplet losses:\n        http://www.bmva.org/bmvc/2016/papers/paper119/index.html\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "margin": {
                          "Type": "<class 'float'>",
                          "Default": "1.0"
                        },
                        "p": {
                          "Type": "<class 'float'>",
                          "Default": "2.0"
                        },
                        "eps": {
                          "Type": "<class 'float'>",
                          "Default": "1e-06"
                        },
                        "swap": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "size_average": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduce": {
                          "Type": null,
                          "Default": "None"
                        },
                        "reduction": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "anchor": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "positive": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "negative": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "TripletMarginWithDistanceLoss": {
                  "Doc": "Creates a criterion that measures the triplet loss given input\n    tensors :math:`a`, :math:`p`, and :math:`n` (representing anchor,\n    positive, and negative examples, respectively), and a nonnegative,\n    real-valued function (\"distance function\") used to compute the relationship\n    between the anchor and positive example (\"positive distance\") and the\n    anchor and negative example (\"negative distance\").\n\n    The unreduced loss (i.e., with :attr:`reduction` set to ``'none'``)\n    can be described as:\n\n    .. math::\n        \\ell(a, p, n) = L = \\{l_1,\\dots,l_N\\}^\\top, \\quad\n        l_i = \\max \\{d(a_i, p_i) - d(a_i, n_i) + {\\rm margin}, 0\\}\n\n    where :math:`N` is the batch size; :math:`d` is a nonnegative, real-valued function\n    quantifying the closeness of two tensors, referred to as the :attr:`distance_function`;\n    and :math:`margin` is a nonnegative margin representing the minimum difference\n    between the positive and negative distances that is required for the loss to\n    be 0.  The input tensors have :math:`N` elements each and can be of any shape\n    that the distance function can handle.\n\n    If :attr:`reduction` is not ``'none'``\n    (default ``'mean'``), then:\n\n    .. math::\n        \\ell(x, y) =\n        \\begin{cases}\n            \\operatorname{mean}(L), &  \\text{if reduction} = \\text{`mean';}\\\\\n            \\operatorname{sum}(L),  &  \\text{if reduction} = \\text{`sum'.}\n        \\end{cases}\n\n    See also :class:`~torch.nn.TripletMarginLoss`, which computes the triplet\n    loss for input tensors using the :math:`l_p` distance as the distance function.\n\n    Args:\n        distance_function (Callable, optional): A nonnegative, real-valued function that\n            quantifies the closeness of two tensors. If not specified,\n            `nn.PairwiseDistance` will be used.  Default: ``None``\n        margin (float, optional): A nonnegative margin representing the minimum difference\n            between the positive and negative distances required for the loss to be 0. Larger\n            margins penalize cases where the negative examples are not distant enough from the\n            anchors, relative to the positives. Default: :math:`1`.\n        swap (bool, optional): Whether to use the distance swap described in the paper\n            `Learning shallow convolutional feature descriptors with triplet losses` by\n            V. Balntas, E. Riba et al. If True, and if the positive example is closer to the\n            negative example than the anchor is, swaps the positive example and the anchor in\n            the loss computation. Default: ``False``.\n        reduction (str, optional): Specifies the (optional) reduction to apply to the output:\n            ``'none'`` | ``'mean'`` | ``'sum'``. ``'none'``: no reduction will be applied,\n            ``'mean'``: the sum of the output will be divided by the number of\n            elements in the output, ``'sum'``: the output will be summed. Default: ``'mean'``\n\n\n    Shape:\n        - Input: :math:`(N, *)` where :math:`*` represents any number of additional dimensions\n          as supported by the distance function.\n        - Output: A Tensor of shape :math:`(N)` if :attr:`reduction` is ``'none'``, or a scalar\n          otherwise.\n\n    Examples::\n\n    >>> # Initialize embeddings\n    >>> embedding = nn.Embedding(1000, 128)\n    >>> anchor_ids = torch.randint(0, 1000, (1,))\n    >>> positive_ids = torch.randint(0, 1000, (1,))\n    >>> negative_ids = torch.randint(0, 1000, (1,))\n    >>> anchor = embedding(anchor_ids)\n    >>> positive = embedding(positive_ids)\n    >>> negative = embedding(negative_ids)\n    >>>\n    >>> # Built-in Distance Function\n    >>> triplet_loss = \\\n    >>>     nn.TripletMarginWithDistanceLoss(distance_function=nn.PairwiseDistance())\n    >>> output = triplet_loss(anchor, positive, negative)\n    >>> output.backward()\n    >>>\n    >>> # Custom Distance Function\n    >>> def l_infinity(x1, x2):\n    >>>     return torch.max(torch.abs(x1 - x2), dim=1).values\n    >>>\n    >>> # xdoctest: +SKIP(\"FIXME: Would call backwards a second time\")\n    >>> triplet_loss = (\n    >>>     nn.TripletMarginWithDistanceLoss(distance_function=l_infinity, margin=1.5))\n    >>> output = triplet_loss(anchor, positive, negative)\n    >>> output.backward()\n    >>>\n    >>> # Custom Distance Function (Lambda)\n    >>> triplet_loss = (\n    >>>     nn.TripletMarginWithDistanceLoss(\n    >>>         distance_function=lambda x, y: 1.0 - F.cosine_similarity(x, y)))\n    >>> output = triplet_loss(anchor, positive, negative)\n    >>> output.backward()\n\n    Reference:\n        V. Balntas, et al.: Learning shallow convolutional feature descriptors with triplet losses:\n        http://www.bmva.org/bmvc/2016/papers/paper119/index.html\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "distance_function": {
                          "Type": "typing.Optional[typing.Callable[[torch.Tensor, torch.Tensor], torch.Tensor]]",
                          "Default": "None"
                        },
                        "margin": {
                          "Type": "<class 'float'>",
                          "Default": "1.0"
                        },
                        "swap": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "reduction": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "anchor": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "positive": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "negative": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                }
              }
            },
            "module": {
              "Doc": null,
              "Classes": {
                "Module": {
                  "Doc": "Base class for all neural network modules.\n\n    Your models should also subclass this class.\n\n    Modules can also contain other Modules, allowing to nest them in\n    a tree structure. You can assign the submodules as regular attributes::\n\n        import torch.nn as nn\n        import torch.nn.functional as F\n\n        class Model(nn.Module):\n            def __init__(self):\n                super().__init__()\n                self.conv1 = nn.Conv2d(1, 20, 5)\n                self.conv2 = nn.Conv2d(20, 20, 5)\n\n            def forward(self, x):\n                x = F.relu(self.conv1(x))\n                return F.relu(self.conv2(x))\n\n    Submodules assigned in this way will be registered, and will have their\n    parameters converted too when you call :meth:`to`, etc.\n\n    .. note::\n        As per the example above, an ``__init__()`` call to the parent class\n        must be made before assignment on the child.\n\n    :ivar training: Boolean represents whether this module is in training or\n                    evaluation mode.\n    :vartype training: bool\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": "\n        Initializes internal Module state, shared by both nn.Module and ScriptModule.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "add_module": {
                      "Doc": "Adds a child module to the current module.\n\n        The module can be accessed as an attribute using the given name.\n\n        Args:\n            name (str): name of the child module. The child module can be\n                accessed from this module using the given name\n            module (Module): child module to be added to the module.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "name": {
                          "Type": "<class 'str'>",
                          "Default": null
                        },
                        "module": {
                          "Type": "typing.Optional[ForwardRef('Module')]",
                          "Default": null
                        }
                      }
                    },
                    "apply": {
                      "Doc": "Applies ``fn`` recursively to every submodule (as returned by ``.children()``)\n        as well as self. Typical use includes initializing the parameters of a model\n        (see also :ref:`nn-init-doc`).\n\n        Args:\n            fn (:class:`Module` -> None): function to be applied to each submodule\n\n        Returns:\n            Module: self\n\n        Example::\n\n            >>> @torch.no_grad()\n            >>> def init_weights(m):\n            >>>     print(m)\n            >>>     if type(m) == nn.Linear:\n            >>>         m.weight.fill_(1.0)\n            >>>         print(m.weight)\n            >>> net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))\n            >>> net.apply(init_weights)\n            Linear(in_features=2, out_features=2, bias=True)\n            Parameter containing:\n            tensor([[1., 1.],\n                    [1., 1.]], requires_grad=True)\n            Linear(in_features=2, out_features=2, bias=True)\n            Parameter containing:\n            tensor([[1., 1.],\n                    [1., 1.]], requires_grad=True)\n            Sequential(\n              (0): Linear(in_features=2, out_features=2, bias=True)\n              (1): Linear(in_features=2, out_features=2, bias=True)\n            )\n\n        ",
                      "Args": {
                        "self": {
                          "Type": "~T",
                          "Default": null
                        },
                        "fn": {
                          "Type": "typing.Callable[[ForwardRef('Module')], NoneType]",
                          "Default": null
                        }
                      }
                    },
                    "bfloat16": {
                      "Doc": "Casts all floating point parameters and buffers to ``bfloat16`` datatype.\n\n        .. note::\n            This method modifies the module in-place.\n\n        Returns:\n            Module: self\n        ",
                      "Args": {
                        "self": {
                          "Type": "~T",
                          "Default": null
                        }
                      }
                    },
                    "buffers": {
                      "Doc": "Returns an iterator over module buffers.\n\n        Args:\n            recurse (bool): if True, then yields buffers of this module\n                and all submodules. Otherwise, yields only buffers that\n                are direct members of this module.\n\n        Yields:\n            torch.Tensor: module buffer\n\n        Example::\n\n            >>> # xdoctest: +SKIP(\"undefined vars\")\n            >>> for buf in model.buffers():\n            >>>     print(type(buf), buf.size())\n            <class 'torch.Tensor'> (20L,)\n            <class 'torch.Tensor'> (20L, 1L, 5L, 5L)\n\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "recurse": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        }
                      }
                    },
                    "children": {
                      "Doc": "Returns an iterator over immediate children modules.\n\n        Yields:\n            Module: a child module\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "cpu": {
                      "Doc": "Moves all model parameters and buffers to the CPU.\n\n        .. note::\n            This method modifies the module in-place.\n\n        Returns:\n            Module: self\n        ",
                      "Args": {
                        "self": {
                          "Type": "~T",
                          "Default": null
                        }
                      }
                    },
                    "cuda": {
                      "Doc": "Moves all model parameters and buffers to the GPU.\n\n        This also makes associated parameters and buffers different objects. So\n        it should be called before constructing optimizer if the module will\n        live on GPU while being optimized.\n\n        .. note::\n            This method modifies the module in-place.\n\n        Args:\n            device (int, optional): if specified, all parameters will be\n                copied to that device\n\n        Returns:\n            Module: self\n        ",
                      "Args": {
                        "self": {
                          "Type": "~T",
                          "Default": null
                        },
                        "device": {
                          "Type": "typing.Union[int, torch.device, NoneType]",
                          "Default": "None"
                        }
                      }
                    },
                    "double": {
                      "Doc": "Casts all floating point parameters and buffers to ``double`` datatype.\n\n        .. note::\n            This method modifies the module in-place.\n\n        Returns:\n            Module: self\n        ",
                      "Args": {
                        "self": {
                          "Type": "~T",
                          "Default": null
                        }
                      }
                    },
                    "eval": {
                      "Doc": "Sets the module in evaluation mode.\n\n        This has any effect only on certain modules. See documentations of\n        particular modules for details of their behaviors in training/evaluation\n        mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,\n        etc.\n\n        This is equivalent with :meth:`self.train(False) <torch.nn.Module.train>`.\n\n        See :ref:`locally-disable-grad-doc` for a comparison between\n        `.eval()` and several similar mechanisms that may be confused with it.\n\n        Returns:\n            Module: self\n        ",
                      "Args": {
                        "self": {
                          "Type": "~T",
                          "Default": null
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": "Set the extra representation of the module\n\n        To print customized extra information, you should re-implement\n        this method in your own modules. Both single-line and multi-line\n        strings are acceptable.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "float": {
                      "Doc": "Casts all floating point parameters and buffers to ``float`` datatype.\n\n        .. note::\n            This method modifies the module in-place.\n\n        Returns:\n            Module: self\n        ",
                      "Args": {
                        "self": {
                          "Type": "~T",
                          "Default": null
                        }
                      }
                    },
                    "get_buffer": {
                      "Doc": "\n        Returns the buffer given by ``target`` if it exists,\n        otherwise throws an error.\n\n        See the docstring for ``get_submodule`` for a more detailed\n        explanation of this method's functionality as well as how to\n        correctly specify ``target``.\n\n        Args:\n            target: The fully-qualified string name of the buffer\n                to look for. (See ``get_submodule`` for how to specify a\n                fully-qualified string.)\n\n        Returns:\n            torch.Tensor: The buffer referenced by ``target``\n\n        Raises:\n            AttributeError: If the target string references an invalid\n                path or resolves to something that is not a\n                buffer\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "target": {
                          "Type": "<class 'str'>",
                          "Default": null
                        }
                      }
                    },
                    "get_extra_state": {
                      "Doc": "\n        Returns any extra state to include in the module's state_dict.\n        Implement this and a corresponding :func:`set_extra_state` for your module\n        if you need to store extra state. This function is called when building the\n        module's `state_dict()`.\n\n        Note that extra state should be pickleable to ensure working serialization\n        of the state_dict. We only provide provide backwards compatibility guarantees\n        for serializing Tensors; other objects may break backwards compatibility if\n        their serialized pickled form changes.\n\n        Returns:\n            object: Any extra state to store in the module's state_dict\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "get_parameter": {
                      "Doc": "\n        Returns the parameter given by ``target`` if it exists,\n        otherwise throws an error.\n\n        See the docstring for ``get_submodule`` for a more detailed\n        explanation of this method's functionality as well as how to\n        correctly specify ``target``.\n\n        Args:\n            target: The fully-qualified string name of the Parameter\n                to look for. (See ``get_submodule`` for how to specify a\n                fully-qualified string.)\n\n        Returns:\n            torch.nn.Parameter: The Parameter referenced by ``target``\n\n        Raises:\n            AttributeError: If the target string references an invalid\n                path or resolves to something that is not an\n                ``nn.Parameter``\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "target": {
                          "Type": "<class 'str'>",
                          "Default": null
                        }
                      }
                    },
                    "get_submodule": {
                      "Doc": "\n        Returns the submodule given by ``target`` if it exists,\n        otherwise throws an error.\n\n        For example, let's say you have an ``nn.Module`` ``A`` that\n        looks like this:\n\n        .. code-block:: text\n\n            A(\n                (net_b): Module(\n                    (net_c): Module(\n                        (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2))\n                    )\n                    (linear): Linear(in_features=100, out_features=200, bias=True)\n                )\n            )\n\n        (The diagram shows an ``nn.Module`` ``A``. ``A`` has a nested\n        submodule ``net_b``, which itself has two submodules ``net_c``\n        and ``linear``. ``net_c`` then has a submodule ``conv``.)\n\n        To check whether or not we have the ``linear`` submodule, we\n        would call ``get_submodule(\"net_b.linear\")``. To check whether\n        we have the ``conv`` submodule, we would call\n        ``get_submodule(\"net_b.net_c.conv\")``.\n\n        The runtime of ``get_submodule`` is bounded by the degree\n        of module nesting in ``target``. A query against\n        ``named_modules`` achieves the same result, but it is O(N) in\n        the number of transitive modules. So, for a simple check to see\n        if some submodule exists, ``get_submodule`` should always be\n        used.\n\n        Args:\n            target: The fully-qualified string name of the submodule\n                to look for. (See above example for how to specify a\n                fully-qualified string.)\n\n        Returns:\n            torch.nn.Module: The submodule referenced by ``target``\n\n        Raises:\n            AttributeError: If the target string references an invalid\n                path or resolves to something that is not an\n                ``nn.Module``\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "target": {
                          "Type": "<class 'str'>",
                          "Default": null
                        }
                      }
                    },
                    "half": {
                      "Doc": "Casts all floating point parameters and buffers to ``half`` datatype.\n\n        .. note::\n            This method modifies the module in-place.\n\n        Returns:\n            Module: self\n        ",
                      "Args": {
                        "self": {
                          "Type": "~T",
                          "Default": null
                        }
                      }
                    },
                    "ipu": {
                      "Doc": "Moves all model parameters and buffers to the IPU.\n\n        This also makes associated parameters and buffers different objects. So\n        it should be called before constructing optimizer if the module will\n        live on IPU while being optimized.\n\n        .. note::\n            This method modifies the module in-place.\n\n        Arguments:\n            device (int, optional): if specified, all parameters will be\n                copied to that device\n\n        Returns:\n            Module: self\n        ",
                      "Args": {
                        "self": {
                          "Type": "~T",
                          "Default": null
                        },
                        "device": {
                          "Type": "typing.Union[int, torch.device, NoneType]",
                          "Default": "None"
                        }
                      }
                    },
                    "load_state_dict": {
                      "Doc": "Copies parameters and buffers from :attr:`state_dict` into\n        this module and its descendants. If :attr:`strict` is ``True``, then\n        the keys of :attr:`state_dict` must exactly match the keys returned\n        by this module's :meth:`~torch.nn.Module.state_dict` function.\n\n        Args:\n            state_dict (dict): a dict containing parameters and\n                persistent buffers.\n            strict (bool, optional): whether to strictly enforce that the keys\n                in :attr:`state_dict` match the keys returned by this module's\n                :meth:`~torch.nn.Module.state_dict` function. Default: ``True``\n\n        Returns:\n            ``NamedTuple`` with ``missing_keys`` and ``unexpected_keys`` fields:\n                * **missing_keys** is a list of str containing the missing keys\n                * **unexpected_keys** is a list of str containing the unexpected keys\n\n        Note:\n            If a parameter or buffer is registered as ``None`` and its corresponding key\n            exists in :attr:`state_dict`, :meth:`load_state_dict` will raise a\n            ``RuntimeError``.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "state_dict": {
                          "Type": "typing.Mapping[str, typing.Any]",
                          "Default": null
                        },
                        "strict": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        }
                      }
                    },
                    "modules": {
                      "Doc": "Returns an iterator over all modules in the network.\n\n        Yields:\n            Module: a module in the network\n\n        Note:\n            Duplicate modules are returned only once. In the following\n            example, ``l`` will be returned only once.\n\n        Example::\n\n            >>> l = nn.Linear(2, 2)\n            >>> net = nn.Sequential(l, l)\n            >>> for idx, m in enumerate(net.modules()):\n            ...     print(idx, '->', m)\n\n            0 -> Sequential(\n              (0): Linear(in_features=2, out_features=2, bias=True)\n              (1): Linear(in_features=2, out_features=2, bias=True)\n            )\n            1 -> Linear(in_features=2, out_features=2, bias=True)\n\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "named_buffers": {
                      "Doc": "Returns an iterator over module buffers, yielding both the\n        name of the buffer as well as the buffer itself.\n\n        Args:\n            prefix (str): prefix to prepend to all buffer names.\n            recurse (bool): if True, then yields buffers of this module\n                and all submodules. Otherwise, yields only buffers that\n                are direct members of this module.\n\n        Yields:\n            (str, torch.Tensor): Tuple containing the name and buffer\n\n        Example::\n\n            >>> # xdoctest: +SKIP(\"undefined vars\")\n            >>> for name, buf in self.named_buffers():\n            >>>    if name in ['running_var']:\n            >>>        print(buf.size())\n\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "prefix": {
                          "Type": "<class 'str'>",
                          "Default": ""
                        },
                        "recurse": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        }
                      }
                    },
                    "named_children": {
                      "Doc": "Returns an iterator over immediate children modules, yielding both\n        the name of the module as well as the module itself.\n\n        Yields:\n            (str, Module): Tuple containing a name and child module\n\n        Example::\n\n            >>> # xdoctest: +SKIP(\"undefined vars\")\n            >>> for name, module in model.named_children():\n            >>>     if name in ['conv4', 'conv5']:\n            >>>         print(module)\n\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "named_modules": {
                      "Doc": "Returns an iterator over all modules in the network, yielding\n        both the name of the module as well as the module itself.\n\n        Args:\n            memo: a memo to store the set of modules already added to the result\n            prefix: a prefix that will be added to the name of the module\n            remove_duplicate: whether to remove the duplicated module instances in the result\n                or not\n\n        Yields:\n            (str, Module): Tuple of name and module\n\n        Note:\n            Duplicate modules are returned only once. In the following\n            example, ``l`` will be returned only once.\n\n        Example::\n\n            >>> l = nn.Linear(2, 2)\n            >>> net = nn.Sequential(l, l)\n            >>> for idx, m in enumerate(net.named_modules()):\n            ...     print(idx, '->', m)\n\n            0 -> ('', Sequential(\n              (0): Linear(in_features=2, out_features=2, bias=True)\n              (1): Linear(in_features=2, out_features=2, bias=True)\n            ))\n            1 -> ('0', Linear(in_features=2, out_features=2, bias=True))\n\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "memo": {
                          "Type": "typing.Optional[typing.Set[ForwardRef('Module')]]",
                          "Default": "None"
                        },
                        "prefix": {
                          "Type": "<class 'str'>",
                          "Default": ""
                        },
                        "remove_duplicate": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        }
                      }
                    },
                    "named_parameters": {
                      "Doc": "Returns an iterator over module parameters, yielding both the\n        name of the parameter as well as the parameter itself.\n\n        Args:\n            prefix (str): prefix to prepend to all parameter names.\n            recurse (bool): if True, then yields parameters of this module\n                and all submodules. Otherwise, yields only parameters that\n                are direct members of this module.\n\n        Yields:\n            (str, Parameter): Tuple containing the name and parameter\n\n        Example::\n\n            >>> # xdoctest: +SKIP(\"undefined vars\")\n            >>> for name, param in self.named_parameters():\n            >>>    if name in ['bias']:\n            >>>        print(param.size())\n\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "prefix": {
                          "Type": "<class 'str'>",
                          "Default": ""
                        },
                        "recurse": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        }
                      }
                    },
                    "parameters": {
                      "Doc": "Returns an iterator over module parameters.\n\n        This is typically passed to an optimizer.\n\n        Args:\n            recurse (bool): if True, then yields parameters of this module\n                and all submodules. Otherwise, yields only parameters that\n                are direct members of this module.\n\n        Yields:\n            Parameter: module parameter\n\n        Example::\n\n            >>> # xdoctest: +SKIP(\"undefined vars\")\n            >>> for param in model.parameters():\n            >>>     print(type(param), param.size())\n            <class 'torch.Tensor'> (20L,)\n            <class 'torch.Tensor'> (20L, 1L, 5L, 5L)\n\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "recurse": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        }
                      }
                    },
                    "register_backward_hook": {
                      "Doc": "Registers a backward hook on the module.\n\n        This function is deprecated in favor of :meth:`~torch.nn.Module.register_full_backward_hook` and\n        the behavior of this function will change in future versions.\n\n        Returns:\n            :class:`torch.utils.hooks.RemovableHandle`:\n                a handle that can be used to remove the added hook by calling\n                ``handle.remove()``\n\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "hook": {
                          "Type": "typing.Callable[[ForwardRef('Module'), typing.Union[typing.Tuple[torch.Tensor, ...], torch.Tensor], typing.Union[typing.Tuple[torch.Tensor, ...], torch.Tensor]], typing.Optional[torch.Tensor]]",
                          "Default": null
                        }
                      }
                    },
                    "register_buffer": {
                      "Doc": "Adds a buffer to the module.\n\n        This is typically used to register a buffer that should not to be\n        considered a model parameter. For example, BatchNorm's ``running_mean``\n        is not a parameter, but is part of the module's state. Buffers, by\n        default, are persistent and will be saved alongside parameters. This\n        behavior can be changed by setting :attr:`persistent` to ``False``. The\n        only difference between a persistent buffer and a non-persistent buffer\n        is that the latter will not be a part of this module's\n        :attr:`state_dict`.\n\n        Buffers can be accessed as attributes using given names.\n\n        Args:\n            name (str): name of the buffer. The buffer can be accessed\n                from this module using the given name\n            tensor (Tensor or None): buffer to be registered. If ``None``, then operations\n                that run on buffers, such as :attr:`cuda`, are ignored. If ``None``,\n                the buffer is **not** included in the module's :attr:`state_dict`.\n            persistent (bool): whether the buffer is part of this module's\n                :attr:`state_dict`.\n\n        Example::\n\n            >>> # xdoctest: +SKIP(\"undefined vars\")\n            >>> self.register_buffer('running_mean', torch.zeros(num_features))\n\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "name": {
                          "Type": "<class 'str'>",
                          "Default": null
                        },
                        "tensor": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": null
                        },
                        "persistent": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        }
                      }
                    },
                    "register_forward_hook": {
                      "Doc": "Registers a forward hook on the module.\n\n        The hook will be called every time after :func:`forward` has computed an output.\n        It should have the following signature::\n\n            hook(module, input, output) -> None or modified output\n\n        The input contains only the positional arguments given to the module.\n        Keyword arguments won't be passed to the hooks and only to the ``forward``.\n        The hook can modify the output. It can modify the input inplace but\n        it will not have effect on forward since this is called after\n        :func:`forward` is called.\n\n        Returns:\n            :class:`torch.utils.hooks.RemovableHandle`:\n                a handle that can be used to remove the added hook by calling\n                ``handle.remove()``\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "hook": {
                          "Type": "typing.Callable[..., NoneType]",
                          "Default": null
                        }
                      }
                    },
                    "register_forward_pre_hook": {
                      "Doc": "Registers a forward pre-hook on the module.\n\n        The hook will be called every time before :func:`forward` is invoked.\n        It should have the following signature::\n\n            hook(module, input) -> None or modified input\n\n        The input contains only the positional arguments given to the module.\n        Keyword arguments won't be passed to the hooks and only to the ``forward``.\n        The hook can modify the input. User can either return a tuple or a\n        single modified value in the hook. We will wrap the value into a tuple\n        if a single value is returned(unless that value is already a tuple).\n\n        Returns:\n            :class:`torch.utils.hooks.RemovableHandle`:\n                a handle that can be used to remove the added hook by calling\n                ``handle.remove()``\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "hook": {
                          "Type": "typing.Callable[..., NoneType]",
                          "Default": null
                        }
                      }
                    },
                    "register_full_backward_hook": {
                      "Doc": "Registers a backward hook on the module.\n\n        The hook will be called every time the gradients with respect to module\n        inputs are computed. The hook should have the following signature::\n\n            hook(module, grad_input, grad_output) -> tuple(Tensor) or None\n\n        The :attr:`grad_input` and :attr:`grad_output` are tuples that contain the gradients\n        with respect to the inputs and outputs respectively. The hook should\n        not modify its arguments, but it can optionally return a new gradient with\n        respect to the input that will be used in place of :attr:`grad_input` in\n        subsequent computations. :attr:`grad_input` will only correspond to the inputs given\n        as positional arguments and all kwarg arguments are ignored. Entries\n        in :attr:`grad_input` and :attr:`grad_output` will be ``None`` for all non-Tensor\n        arguments.\n\n        For technical reasons, when this hook is applied to a Module, its forward function will\n        receive a view of each Tensor passed to the Module. Similarly the caller will receive a view\n        of each Tensor returned by the Module's forward function.\n\n        .. warning ::\n            Modifying inputs or outputs inplace is not allowed when using backward hooks and\n            will raise an error.\n\n        Returns:\n            :class:`torch.utils.hooks.RemovableHandle`:\n                a handle that can be used to remove the added hook by calling\n                ``handle.remove()``\n\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "hook": {
                          "Type": "typing.Callable[[ForwardRef('Module'), typing.Union[typing.Tuple[torch.Tensor, ...], torch.Tensor], typing.Union[typing.Tuple[torch.Tensor, ...], torch.Tensor]], typing.Optional[torch.Tensor]]",
                          "Default": null
                        }
                      }
                    },
                    "register_load_state_dict_post_hook": {
                      "Doc": "Registers a post hook to be run after module's ``load_state_dict``\n        is called.\n\n        It should have the following signature::\n            hook(module, incompatible_keys) -> None\n\n        The ``module`` argument is the current module that this hook is registered\n        on, and the ``incompatible_keys`` argument is a ``NamedTuple`` consisting\n        of attributes ``missing_keys`` and ``unexpected_keys``. ``missing_keys``\n        is a ``list`` of ``str`` containing the missing keys and\n        ``unexpected_keys`` is a ``list`` of ``str`` containing the unexpected keys.\n\n        The given incompatible_keys can be modified inplace if needed.\n\n        Note that the checks performed when calling :func:`load_state_dict` with\n        ``strict=True`` are affected by modifications the hook makes to\n        ``missing_keys`` or ``unexpected_keys``, as expected. Additions to either\n        set of keys will result in an error being thrown when ``strict=True``, and\n        clearning out both missing and unexpected keys will avoid an error.\n\n        Returns:\n            :class:`torch.utils.hooks.RemovableHandle`:\n                a handle that can be used to remove the added hook by calling\n                ``handle.remove()``\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "hook": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "register_module": {
                      "Doc": "Alias for :func:`add_module`.",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "name": {
                          "Type": "<class 'str'>",
                          "Default": null
                        },
                        "module": {
                          "Type": "typing.Optional[ForwardRef('Module')]",
                          "Default": null
                        }
                      }
                    },
                    "register_parameter": {
                      "Doc": "Adds a parameter to the module.\n\n        The parameter can be accessed as an attribute using given name.\n\n        Args:\n            name (str): name of the parameter. The parameter can be accessed\n                from this module using the given name\n            param (Parameter or None): parameter to be added to the module. If\n                ``None``, then operations that run on parameters, such as :attr:`cuda`,\n                are ignored. If ``None``, the parameter is **not** included in the\n                module's :attr:`state_dict`.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "name": {
                          "Type": "<class 'str'>",
                          "Default": null
                        },
                        "param": {
                          "Type": "typing.Optional[torch.nn.parameter.Parameter]",
                          "Default": null
                        }
                      }
                    },
                    "set_extra_state": {
                      "Doc": "\n        This function is called from :func:`load_state_dict` to handle any extra state\n        found within the `state_dict`. Implement this function and a corresponding\n        :func:`get_extra_state` for your module if you need to store extra state within its\n        `state_dict`.\n\n        Args:\n            state (dict): Extra state from the `state_dict`\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "state": {
                          "Type": "typing.Any",
                          "Default": null
                        }
                      }
                    },
                    "share_memory": {
                      "Doc": "See :meth:`torch.Tensor.share_memory_`",
                      "Args": {
                        "self": {
                          "Type": "~T",
                          "Default": null
                        }
                      }
                    },
                    "state_dict": {
                      "Doc": "Returns a dictionary containing references to the whole state of the module.\n\n        Both parameters and persistent buffers (e.g. running averages) are\n        included. Keys are corresponding parameter and buffer names.\n        Parameters and buffers set to ``None`` are not included.\n\n        .. note::\n            The returned object is a shallow copy. It contains references\n            to the module's parameters and buffers.\n\n        .. warning::\n            Currently ``state_dict()`` also accepts positional arguments for\n            ``destination``, ``prefix`` and ``keep_vars`` in order. However,\n            this is being deprecated and keyword arguments will be enforced in\n            future releases.\n\n        .. warning::\n            Please avoid the use of argument ``destination`` as it is not\n            designed for end-users.\n\n        Args:\n            destination (dict, optional): If provided, the state of module will\n                be updated into the dict and the same object is returned.\n                Otherwise, an ``OrderedDict`` will be created and returned.\n                Default: ``None``.\n            prefix (str, optional): a prefix added to parameter and buffer\n                names to compose the keys in state_dict. Default: ``''``.\n            keep_vars (bool, optional): by default the :class:`~torch.Tensor` s\n                returned in the state dict are detached from autograd. If it's\n                set to ``True``, detaching will not be performed.\n                Default: ``False``.\n\n        Returns:\n            dict:\n                a dictionary containing a whole state of the module\n\n        Example::\n\n            >>> # xdoctest: +SKIP(\"undefined vars\")\n            >>> module.state_dict().keys()\n            ['bias', 'weight']\n\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "*args": {
                          "Type": null,
                          "Default": null
                        },
                        "destination": {
                          "Type": null,
                          "Default": "None"
                        },
                        "prefix": {
                          "Type": null,
                          "Default": ""
                        },
                        "keep_vars": {
                          "Type": null,
                          "Default": "False"
                        }
                      }
                    },
                    "to": {
                      "Doc": "Moves and/or casts the parameters and buffers.\n\n        This can be called as\n\n        .. function:: to(device=None, dtype=None, non_blocking=False)\n           :noindex:\n\n        .. function:: to(dtype, non_blocking=False)\n           :noindex:\n\n        .. function:: to(tensor, non_blocking=False)\n           :noindex:\n\n        .. function:: to(memory_format=torch.channels_last)\n           :noindex:\n\n        Its signature is similar to :meth:`torch.Tensor.to`, but only accepts\n        floating point or complex :attr:`dtype`\\ s. In addition, this method will\n        only cast the floating point or complex parameters and buffers to :attr:`dtype`\n        (if given). The integral parameters and buffers will be moved\n        :attr:`device`, if that is given, but with dtypes unchanged. When\n        :attr:`non_blocking` is set, it tries to convert/move asynchronously\n        with respect to the host if possible, e.g., moving CPU Tensors with\n        pinned memory to CUDA devices.\n\n        See below for examples.\n\n        .. note::\n            This method modifies the module in-place.\n\n        Args:\n            device (:class:`torch.device`): the desired device of the parameters\n                and buffers in this module\n            dtype (:class:`torch.dtype`): the desired floating point or complex dtype of\n                the parameters and buffers in this module\n            tensor (torch.Tensor): Tensor whose dtype and device are the desired\n                dtype and device for all parameters and buffers in this module\n            memory_format (:class:`torch.memory_format`): the desired memory\n                format for 4D parameters and buffers in this module (keyword\n                only argument)\n\n        Returns:\n            Module: self\n\n        Examples::\n\n            >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\")\n            >>> linear = nn.Linear(2, 2)\n            >>> linear.weight\n            Parameter containing:\n            tensor([[ 0.1913, -0.3420],\n                    [-0.5113, -0.2325]])\n            >>> linear.to(torch.double)\n            Linear(in_features=2, out_features=2, bias=True)\n            >>> linear.weight\n            Parameter containing:\n            tensor([[ 0.1913, -0.3420],\n                    [-0.5113, -0.2325]], dtype=torch.float64)\n            >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_CUDA1)\n            >>> gpu1 = torch.device(\"cuda:1\")\n            >>> linear.to(gpu1, dtype=torch.half, non_blocking=True)\n            Linear(in_features=2, out_features=2, bias=True)\n            >>> linear.weight\n            Parameter containing:\n            tensor([[ 0.1914, -0.3420],\n                    [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')\n            >>> cpu = torch.device(\"cpu\")\n            >>> linear.to(cpu)\n            Linear(in_features=2, out_features=2, bias=True)\n            >>> linear.weight\n            Parameter containing:\n            tensor([[ 0.1914, -0.3420],\n                    [-0.5112, -0.2324]], dtype=torch.float16)\n\n            >>> linear = nn.Linear(2, 2, bias=None).to(torch.cdouble)\n            >>> linear.weight\n            Parameter containing:\n            tensor([[ 0.3741+0.j,  0.2382+0.j],\n                    [ 0.5593+0.j, -0.4443+0.j]], dtype=torch.complex128)\n            >>> linear(torch.ones(3, 2, dtype=torch.cdouble))\n            tensor([[0.6122+0.j, 0.1150+0.j],\n                    [0.6122+0.j, 0.1150+0.j],\n                    [0.6122+0.j, 0.1150+0.j]], dtype=torch.complex128)\n\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "*args": {
                          "Type": null,
                          "Default": null
                        },
                        "**kwargs": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "to_empty": {
                      "Doc": "Moves the parameters and buffers to the specified device without copying storage.\n\n        Args:\n            device (:class:`torch.device`): The desired device of the parameters\n                and buffers in this module.\n\n        Returns:\n            Module: self\n        ",
                      "Args": {
                        "self": {
                          "Type": "~T",
                          "Default": null
                        }
                      }
                    },
                    "train": {
                      "Doc": "Sets the module in training mode.\n\n        This has any effect only on certain modules. See documentations of\n        particular modules for details of their behaviors in training/evaluation\n        mode, if they are affected, e.g. :class:`Dropout`, :class:`BatchNorm`,\n        etc.\n\n        Args:\n            mode (bool): whether to set training mode (``True``) or evaluation\n                         mode (``False``). Default: ``True``.\n\n        Returns:\n            Module: self\n        ",
                      "Args": {
                        "self": {
                          "Type": "~T",
                          "Default": null
                        },
                        "mode": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        }
                      }
                    },
                    "type": {
                      "Doc": "Casts all parameters and buffers to :attr:`dst_type`.\n\n        .. note::\n            This method modifies the module in-place.\n\n        Args:\n            dst_type (type or string): the desired type\n\n        Returns:\n            Module: self\n        ",
                      "Args": {
                        "self": {
                          "Type": "~T",
                          "Default": null
                        },
                        "dst_type": {
                          "Type": "typing.Union[torch.dtype, str]",
                          "Default": null
                        }
                      }
                    },
                    "xpu": {
                      "Doc": "Moves all model parameters and buffers to the XPU.\n\n        This also makes associated parameters and buffers different objects. So\n        it should be called before constructing optimizer if the module will\n        live on XPU while being optimized.\n\n        .. note::\n            This method modifies the module in-place.\n\n        Arguments:\n            device (int, optional): if specified, all parameters will be\n                copied to that device\n\n        Returns:\n            Module: self\n        ",
                      "Args": {
                        "self": {
                          "Type": "~T",
                          "Default": null
                        },
                        "device": {
                          "Type": "typing.Union[int, torch.device, NoneType]",
                          "Default": "None"
                        }
                      }
                    },
                    "zero_grad": {
                      "Doc": "Sets gradients of all model parameters to zero. See similar function\n        under :class:`torch.optim.Optimizer` for more context.\n\n        Args:\n            set_to_none (bool): instead of setting to zero, set the grads to None.\n                See :meth:`torch.optim.Optimizer.zero_grad` for details.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "set_to_none": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        }
                      }
                    }
                  }
                }
              },
              "Functions": {
                "namedtuple": {
                  "Doc": "Returns a new subclass of tuple with named fields.\n\n    >>> Point = namedtuple('Point', ['x', 'y'])\n    >>> Point.__doc__                   # docstring for the new class\n    'Point(x, y)'\n    >>> p = Point(11, y=22)             # instantiate with positional args or keywords\n    >>> p[0] + p[1]                     # indexable like a plain tuple\n    33\n    >>> x, y = p                        # unpack like a regular tuple\n    >>> x, y\n    (11, 22)\n    >>> p.x + p.y                       # fields also accessible by name\n    33\n    >>> d = p._asdict()                 # convert to a dictionary\n    >>> d['x']\n    11\n    >>> Point(**d)                      # convert from a dictionary\n    Point(x=11, y=22)\n    >>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\n    Point(x=100, y=22)\n\n    ",
                  "Args": {
                    "typename": {
                      "Type": null,
                      "Default": null
                    },
                    "field_names": {
                      "Type": null,
                      "Default": null
                    },
                    "rename": {
                      "Type": null,
                      "Default": "False"
                    },
                    "defaults": {
                      "Type": null,
                      "Default": "None"
                    },
                    "module": {
                      "Type": null,
                      "Default": "None"
                    }
                  }
                },
                "overload": {
                  "Doc": "Decorator for overloaded functions/methods.\n\n    In a stub file, place two or more stub definitions for the same\n    function in a row, each decorated with @overload.  For example:\n\n      @overload\n      def utf8(value: None) -> None: ...\n      @overload\n      def utf8(value: bytes) -> bytes: ...\n      @overload\n      def utf8(value: str) -> bytes: ...\n\n    In a non-stub file (i.e. a regular .py file), do the same but\n    follow it with an implementation.  The implementation should *not*\n    be decorated with @overload.  For example:\n\n      @overload\n      def utf8(value: None) -> None: ...\n      @overload\n      def utf8(value: bytes) -> bytes: ...\n      @overload\n      def utf8(value: str) -> bytes: ...\n      def utf8(value):\n          # implementation goes here\n    ",
                  "Args": {
                    "func": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "register_module_backward_hook": {
                  "Doc": "Registers a backward hook common to all the modules.\n\n    This function is deprecated in favor of\n    :func:`torch.nn.modules.module.register_module_full_backward_hook`\n    and the behavior of this function will change in future versions.\n\n    Returns:\n        :class:`torch.utils.hooks.RemovableHandle`:\n            a handle that can be used to remove the added hook by calling\n            ``handle.remove()``\n\n    ",
                  "Args": {
                    "hook": {
                      "Type": "typing.Callable[[ForwardRef('Module'), typing.Union[typing.Tuple[torch.Tensor, ...], torch.Tensor], typing.Union[typing.Tuple[torch.Tensor, ...], torch.Tensor]], typing.Optional[torch.Tensor]]",
                      "Default": null
                    }
                  }
                },
                "register_module_forward_hook": {
                  "Doc": "Registers a global forward hook for all the modules\n\n    .. warning ::\n\n        This adds global state to the `nn.module` module\n        and it is only intended for debugging/profiling purposes.\n\n    The hook will be called every time after :func:`forward` has computed an output.\n    It should have the following signature::\n\n        hook(module, input, output) -> None or modified output\n\n    The input contains only the positional arguments given to the module.\n    Keyword arguments won't be passed to the hooks and only to the ``forward``.\n    The hook can modify the output. It can modify the input inplace but\n    it will not have effect on forward since this is called after\n    :func:`forward` is called.\n\n    Returns:\n        :class:`torch.utils.hooks.RemovableHandle`:\n            a handle that can be used to remove the added hook by calling\n            ``handle.remove()``\n\n    This hook will be executed before specific module hooks registered with\n    ``register_forward_hook``.\n    ",
                  "Args": {
                    "hook": {
                      "Type": "typing.Callable[..., NoneType]",
                      "Default": null
                    }
                  }
                },
                "register_module_forward_pre_hook": {
                  "Doc": "Registers a forward pre-hook common to all modules.\n\n    .. warning ::\n\n        This adds global state to the `nn.module` module\n        and it is only intended for debugging/profiling purposes.\n\n    The hook will be called every time before :func:`forward` is invoked.\n    It should have the following signature::\n\n        hook(module, input) -> None or modified input\n\n    The input contains only the positional arguments given to the module.\n    Keyword arguments won't be passed to the hooks and only to the ``forward``.\n    The hook can modify the input. User can either return a tuple or a\n    single modified value in the hook. We will wrap the value into a tuple\n    if a single value is returned(unless that value is already a tuple).\n\n    This hook has precedence over the specific module hooks registered with\n    ``register_forward_pre_hook``.\n\n    Returns:\n        :class:`torch.utils.hooks.RemovableHandle`:\n            a handle that can be used to remove the added hook by calling\n            ``handle.remove()``\n    ",
                  "Args": {
                    "hook": {
                      "Type": "typing.Callable[..., NoneType]",
                      "Default": null
                    }
                  }
                },
                "register_module_full_backward_hook": {
                  "Doc": "Registers a backward hook common to all the modules.\n\n    .. warning ::\n        This adds global state to the `nn.module` module\n        and it is only intended for debugging/profiling purposes.\n\n    The hook will be called every time the gradients with respect to module\n    inputs are computed. The hook should have the following signature::\n\n        hook(module, grad_input, grad_output) -> Tensor or None\n\n    The :attr:`grad_input` and :attr:`grad_output` are tuples. The hook should\n    not modify its arguments, but it can optionally return a new gradient with\n    respect to the input that will be used in place of :attr:`grad_input` in\n    subsequent computations. :attr:`grad_input` will only correspond to the inputs given\n    as positional arguments and all kwarg arguments will not appear in the hook. Entries\n    in :attr:`grad_input` and :attr:`grad_output` will be ``None`` for all non-Tensor\n    arguments.\n\n    For technical reasons, when this hook is applied to a Module, its forward function will\n    receive a view of each Tensor passed to the Module. Similarly the caller will receive a view\n    of each Tensor returned by the Module's forward function.\n\n    Global hooks are called before hooks registered with `register_backward_hook`\n\n    Returns:\n        :class:`torch.utils.hooks.RemovableHandle`:\n            a handle that can be used to remove the added hook by calling\n            ``handle.remove()``\n\n    ",
                  "Args": {
                    "hook": {
                      "Type": "typing.Callable[[ForwardRef('Module'), typing.Union[typing.Tuple[torch.Tensor, ...], torch.Tensor], typing.Union[typing.Tuple[torch.Tensor, ...], torch.Tensor]], typing.Optional[torch.Tensor]]",
                      "Default": null
                    }
                  }
                }
              }
            },
            "normalization": {
              "Doc": null,
              "Classes": {
                "CrossMapLRN2d": {
                  "Doc": null,
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "size": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "alpha": {
                          "Type": "<class 'float'>",
                          "Default": "0.0001"
                        },
                        "beta": {
                          "Type": "<class 'float'>",
                          "Default": "0.75"
                        },
                        "k": {
                          "Type": "<class 'float'>",
                          "Default": "1"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "GroupNorm": {
                  "Doc": "Applies Group Normalization over a mini-batch of inputs as described in\n    the paper `Group Normalization <https://arxiv.org/abs/1803.08494>`__\n\n    .. math::\n        y = \\frac{x - \\mathrm{E}[x]}{ \\sqrt{\\mathrm{Var}[x] + \\epsilon}} * \\gamma + \\beta\n\n    The input channels are separated into :attr:`num_groups` groups, each containing\n    ``num_channels / num_groups`` channels. :attr:`num_channels` must be divisible by\n    :attr:`num_groups`. The mean and standard-deviation are calculated\n    separately over the each group. :math:`\\gamma` and :math:`\\beta` are learnable\n    per-channel affine transform parameter vectors of size :attr:`num_channels` if\n    :attr:`affine` is ``True``.\n    The standard-deviation is calculated via the biased estimator, equivalent to\n    `torch.var(input, unbiased=False)`.\n\n    This layer uses statistics computed from input data in both training and\n    evaluation modes.\n\n    Args:\n        num_groups (int): number of groups to separate the channels into\n        num_channels (int): number of channels expected in input\n        eps: a value added to the denominator for numerical stability. Default: 1e-5\n        affine: a boolean value that when set to ``True``, this module\n            has learnable per-channel affine parameters initialized to ones (for weights)\n            and zeros (for biases). Default: ``True``.\n\n    Shape:\n        - Input: :math:`(N, C, *)` where :math:`C=\\text{num\\_channels}`\n        - Output: :math:`(N, C, *)` (same shape as input)\n\n    Examples::\n\n        >>> input = torch.randn(20, 6, 10, 10)\n        >>> # Separate 6 channels into 3 groups\n        >>> m = nn.GroupNorm(3, 6)\n        >>> # Separate 6 channels into 6 groups (equivalent with InstanceNorm)\n        >>> m = nn.GroupNorm(6, 6)\n        >>> # Put all 6 channels into a single group (equivalent with LayerNorm)\n        >>> m = nn.GroupNorm(1, 6)\n        >>> # Activating the module\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "num_groups": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "num_channels": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "eps": {
                          "Type": "<class 'float'>",
                          "Default": "1e-05"
                        },
                        "affine": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    },
                    "reset_parameters": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "LayerNorm": {
                  "Doc": "Applies Layer Normalization over a mini-batch of inputs as described in\n    the paper `Layer Normalization <https://arxiv.org/abs/1607.06450>`__\n\n    .. math::\n        y = \\frac{x - \\mathrm{E}[x]}{ \\sqrt{\\mathrm{Var}[x] + \\epsilon}} * \\gamma + \\beta\n\n    The mean and standard-deviation are calculated over the last `D` dimensions, where `D`\n    is the dimension of :attr:`normalized_shape`. For example, if :attr:`normalized_shape`\n    is ``(3, 5)`` (a 2-dimensional shape), the mean and standard-deviation are computed over\n    the last 2 dimensions of the input (i.e. ``input.mean((-2, -1))``).\n    :math:`\\gamma` and :math:`\\beta` are learnable affine transform parameters of\n    :attr:`normalized_shape` if :attr:`elementwise_affine` is ``True``.\n    The standard-deviation is calculated via the biased estimator, equivalent to\n    `torch.var(input, unbiased=False)`.\n\n    .. note::\n        Unlike Batch Normalization and Instance Normalization, which applies\n        scalar scale and bias for each entire channel/plane with the\n        :attr:`affine` option, Layer Normalization applies per-element scale and\n        bias with :attr:`elementwise_affine`.\n\n    This layer uses statistics computed from input data in both training and\n    evaluation modes.\n\n    Args:\n        normalized_shape (int or list or torch.Size): input shape from an expected input\n            of size\n\n            .. math::\n                [* \\times \\text{normalized\\_shape}[0] \\times \\text{normalized\\_shape}[1]\n                    \\times \\ldots \\times \\text{normalized\\_shape}[-1]]\n\n            If a single integer is used, it is treated as a singleton list, and this module will\n            normalize over the last dimension which is expected to be of that specific size.\n        eps: a value added to the denominator for numerical stability. Default: 1e-5\n        elementwise_affine: a boolean value that when set to ``True``, this module\n            has learnable per-element affine parameters initialized to ones (for weights)\n            and zeros (for biases). Default: ``True``.\n\n    Attributes:\n        weight: the learnable weights of the module of shape\n            :math:`\\text{normalized\\_shape}` when :attr:`elementwise_affine` is set to ``True``.\n            The values are initialized to 1.\n        bias:   the learnable bias of the module of shape\n                :math:`\\text{normalized\\_shape}` when :attr:`elementwise_affine` is set to ``True``.\n                The values are initialized to 0.\n\n    Shape:\n        - Input: :math:`(N, *)`\n        - Output: :math:`(N, *)` (same shape as input)\n\n    Examples::\n\n        >>> # NLP Example\n        >>> batch, sentence_length, embedding_dim = 20, 5, 10\n        >>> embedding = torch.randn(batch, sentence_length, embedding_dim)\n        >>> layer_norm = nn.LayerNorm(embedding_dim)\n        >>> # Activate module\n        >>> layer_norm(embedding)\n        >>>\n        >>> # Image Example\n        >>> N, C, H, W = 20, 5, 10, 10\n        >>> input = torch.randn(N, C, H, W)\n        >>> # Normalize over the last three dimensions (i.e. the channel and spatial dimensions)\n        >>> # as shown in the image below\n        >>> layer_norm = nn.LayerNorm([C, H, W])\n        >>> output = layer_norm(input)\n\n    .. image:: ../_static/img/nn/layer_norm.jpg\n        :scale: 50 %\n\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "normalized_shape": {
                          "Type": "typing.Union[int, typing.List[int], torch.Size]",
                          "Default": null
                        },
                        "eps": {
                          "Type": "<class 'float'>",
                          "Default": "1e-05"
                        },
                        "elementwise_affine": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    },
                    "reset_parameters": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "LocalResponseNorm": {
                  "Doc": "Applies local response normalization over an input signal composed\n    of several input planes, where channels occupy the second dimension.\n    Applies normalization across channels.\n\n    .. math::\n        b_{c} = a_{c}\\left(k + \\frac{\\alpha}{n}\n        \\sum_{c'=\\max(0, c-n/2)}^{\\min(N-1,c+n/2)}a_{c'}^2\\right)^{-\\beta}\n\n    Args:\n        size: amount of neighbouring channels used for normalization\n        alpha: multiplicative factor. Default: 0.0001\n        beta: exponent. Default: 0.75\n        k: additive factor. Default: 1\n\n    Shape:\n        - Input: :math:`(N, C, *)`\n        - Output: :math:`(N, C, *)` (same shape as input)\n\n    Examples::\n\n        >>> lrn = nn.LocalResponseNorm(2)\n        >>> signal_2d = torch.randn(32, 5, 24, 24)\n        >>> signal_4d = torch.randn(16, 5, 7, 7, 7, 7)\n        >>> output_2d = lrn(signal_2d)\n        >>> output_4d = lrn(signal_4d)\n\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "size": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "alpha": {
                          "Type": "<class 'float'>",
                          "Default": "0.0001"
                        },
                        "beta": {
                          "Type": "<class 'float'>",
                          "Default": "0.75"
                        },
                        "k": {
                          "Type": "<class 'float'>",
                          "Default": "1.0"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                }
              }
            },
            "padding": {
              "Doc": null,
              "Classes": {
                "ConstantPad1d": {
                  "Doc": "Pads the input tensor boundaries with a constant value.\n\n    For `N`-dimensional padding, use :func:`torch.nn.functional.pad()`.\n\n    Args:\n        padding (int, tuple): the size of the padding. If is `int`, uses the same\n            padding in both boundaries. If a 2-`tuple`, uses\n            (:math:`\\text{padding\\_left}`, :math:`\\text{padding\\_right}`)\n\n    Shape:\n        - Input: :math:`(C, W_{in})` or :math:`(N, C, W_{in})`.\n        - Output: :math:`(C, W_{out})` or :math:`(N, C, W_{out})`, where\n\n          :math:`W_{out} = W_{in} + \\text{padding\\_left} + \\text{padding\\_right}`\n\n    Examples::\n\n        >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\")\n        >>> m = nn.ConstantPad1d(2, 3.5)\n        >>> input = torch.randn(1, 2, 4)\n        >>> input\n        tensor([[[-1.0491, -0.7152, -0.0749,  0.8530],\n                 [-1.3287,  1.8966,  0.1466, -0.2771]]])\n        >>> m(input)\n        tensor([[[ 3.5000,  3.5000, -1.0491, -0.7152, -0.0749,  0.8530,  3.5000,\n                   3.5000],\n                 [ 3.5000,  3.5000, -1.3287,  1.8966,  0.1466, -0.2771,  3.5000,\n                   3.5000]]])\n        >>> m = nn.ConstantPad1d(2, 3.5)\n        >>> input = torch.randn(1, 2, 3)\n        >>> input\n        tensor([[[ 1.6616,  1.4523, -1.1255],\n                 [-3.6372,  0.1182, -1.8652]]])\n        >>> m(input)\n        tensor([[[ 3.5000,  3.5000,  1.6616,  1.4523, -1.1255,  3.5000,  3.5000],\n                 [ 3.5000,  3.5000, -3.6372,  0.1182, -1.8652,  3.5000,  3.5000]]])\n        >>> # using different paddings for different sides\n        >>> m = nn.ConstantPad1d((3, 1), 3.5)\n        >>> m(input)\n        tensor([[[ 3.5000,  3.5000,  3.5000,  1.6616,  1.4523, -1.1255,  3.5000],\n                 [ 3.5000,  3.5000,  3.5000, -3.6372,  0.1182, -1.8652,  3.5000]]])\n\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": null
                        },
                        "value": {
                          "Type": "<class 'float'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "ConstantPad2d": {
                  "Doc": "Pads the input tensor boundaries with a constant value.\n\n    For `N`-dimensional padding, use :func:`torch.nn.functional.pad()`.\n\n    Args:\n        padding (int, tuple): the size of the padding. If is `int`, uses the same\n            padding in all boundaries. If a 4-`tuple`, uses (:math:`\\text{padding\\_left}`,\n            :math:`\\text{padding\\_right}`, :math:`\\text{padding\\_top}`, :math:`\\text{padding\\_bottom}`)\n\n    Shape:\n        - Input: :math:`(N, C, H_{in}, W_{in})` or :math:`(C, H_{in}, W_{in})`.\n        - Output: :math:`(N, C, H_{out}, W_{out})` or :math:`(C, H_{out}, W_{out})`, where\n\n          :math:`H_{out} = H_{in} + \\text{padding\\_top} + \\text{padding\\_bottom}`\n\n          :math:`W_{out} = W_{in} + \\text{padding\\_left} + \\text{padding\\_right}`\n\n    Examples::\n\n        >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\")\n        >>> m = nn.ConstantPad2d(2, 3.5)\n        >>> input = torch.randn(1, 2, 2)\n        >>> input\n        tensor([[[ 1.6585,  0.4320],\n                 [-0.8701, -0.4649]]])\n        >>> m(input)\n        tensor([[[ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000],\n                 [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000],\n                 [ 3.5000,  3.5000,  1.6585,  0.4320,  3.5000,  3.5000],\n                 [ 3.5000,  3.5000, -0.8701, -0.4649,  3.5000,  3.5000],\n                 [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000],\n                 [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000]]])\n        >>> # using different paddings for different sides\n        >>> m = nn.ConstantPad2d((3, 0, 2, 1), 3.5)\n        >>> m(input)\n        tensor([[[ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000],\n                 [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000],\n                 [ 3.5000,  3.5000,  3.5000,  1.6585,  0.4320],\n                 [ 3.5000,  3.5000,  3.5000, -0.8701, -0.4649],\n                 [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000]]])\n\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int, int]]",
                          "Default": null
                        },
                        "value": {
                          "Type": "<class 'float'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "ConstantPad3d": {
                  "Doc": "Pads the input tensor boundaries with a constant value.\n\n    For `N`-dimensional padding, use :func:`torch.nn.functional.pad()`.\n\n    Args:\n        padding (int, tuple): the size of the padding. If is `int`, uses the same\n            padding in all boundaries. If a 6-`tuple`, uses\n            (:math:`\\text{padding\\_left}`, :math:`\\text{padding\\_right}`,\n            :math:`\\text{padding\\_top}`, :math:`\\text{padding\\_bottom}`,\n            :math:`\\text{padding\\_front}`, :math:`\\text{padding\\_back}`)\n\n    Shape:\n        - Input: :math:`(N, C, D_{in}, H_{in}, W_{in})` or :math:`(C, D_{in}, H_{in}, W_{in})`.\n        - Output: :math:`(N, C, D_{out}, H_{out}, W_{out})` or\n          :math:`(C, D_{out}, H_{out}, W_{out})`, where\n\n          :math:`D_{out} = D_{in} + \\text{padding\\_front} + \\text{padding\\_back}`\n\n          :math:`H_{out} = H_{in} + \\text{padding\\_top} + \\text{padding\\_bottom}`\n\n          :math:`W_{out} = W_{in} + \\text{padding\\_left} + \\text{padding\\_right}`\n\n    Examples::\n\n        >>> m = nn.ConstantPad3d(3, 3.5)\n        >>> input = torch.randn(16, 3, 10, 20, 30)\n        >>> output = m(input)\n        >>> # using different paddings for different sides\n        >>> m = nn.ConstantPad3d((3, 3, 6, 6, 0, 1), 3.5)\n        >>> output = m(input)\n\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int, int, int, int]]",
                          "Default": null
                        },
                        "value": {
                          "Type": "<class 'float'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "ReflectionPad1d": {
                  "Doc": "Pads the input tensor using the reflection of the input boundary.\n\n    For `N`-dimensional padding, use :func:`torch.nn.functional.pad()`.\n\n    Args:\n        padding (int, tuple): the size of the padding. If is `int`, uses the same\n            padding in all boundaries. If a 2-`tuple`, uses\n            (:math:`\\text{padding\\_left}`, :math:`\\text{padding\\_right}`)\n\n    Shape:\n        - Input: :math:`(C, W_{in})` or :math:`(N, C, W_{in})`.\n        - Output: :math:`(C, W_{out})` or :math:`(N, C, W_{out})`, where\n\n          :math:`W_{out} = W_{in} + \\text{padding\\_left} + \\text{padding\\_right}`\n\n    Examples::\n\n        >>> m = nn.ReflectionPad1d(2)\n        >>> # xdoctest: +IGNORE_WANT(\"other tests seem to modify printing styles\")\n        >>> input = torch.arange(8, dtype=torch.float).reshape(1, 2, 4)\n        >>> input\n        tensor([[[0., 1., 2., 3.],\n                 [4., 5., 6., 7.]]])\n        >>> m(input)\n        tensor([[[2., 1., 0., 1., 2., 3., 2., 1.],\n                 [6., 5., 4., 5., 6., 7., 6., 5.]]])\n        >>> # using different paddings for different sides\n        >>> m = nn.ReflectionPad1d((3, 1))\n        >>> m(input)\n        tensor([[[3., 2., 1., 0., 1., 2., 3., 2.],\n                 [7., 6., 5., 4., 5., 6., 7., 6.]]])\n\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "ReflectionPad2d": {
                  "Doc": "Pads the input tensor using the reflection of the input boundary.\n\n    For `N`-dimensional padding, use :func:`torch.nn.functional.pad()`.\n\n    Args:\n        padding (int, tuple): the size of the padding. If is `int`, uses the same\n            padding in all boundaries. If a 4-`tuple`, uses (:math:`\\text{padding\\_left}`,\n            :math:`\\text{padding\\_right}`, :math:`\\text{padding\\_top}`, :math:`\\text{padding\\_bottom}`)\n\n    Shape:\n        - Input: :math:`(N, C, H_{in}, W_{in})` or :math:`(C, H_{in}, W_{in})`.\n        - Output: :math:`(N, C, H_{out}, W_{out})` or :math:`(C, H_{out}, W_{out})` where\n\n          :math:`H_{out} = H_{in} + \\text{padding\\_top} + \\text{padding\\_bottom}`\n\n          :math:`W_{out} = W_{in} + \\text{padding\\_left} + \\text{padding\\_right}`\n\n    Examples::\n\n        >>> # xdoctest: +IGNORE_WANT(\"not sure why xdoctest is choking on this\")\n        >>> m = nn.ReflectionPad2d(2)\n        >>> input = torch.arange(9, dtype=torch.float).reshape(1, 1, 3, 3)\n        >>> input\n        tensor([[[[0., 1., 2.],\n                  [3., 4., 5.],\n                  [6., 7., 8.]]]])\n        >>> m(input)\n        tensor([[[[8., 7., 6., 7., 8., 7., 6.],\n                  [5., 4., 3., 4., 5., 4., 3.],\n                  [2., 1., 0., 1., 2., 1., 0.],\n                  [5., 4., 3., 4., 5., 4., 3.],\n                  [8., 7., 6., 7., 8., 7., 6.],\n                  [5., 4., 3., 4., 5., 4., 3.],\n                  [2., 1., 0., 1., 2., 1., 0.]]]])\n        >>> # using different paddings for different sides\n        >>> m = nn.ReflectionPad2d((1, 1, 2, 0))\n        >>> m(input)\n        tensor([[[[7., 6., 7., 8., 7.],\n                  [4., 3., 4., 5., 4.],\n                  [1., 0., 1., 2., 1.],\n                  [4., 3., 4., 5., 4.],\n                  [7., 6., 7., 8., 7.]]]])\n\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int, int]]",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "ReflectionPad3d": {
                  "Doc": "Pads the input tensor using the reflection of the input boundary.\n\n    For `N`-dimensional padding, use :func:`torch.nn.functional.pad()`.\n\n    Args:\n        padding (int, tuple): the size of the padding. If is `int`, uses the same\n            padding in all boundaries. If a 6-`tuple`, uses\n            (:math:`\\text{padding\\_left}`, :math:`\\text{padding\\_right}`,\n            :math:`\\text{padding\\_top}`, :math:`\\text{padding\\_bottom}`,\n            :math:`\\text{padding\\_front}`, :math:`\\text{padding\\_back}`)\n\n    Shape:\n        - Input: :math:`(N, C, D_{in}, H_{in}, W_{in})` or :math:`(C, D_{in}, H_{in}, W_{in})`.\n        - Output: :math:`(N, C, D_{out}, H_{out}, W_{out})` or :math:`(C, D_{out}, H_{out}, W_{out})`,\n          where\n\n          :math:`D_{out} = D_{in} + \\text{padding\\_front} + \\text{padding\\_back}`\n\n          :math:`H_{out} = H_{in} + \\text{padding\\_top} + \\text{padding\\_bottom}`\n\n          :math:`W_{out} = W_{in} + \\text{padding\\_left} + \\text{padding\\_right}`\n\n    Examples::\n\n        >>> # xdoctest: +IGNORE_WANT(\"not sure why xdoctest is choking on this\")\n        >>> m = nn.ReflectionPad3d(1)\n        >>> input = torch.arange(8, dtype=torch.float).reshape(1, 1, 2, 2, 2)\n        >>> m(input)\n        tensor([[[[[7., 6., 7., 6.],\n                   [5., 4., 5., 4.],\n                   [7., 6., 7., 6.],\n                   [5., 4., 5., 4.]],\n                  [[3., 2., 3., 2.],\n                   [1., 0., 1., 0.],\n                   [3., 2., 3., 2.],\n                   [1., 0., 1., 0.]],\n                  [[7., 6., 7., 6.],\n                   [5., 4., 5., 4.],\n                   [7., 6., 7., 6.],\n                   [5., 4., 5., 4.]],\n                  [[3., 2., 3., 2.],\n                   [1., 0., 1., 0.],\n                   [3., 2., 3., 2.],\n                   [1., 0., 1., 0.]]]]])\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int, int, int, int]]",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "ReplicationPad1d": {
                  "Doc": "Pads the input tensor using replication of the input boundary.\n\n    For `N`-dimensional padding, use :func:`torch.nn.functional.pad()`.\n\n    Args:\n        padding (int, tuple): the size of the padding. If is `int`, uses the same\n            padding in all boundaries. If a 2-`tuple`, uses\n            (:math:`\\text{padding\\_left}`, :math:`\\text{padding\\_right}`)\n\n    Shape:\n        - Input: :math:`(C, W_{in})` or :math:`(N, C, W_{in})`.\n        - Output: :math:`(C, W_{out})` or :math:`(N, C, W_{out})`, where\n\n          :math:`W_{out} = W_{in} + \\text{padding\\_left} + \\text{padding\\_right}`\n\n    Examples::\n\n        >>> # xdoctest: +IGNORE_WANT(\"not sure why xdoctest is choking on this\")\n        >>> m = nn.ReplicationPad1d(2)\n        >>> input = torch.arange(8, dtype=torch.float).reshape(1, 2, 4)\n        >>> input\n        tensor([[[0., 1., 2., 3.],\n                 [4., 5., 6., 7.]]])\n        >>> m(input)\n        tensor([[[0., 0., 0., 1., 2., 3., 3., 3.],\n                 [4., 4., 4., 5., 6., 7., 7., 7.]]])\n        >>> # using different paddings for different sides\n        >>> m = nn.ReplicationPad1d((3, 1))\n        >>> m(input)\n        tensor([[[0., 0., 0., 0., 1., 2., 3., 3.],\n                 [4., 4., 4., 4., 5., 6., 7., 7.]]])\n\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "ReplicationPad2d": {
                  "Doc": "Pads the input tensor using replication of the input boundary.\n\n    For `N`-dimensional padding, use :func:`torch.nn.functional.pad()`.\n\n    Args:\n        padding (int, tuple): the size of the padding. If is `int`, uses the same\n            padding in all boundaries. If a 4-`tuple`, uses (:math:`\\text{padding\\_left}`,\n            :math:`\\text{padding\\_right}`, :math:`\\text{padding\\_top}`, :math:`\\text{padding\\_bottom}`)\n\n    Shape:\n        - Input: :math:`(N, C, H_{in}, W_{in})` or :math:`(C, H_{in}, W_{in})`.\n        - Output: :math:`(N, C, H_{out}, W_{out})` or :math:`(C, H_{out}, W_{out})`, where\n\n          :math:`H_{out} = H_{in} + \\text{padding\\_top} + \\text{padding\\_bottom}`\n\n          :math:`W_{out} = W_{in} + \\text{padding\\_left} + \\text{padding\\_right}`\n\n    Examples::\n\n        >>> m = nn.ReplicationPad2d(2)\n        >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\")\n        >>> input = torch.arange(9, dtype=torch.float).reshape(1, 1, 3, 3)\n        >>> input\n        tensor([[[[0., 1., 2.],\n                  [3., 4., 5.],\n                  [6., 7., 8.]]]])\n        >>> m(input)\n        tensor([[[[0., 0., 0., 1., 2., 2., 2.],\n                  [0., 0., 0., 1., 2., 2., 2.],\n                  [0., 0., 0., 1., 2., 2., 2.],\n                  [3., 3., 3., 4., 5., 5., 5.],\n                  [6., 6., 6., 7., 8., 8., 8.],\n                  [6., 6., 6., 7., 8., 8., 8.],\n                  [6., 6., 6., 7., 8., 8., 8.]]]])\n        >>> # using different paddings for different sides\n        >>> m = nn.ReplicationPad2d((1, 1, 2, 0))\n        >>> m(input)\n        tensor([[[[0., 0., 1., 2., 2.],\n                  [0., 0., 1., 2., 2.],\n                  [0., 0., 1., 2., 2.],\n                  [3., 3., 4., 5., 5.],\n                  [6., 6., 7., 8., 8.]]]])\n\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int, int]]",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "ReplicationPad3d": {
                  "Doc": "Pads the input tensor using replication of the input boundary.\n\n    For `N`-dimensional padding, use :func:`torch.nn.functional.pad()`.\n\n    Args:\n        padding (int, tuple): the size of the padding. If is `int`, uses the same\n            padding in all boundaries. If a 6-`tuple`, uses\n            (:math:`\\text{padding\\_left}`, :math:`\\text{padding\\_right}`,\n            :math:`\\text{padding\\_top}`, :math:`\\text{padding\\_bottom}`,\n            :math:`\\text{padding\\_front}`, :math:`\\text{padding\\_back}`)\n\n    Shape:\n        - Input: :math:`(N, C, D_{in}, H_{in}, W_{in})` or :math:`(C, D_{in}, H_{in}, W_{in})`.\n        - Output: :math:`(N, C, D_{out}, H_{out}, W_{out})` or :math:`(C, D_{out}, H_{out}, W_{out})`,\n          where\n\n          :math:`D_{out} = D_{in} + \\text{padding\\_front} + \\text{padding\\_back}`\n\n          :math:`H_{out} = H_{in} + \\text{padding\\_top} + \\text{padding\\_bottom}`\n\n          :math:`W_{out} = W_{in} + \\text{padding\\_left} + \\text{padding\\_right}`\n\n    Examples::\n\n        >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\")\n        >>> m = nn.ReplicationPad3d(3)\n        >>> input = torch.randn(16, 3, 8, 320, 480)\n        >>> output = m(input)\n        >>> # using different paddings for different sides\n        >>> m = nn.ReplicationPad3d((3, 3, 6, 6, 1, 1))\n        >>> output = m(input)\n\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int, int, int, int]]",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "ZeroPad2d": {
                  "Doc": "Pads the input tensor boundaries with zero.\n\n    For `N`-dimensional padding, use :func:`torch.nn.functional.pad()`.\n\n    Args:\n        padding (int, tuple): the size of the padding. If is `int`, uses the same\n            padding in all boundaries. If a 4-`tuple`, uses (:math:`\\text{padding\\_left}`,\n            :math:`\\text{padding\\_right}`, :math:`\\text{padding\\_top}`, :math:`\\text{padding\\_bottom}`)\n\n    Shape:\n        - Input: :math:`(N, C, H_{in}, W_{in})` or :math:`(C, H_{in}, W_{in})`.\n        - Output: :math:`(N, C, H_{out}, W_{out})` or :math:`(C, H_{out}, W_{out})`, where\n\n          :math:`H_{out} = H_{in} + \\text{padding\\_top} + \\text{padding\\_bottom}`\n\n          :math:`W_{out} = W_{in} + \\text{padding\\_left} + \\text{padding\\_right}`\n\n    Examples::\n\n        >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\")\n        >>> m = nn.ZeroPad2d(2)\n        >>> input = torch.randn(1, 1, 3, 3)\n        >>> input\n        tensor([[[[-0.1678, -0.4418,  1.9466],\n                  [ 0.9604, -0.4219, -0.5241],\n                  [-0.9162, -0.5436, -0.6446]]]])\n        >>> m(input)\n        tensor([[[[ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],\n                  [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],\n                  [ 0.0000,  0.0000, -0.1678, -0.4418,  1.9466,  0.0000,  0.0000],\n                  [ 0.0000,  0.0000,  0.9604, -0.4219, -0.5241,  0.0000,  0.0000],\n                  [ 0.0000,  0.0000, -0.9162, -0.5436, -0.6446,  0.0000,  0.0000],\n                  [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],\n                  [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000]]]])\n        >>> # using different paddings for different sides\n        >>> m = nn.ZeroPad2d((1, 1, 2, 0))\n        >>> m(input)\n        tensor([[[[ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000],\n                  [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000],\n                  [ 0.0000, -0.1678, -0.4418,  1.9466,  0.0000],\n                  [ 0.0000,  0.9604, -0.4219, -0.5241,  0.0000],\n                  [ 0.0000, -0.9162, -0.5436, -0.6446,  0.0000]]]])\n\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int, int]]",
                          "Default": null
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    }
                  }
                }
              }
            },
            "pixelshuffle": {
              "Doc": null,
              "Classes": {
                "PixelShuffle": {
                  "Doc": "Rearranges elements in a tensor of shape :math:`(*, C \\times r^2, H, W)`\n    to a tensor of shape :math:`(*, C, H \\times r, W \\times r)`, where r is an upscale factor.\n\n    This is useful for implementing efficient sub-pixel convolution\n    with a stride of :math:`1/r`.\n\n    See the paper:\n    `Real-Time Single Image and Video Super-Resolution Using an Efficient Sub-Pixel Convolutional Neural Network`_\n    by Shi et. al (2016) for more details.\n\n    Args:\n        upscale_factor (int): factor to increase spatial resolution by\n\n    Shape:\n        - Input: :math:`(*, C_{in}, H_{in}, W_{in})`, where * is zero or more batch dimensions\n        - Output: :math:`(*, C_{out}, H_{out}, W_{out})`, where\n\n    .. math::\n        C_{out} = C_{in} \\div \\text{upscale\\_factor}^2\n\n    .. math::\n        H_{out} = H_{in} \\times \\text{upscale\\_factor}\n\n    .. math::\n        W_{out} = W_{in} \\times \\text{upscale\\_factor}\n\n    Examples::\n\n        >>> pixel_shuffle = nn.PixelShuffle(3)\n        >>> input = torch.randn(1, 9, 4, 4)\n        >>> output = pixel_shuffle(input)\n        >>> print(output.size())\n        torch.Size([1, 1, 12, 12])\n\n    .. _Real-Time Single Image and Video Super-Resolution Using an Efficient Sub-Pixel Convolutional Neural Network:\n        https://arxiv.org/abs/1609.05158\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "upscale_factor": {
                          "Type": "<class 'int'>",
                          "Default": null
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "PixelUnshuffle": {
                  "Doc": "Reverses the :class:`~torch.nn.PixelShuffle` operation by rearranging elements\n    in a tensor of shape :math:`(*, C, H \\times r, W \\times r)` to a tensor of shape\n    :math:`(*, C \\times r^2, H, W)`, where r is a downscale factor.\n\n    See the paper:\n    `Real-Time Single Image and Video Super-Resolution Using an Efficient Sub-Pixel Convolutional Neural Network`_\n    by Shi et. al (2016) for more details.\n\n    Args:\n        downscale_factor (int): factor to decrease spatial resolution by\n\n    Shape:\n        - Input: :math:`(*, C_{in}, H_{in}, W_{in})`, where * is zero or more batch dimensions\n        - Output: :math:`(*, C_{out}, H_{out}, W_{out})`, where\n\n    .. math::\n        C_{out} = C_{in} \\times \\text{downscale\\_factor}^2\n\n    .. math::\n        H_{out} = H_{in} \\div \\text{downscale\\_factor}\n\n    .. math::\n        W_{out} = W_{in} \\div \\text{downscale\\_factor}\n\n    Examples::\n\n        >>> pixel_unshuffle = nn.PixelUnshuffle(3)\n        >>> input = torch.randn(1, 1, 12, 12)\n        >>> output = pixel_unshuffle(input)\n        >>> print(output.size())\n        torch.Size([1, 9, 4, 4])\n\n    .. _Real-Time Single Image and Video Super-Resolution Using an Efficient Sub-Pixel Convolutional Neural Network:\n        https://arxiv.org/abs/1609.05158\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "downscale_factor": {
                          "Type": "<class 'int'>",
                          "Default": null
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                }
              }
            },
            "pooling": {
              "Doc": null,
              "Classes": {
                "AdaptiveAvgPool1d": {
                  "Doc": "Applies a 1D adaptive average pooling over an input signal composed of several input planes.\n\n    The output size is :math:`L_{out}`, for any input size.\n    The number of output features is equal to the number of input planes.\n\n    Args:\n        output_size: the target output size :math:`L_{out}`.\n\n    Shape:\n        - Input: :math:`(N, C, L_{in})` or :math:`(C, L_{in})`.\n        - Output: :math:`(N, C, L_{out})` or :math:`(C, L_{out})`, where\n          :math:`L_{out}=\\text{output\\_size}`.\n\n    Examples:\n        >>> # target output size of 5\n        >>> m = nn.AdaptiveAvgPool1d(5)\n        >>> input = torch.randn(1, 64, 8)\n        >>> output = m(input)\n\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "AdaptiveAvgPool2d": {
                  "Doc": "Applies a 2D adaptive average pooling over an input signal composed of several input planes.\n\n    The output is of size H x W, for any input size.\n    The number of output features is equal to the number of input planes.\n\n    Args:\n        output_size: the target output size of the image of the form H x W.\n                     Can be a tuple (H, W) or a single H for a square image H x H.\n                     H and W can be either a ``int``, or ``None`` which means the size will\n                     be the same as that of the input.\n\n    Shape:\n        - Input: :math:`(N, C, H_{in}, W_{in})` or :math:`(C, H_{in}, W_{in})`.\n        - Output: :math:`(N, C, S_{0}, S_{1})` or :math:`(C, S_{0}, S_{1})`, where\n          :math:`S=\\text{output\\_size}`.\n\n    Examples:\n        >>> # target output size of 5x7\n        >>> m = nn.AdaptiveAvgPool2d((5,7))\n        >>> input = torch.randn(1, 64, 8, 9)\n        >>> output = m(input)\n        >>> # target output size of 7x7 (square)\n        >>> m = nn.AdaptiveAvgPool2d(7)\n        >>> input = torch.randn(1, 64, 10, 9)\n        >>> output = m(input)\n        >>> # target output size of 10x7\n        >>> m = nn.AdaptiveAvgPool2d((None, 7))\n        >>> input = torch.randn(1, 64, 10, 9)\n        >>> output = m(input)\n\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "AdaptiveAvgPool3d": {
                  "Doc": "Applies a 3D adaptive average pooling over an input signal composed of several input planes.\n\n    The output is of size D x H x W, for any input size.\n    The number of output features is equal to the number of input planes.\n\n    Args:\n        output_size: the target output size of the form D x H x W.\n                     Can be a tuple (D, H, W) or a single number D for a cube D x D x D.\n                     D, H and W can be either a ``int``, or ``None`` which means the size will\n                     be the same as that of the input.\n\n    Shape:\n        - Input: :math:`(N, C, D_{in}, H_{in}, W_{in})` or :math:`(C, D_{in}, H_{in}, W_{in})`.\n        - Output: :math:`(N, C, S_{0}, S_{1}, S_{2})` or :math:`(C, S_{0}, S_{1}, S_{2})`,\n          where :math:`S=\\text{output\\_size}`.\n\n    Examples:\n        >>> # target output size of 5x7x9\n        >>> m = nn.AdaptiveAvgPool3d((5,7,9))\n        >>> input = torch.randn(1, 64, 8, 9, 10)\n        >>> output = m(input)\n        >>> # target output size of 7x7x7 (cube)\n        >>> m = nn.AdaptiveAvgPool3d(7)\n        >>> input = torch.randn(1, 64, 10, 9, 8)\n        >>> output = m(input)\n        >>> # target output size of 7x9x8\n        >>> m = nn.AdaptiveAvgPool3d((7, None, None))\n        >>> input = torch.randn(1, 64, 10, 9, 8)\n        >>> output = m(input)\n\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "AdaptiveMaxPool1d": {
                  "Doc": "Applies a 1D adaptive max pooling over an input signal composed of several input planes.\n\n    The output size is :math:`L_{out}`, for any input size.\n    The number of output features is equal to the number of input planes.\n\n    Args:\n        output_size: the target output size :math:`L_{out}`.\n        return_indices: if ``True``, will return the indices along with the outputs.\n                        Useful to pass to nn.MaxUnpool1d. Default: ``False``\n\n    Shape:\n        - Input: :math:`(N, C, L_{in})` or :math:`(C, L_{in})`.\n        - Output: :math:`(N, C, L_{out})` or :math:`(C, L_{out})`, where\n          :math:`L_{out}=\\text{output\\_size}`.\n\n    Examples:\n        >>> # target output size of 5\n        >>> m = nn.AdaptiveMaxPool1d(5)\n        >>> input = torch.randn(1, 64, 8)\n        >>> output = m(input)\n\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "AdaptiveMaxPool2d": {
                  "Doc": "Applies a 2D adaptive max pooling over an input signal composed of several input planes.\n\n    The output is of size :math:`H_{out} \\times W_{out}`, for any input size.\n    The number of output features is equal to the number of input planes.\n\n    Args:\n        output_size: the target output size of the image of the form :math:`H_{out} \\times W_{out}`.\n                     Can be a tuple :math:`(H_{out}, W_{out})` or a single :math:`H_{out}` for a\n                     square image :math:`H_{out} \\times H_{out}`. :math:`H_{out}` and :math:`W_{out}`\n                     can be either a ``int``, or ``None`` which means the size will be the same as that\n                     of the input.\n        return_indices: if ``True``, will return the indices along with the outputs.\n                        Useful to pass to nn.MaxUnpool2d. Default: ``False``\n\n    Shape:\n        - Input: :math:`(N, C, H_{in}, W_{in})` or :math:`(C, H_{in}, W_{in})`.\n        - Output: :math:`(N, C, H_{out}, W_{out})` or :math:`(C, H_{out}, W_{out})`, where\n          :math:`(H_{out}, W_{out})=\\text{output\\_size}`.\n\n    Examples:\n        >>> # target output size of 5x7\n        >>> m = nn.AdaptiveMaxPool2d((5,7))\n        >>> input = torch.randn(1, 64, 8, 9)\n        >>> output = m(input)\n        >>> # target output size of 7x7 (square)\n        >>> m = nn.AdaptiveMaxPool2d(7)\n        >>> input = torch.randn(1, 64, 10, 9)\n        >>> output = m(input)\n        >>> # target output size of 10x7\n        >>> m = nn.AdaptiveMaxPool2d((None, 7))\n        >>> input = torch.randn(1, 64, 10, 9)\n        >>> output = m(input)\n\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "AdaptiveMaxPool3d": {
                  "Doc": "Applies a 3D adaptive max pooling over an input signal composed of several input planes.\n\n    The output is of size :math:`D_{out} \\times H_{out} \\times W_{out}`, for any input size.\n    The number of output features is equal to the number of input planes.\n\n    Args:\n        output_size: the target output size of the image of the form :math:`D_{out} \\times H_{out} \\times W_{out}`.\n                     Can be a tuple :math:`(D_{out}, H_{out}, W_{out})` or a single\n                     :math:`D_{out}` for a cube :math:`D_{out} \\times D_{out} \\times D_{out}`.\n                     :math:`D_{out}`, :math:`H_{out}` and :math:`W_{out}` can be either a\n                     ``int``, or ``None`` which means the size will be the same as that of the input.\n\n        return_indices: if ``True``, will return the indices along with the outputs.\n                        Useful to pass to nn.MaxUnpool3d. Default: ``False``\n\n    Shape:\n        - Input: :math:`(N, C, D_{in}, H_{in}, W_{in})` or :math:`(C, D_{in}, H_{in}, W_{in})`.\n        - Output: :math:`(N, C, D_{out}, H_{out}, W_{out})` or :math:`(C, D_{out}, H_{out}, W_{out})`,\n          where :math:`(D_{out}, H_{out}, W_{out})=\\text{output\\_size}`.\n\n    Examples:\n        >>> # target output size of 5x7x9\n        >>> m = nn.AdaptiveMaxPool3d((5,7,9))\n        >>> input = torch.randn(1, 64, 8, 9, 10)\n        >>> output = m(input)\n        >>> # target output size of 7x7x7 (cube)\n        >>> m = nn.AdaptiveMaxPool3d(7)\n        >>> input = torch.randn(1, 64, 10, 9, 8)\n        >>> output = m(input)\n        >>> # target output size of 7x9x8\n        >>> m = nn.AdaptiveMaxPool3d((7, None, None))\n        >>> input = torch.randn(1, 64, 10, 9, 8)\n        >>> output = m(input)\n\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "AvgPool1d": {
                  "Doc": "Applies a 1D average pooling over an input signal composed of several\n    input planes.\n\n    In the simplest case, the output value of the layer with input size :math:`(N, C, L)`,\n    output :math:`(N, C, L_{out})` and :attr:`kernel_size` :math:`k`\n    can be precisely described as:\n\n    .. math::\n\n        \\text{out}(N_i, C_j, l) = \\frac{1}{k} \\sum_{m=0}^{k-1}\n                               \\text{input}(N_i, C_j, \\text{stride} \\times l + m)\n\n    If :attr:`padding` is non-zero, then the input is implicitly zero-padded on both sides\n    for :attr:`padding` number of points.\n\n    Note:\n        When ceil_mode=True, sliding windows are allowed to go off-bounds if they start within the left padding\n        or the input. Sliding windows that would start in the right padded region are ignored.\n\n    The parameters :attr:`kernel_size`, :attr:`stride`, :attr:`padding` can each be\n    an ``int`` or a one-element tuple.\n\n    Args:\n        kernel_size: the size of the window\n        stride: the stride of the window. Default value is :attr:`kernel_size`\n        padding: implicit zero padding to be added on both sides\n        ceil_mode: when True, will use `ceil` instead of `floor` to compute the output shape\n        count_include_pad: when True, will include the zero-padding in the averaging calculation\n\n    Shape:\n        - Input: :math:`(N, C, L_{in})` or :math:`(C, L_{in})`.\n        - Output: :math:`(N, C, L_{out})` or :math:`(C, L_{out})`, where\n\n          .. math::\n              L_{out} = \\left\\lfloor \\frac{L_{in} +\n              2 \\times \\text{padding} - \\text{kernel\\_size}}{\\text{stride}} + 1\\right\\rfloor\n\n    Examples::\n\n        >>> # pool with window of size=3, stride=2\n        >>> m = nn.AvgPool1d(3, stride=2)\n        >>> m(torch.tensor([[[1.,2,3,4,5,6,7]]]))\n        tensor([[[2., 4., 6.]]])\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "kernel_size": {
                          "Type": "typing.Union[int, typing.Tuple[int]]",
                          "Default": null
                        },
                        "stride": {
                          "Type": "typing.Union[int, typing.Tuple[int]]",
                          "Default": "None"
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int]]",
                          "Default": "0"
                        },
                        "ceil_mode": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "count_include_pad": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "AvgPool2d": {
                  "Doc": "Applies a 2D average pooling over an input signal composed of several input\n    planes.\n\n    In the simplest case, the output value of the layer with input size :math:`(N, C, H, W)`,\n    output :math:`(N, C, H_{out}, W_{out})` and :attr:`kernel_size` :math:`(kH, kW)`\n    can be precisely described as:\n\n    .. math::\n\n        out(N_i, C_j, h, w)  = \\frac{1}{kH * kW} \\sum_{m=0}^{kH-1} \\sum_{n=0}^{kW-1}\n                               input(N_i, C_j, stride[0] \\times h + m, stride[1] \\times w + n)\n\n    If :attr:`padding` is non-zero, then the input is implicitly zero-padded on both sides\n    for :attr:`padding` number of points.\n\n    Note:\n        When ceil_mode=True, sliding windows are allowed to go off-bounds if they start within the left padding\n        or the input. Sliding windows that would start in the right padded region are ignored.\n\n    The parameters :attr:`kernel_size`, :attr:`stride`, :attr:`padding` can either be:\n\n        - a single ``int`` -- in which case the same value is used for the height and width dimension\n        - a ``tuple`` of two ints -- in which case, the first `int` is used for the height dimension,\n          and the second `int` for the width dimension\n\n    Args:\n        kernel_size: the size of the window\n        stride: the stride of the window. Default value is :attr:`kernel_size`\n        padding: implicit zero padding to be added on both sides\n        ceil_mode: when True, will use `ceil` instead of `floor` to compute the output shape\n        count_include_pad: when True, will include the zero-padding in the averaging calculation\n        divisor_override: if specified, it will be used as divisor, otherwise size of the pooling region will be used.\n\n\n    Shape:\n        - Input: :math:`(N, C, H_{in}, W_{in})` or :math:`(C, H_{in}, W_{in})`.\n        - Output: :math:`(N, C, H_{out}, W_{out})` or :math:`(C, H_{out}, W_{out})`, where\n\n          .. math::\n              H_{out} = \\left\\lfloor\\frac{H_{in}  + 2 \\times \\text{padding}[0] -\n                \\text{kernel\\_size}[0]}{\\text{stride}[0]} + 1\\right\\rfloor\n\n          .. math::\n              W_{out} = \\left\\lfloor\\frac{W_{in}  + 2 \\times \\text{padding}[1] -\n                \\text{kernel\\_size}[1]}{\\text{stride}[1]} + 1\\right\\rfloor\n\n    Examples::\n\n        >>> # pool of square window of size=3, stride=2\n        >>> m = nn.AvgPool2d(3, stride=2)\n        >>> # pool of non-square window\n        >>> m = nn.AvgPool2d((3, 2), stride=(2, 1))\n        >>> input = torch.randn(20, 16, 50, 32)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "kernel_size": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": null
                        },
                        "stride": {
                          "Type": "typing.Union[int, typing.Tuple[int, int], NoneType]",
                          "Default": "None"
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": "0"
                        },
                        "ceil_mode": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "count_include_pad": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "divisor_override": {
                          "Type": "typing.Optional[int]",
                          "Default": "None"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "AvgPool3d": {
                  "Doc": "Applies a 3D average pooling over an input signal composed of several input\n    planes.\n\n    In the simplest case, the output value of the layer with input size :math:`(N, C, D, H, W)`,\n    output :math:`(N, C, D_{out}, H_{out}, W_{out})` and :attr:`kernel_size` :math:`(kD, kH, kW)`\n    can be precisely described as:\n\n    .. math::\n        \\begin{aligned}\n            \\text{out}(N_i, C_j, d, h, w) ={} & \\sum_{k=0}^{kD-1} \\sum_{m=0}^{kH-1} \\sum_{n=0}^{kW-1} \\\\\n                                              & \\frac{\\text{input}(N_i, C_j, \\text{stride}[0] \\times d + k,\n                                                      \\text{stride}[1] \\times h + m, \\text{stride}[2] \\times w + n)}\n                                                     {kD \\times kH \\times kW}\n        \\end{aligned}\n\n    If :attr:`padding` is non-zero, then the input is implicitly zero-padded on all three sides\n    for :attr:`padding` number of points.\n\n    Note:\n        When ceil_mode=True, sliding windows are allowed to go off-bounds if they start within the left padding\n        or the input. Sliding windows that would start in the right padded region are ignored.\n\n    The parameters :attr:`kernel_size`, :attr:`stride` can either be:\n\n        - a single ``int`` -- in which case the same value is used for the depth, height and width dimension\n        - a ``tuple`` of three ints -- in which case, the first `int` is used for the depth dimension,\n          the second `int` for the height dimension and the third `int` for the width dimension\n\n    Args:\n        kernel_size: the size of the window\n        stride: the stride of the window. Default value is :attr:`kernel_size`\n        padding: implicit zero padding to be added on all three sides\n        ceil_mode: when True, will use `ceil` instead of `floor` to compute the output shape\n        count_include_pad: when True, will include the zero-padding in the averaging calculation\n        divisor_override: if specified, it will be used as divisor, otherwise :attr:`kernel_size` will be used\n\n    Shape:\n        - Input: :math:`(N, C, D_{in}, H_{in}, W_{in})` or :math:`(C, D_{in}, H_{in}, W_{in})`.\n        - Output: :math:`(N, C, D_{out}, H_{out}, W_{out})` or\n          :math:`(C, D_{out}, H_{out}, W_{out})`, where\n\n          .. math::\n              D_{out} = \\left\\lfloor\\frac{D_{in} + 2 \\times \\text{padding}[0] -\n                    \\text{kernel\\_size}[0]}{\\text{stride}[0]} + 1\\right\\rfloor\n\n          .. math::\n              H_{out} = \\left\\lfloor\\frac{H_{in} + 2 \\times \\text{padding}[1] -\n                    \\text{kernel\\_size}[1]}{\\text{stride}[1]} + 1\\right\\rfloor\n\n          .. math::\n              W_{out} = \\left\\lfloor\\frac{W_{in} + 2 \\times \\text{padding}[2] -\n                    \\text{kernel\\_size}[2]}{\\text{stride}[2]} + 1\\right\\rfloor\n\n    Examples::\n\n        >>> # pool of square window of size=3, stride=2\n        >>> m = nn.AvgPool3d(3, stride=2)\n        >>> # pool of non-square window\n        >>> m = nn.AvgPool3d((3, 2, 2), stride=(2, 1, 2))\n        >>> input = torch.randn(20, 16, 50,44, 31)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "kernel_size": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int]]",
                          "Default": null
                        },
                        "stride": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int], NoneType]",
                          "Default": "None"
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int]]",
                          "Default": "0"
                        },
                        "ceil_mode": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "count_include_pad": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "divisor_override": {
                          "Type": "typing.Optional[int]",
                          "Default": "None"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "FractionalMaxPool2d": {
                  "Doc": "Applies a 2D fractional max pooling over an input signal composed of several input planes.\n\n    Fractional MaxPooling is described in detail in the paper `Fractional MaxPooling`_ by Ben Graham\n\n    The max-pooling operation is applied in :math:`kH \\times kW` regions by a stochastic\n    step size determined by the target output size.\n    The number of output features is equal to the number of input planes.\n\n    Args:\n        kernel_size: the size of the window to take a max over.\n                     Can be a single number k (for a square kernel of k x k) or a tuple `(kh, kw)`\n        output_size: the target output size of the image of the form `oH x oW`.\n                     Can be a tuple `(oH, oW)` or a single number oH for a square image `oH x oH`\n        output_ratio: If one wants to have an output size as a ratio of the input size, this option can be given.\n                      This has to be a number or tuple in the range (0, 1)\n        return_indices: if ``True``, will return the indices along with the outputs.\n                        Useful to pass to :meth:`nn.MaxUnpool2d`. Default: ``False``\n\n    Shape:\n        - Input: :math:`(N, C, H_{in}, W_{in})` or :math:`(C, H_{in}, W_{in})`.\n        - Output: :math:`(N, C, H_{out}, W_{out})` or :math:`(C, H_{out}, W_{out})`, where\n          :math:`(H_{out}, W_{out})=\\text{output\\_size}` or\n          :math:`(H_{out}, W_{out})=\\text{output\\_ratio} \\times (H_{in}, W_{in})`.\n\n    Examples:\n        >>> # pool of square window of size=3, and target output size 13x12\n        >>> m = nn.FractionalMaxPool2d(3, output_size=(13, 12))\n        >>> # pool of square window and target output size being half of input image size\n        >>> m = nn.FractionalMaxPool2d(3, output_ratio=(0.5, 0.5))\n        >>> input = torch.randn(20, 16, 50, 32)\n        >>> output = m(input)\n\n    .. _Fractional MaxPooling:\n        https://arxiv.org/abs/1412.6071\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "kernel_size": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": null
                        },
                        "output_size": {
                          "Type": "typing.Union[int, typing.Tuple[int, int], NoneType]",
                          "Default": "None"
                        },
                        "output_ratio": {
                          "Type": "typing.Union[float, typing.Tuple[float, float], NoneType]",
                          "Default": "None"
                        },
                        "return_indices": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "_random_samples": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "FractionalMaxPool3d": {
                  "Doc": "Applies a 3D fractional max pooling over an input signal composed of several input planes.\n\n    Fractional MaxPooling is described in detail in the paper `Fractional MaxPooling`_ by Ben Graham\n\n    The max-pooling operation is applied in :math:`kT \\times kH \\times kW` regions by a stochastic\n    step size determined by the target output size.\n    The number of output features is equal to the number of input planes.\n\n    Args:\n        kernel_size: the size of the window to take a max over.\n                     Can be a single number k (for a square kernel of k x k x k) or a tuple `(kt x kh x kw)`\n        output_size: the target output size of the image of the form `oT x oH x oW`.\n                     Can be a tuple `(oT, oH, oW)` or a single number oH for a square image `oH x oH x oH`\n        output_ratio: If one wants to have an output size as a ratio of the input size, this option can be given.\n                      This has to be a number or tuple in the range (0, 1)\n        return_indices: if ``True``, will return the indices along with the outputs.\n                        Useful to pass to :meth:`nn.MaxUnpool3d`. Default: ``False``\n\n    Shape:\n        - Input: :math:`(N, C, T_{in}, H_{in}, W_{in})` or :math:`(C, T_{in}, H_{in}, W_{in})`.\n        - Output: :math:`(N, C, T_{out}, H_{out}, W_{out})` or :math:`(C, T_{out}, H_{out}, W_{out})`, where\n          :math:`(T_{out}, H_{out}, W_{out})=\\text{output\\_size}` or\n          :math:`(T_{out}, H_{out}, W_{out})=\\text{output\\_ratio} \\times (T_{in}, H_{in}, W_{in})`\n\n    Examples:\n        >>> # pool of cubic window of size=3, and target output size 13x12x11\n        >>> m = nn.FractionalMaxPool3d(3, output_size=(13, 12, 11))\n        >>> # pool of cubic window and target output size being half of input size\n        >>> m = nn.FractionalMaxPool3d(3, output_ratio=(0.5, 0.5, 0.5))\n        >>> input = torch.randn(20, 16, 50, 32, 16)\n        >>> output = m(input)\n\n    .. _Fractional MaxPooling:\n        https://arxiv.org/abs/1412.6071\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "kernel_size": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int]]",
                          "Default": null
                        },
                        "output_size": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int], NoneType]",
                          "Default": "None"
                        },
                        "output_ratio": {
                          "Type": "typing.Union[float, typing.Tuple[float, float, float], NoneType]",
                          "Default": "None"
                        },
                        "return_indices": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "_random_samples": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "LPPool1d": {
                  "Doc": "Applies a 1D power-average pooling over an input signal composed of several input\n    planes.\n\n    On each window, the function computed is:\n\n    .. math::\n        f(X) = \\sqrt[p]{\\sum_{x \\in X} x^{p}}\n\n    - At p = :math:`\\infty`, one gets Max Pooling\n    - At p = 1, one gets Sum Pooling (which is proportional to Average Pooling)\n\n    .. note:: If the sum to the power of `p` is zero, the gradient of this function is\n              not defined. This implementation will set the gradient to zero in this case.\n\n    Args:\n        kernel_size: a single int, the size of the window\n        stride: a single int, the stride of the window. Default value is :attr:`kernel_size`\n        ceil_mode: when True, will use `ceil` instead of `floor` to compute the output shape\n\n    Shape:\n        - Input: :math:`(N, C, L_{in})` or :math:`(C, L_{in})`.\n        - Output: :math:`(N, C, L_{out})` or :math:`(C, L_{out})`, where\n\n          .. math::\n              L_{out} = \\left\\lfloor\\frac{L_{in} - \\text{kernel\\_size}}{\\text{stride}} + 1\\right\\rfloor\n\n    Examples::\n        >>> # power-2 pool of window of length 3, with stride 2.\n        >>> m = nn.LPPool1d(2, 3, stride=2)\n        >>> input = torch.randn(20, 16, 50)\n        >>> output = m(input)\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "LPPool2d": {
                  "Doc": "Applies a 2D power-average pooling over an input signal composed of several input\n    planes.\n\n    On each window, the function computed is:\n\n    .. math::\n        f(X) = \\sqrt[p]{\\sum_{x \\in X} x^{p}}\n\n    - At p = :math:`\\infty`, one gets Max Pooling\n    - At p = 1, one gets Sum Pooling (which is proportional to average pooling)\n\n    The parameters :attr:`kernel_size`, :attr:`stride` can either be:\n\n        - a single ``int`` -- in which case the same value is used for the height and width dimension\n        - a ``tuple`` of two ints -- in which case, the first `int` is used for the height dimension,\n          and the second `int` for the width dimension\n\n    .. note:: If the sum to the power of `p` is zero, the gradient of this function is\n              not defined. This implementation will set the gradient to zero in this case.\n\n    Args:\n        kernel_size: the size of the window\n        stride: the stride of the window. Default value is :attr:`kernel_size`\n        ceil_mode: when True, will use `ceil` instead of `floor` to compute the output shape\n\n    Shape:\n        - Input: :math:`(N, C, H_{in}, W_{in})`\n        - Output: :math:`(N, C, H_{out}, W_{out})`, where\n\n          .. math::\n              H_{out} = \\left\\lfloor\\frac{H_{in} - \\text{kernel\\_size}[0]}{\\text{stride}[0]} + 1\\right\\rfloor\n\n          .. math::\n              W_{out} = \\left\\lfloor\\frac{W_{in} - \\text{kernel\\_size}[1]}{\\text{stride}[1]} + 1\\right\\rfloor\n\n    Examples::\n\n        >>> # power-2 pool of square window of size=3, stride=2\n        >>> m = nn.LPPool2d(2, 3, stride=2)\n        >>> # pool of non-square window of power 1.2\n        >>> m = nn.LPPool2d(1.2, (3, 2), stride=(2, 1))\n        >>> input = torch.randn(20, 16, 50, 32)\n        >>> output = m(input)\n\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "MaxPool1d": {
                  "Doc": "Applies a 1D max pooling over an input signal composed of several input\n    planes.\n\n    In the simplest case, the output value of the layer with input size :math:`(N, C, L)`\n    and output :math:`(N, C, L_{out})` can be precisely described as:\n\n    .. math::\n        out(N_i, C_j, k) = \\max_{m=0, \\ldots, \\text{kernel\\_size} - 1}\n                input(N_i, C_j, stride \\times k + m)\n\n    If :attr:`padding` is non-zero, then the input is implicitly padded with negative infinity on both sides\n    for :attr:`padding` number of points. :attr:`dilation` is the stride between the elements within the\n    sliding window. This `link`_ has a nice visualization of the pooling parameters.\n\n    Note:\n        When ceil_mode=True, sliding windows are allowed to go off-bounds if they start within the left padding\n        or the input. Sliding windows that would start in the right padded region are ignored.\n\n    Args:\n        kernel_size: The size of the sliding window, must be > 0.\n        stride: The stride of the sliding window, must be > 0. Default value is :attr:`kernel_size`.\n        padding: Implicit negative infinity padding to be added on both sides, must be >= 0 and <= kernel_size / 2.\n        dilation: The stride between elements within a sliding window, must be > 0.\n        return_indices: If ``True``, will return the argmax along with the max values.\n                        Useful for :class:`torch.nn.MaxUnpool1d` later\n        ceil_mode: If ``True``, will use `ceil` instead of `floor` to compute the output shape. This\n                   ensures that every element in the input tensor is covered by a sliding window.\n\n    Shape:\n        - Input: :math:`(N, C, L_{in})` or :math:`(C, L_{in})`.\n        - Output: :math:`(N, C, L_{out})` or :math:`(C, L_{out})`, where\n\n          .. math::\n              L_{out} = \\left\\lfloor \\frac{L_{in} + 2 \\times \\text{padding} - \\text{dilation}\n                    \\times (\\text{kernel\\_size} - 1) - 1}{\\text{stride}} + 1\\right\\rfloor\n\n    Examples::\n\n        >>> # pool of size=3, stride=2\n        >>> m = nn.MaxPool1d(3, stride=2)\n        >>> input = torch.randn(20, 16, 50)\n        >>> output = m(input)\n\n    .. _link:\n        https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "MaxPool2d": {
                  "Doc": "Applies a 2D max pooling over an input signal composed of several input\n    planes.\n\n    In the simplest case, the output value of the layer with input size :math:`(N, C, H, W)`,\n    output :math:`(N, C, H_{out}, W_{out})` and :attr:`kernel_size` :math:`(kH, kW)`\n    can be precisely described as:\n\n    .. math::\n        \\begin{aligned}\n            out(N_i, C_j, h, w) ={} & \\max_{m=0, \\ldots, kH-1} \\max_{n=0, \\ldots, kW-1} \\\\\n                                    & \\text{input}(N_i, C_j, \\text{stride[0]} \\times h + m,\n                                                   \\text{stride[1]} \\times w + n)\n        \\end{aligned}\n\n    If :attr:`padding` is non-zero, then the input is implicitly padded with negative infinity on both sides\n    for :attr:`padding` number of points. :attr:`dilation` controls the spacing between the kernel points.\n    It is harder to describe, but this `link`_ has a nice visualization of what :attr:`dilation` does.\n\n    Note:\n        When ceil_mode=True, sliding windows are allowed to go off-bounds if they start within the left padding\n        or the input. Sliding windows that would start in the right padded region are ignored.\n\n    The parameters :attr:`kernel_size`, :attr:`stride`, :attr:`padding`, :attr:`dilation` can either be:\n\n        - a single ``int`` -- in which case the same value is used for the height and width dimension\n        - a ``tuple`` of two ints -- in which case, the first `int` is used for the height dimension,\n          and the second `int` for the width dimension\n\n    Args:\n        kernel_size: the size of the window to take a max over\n        stride: the stride of the window. Default value is :attr:`kernel_size`\n        padding: implicit zero padding to be added on both sides\n        dilation: a parameter that controls the stride of elements in the window\n        return_indices: if ``True``, will return the max indices along with the outputs.\n                        Useful for :class:`torch.nn.MaxUnpool2d` later\n        ceil_mode: when True, will use `ceil` instead of `floor` to compute the output shape\n\n    Shape:\n        - Input: :math:`(N, C, H_{in}, W_{in})` or :math:`(C, H_{in}, W_{in})`\n        - Output: :math:`(N, C, H_{out}, W_{out})` or :math:`(C, H_{out}, W_{out})`, where\n\n          .. math::\n              H_{out} = \\left\\lfloor\\frac{H_{in} + 2 * \\text{padding[0]} - \\text{dilation[0]}\n                    \\times (\\text{kernel\\_size[0]} - 1) - 1}{\\text{stride[0]}} + 1\\right\\rfloor\n\n          .. math::\n              W_{out} = \\left\\lfloor\\frac{W_{in} + 2 * \\text{padding[1]} - \\text{dilation[1]}\n                    \\times (\\text{kernel\\_size[1]} - 1) - 1}{\\text{stride[1]}} + 1\\right\\rfloor\n\n    Examples::\n\n        >>> # pool of square window of size=3, stride=2\n        >>> m = nn.MaxPool2d(3, stride=2)\n        >>> # pool of non-square window\n        >>> m = nn.MaxPool2d((3, 2), stride=(2, 1))\n        >>> input = torch.randn(20, 16, 50, 32)\n        >>> output = m(input)\n\n    .. _link:\n        https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "MaxPool3d": {
                  "Doc": "Applies a 3D max pooling over an input signal composed of several input\n    planes.\n\n    In the simplest case, the output value of the layer with input size :math:`(N, C, D, H, W)`,\n    output :math:`(N, C, D_{out}, H_{out}, W_{out})` and :attr:`kernel_size` :math:`(kD, kH, kW)`\n    can be precisely described as:\n\n    .. math::\n        \\begin{aligned}\n            \\text{out}(N_i, C_j, d, h, w) ={} & \\max_{k=0, \\ldots, kD-1} \\max_{m=0, \\ldots, kH-1} \\max_{n=0, \\ldots, kW-1} \\\\\n                                              & \\text{input}(N_i, C_j, \\text{stride[0]} \\times d + k,\n                                                             \\text{stride[1]} \\times h + m, \\text{stride[2]} \\times w + n)\n        \\end{aligned}\n\n    If :attr:`padding` is non-zero, then the input is implicitly padded with negative infinity on both sides\n    for :attr:`padding` number of points. :attr:`dilation` controls the spacing between the kernel points.\n    It is harder to describe, but this `link`_ has a nice visualization of what :attr:`dilation` does.\n\n    Note:\n        When ceil_mode=True, sliding windows are allowed to go off-bounds if they start within the left padding\n        or the input. Sliding windows that would start in the right padded region are ignored.\n\n    The parameters :attr:`kernel_size`, :attr:`stride`, :attr:`padding`, :attr:`dilation` can either be:\n\n        - a single ``int`` -- in which case the same value is used for the depth, height and width dimension\n        - a ``tuple`` of three ints -- in which case, the first `int` is used for the depth dimension,\n          the second `int` for the height dimension and the third `int` for the width dimension\n\n    Args:\n        kernel_size: the size of the window to take a max over\n        stride: the stride of the window. Default value is :attr:`kernel_size`\n        padding: implicit zero padding to be added on all three sides\n        dilation: a parameter that controls the stride of elements in the window\n        return_indices: if ``True``, will return the max indices along with the outputs.\n                        Useful for :class:`torch.nn.MaxUnpool3d` later\n        ceil_mode: when True, will use `ceil` instead of `floor` to compute the output shape\n\n    Shape:\n        - Input: :math:`(N, C, D_{in}, H_{in}, W_{in})` or :math:`(C, D_{in}, H_{in}, W_{in})`.\n        - Output: :math:`(N, C, D_{out}, H_{out}, W_{out})` or :math:`(C, D_{out}, H_{out}, W_{out})`, where\n\n          .. math::\n              D_{out} = \\left\\lfloor\\frac{D_{in} + 2 \\times \\text{padding}[0] - \\text{dilation}[0] \\times\n                (\\text{kernel\\_size}[0] - 1) - 1}{\\text{stride}[0]} + 1\\right\\rfloor\n\n          .. math::\n              H_{out} = \\left\\lfloor\\frac{H_{in} + 2 \\times \\text{padding}[1] - \\text{dilation}[1] \\times\n                (\\text{kernel\\_size}[1] - 1) - 1}{\\text{stride}[1]} + 1\\right\\rfloor\n\n          .. math::\n              W_{out} = \\left\\lfloor\\frac{W_{in} + 2 \\times \\text{padding}[2] - \\text{dilation}[2] \\times\n                (\\text{kernel\\_size}[2] - 1) - 1}{\\text{stride}[2]} + 1\\right\\rfloor\n\n    Examples::\n\n        >>> # pool of square window of size=3, stride=2\n        >>> m = nn.MaxPool3d(3, stride=2)\n        >>> # pool of non-square window\n        >>> m = nn.MaxPool3d((3, 2, 2), stride=(2, 1, 2))\n        >>> input = torch.randn(20, 16, 50,44, 31)\n        >>> output = m(input)\n\n    .. _link:\n        https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md\n    ",
                  "Functions": {
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "MaxUnpool1d": {
                  "Doc": "Computes a partial inverse of :class:`MaxPool1d`.\n\n    :class:`MaxPool1d` is not fully invertible, since the non-maximal values are lost.\n\n    :class:`MaxUnpool1d` takes in as input the output of :class:`MaxPool1d`\n    including the indices of the maximal values and computes a partial inverse\n    in which all non-maximal values are set to zero.\n\n    .. note:: :class:`MaxPool1d` can map several input sizes to the same output\n              sizes. Hence, the inversion process can get ambiguous.\n              To accommodate this, you can provide the needed output size\n              as an additional argument :attr:`output_size` in the forward call.\n              See the Inputs and Example below.\n\n    Args:\n        kernel_size (int or tuple): Size of the max pooling window.\n        stride (int or tuple): Stride of the max pooling window.\n            It is set to :attr:`kernel_size` by default.\n        padding (int or tuple): Padding that was added to the input\n\n    Inputs:\n        - `input`: the input Tensor to invert\n        - `indices`: the indices given out by :class:`~torch.nn.MaxPool1d`\n        - `output_size` (optional): the targeted output size\n\n    Shape:\n        - Input: :math:`(N, C, H_{in})` or :math:`(C, H_{in})`.\n        - Output: :math:`(N, C, H_{out})` or :math:`(C, H_{out})`, where\n\n          .. math::\n              H_{out} = (H_{in} - 1) \\times \\text{stride}[0] - 2 \\times \\text{padding}[0] + \\text{kernel\\_size}[0]\n\n          or as given by :attr:`output_size` in the call operator\n\n    Example::\n\n        >>> # xdoctest: +IGNORE_WANT(\"do other tests modify the global state?\")\n        >>> pool = nn.MaxPool1d(2, stride=2, return_indices=True)\n        >>> unpool = nn.MaxUnpool1d(2, stride=2)\n        >>> input = torch.tensor([[[1., 2, 3, 4, 5, 6, 7, 8]]])\n        >>> output, indices = pool(input)\n        >>> unpool(output, indices)\n        tensor([[[ 0.,  2.,  0.,  4.,  0.,  6.,  0., 8.]]])\n\n        >>> # Example showcasing the use of output_size\n        >>> input = torch.tensor([[[1., 2, 3, 4, 5, 6, 7, 8, 9]]])\n        >>> output, indices = pool(input)\n        >>> unpool(output, indices, output_size=input.size())\n        tensor([[[ 0.,  2.,  0.,  4.,  0.,  6.,  0., 8.,  0.]]])\n\n        >>> unpool(output, indices)\n        tensor([[[ 0.,  2.,  0.,  4.,  0.,  6.,  0., 8.]]])\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "kernel_size": {
                          "Type": "typing.Union[int, typing.Tuple[int]]",
                          "Default": null
                        },
                        "stride": {
                          "Type": "typing.Union[int, typing.Tuple[int], NoneType]",
                          "Default": "None"
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int]]",
                          "Default": "0"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "indices": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "output_size": {
                          "Type": "typing.Optional[typing.List[int]]",
                          "Default": "None"
                        }
                      }
                    }
                  }
                },
                "MaxUnpool2d": {
                  "Doc": "Computes a partial inverse of :class:`MaxPool2d`.\n\n    :class:`MaxPool2d` is not fully invertible, since the non-maximal values are lost.\n\n    :class:`MaxUnpool2d` takes in as input the output of :class:`MaxPool2d`\n    including the indices of the maximal values and computes a partial inverse\n    in which all non-maximal values are set to zero.\n\n    .. note:: :class:`MaxPool2d` can map several input sizes to the same output\n              sizes. Hence, the inversion process can get ambiguous.\n              To accommodate this, you can provide the needed output size\n              as an additional argument :attr:`output_size` in the forward call.\n              See the Inputs and Example below.\n\n    Args:\n        kernel_size (int or tuple): Size of the max pooling window.\n        stride (int or tuple): Stride of the max pooling window.\n            It is set to :attr:`kernel_size` by default.\n        padding (int or tuple): Padding that was added to the input\n\n    Inputs:\n        - `input`: the input Tensor to invert\n        - `indices`: the indices given out by :class:`~torch.nn.MaxPool2d`\n        - `output_size` (optional): the targeted output size\n\n    Shape:\n        - Input: :math:`(N, C, H_{in}, W_{in})` or :math:`(C, H_{in}, W_{in})`.\n        - Output: :math:`(N, C, H_{out}, W_{out})` or :math:`(C, H_{out}, W_{out})`, where\n\n          .. math::\n            H_{out} = (H_{in} - 1) \\times \\text{stride[0]} - 2 \\times \\text{padding[0]} + \\text{kernel\\_size[0]}\n\n          .. math::\n            W_{out} = (W_{in} - 1) \\times \\text{stride[1]} - 2 \\times \\text{padding[1]} + \\text{kernel\\_size[1]}\n\n          or as given by :attr:`output_size` in the call operator\n\n    Example::\n\n        >>> pool = nn.MaxPool2d(2, stride=2, return_indices=True)\n        >>> unpool = nn.MaxUnpool2d(2, stride=2)\n        >>> input = torch.tensor([[[[ 1.,  2.,  3.,  4.],\n                                    [ 5.,  6.,  7.,  8.],\n                                    [ 9., 10., 11., 12.],\n                                    [13., 14., 15., 16.]]]])\n        >>> output, indices = pool(input)\n        >>> unpool(output, indices)\n        tensor([[[[  0.,   0.,   0.,   0.],\n                  [  0.,   6.,   0.,   8.],\n                  [  0.,   0.,   0.,   0.],\n                  [  0.,  14.,   0.,  16.]]]])\n        >>> # Now using output_size to resolve an ambiguous size for the inverse\n        >>> input = torch.torch.tensor([[[[ 1.,  2.,  3., 4., 5.],\n                                          [ 6.,  7.,  8., 9., 10.],\n                                          [11., 12., 13., 14., 15.],\n                                          [16., 17., 18., 19., 20.]]]])\n        >>> output, indices = pool(input)\n        >>> # This call will not work without specifying output_size\n        >>> unpool(output, indices, output_size=input.size())\n        tensor([[[[ 0.,  0.,  0.,  0.,  0.],\n                  [ 0.,  7.,  0.,  9.,  0.],\n                  [ 0.,  0.,  0.,  0.,  0.],\n                  [ 0., 17.,  0., 19.,  0.]]]])\n\n\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "kernel_size": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": null
                        },
                        "stride": {
                          "Type": "typing.Union[int, typing.Tuple[int, int], NoneType]",
                          "Default": "None"
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int]]",
                          "Default": "0"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "indices": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "output_size": {
                          "Type": "typing.Optional[typing.List[int]]",
                          "Default": "None"
                        }
                      }
                    }
                  }
                },
                "MaxUnpool3d": {
                  "Doc": "Computes a partial inverse of :class:`MaxPool3d`.\n\n    :class:`MaxPool3d` is not fully invertible, since the non-maximal values are lost.\n    :class:`MaxUnpool3d` takes in as input the output of :class:`MaxPool3d`\n    including the indices of the maximal values and computes a partial inverse\n    in which all non-maximal values are set to zero.\n\n    .. note:: :class:`MaxPool3d` can map several input sizes to the same output\n              sizes. Hence, the inversion process can get ambiguous.\n              To accommodate this, you can provide the needed output size\n              as an additional argument :attr:`output_size` in the forward call.\n              See the Inputs section below.\n\n    Args:\n        kernel_size (int or tuple): Size of the max pooling window.\n        stride (int or tuple): Stride of the max pooling window.\n            It is set to :attr:`kernel_size` by default.\n        padding (int or tuple): Padding that was added to the input\n\n    Inputs:\n        - `input`: the input Tensor to invert\n        - `indices`: the indices given out by :class:`~torch.nn.MaxPool3d`\n        - `output_size` (optional): the targeted output size\n\n    Shape:\n        - Input: :math:`(N, C, D_{in}, H_{in}, W_{in})` or :math:`(C, D_{in}, H_{in}, W_{in})`.\n        - Output: :math:`(N, C, D_{out}, H_{out}, W_{out})` or :math:`(C, D_{out}, H_{out}, W_{out})`, where\n\n          .. math::\n              D_{out} = (D_{in} - 1) \\times \\text{stride[0]} - 2 \\times \\text{padding[0]} + \\text{kernel\\_size[0]}\n\n          .. math::\n              H_{out} = (H_{in} - 1) \\times \\text{stride[1]} - 2 \\times \\text{padding[1]} + \\text{kernel\\_size[1]}\n\n          .. math::\n              W_{out} = (W_{in} - 1) \\times \\text{stride[2]} - 2 \\times \\text{padding[2]} + \\text{kernel\\_size[2]}\n\n          or as given by :attr:`output_size` in the call operator\n\n    Example::\n\n        >>> # pool of square window of size=3, stride=2\n        >>> pool = nn.MaxPool3d(3, stride=2, return_indices=True)\n        >>> unpool = nn.MaxUnpool3d(3, stride=2)\n        >>> output, indices = pool(torch.randn(20, 16, 51, 33, 15))\n        >>> unpooled_output = unpool(output, indices)\n        >>> unpooled_output.size()\n        torch.Size([20, 16, 51, 33, 15])\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "kernel_size": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int]]",
                          "Default": null
                        },
                        "stride": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int], NoneType]",
                          "Default": "None"
                        },
                        "padding": {
                          "Type": "typing.Union[int, typing.Tuple[int, int, int]]",
                          "Default": "0"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "indices": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "output_size": {
                          "Type": "typing.Optional[typing.List[int]]",
                          "Default": "None"
                        }
                      }
                    }
                  }
                }
              }
            },
            "rnn": {
              "Doc": null,
              "Classes": {
                "GRU": {
                  "Doc": "Applies a multi-layer gated recurrent unit (GRU) RNN to an input sequence.\n\n\n    For each element in the input sequence, each layer computes the following\n    function:\n\n    .. math::\n        \\begin{array}{ll}\n            r_t = \\sigma(W_{ir} x_t + b_{ir} + W_{hr} h_{(t-1)} + b_{hr}) \\\\\n            z_t = \\sigma(W_{iz} x_t + b_{iz} + W_{hz} h_{(t-1)} + b_{hz}) \\\\\n            n_t = \\tanh(W_{in} x_t + b_{in} + r_t * (W_{hn} h_{(t-1)}+ b_{hn})) \\\\\n            h_t = (1 - z_t) * n_t + z_t * h_{(t-1)}\n        \\end{array}\n\n    where :math:`h_t` is the hidden state at time `t`, :math:`x_t` is the input\n    at time `t`, :math:`h_{(t-1)}` is the hidden state of the layer\n    at time `t-1` or the initial hidden state at time `0`, and :math:`r_t`,\n    :math:`z_t`, :math:`n_t` are the reset, update, and new gates, respectively.\n    :math:`\\sigma` is the sigmoid function, and :math:`*` is the Hadamard product.\n\n    In a multilayer GRU, the input :math:`x^{(l)}_t` of the :math:`l` -th layer\n    (:math:`l >= 2`) is the hidden state :math:`h^{(l-1)}_t` of the previous layer multiplied by\n    dropout :math:`\\delta^{(l-1)}_t` where each :math:`\\delta^{(l-1)}_t` is a Bernoulli random\n    variable which is :math:`0` with probability :attr:`dropout`.\n\n    Args:\n        input_size: The number of expected features in the input `x`\n        hidden_size: The number of features in the hidden state `h`\n        num_layers: Number of recurrent layers. E.g., setting ``num_layers=2``\n            would mean stacking two GRUs together to form a `stacked GRU`,\n            with the second GRU taking in outputs of the first GRU and\n            computing the final results. Default: 1\n        bias: If ``False``, then the layer does not use bias weights `b_ih` and `b_hh`.\n            Default: ``True``\n        batch_first: If ``True``, then the input and output tensors are provided\n            as `(batch, seq, feature)` instead of `(seq, batch, feature)`.\n            Note that this does not apply to hidden or cell states. See the\n            Inputs/Outputs sections below for details.  Default: ``False``\n        dropout: If non-zero, introduces a `Dropout` layer on the outputs of each\n            GRU layer except the last layer, with dropout probability equal to\n            :attr:`dropout`. Default: 0\n        bidirectional: If ``True``, becomes a bidirectional GRU. Default: ``False``\n\n    Inputs: input, h_0\n        * **input**: tensor of shape :math:`(L, H_{in})` for unbatched input,\n          :math:`(L, N, H_{in})` when ``batch_first=False`` or\n          :math:`(N, L, H_{in})` when ``batch_first=True`` containing the features of\n          the input sequence.  The input can also be a packed variable length sequence.\n          See :func:`torch.nn.utils.rnn.pack_padded_sequence` or\n          :func:`torch.nn.utils.rnn.pack_sequence` for details.\n        * **h_0**: tensor of shape :math:`(D * \\text{num\\_layers}, H_{out})` or\n          :math:`(D * \\text{num\\_layers}, N, H_{out})`\n          containing the initial hidden state for the input sequence. Defaults to zeros if not provided.\n\n        where:\n\n        .. math::\n            \\begin{aligned}\n                N ={} & \\text{batch size} \\\\\n                L ={} & \\text{sequence length} \\\\\n                D ={} & 2 \\text{ if bidirectional=True otherwise } 1 \\\\\n                H_{in} ={} & \\text{input\\_size} \\\\\n                H_{out} ={} & \\text{hidden\\_size}\n            \\end{aligned}\n\n    Outputs: output, h_n\n        * **output**: tensor of shape :math:`(L, D * H_{out})` for unbatched input,\n          :math:`(L, N, D * H_{out})` when ``batch_first=False`` or\n          :math:`(N, L, D * H_{out})` when ``batch_first=True`` containing the output features\n          `(h_t)` from the last layer of the GRU, for each `t`. If a\n          :class:`torch.nn.utils.rnn.PackedSequence` has been given as the input, the output\n          will also be a packed sequence.\n        * **h_n**: tensor of shape :math:`(D * \\text{num\\_layers}, H_{out})` or\n          :math:`(D * \\text{num\\_layers}, N, H_{out})` containing the final hidden state\n          for the input sequence.\n\n    Attributes:\n        weight_ih_l[k] : the learnable input-hidden weights of the :math:`\\text{k}^{th}` layer\n            (W_ir|W_iz|W_in), of shape `(3*hidden_size, input_size)` for `k = 0`.\n            Otherwise, the shape is `(3*hidden_size, num_directions * hidden_size)`\n        weight_hh_l[k] : the learnable hidden-hidden weights of the :math:`\\text{k}^{th}` layer\n            (W_hr|W_hz|W_hn), of shape `(3*hidden_size, hidden_size)`\n        bias_ih_l[k] : the learnable input-hidden bias of the :math:`\\text{k}^{th}` layer\n            (b_ir|b_iz|b_in), of shape `(3*hidden_size)`\n        bias_hh_l[k] : the learnable hidden-hidden bias of the :math:`\\text{k}^{th}` layer\n            (b_hr|b_hz|b_hn), of shape `(3*hidden_size)`\n\n    .. note::\n        All the weights and biases are initialized from :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})`\n        where :math:`k = \\frac{1}{\\text{hidden\\_size}}`\n\n    .. note::\n        For bidirectional GRUs, forward and backward are directions 0 and 1 respectively.\n        Example of splitting the output layers when ``batch_first=False``:\n        ``output.view(seq_len, batch, num_directions, hidden_size)``.\n\n    .. note::\n        ``batch_first`` argument is ignored for unbatched inputs.\n\n    .. include:: ../cudnn_persistent_rnn.rst\n\n    Examples::\n\n        >>> rnn = nn.GRU(10, 20, 2)\n        >>> input = torch.randn(5, 3, 10)\n        >>> h0 = torch.randn(2, 3, 20)\n        >>> output, hn = rnn(input, h0)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "*args": {
                          "Type": null,
                          "Default": null
                        },
                        "**kwargs": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": null,
                          "Default": null
                        },
                        "hx": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    }
                  }
                },
                "GRUCell": {
                  "Doc": "A gated recurrent unit (GRU) cell\n\n    .. math::\n\n        \\begin{array}{ll}\n        r = \\sigma(W_{ir} x + b_{ir} + W_{hr} h + b_{hr}) \\\\\n        z = \\sigma(W_{iz} x + b_{iz} + W_{hz} h + b_{hz}) \\\\\n        n = \\tanh(W_{in} x + b_{in} + r * (W_{hn} h + b_{hn})) \\\\\n        h' = (1 - z) * n + z * h\n        \\end{array}\n\n    where :math:`\\sigma` is the sigmoid function, and :math:`*` is the Hadamard product.\n\n    Args:\n        input_size: The number of expected features in the input `x`\n        hidden_size: The number of features in the hidden state `h`\n        bias: If ``False``, then the layer does not use bias weights `b_ih` and\n            `b_hh`. Default: ``True``\n\n    Inputs: input, hidden\n        - **input** : tensor containing input features\n        - **hidden** : tensor containing the initial hidden\n          state for each element in the batch.\n          Defaults to zero if not provided.\n\n    Outputs: h'\n        - **h'** : tensor containing the next hidden state\n          for each element in the batch\n\n    Shape:\n        - input: :math:`(N, H_{in})` or :math:`(H_{in})` tensor containing input features where\n          :math:`H_{in}` = `input_size`.\n        - hidden: :math:`(N, H_{out})` or :math:`(H_{out})` tensor containing the initial hidden\n          state where :math:`H_{out}` = `hidden_size`. Defaults to zero if not provided.\n        - output: :math:`(N, H_{out})` or :math:`(H_{out})` tensor containing the next hidden state.\n\n    Attributes:\n        weight_ih: the learnable input-hidden weights, of shape\n            `(3*hidden_size, input_size)`\n        weight_hh: the learnable hidden-hidden weights, of shape\n            `(3*hidden_size, hidden_size)`\n        bias_ih: the learnable input-hidden bias, of shape `(3*hidden_size)`\n        bias_hh: the learnable hidden-hidden bias, of shape `(3*hidden_size)`\n\n    .. note::\n        All the weights and biases are initialized from :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})`\n        where :math:`k = \\frac{1}{\\text{hidden\\_size}}`\n\n    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.\n\n    Examples::\n\n        >>> rnn = nn.GRUCell(10, 20)\n        >>> input = torch.randn(6, 3, 10)\n        >>> hx = torch.randn(3, 20)\n        >>> output = []\n        >>> for i in range(6):\n        ...     hx = rnn(input[i], hx)\n        ...     output.append(hx)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input_size": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "hidden_size": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "bias": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "hx": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        }
                      }
                    }
                  }
                },
                "LSTM": {
                  "Doc": "Applies a multi-layer long short-term memory (LSTM) RNN to an input\n    sequence.\n\n\n    For each element in the input sequence, each layer computes the following\n    function:\n\n    .. math::\n        \\begin{array}{ll} \\\\\n            i_t = \\sigma(W_{ii} x_t + b_{ii} + W_{hi} h_{t-1} + b_{hi}) \\\\\n            f_t = \\sigma(W_{if} x_t + b_{if} + W_{hf} h_{t-1} + b_{hf}) \\\\\n            g_t = \\tanh(W_{ig} x_t + b_{ig} + W_{hg} h_{t-1} + b_{hg}) \\\\\n            o_t = \\sigma(W_{io} x_t + b_{io} + W_{ho} h_{t-1} + b_{ho}) \\\\\n            c_t = f_t \\odot c_{t-1} + i_t \\odot g_t \\\\\n            h_t = o_t \\odot \\tanh(c_t) \\\\\n        \\end{array}\n\n    where :math:`h_t` is the hidden state at time `t`, :math:`c_t` is the cell\n    state at time `t`, :math:`x_t` is the input at time `t`, :math:`h_{t-1}`\n    is the hidden state of the layer at time `t-1` or the initial hidden\n    state at time `0`, and :math:`i_t`, :math:`f_t`, :math:`g_t`,\n    :math:`o_t` are the input, forget, cell, and output gates, respectively.\n    :math:`\\sigma` is the sigmoid function, and :math:`\\odot` is the Hadamard product.\n\n    In a multilayer LSTM, the input :math:`x^{(l)}_t` of the :math:`l` -th layer\n    (:math:`l >= 2`) is the hidden state :math:`h^{(l-1)}_t` of the previous layer multiplied by\n    dropout :math:`\\delta^{(l-1)}_t` where each :math:`\\delta^{(l-1)}_t` is a Bernoulli random\n    variable which is :math:`0` with probability :attr:`dropout`.\n\n    If ``proj_size > 0`` is specified, LSTM with projections will be used. This changes\n    the LSTM cell in the following way. First, the dimension of :math:`h_t` will be changed from\n    ``hidden_size`` to ``proj_size`` (dimensions of :math:`W_{hi}` will be changed accordingly).\n    Second, the output hidden state of each layer will be multiplied by a learnable projection\n    matrix: :math:`h_t = W_{hr}h_t`. Note that as a consequence of this, the output\n    of LSTM network will be of different shape as well. See Inputs/Outputs sections below for exact\n    dimensions of all variables. You can find more details in https://arxiv.org/abs/1402.1128.\n\n    Args:\n        input_size: The number of expected features in the input `x`\n        hidden_size: The number of features in the hidden state `h`\n        num_layers: Number of recurrent layers. E.g., setting ``num_layers=2``\n            would mean stacking two LSTMs together to form a `stacked LSTM`,\n            with the second LSTM taking in outputs of the first LSTM and\n            computing the final results. Default: 1\n        bias: If ``False``, then the layer does not use bias weights `b_ih` and `b_hh`.\n            Default: ``True``\n        batch_first: If ``True``, then the input and output tensors are provided\n            as `(batch, seq, feature)` instead of `(seq, batch, feature)`.\n            Note that this does not apply to hidden or cell states. See the\n            Inputs/Outputs sections below for details.  Default: ``False``\n        dropout: If non-zero, introduces a `Dropout` layer on the outputs of each\n            LSTM layer except the last layer, with dropout probability equal to\n            :attr:`dropout`. Default: 0\n        bidirectional: If ``True``, becomes a bidirectional LSTM. Default: ``False``\n        proj_size: If ``> 0``, will use LSTM with projections of corresponding size. Default: 0\n\n    Inputs: input, (h_0, c_0)\n        * **input**: tensor of shape :math:`(L, H_{in})` for unbatched input,\n          :math:`(L, N, H_{in})` when ``batch_first=False`` or\n          :math:`(N, L, H_{in})` when ``batch_first=True`` containing the features of\n          the input sequence.  The input can also be a packed variable length sequence.\n          See :func:`torch.nn.utils.rnn.pack_padded_sequence` or\n          :func:`torch.nn.utils.rnn.pack_sequence` for details.\n        * **h_0**: tensor of shape :math:`(D * \\text{num\\_layers}, H_{out})` for unbatched input or\n          :math:`(D * \\text{num\\_layers}, N, H_{out})` containing the\n          initial hidden state for each element in the input sequence.\n          Defaults to zeros if (h_0, c_0) is not provided.\n        * **c_0**: tensor of shape :math:`(D * \\text{num\\_layers}, H_{cell})` for unbatched input or\n          :math:`(D * \\text{num\\_layers}, N, H_{cell})` containing the\n          initial cell state for each element in the input sequence.\n          Defaults to zeros if (h_0, c_0) is not provided.\n\n        where:\n\n        .. math::\n            \\begin{aligned}\n                N ={} & \\text{batch size} \\\\\n                L ={} & \\text{sequence length} \\\\\n                D ={} & 2 \\text{ if bidirectional=True otherwise } 1 \\\\\n                H_{in} ={} & \\text{input\\_size} \\\\\n                H_{cell} ={} & \\text{hidden\\_size} \\\\\n                H_{out} ={} & \\text{proj\\_size if } \\text{proj\\_size}>0 \\text{ otherwise hidden\\_size} \\\\\n            \\end{aligned}\n\n    Outputs: output, (h_n, c_n)\n        * **output**: tensor of shape :math:`(L, D * H_{out})` for unbatched input,\n          :math:`(L, N, D * H_{out})` when ``batch_first=False`` or\n          :math:`(N, L, D * H_{out})` when ``batch_first=True`` containing the output features\n          `(h_t)` from the last layer of the LSTM, for each `t`. If a\n          :class:`torch.nn.utils.rnn.PackedSequence` has been given as the input, the output\n          will also be a packed sequence. When ``bidirectional=True``, `output` will contain\n          a concatenation of the forward and reverse hidden states at each time step in the sequence.\n        * **h_n**: tensor of shape :math:`(D * \\text{num\\_layers}, H_{out})` for unbatched input or\n          :math:`(D * \\text{num\\_layers}, N, H_{out})` containing the\n          final hidden state for each element in the sequence. When ``bidirectional=True``,\n          `h_n` will contain a concatenation of the final forward and reverse hidden states, respectively.\n        * **c_n**: tensor of shape :math:`(D * \\text{num\\_layers}, H_{cell})` for unbatched input or\n          :math:`(D * \\text{num\\_layers}, N, H_{cell})` containing the\n          final cell state for each element in the sequence. When ``bidirectional=True``,\n          `c_n` will contain a concatenation of the final forward and reverse cell states, respectively.\n\n    Attributes:\n        weight_ih_l[k] : the learnable input-hidden weights of the :math:`\\text{k}^{th}` layer\n            `(W_ii|W_if|W_ig|W_io)`, of shape `(4*hidden_size, input_size)` for `k = 0`.\n            Otherwise, the shape is `(4*hidden_size, num_directions * hidden_size)`. If\n            ``proj_size > 0`` was specified, the shape will be\n            `(4*hidden_size, num_directions * proj_size)` for `k > 0`\n        weight_hh_l[k] : the learnable hidden-hidden weights of the :math:`\\text{k}^{th}` layer\n            `(W_hi|W_hf|W_hg|W_ho)`, of shape `(4*hidden_size, hidden_size)`. If ``proj_size > 0``\n            was specified, the shape will be `(4*hidden_size, proj_size)`.\n        bias_ih_l[k] : the learnable input-hidden bias of the :math:`\\text{k}^{th}` layer\n            `(b_ii|b_if|b_ig|b_io)`, of shape `(4*hidden_size)`\n        bias_hh_l[k] : the learnable hidden-hidden bias of the :math:`\\text{k}^{th}` layer\n            `(b_hi|b_hf|b_hg|b_ho)`, of shape `(4*hidden_size)`\n        weight_hr_l[k] : the learnable projection weights of the :math:`\\text{k}^{th}` layer\n            of shape `(proj_size, hidden_size)`. Only present when ``proj_size > 0`` was\n            specified.\n        weight_ih_l[k]_reverse: Analogous to `weight_ih_l[k]` for the reverse direction.\n            Only present when ``bidirectional=True``.\n        weight_hh_l[k]_reverse:  Analogous to `weight_hh_l[k]` for the reverse direction.\n            Only present when ``bidirectional=True``.\n        bias_ih_l[k]_reverse:  Analogous to `bias_ih_l[k]` for the reverse direction.\n            Only present when ``bidirectional=True``.\n        bias_hh_l[k]_reverse:  Analogous to `bias_hh_l[k]` for the reverse direction.\n            Only present when ``bidirectional=True``.\n        weight_hr_l[k]_reverse:  Analogous to `weight_hr_l[k]` for the reverse direction.\n            Only present when ``bidirectional=True`` and ``proj_size > 0`` was specified.\n\n    .. note::\n        All the weights and biases are initialized from :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})`\n        where :math:`k = \\frac{1}{\\text{hidden\\_size}}`\n\n    .. note::\n        For bidirectional LSTMs, forward and backward are directions 0 and 1 respectively.\n        Example of splitting the output layers when ``batch_first=False``:\n        ``output.view(seq_len, batch, num_directions, hidden_size)``.\n\n    .. note::\n        For bidirectional LSTMs, `h_n` is not equivalent to the last element of `output`; the\n        former contains the final forward and reverse hidden states, while the latter contains the\n        final forward hidden state and the initial reverse hidden state.\n\n    .. note::\n        ``batch_first`` argument is ignored for unbatched inputs.\n\n    .. include:: ../cudnn_rnn_determinism.rst\n\n    .. include:: ../cudnn_persistent_rnn.rst\n\n    Examples::\n\n        >>> rnn = nn.LSTM(10, 20, 2)\n        >>> input = torch.randn(5, 3, 10)\n        >>> h0 = torch.randn(2, 3, 20)\n        >>> c0 = torch.randn(2, 3, 20)\n        >>> output, (hn, cn) = rnn(input, (h0, c0))\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "*args": {
                          "Type": null,
                          "Default": null
                        },
                        "**kwargs": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "check_forward_args": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "hidden": {
                          "Type": "typing.Tuple[torch.Tensor, torch.Tensor]",
                          "Default": null
                        },
                        "batch_sizes": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": null,
                          "Default": null
                        },
                        "hx": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "get_expected_cell_size": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "batch_sizes": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": null
                        }
                      }
                    },
                    "permute_hidden": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "hx": {
                          "Type": "typing.Tuple[torch.Tensor, torch.Tensor]",
                          "Default": null
                        },
                        "permutation": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "LSTMCell": {
                  "Doc": "A long short-term memory (LSTM) cell.\n\n    .. math::\n\n        \\begin{array}{ll}\n        i = \\sigma(W_{ii} x + b_{ii} + W_{hi} h + b_{hi}) \\\\\n        f = \\sigma(W_{if} x + b_{if} + W_{hf} h + b_{hf}) \\\\\n        g = \\tanh(W_{ig} x + b_{ig} + W_{hg} h + b_{hg}) \\\\\n        o = \\sigma(W_{io} x + b_{io} + W_{ho} h + b_{ho}) \\\\\n        c' = f * c + i * g \\\\\n        h' = o * \\tanh(c') \\\\\n        \\end{array}\n\n    where :math:`\\sigma` is the sigmoid function, and :math:`*` is the Hadamard product.\n\n    Args:\n        input_size: The number of expected features in the input `x`\n        hidden_size: The number of features in the hidden state `h`\n        bias: If ``False``, then the layer does not use bias weights `b_ih` and\n            `b_hh`. Default: ``True``\n\n    Inputs: input, (h_0, c_0)\n        - **input** of shape `(batch, input_size)` or `(input_size)`: tensor containing input features\n        - **h_0** of shape `(batch, hidden_size)` or `(hidden_size)`: tensor containing the initial hidden state\n        - **c_0** of shape `(batch, hidden_size)` or `(hidden_size)`: tensor containing the initial cell state\n\n          If `(h_0, c_0)` is not provided, both **h_0** and **c_0** default to zero.\n\n    Outputs: (h_1, c_1)\n        - **h_1** of shape `(batch, hidden_size)` or `(hidden_size)`: tensor containing the next hidden state\n        - **c_1** of shape `(batch, hidden_size)` or `(hidden_size)`: tensor containing the next cell state\n\n    Attributes:\n        weight_ih: the learnable input-hidden weights, of shape\n            `(4*hidden_size, input_size)`\n        weight_hh: the learnable hidden-hidden weights, of shape\n            `(4*hidden_size, hidden_size)`\n        bias_ih: the learnable input-hidden bias, of shape `(4*hidden_size)`\n        bias_hh: the learnable hidden-hidden bias, of shape `(4*hidden_size)`\n\n    .. note::\n        All the weights and biases are initialized from :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})`\n        where :math:`k = \\frac{1}{\\text{hidden\\_size}}`\n\n    On certain ROCm devices, when using float16 inputs this module will use :ref:`different precision<fp16_on_mi200>` for backward.\n\n    Examples::\n\n        >>> rnn = nn.LSTMCell(10, 20) # (input_size, hidden_size)\n        >>> input = torch.randn(2, 3, 10) # (time_steps, batch, input_size)\n        >>> hx = torch.randn(3, 20) # (batch, hidden_size)\n        >>> cx = torch.randn(3, 20)\n        >>> output = []\n        >>> for i in range(input.size()[0]):\n        ...     hx, cx = rnn(input[i], (hx, cx))\n        ...     output.append(hx)\n        >>> output = torch.stack(output, dim=0)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input_size": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "hidden_size": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "bias": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "hx": {
                          "Type": "typing.Optional[typing.Tuple[torch.Tensor, torch.Tensor]]",
                          "Default": "None"
                        }
                      }
                    }
                  }
                },
                "RNN": {
                  "Doc": "Applies a multi-layer Elman RNN with :math:`\\tanh` or :math:`\\text{ReLU}` non-linearity to an\n    input sequence.\n\n\n    For each element in the input sequence, each layer computes the following\n    function:\n\n    .. math::\n        h_t = \\tanh(x_t W_{ih}^T + b_{ih} + h_{t-1}W_{hh}^T + b_{hh})\n\n    where :math:`h_t` is the hidden state at time `t`, :math:`x_t` is\n    the input at time `t`, and :math:`h_{(t-1)}` is the hidden state of the\n    previous layer at time `t-1` or the initial hidden state at time `0`.\n    If :attr:`nonlinearity` is ``'relu'``, then :math:`\\text{ReLU}` is used instead of :math:`\\tanh`.\n\n    Args:\n        input_size: The number of expected features in the input `x`\n        hidden_size: The number of features in the hidden state `h`\n        num_layers: Number of recurrent layers. E.g., setting ``num_layers=2``\n            would mean stacking two RNNs together to form a `stacked RNN`,\n            with the second RNN taking in outputs of the first RNN and\n            computing the final results. Default: 1\n        nonlinearity: The non-linearity to use. Can be either ``'tanh'`` or ``'relu'``. Default: ``'tanh'``\n        bias: If ``False``, then the layer does not use bias weights `b_ih` and `b_hh`.\n            Default: ``True``\n        batch_first: If ``True``, then the input and output tensors are provided\n            as `(batch, seq, feature)` instead of `(seq, batch, feature)`.\n            Note that this does not apply to hidden or cell states. See the\n            Inputs/Outputs sections below for details.  Default: ``False``\n        dropout: If non-zero, introduces a `Dropout` layer on the outputs of each\n            RNN layer except the last layer, with dropout probability equal to\n            :attr:`dropout`. Default: 0\n        bidirectional: If ``True``, becomes a bidirectional RNN. Default: ``False``\n\n    Inputs: input, h_0\n        * **input**: tensor of shape :math:`(L, H_{in})` for unbatched input,\n          :math:`(L, N, H_{in})` when ``batch_first=False`` or\n          :math:`(N, L, H_{in})` when ``batch_first=True`` containing the features of\n          the input sequence.  The input can also be a packed variable length sequence.\n          See :func:`torch.nn.utils.rnn.pack_padded_sequence` or\n          :func:`torch.nn.utils.rnn.pack_sequence` for details.\n        * **h_0**: tensor of shape :math:`(D * \\text{num\\_layers}, H_{out})` for unbatched input or\n          :math:`(D * \\text{num\\_layers}, N, H_{out})` containing the initial hidden\n          state for the input sequence batch. Defaults to zeros if not provided.\n\n        where:\n\n        .. math::\n            \\begin{aligned}\n                N ={} & \\text{batch size} \\\\\n                L ={} & \\text{sequence length} \\\\\n                D ={} & 2 \\text{ if bidirectional=True otherwise } 1 \\\\\n                H_{in} ={} & \\text{input\\_size} \\\\\n                H_{out} ={} & \\text{hidden\\_size}\n            \\end{aligned}\n\n    Outputs: output, h_n\n        * **output**: tensor of shape :math:`(L, D * H_{out})` for unbatched input,\n          :math:`(L, N, D * H_{out})` when ``batch_first=False`` or\n          :math:`(N, L, D * H_{out})` when ``batch_first=True`` containing the output features\n          `(h_t)` from the last layer of the RNN, for each `t`. If a\n          :class:`torch.nn.utils.rnn.PackedSequence` has been given as the input, the output\n          will also be a packed sequence.\n        * **h_n**: tensor of shape :math:`(D * \\text{num\\_layers}, H_{out})` for unbatched input or\n          :math:`(D * \\text{num\\_layers}, N, H_{out})` containing the final hidden state\n          for each element in the batch.\n\n    Attributes:\n        weight_ih_l[k]: the learnable input-hidden weights of the k-th layer,\n            of shape `(hidden_size, input_size)` for `k = 0`. Otherwise, the shape is\n            `(hidden_size, num_directions * hidden_size)`\n        weight_hh_l[k]: the learnable hidden-hidden weights of the k-th layer,\n            of shape `(hidden_size, hidden_size)`\n        bias_ih_l[k]: the learnable input-hidden bias of the k-th layer,\n            of shape `(hidden_size)`\n        bias_hh_l[k]: the learnable hidden-hidden bias of the k-th layer,\n            of shape `(hidden_size)`\n\n    .. note::\n        All the weights and biases are initialized from :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})`\n        where :math:`k = \\frac{1}{\\text{hidden\\_size}}`\n\n    .. note::\n        For bidirectional RNNs, forward and backward are directions 0 and 1 respectively.\n        Example of splitting the output layers when ``batch_first=False``:\n        ``output.view(seq_len, batch, num_directions, hidden_size)``.\n\n    .. note::\n        ``batch_first`` argument is ignored for unbatched inputs.\n\n    .. include:: ../cudnn_rnn_determinism.rst\n\n    .. include:: ../cudnn_persistent_rnn.rst\n\n    Examples::\n\n        >>> rnn = nn.RNN(10, 20, 2)\n        >>> input = torch.randn(5, 3, 10)\n        >>> h0 = torch.randn(2, 3, 20)\n        >>> output, hn = rnn(input, h0)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "*args": {
                          "Type": null,
                          "Default": null
                        },
                        "**kwargs": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": null,
                          "Default": null
                        },
                        "hx": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    }
                  }
                },
                "RNNBase": {
                  "Doc": null,
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "mode": {
                          "Type": "<class 'str'>",
                          "Default": null
                        },
                        "input_size": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "hidden_size": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "num_layers": {
                          "Type": "<class 'int'>",
                          "Default": "1"
                        },
                        "bias": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "batch_first": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "dropout": {
                          "Type": "<class 'float'>",
                          "Default": "0.0"
                        },
                        "bidirectional": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "proj_size": {
                          "Type": "<class 'int'>",
                          "Default": "0"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "check_forward_args": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "hidden": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "batch_sizes": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": null
                        }
                      }
                    },
                    "check_hidden_size": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "hx": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "expected_hidden_size": {
                          "Type": "typing.Tuple[int, int, int]",
                          "Default": null
                        },
                        "msg": {
                          "Type": "<class 'str'>",
                          "Default": "Expected hidden size {}, got {}"
                        }
                      }
                    },
                    "check_input": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "batch_sizes": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": null
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "flatten_parameters": {
                      "Doc": "Resets parameter data pointer so that they can use faster code paths.\n\n        Right now, this works only if the module is on the GPU and cuDNN is enabled.\n        Otherwise, it's a no-op.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "get_expected_hidden_size": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "batch_sizes": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": null
                        }
                      }
                    },
                    "permute_hidden": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "hx": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "permutation": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": null
                        }
                      }
                    },
                    "reset_parameters": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "RNNCell": {
                  "Doc": "An Elman RNN cell with tanh or ReLU non-linearity.\n\n    .. math::\n\n        h' = \\tanh(W_{ih} x + b_{ih}  +  W_{hh} h + b_{hh})\n\n    If :attr:`nonlinearity` is `'relu'`, then ReLU is used in place of tanh.\n\n    Args:\n        input_size: The number of expected features in the input `x`\n        hidden_size: The number of features in the hidden state `h`\n        bias: If ``False``, then the layer does not use bias weights `b_ih` and `b_hh`.\n            Default: ``True``\n        nonlinearity: The non-linearity to use. Can be either ``'tanh'`` or ``'relu'``. Default: ``'tanh'``\n\n    Inputs: input, hidden\n        - **input**: tensor containing input features\n        - **hidden**: tensor containing the initial hidden state\n          Defaults to zero if not provided.\n\n    Outputs: h'\n        - **h'** of shape `(batch, hidden_size)`: tensor containing the next hidden state\n          for each element in the batch\n\n    Shape:\n        - input: :math:`(N, H_{in})` or :math:`(H_{in})` tensor containing input features where\n          :math:`H_{in}` = `input_size`.\n        - hidden: :math:`(N, H_{out})` or :math:`(H_{out})` tensor containing the initial hidden\n          state where :math:`H_{out}` = `hidden_size`. Defaults to zero if not provided.\n        - output: :math:`(N, H_{out})` or :math:`(H_{out})` tensor containing the next hidden state.\n\n    Attributes:\n        weight_ih: the learnable input-hidden weights, of shape\n            `(hidden_size, input_size)`\n        weight_hh: the learnable hidden-hidden weights, of shape\n            `(hidden_size, hidden_size)`\n        bias_ih: the learnable input-hidden bias, of shape `(hidden_size)`\n        bias_hh: the learnable hidden-hidden bias, of shape `(hidden_size)`\n\n    .. note::\n        All the weights and biases are initialized from :math:`\\mathcal{U}(-\\sqrt{k}, \\sqrt{k})`\n        where :math:`k = \\frac{1}{\\text{hidden\\_size}}`\n\n    Examples::\n\n        >>> rnn = nn.RNNCell(10, 20)\n        >>> input = torch.randn(6, 3, 10)\n        >>> hx = torch.randn(3, 20)\n        >>> output = []\n        >>> for i in range(6):\n        ...     hx = rnn(input[i], hx)\n        ...     output.append(hx)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input_size": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "hidden_size": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "bias": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "nonlinearity": {
                          "Type": "<class 'str'>",
                          "Default": "tanh"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "hx": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        }
                      }
                    }
                  }
                },
                "RNNCellBase": {
                  "Doc": null,
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input_size": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "hidden_size": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "bias": {
                          "Type": "<class 'bool'>",
                          "Default": null
                        },
                        "num_chunks": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "reset_parameters": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    }
                  }
                }
              },
              "Functions": {
                "apply_permutation": {
                  "Doc": null,
                  "Args": {
                    "tensor": {
                      "Type": "<class 'torch.Tensor'>",
                      "Default": null
                    },
                    "permutation": {
                      "Type": "<class 'torch.Tensor'>",
                      "Default": null
                    },
                    "dim": {
                      "Type": "<class 'int'>",
                      "Default": "1"
                    }
                  }
                },
                "overload": {
                  "Doc": "Decorator for overloaded functions/methods.\n\n    In a stub file, place two or more stub definitions for the same\n    function in a row, each decorated with @overload.  For example:\n\n      @overload\n      def utf8(value: None) -> None: ...\n      @overload\n      def utf8(value: bytes) -> bytes: ...\n      @overload\n      def utf8(value: str) -> bytes: ...\n\n    In a non-stub file (i.e. a regular .py file), do the same but\n    follow it with an implementation.  The implementation should *not*\n    be decorated with @overload.  For example:\n\n      @overload\n      def utf8(value: None) -> None: ...\n      @overload\n      def utf8(value: bytes) -> bytes: ...\n      @overload\n      def utf8(value: str) -> bytes: ...\n      def utf8(value):\n          # implementation goes here\n    ",
                  "Args": {
                    "func": {
                      "Type": null,
                      "Default": null
                    }
                  }
                }
              }
            },
            "sparse": {
              "Doc": null,
              "Classes": {
                "Embedding": {
                  "Doc": "A simple lookup table that stores embeddings of a fixed dictionary and size.\n\n    This module is often used to store word embeddings and retrieve them using indices.\n    The input to the module is a list of indices, and the output is the corresponding\n    word embeddings.\n\n    Args:\n        num_embeddings (int): size of the dictionary of embeddings\n        embedding_dim (int): the size of each embedding vector\n        padding_idx (int, optional): If specified, the entries at :attr:`padding_idx` do not contribute to the gradient;\n                                     therefore, the embedding vector at :attr:`padding_idx` is not updated during training,\n                                     i.e. it remains as a fixed \"pad\". For a newly constructed Embedding,\n                                     the embedding vector at :attr:`padding_idx` will default to all zeros,\n                                     but can be updated to another value to be used as the padding vector.\n        max_norm (float, optional): If given, each embedding vector with norm larger than :attr:`max_norm`\n                                    is renormalized to have norm :attr:`max_norm`.\n        norm_type (float, optional): The p of the p-norm to compute for the :attr:`max_norm` option. Default ``2``.\n        scale_grad_by_freq (bool, optional): If given, this will scale gradients by the inverse of frequency of\n                                                the words in the mini-batch. Default ``False``.\n        sparse (bool, optional): If ``True``, gradient w.r.t. :attr:`weight` matrix will be a sparse tensor.\n                                 See Notes for more details regarding sparse gradients.\n\n    Attributes:\n        weight (Tensor): the learnable weights of the module of shape (num_embeddings, embedding_dim)\n                         initialized from :math:`\\mathcal{N}(0, 1)`\n\n    Shape:\n        - Input: :math:`(*)`, IntTensor or LongTensor of arbitrary shape containing the indices to extract\n        - Output: :math:`(*, H)`, where `*` is the input shape and :math:`H=\\text{embedding\\_dim}`\n\n    .. note::\n        Keep in mind that only a limited number of optimizers support\n        sparse gradients: currently it's :class:`optim.SGD` (`CUDA` and `CPU`),\n        :class:`optim.SparseAdam` (`CUDA` and `CPU`) and :class:`optim.Adagrad` (`CPU`)\n\n    .. note::\n        When :attr:`max_norm` is not ``None``, :class:`Embedding`'s forward method will modify the\n        :attr:`weight` tensor in-place. Since tensors needed for gradient computations cannot be\n        modified in-place, performing a differentiable operation on ``Embedding.weight`` before\n        calling :class:`Embedding`'s forward method requires cloning ``Embedding.weight`` when\n        :attr:`max_norm` is not ``None``. For example::\n\n            n, d, m = 3, 5, 7\n            embedding = nn.Embedding(n, d, max_norm=True)\n            W = torch.randn((m, d), requires_grad=True)\n            idx = torch.tensor([1, 2])\n            a = embedding.weight.clone() @ W.t()  # weight must be cloned for this to be differentiable\n            b = embedding(idx) @ W.t()  # modifies weight in-place\n            out = (a.unsqueeze(0) + b.unsqueeze(1))\n            loss = out.sigmoid().prod()\n            loss.backward()\n\n    Examples::\n\n        >>> # an Embedding module containing 10 tensors of size 3\n        >>> embedding = nn.Embedding(10, 3)\n        >>> # a batch of 2 samples of 4 indices each\n        >>> input = torch.LongTensor([[1,2,4,5],[4,3,2,9]])\n        >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\")\n        >>> embedding(input)\n        tensor([[[-0.0251, -1.6902,  0.7172],\n                 [-0.6431,  0.0748,  0.6969],\n                 [ 1.4970,  1.3448, -0.9685],\n                 [-0.3677, -2.7265, -0.1685]],\n\n                [[ 1.4970,  1.3448, -0.9685],\n                 [ 0.4362, -0.4004,  0.9400],\n                 [-0.6431,  0.0748,  0.6969],\n                 [ 0.9124, -2.3616,  1.1151]]])\n\n\n        >>> # example with padding_idx\n        >>> embedding = nn.Embedding(10, 3, padding_idx=0)\n        >>> input = torch.LongTensor([[0,2,0,5]])\n        >>> embedding(input)\n        tensor([[[ 0.0000,  0.0000,  0.0000],\n                 [ 0.1535, -2.0309,  0.9315],\n                 [ 0.0000,  0.0000,  0.0000],\n                 [-0.1655,  0.9897,  0.0635]]])\n\n        >>> # example of changing `pad` vector\n        >>> padding_idx = 0\n        >>> embedding = nn.Embedding(3, 3, padding_idx=padding_idx)\n        >>> embedding.weight\n        Parameter containing:\n        tensor([[ 0.0000,  0.0000,  0.0000],\n                [-0.7895, -0.7089, -0.0364],\n                [ 0.6778,  0.5803,  0.2678]], requires_grad=True)\n        >>> with torch.no_grad():\n        ...     embedding.weight[padding_idx] = torch.ones(3)\n        >>> embedding.weight\n        Parameter containing:\n        tensor([[ 1.0000,  1.0000,  1.0000],\n                [-0.7895, -0.7089, -0.0364],\n                [ 0.6778,  0.5803,  0.2678]], requires_grad=True)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "num_embeddings": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "embedding_dim": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "padding_idx": {
                          "Type": "typing.Optional[int]",
                          "Default": "None"
                        },
                        "max_norm": {
                          "Type": "typing.Optional[float]",
                          "Default": "None"
                        },
                        "norm_type": {
                          "Type": "<class 'float'>",
                          "Default": "2.0"
                        },
                        "scale_grad_by_freq": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "sparse": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "_weight": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    },
                    "from_pretrained": {
                      "Doc": "Creates Embedding instance from given 2-dimensional FloatTensor.\n\n        Args:\n            embeddings (Tensor): FloatTensor containing weights for the Embedding.\n                First dimension is being passed to Embedding as ``num_embeddings``, second as ``embedding_dim``.\n            freeze (bool, optional): If ``True``, the tensor does not get updated in the learning process.\n                Equivalent to ``embedding.weight.requires_grad = False``. Default: ``True``\n            padding_idx (int, optional): If specified, the entries at :attr:`padding_idx` do not contribute to the gradient;\n                                         therefore, the embedding vector at :attr:`padding_idx` is not updated during training,\n                                         i.e. it remains as a fixed \"pad\".\n            max_norm (float, optional): See module initialization documentation.\n            norm_type (float, optional): See module initialization documentation. Default ``2``.\n            scale_grad_by_freq (bool, optional): See module initialization documentation. Default ``False``.\n            sparse (bool, optional): See module initialization documentation.\n\n        Examples::\n\n            >>> # FloatTensor containing pretrained weights\n            >>> weight = torch.FloatTensor([[1, 2.3, 3], [4, 5.1, 6.3]])\n            >>> embedding = nn.Embedding.from_pretrained(weight)\n            >>> # Get embeddings for index 1\n            >>> input = torch.LongTensor([1])\n            >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\")\n            >>> embedding(input)\n            tensor([[ 4.0000,  5.1000,  6.3000]])\n        ",
                      "Args": {
                        "cls": {
                          "Type": null,
                          "Default": null
                        },
                        "embeddings": {
                          "Type": null,
                          "Default": null
                        },
                        "freeze": {
                          "Type": null,
                          "Default": "True"
                        },
                        "padding_idx": {
                          "Type": null,
                          "Default": "None"
                        },
                        "max_norm": {
                          "Type": null,
                          "Default": "None"
                        },
                        "norm_type": {
                          "Type": null,
                          "Default": "2.0"
                        },
                        "scale_grad_by_freq": {
                          "Type": null,
                          "Default": "False"
                        },
                        "sparse": {
                          "Type": null,
                          "Default": "False"
                        }
                      }
                    },
                    "reset_parameters": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "EmbeddingBag": {
                  "Doc": "Computes sums or means of 'bags' of embeddings, without instantiating the\n    intermediate embeddings.\n\n    For bags of constant length, no :attr:`per_sample_weights`, no indices equal to :attr:`padding_idx`,\n    and with 2D inputs, this class\n\n        * with ``mode=\"sum\"`` is equivalent to :class:`~torch.nn.Embedding` followed by ``torch.sum(dim=1)``,\n        * with ``mode=\"mean\"`` is equivalent to :class:`~torch.nn.Embedding` followed by ``torch.mean(dim=1)``,\n        * with ``mode=\"max\"`` is equivalent to :class:`~torch.nn.Embedding` followed by ``torch.max(dim=1)``.\n\n    However, :class:`~torch.nn.EmbeddingBag` is much more time and memory efficient than using a chain of these\n    operations.\n\n    EmbeddingBag also supports per-sample weights as an argument to the forward\n    pass. This scales the output of the Embedding before performing a weighted\n    reduction as specified by ``mode``. If :attr:`per_sample_weights` is passed, the\n    only supported ``mode`` is ``\"sum\"``, which computes a weighted sum according to\n    :attr:`per_sample_weights`.\n\n    Args:\n        num_embeddings (int): size of the dictionary of embeddings\n        embedding_dim (int): the size of each embedding vector\n        max_norm (float, optional): If given, each embedding vector with norm larger than :attr:`max_norm`\n                                    is renormalized to have norm :attr:`max_norm`.\n        norm_type (float, optional): The p of the p-norm to compute for the :attr:`max_norm` option. Default ``2``.\n        scale_grad_by_freq (bool, optional): if given, this will scale gradients by the inverse of frequency of\n                                                the words in the mini-batch. Default ``False``.\n                                                Note: this option is not supported when ``mode=\"max\"``.\n        mode (str, optional): ``\"sum\"``, ``\"mean\"`` or ``\"max\"``. Specifies the way to reduce the bag.\n                                 ``\"sum\"`` computes the weighted sum, taking :attr:`per_sample_weights`\n                                 into consideration. ``\"mean\"`` computes the average of the values\n                                 in the bag, ``\"max\"`` computes the max value over each bag.\n                                 Default: ``\"mean\"``\n        sparse (bool, optional): if ``True``, gradient w.r.t. :attr:`weight` matrix will be a sparse tensor. See\n                                 Notes for more details regarding sparse gradients. Note: this option is not\n                                 supported when ``mode=\"max\"``.\n        include_last_offset (bool, optional): if ``True``, :attr:`offsets` has one additional element, where the last element\n                                      is equivalent to the size of `indices`. This matches the CSR format.\n        padding_idx (int, optional): If specified, the entries at :attr:`padding_idx` do not contribute to the\n                                     gradient; therefore, the embedding vector at :attr:`padding_idx` is not updated\n                                     during training, i.e. it remains as a fixed \"pad\". For a newly constructed\n                                     EmbeddingBag, the embedding vector at :attr:`padding_idx` will default to all\n                                     zeros, but can be updated to another value to be used as the padding vector.\n                                     Note that the embedding vector at :attr:`padding_idx` is excluded from the\n                                     reduction.\n\n    Attributes:\n        weight (Tensor): the learnable weights of the module of shape `(num_embeddings, embedding_dim)`\n                         initialized from :math:`\\mathcal{N}(0, 1)`.\n\n    Examples::\n\n        >>> # an EmbeddingBag module containing 10 tensors of size 3\n        >>> embedding_sum = nn.EmbeddingBag(10, 3, mode='sum')\n        >>> # a batch of 2 samples of 4 indices each\n        >>> input = torch.tensor([1,2,4,5,4,3,2,9], dtype=torch.long)\n        >>> offsets = torch.tensor([0,4], dtype=torch.long)\n        >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\")\n        >>> embedding_sum(input, offsets)\n        tensor([[-0.8861, -5.4350, -0.0523],\n                [ 1.1306, -2.5798, -1.0044]])\n\n        >>> # Example with padding_idx\n        >>> embedding_sum = nn.EmbeddingBag(10, 3, mode='sum', padding_idx=2)\n        >>> input = torch.tensor([2, 2, 2, 2, 4, 3, 2, 9], dtype=torch.long)\n        >>> offsets = torch.tensor([0,4], dtype=torch.long)\n        >>> embedding_sum(input, offsets)\n        tensor([[ 0.0000,  0.0000,  0.0000],\n                [-0.7082,  3.2145, -2.6251]])\n\n        >>> # An EmbeddingBag can be loaded from an Embedding like so\n        >>> embedding = nn.Embedding(10, 3, padding_idx=2)\n        >>> embedding_sum = nn.EmbeddingBag.from_pretrained(\n                embedding.weight,\n                padding_idx=embedding.padding_idx,\n                mode='sum')\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "num_embeddings": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "embedding_dim": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "max_norm": {
                          "Type": "typing.Optional[float]",
                          "Default": "None"
                        },
                        "norm_type": {
                          "Type": "<class 'float'>",
                          "Default": "2.0"
                        },
                        "scale_grad_by_freq": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "mode": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        },
                        "sparse": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "_weight": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "include_last_offset": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "padding_idx": {
                          "Type": "typing.Optional[int]",
                          "Default": "None"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": "Forward pass of EmbeddingBag.\n\n        Args:\n            input (Tensor): Tensor containing bags of indices into the embedding matrix.\n            offsets (Tensor, optional): Only used when :attr:`input` is 1D. :attr:`offsets` determines\n                the starting index position of each bag (sequence) in :attr:`input`.\n            per_sample_weights (Tensor, optional): a tensor of float / double weights, or None\n                to indicate all weights should be taken to be ``1``. If specified, :attr:`per_sample_weights`\n                must have exactly the same shape as input and is treated as having the same\n                :attr:`offsets`, if those are not ``None``. Only supported for ``mode='sum'``.\n\n        Returns:\n            Tensor output shape of `(B, embedding_dim)`.\n\n        .. note::\n\n            A few notes about ``input`` and ``offsets``:\n\n            - :attr:`input` and :attr:`offsets` have to be of the same type, either int or long\n\n            - If :attr:`input` is 2D of shape `(B, N)`, it will be treated as ``B`` bags (sequences)\n              each of fixed length ``N``, and this will return ``B`` values aggregated in a way\n              depending on the :attr:`mode`. :attr:`offsets` is ignored and required to be ``None`` in this case.\n\n            - If :attr:`input` is 1D of shape `(N)`, it will be treated as a concatenation of\n              multiple bags (sequences).  :attr:`offsets` is required to be a 1D tensor containing the\n              starting index positions of each bag in :attr:`input`. Therefore, for :attr:`offsets` of shape `(B)`,\n              :attr:`input` will be viewed as having ``B`` bags. Empty bags (i.e., having 0-length) will have\n              returned vectors filled by zeros.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "offsets": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "per_sample_weights": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        }
                      }
                    },
                    "from_pretrained": {
                      "Doc": "Creates EmbeddingBag instance from given 2-dimensional FloatTensor.\n\n        Args:\n            embeddings (Tensor): FloatTensor containing weights for the EmbeddingBag.\n                First dimension is being passed to EmbeddingBag as 'num_embeddings', second as 'embedding_dim'.\n            freeze (bool, optional): If ``True``, the tensor does not get updated in the learning process.\n                Equivalent to ``embeddingbag.weight.requires_grad = False``. Default: ``True``\n            max_norm (float, optional): See module initialization documentation. Default: ``None``\n            norm_type (float, optional): See module initialization documentation. Default ``2``.\n            scale_grad_by_freq (bool, optional): See module initialization documentation. Default ``False``.\n            mode (str, optional): See module initialization documentation. Default: ``\"mean\"``\n            sparse (bool, optional): See module initialization documentation. Default: ``False``.\n            include_last_offset (bool, optional): See module initialization documentation. Default: ``False``.\n            padding_idx (int, optional): See module initialization documentation. Default: ``None``.\n\n        Examples::\n\n            >>> # FloatTensor containing pretrained weights\n            >>> weight = torch.FloatTensor([[1, 2.3, 3], [4, 5.1, 6.3]])\n            >>> embeddingbag = nn.EmbeddingBag.from_pretrained(weight)\n            >>> # Get embeddings for index 1\n            >>> input = torch.LongTensor([[1, 0]])\n            >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\")\n            >>> embeddingbag(input)\n            tensor([[ 2.5000,  3.7000,  4.6500]])\n        ",
                      "Args": {
                        "cls": {
                          "Type": null,
                          "Default": null
                        },
                        "embeddings": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "freeze": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "max_norm": {
                          "Type": "typing.Optional[float]",
                          "Default": "None"
                        },
                        "norm_type": {
                          "Type": "<class 'float'>",
                          "Default": "2.0"
                        },
                        "scale_grad_by_freq": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "mode": {
                          "Type": "<class 'str'>",
                          "Default": "mean"
                        },
                        "sparse": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "include_last_offset": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "padding_idx": {
                          "Type": "typing.Optional[int]",
                          "Default": "None"
                        }
                      }
                    },
                    "reset_parameters": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    }
                  }
                }
              }
            },
            "transformer": {
              "Doc": null,
              "Classes": {
                "Transformer": {
                  "Doc": "A transformer model. User is able to modify the attributes as needed. The architecture\n    is based on the paper \"Attention Is All You Need\". Ashish Vaswani, Noam Shazeer,\n    Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez, Lukasz Kaiser, and\n    Illia Polosukhin. 2017. Attention is all you need. In Advances in Neural Information\n    Processing Systems, pages 6000-6010.\n\n    Args:\n        d_model: the number of expected features in the encoder/decoder inputs (default=512).\n        nhead: the number of heads in the multiheadattention models (default=8).\n        num_encoder_layers: the number of sub-encoder-layers in the encoder (default=6).\n        num_decoder_layers: the number of sub-decoder-layers in the decoder (default=6).\n        dim_feedforward: the dimension of the feedforward network model (default=2048).\n        dropout: the dropout value (default=0.1).\n        activation: the activation function of encoder/decoder intermediate layer, can be a string\n            (\"relu\" or \"gelu\") or a unary callable. Default: relu\n        custom_encoder: custom encoder (default=None).\n        custom_decoder: custom decoder (default=None).\n        layer_norm_eps: the eps value in layer normalization components (default=1e-5).\n        batch_first: If ``True``, then the input and output tensors are provided\n            as (batch, seq, feature). Default: ``False`` (seq, batch, feature).\n        norm_first: if ``True``, encoder and decoder layers will perform LayerNorms before\n            other attention and feedforward operations, otherwise after. Default: ``False`` (after).\n\n    Examples::\n        >>> transformer_model = nn.Transformer(nhead=16, num_encoder_layers=12)\n        >>> src = torch.rand((10, 32, 512))\n        >>> tgt = torch.rand((20, 32, 512))\n        >>> out = transformer_model(src, tgt)\n\n    Note: A full example to apply nn.Transformer module for the word language model is available in\n    https://github.com/pytorch/examples/tree/master/word_language_model\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "d_model": {
                          "Type": "<class 'int'>",
                          "Default": "512"
                        },
                        "nhead": {
                          "Type": "<class 'int'>",
                          "Default": "8"
                        },
                        "num_encoder_layers": {
                          "Type": "<class 'int'>",
                          "Default": "6"
                        },
                        "num_decoder_layers": {
                          "Type": "<class 'int'>",
                          "Default": "6"
                        },
                        "dim_feedforward": {
                          "Type": "<class 'int'>",
                          "Default": "2048"
                        },
                        "dropout": {
                          "Type": "<class 'float'>",
                          "Default": "0.1"
                        },
                        "activation": {
                          "Type": "typing.Union[str, typing.Callable[[torch.Tensor], torch.Tensor]]",
                          "Default": "<function relu at 0x0000024A58A265E0>"
                        },
                        "custom_encoder": {
                          "Type": "typing.Optional[typing.Any]",
                          "Default": "None"
                        },
                        "custom_decoder": {
                          "Type": "typing.Optional[typing.Any]",
                          "Default": "None"
                        },
                        "layer_norm_eps": {
                          "Type": "<class 'float'>",
                          "Default": "1e-05"
                        },
                        "batch_first": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "norm_first": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "forward": {
                      "Doc": "Take in and process masked source/target sequences.\n\n        Args:\n            src: the sequence to the encoder (required).\n            tgt: the sequence to the decoder (required).\n            src_mask: the additive mask for the src sequence (optional).\n            tgt_mask: the additive mask for the tgt sequence (optional).\n            memory_mask: the additive mask for the encoder output (optional).\n            src_key_padding_mask: the ByteTensor mask for src keys per batch (optional).\n            tgt_key_padding_mask: the ByteTensor mask for tgt keys per batch (optional).\n            memory_key_padding_mask: the ByteTensor mask for memory keys per batch (optional).\n\n        Shape:\n            - src: :math:`(S, E)` for unbatched input, :math:`(S, N, E)` if `batch_first=False` or\n              `(N, S, E)` if `batch_first=True`.\n            - tgt: :math:`(T, E)` for unbatched input, :math:`(T, N, E)` if `batch_first=False` or\n              `(N, T, E)` if `batch_first=True`.\n            - src_mask: :math:`(S, S)` or :math:`(N\\cdot\\text{num\\_heads}, S, S)`.\n            - tgt_mask: :math:`(T, T)` or :math:`(N\\cdot\\text{num\\_heads}, T, T)`.\n            - memory_mask: :math:`(T, S)`.\n            - src_key_padding_mask: :math:`(S)` for unbatched input otherwise :math:`(N, S)`.\n            - tgt_key_padding_mask: :math:`(T)` for unbatched input otherwise :math:`(N, T)`.\n            - memory_key_padding_mask: :math:`(S)` for unbatched input otherwise :math:`(N, S)`.\n\n            Note: [src/tgt/memory]_mask ensures that position i is allowed to attend the unmasked\n            positions. If a ByteTensor is provided, the non-zero positions are not allowed to attend\n            while the zero positions will be unchanged. If a BoolTensor is provided, positions with ``True``\n            are not allowed to attend while ``False`` values will be unchanged. If a FloatTensor\n            is provided, it will be added to the attention weight.\n            [src/tgt/memory]_key_padding_mask provides specified elements in the key to be ignored by\n            the attention. If a ByteTensor is provided, the non-zero positions will be ignored while the zero\n            positions will be unchanged. If a BoolTensor is provided, the positions with the\n            value of ``True`` will be ignored while the position with the value of ``False`` will be unchanged.\n\n            - output: :math:`(T, E)` for unbatched input, :math:`(T, N, E)` if `batch_first=False` or\n              `(N, T, E)` if `batch_first=True`.\n\n            Note: Due to the multi-head attention architecture in the transformer model,\n            the output sequence length of a transformer is same as the input sequence\n            (i.e. target) length of the decoder.\n\n            where S is the source sequence length, T is the target sequence length, N is the\n            batch size, E is the feature number\n\n        Examples:\n            >>> # xdoctest: +SKIP\n            >>> output = transformer_model(src, tgt, src_mask=src_mask, tgt_mask=tgt_mask)\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "src": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "tgt": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "src_mask": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "tgt_mask": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "memory_mask": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "src_key_padding_mask": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "tgt_key_padding_mask": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "memory_key_padding_mask": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        }
                      }
                    },
                    "generate_square_subsequent_mask": {
                      "Doc": "Generate a square mask for the sequence. The masked positions are filled with float('-inf').\n            Unmasked positions are filled with float(0.0).\n        ",
                      "Args": {
                        "sz": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "device": {
                          "Type": null,
                          "Default": "cpu"
                        }
                      }
                    }
                  }
                },
                "TransformerDecoder": {
                  "Doc": "TransformerDecoder is a stack of N decoder layers\n\n    Args:\n        decoder_layer: an instance of the TransformerDecoderLayer() class (required).\n        num_layers: the number of sub-decoder-layers in the decoder (required).\n        norm: the layer normalization component (optional).\n\n    Examples::\n        >>> decoder_layer = nn.TransformerDecoderLayer(d_model=512, nhead=8)\n        >>> transformer_decoder = nn.TransformerDecoder(decoder_layer, num_layers=6)\n        >>> memory = torch.rand(10, 32, 512)\n        >>> tgt = torch.rand(20, 32, 512)\n        >>> out = transformer_decoder(tgt, memory)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "decoder_layer": {
                          "Type": null,
                          "Default": null
                        },
                        "num_layers": {
                          "Type": null,
                          "Default": null
                        },
                        "norm": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "forward": {
                      "Doc": "Pass the inputs (and mask) through the decoder layer in turn.\n\n        Args:\n            tgt: the sequence to the decoder (required).\n            memory: the sequence from the last layer of the encoder (required).\n            tgt_mask: the mask for the tgt sequence (optional).\n            memory_mask: the mask for the memory sequence (optional).\n            tgt_key_padding_mask: the mask for the tgt keys per batch (optional).\n            memory_key_padding_mask: the mask for the memory keys per batch (optional).\n\n        Shape:\n            see the docs in Transformer class.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "tgt": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "memory": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "tgt_mask": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "memory_mask": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "tgt_key_padding_mask": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "memory_key_padding_mask": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        }
                      }
                    }
                  }
                },
                "TransformerDecoderLayer": {
                  "Doc": "TransformerDecoderLayer is made up of self-attn, multi-head-attn and feedforward network.\n    This standard decoder layer is based on the paper \"Attention Is All You Need\".\n    Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez,\n    Lukasz Kaiser, and Illia Polosukhin. 2017. Attention is all you need. In Advances in\n    Neural Information Processing Systems, pages 6000-6010. Users may modify or implement\n    in a different way during application.\n\n    Args:\n        d_model: the number of expected features in the input (required).\n        nhead: the number of heads in the multiheadattention models (required).\n        dim_feedforward: the dimension of the feedforward network model (default=2048).\n        dropout: the dropout value (default=0.1).\n        activation: the activation function of the intermediate layer, can be a string\n            (\"relu\" or \"gelu\") or a unary callable. Default: relu\n        layer_norm_eps: the eps value in layer normalization components (default=1e-5).\n        batch_first: If ``True``, then the input and output tensors are provided\n            as (batch, seq, feature). Default: ``False`` (seq, batch, feature).\n        norm_first: if ``True``, layer norm is done prior to self attention, multihead\n            attention and feedforward operations, respectively. Otherwise it's done after.\n            Default: ``False`` (after).\n\n    Examples::\n        >>> decoder_layer = nn.TransformerDecoderLayer(d_model=512, nhead=8)\n        >>> memory = torch.rand(10, 32, 512)\n        >>> tgt = torch.rand(20, 32, 512)\n        >>> out = decoder_layer(tgt, memory)\n\n    Alternatively, when ``batch_first`` is ``True``:\n        >>> decoder_layer = nn.TransformerDecoderLayer(d_model=512, nhead=8, batch_first=True)\n        >>> memory = torch.rand(32, 10, 512)\n        >>> tgt = torch.rand(32, 20, 512)\n        >>> out = decoder_layer(tgt, memory)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "d_model": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "nhead": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "dim_feedforward": {
                          "Type": "<class 'int'>",
                          "Default": "2048"
                        },
                        "dropout": {
                          "Type": "<class 'float'>",
                          "Default": "0.1"
                        },
                        "activation": {
                          "Type": "typing.Union[str, typing.Callable[[torch.Tensor], torch.Tensor]]",
                          "Default": "<function relu at 0x0000024A58A265E0>"
                        },
                        "layer_norm_eps": {
                          "Type": "<class 'float'>",
                          "Default": "1e-05"
                        },
                        "batch_first": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "norm_first": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "forward": {
                      "Doc": "Pass the inputs (and mask) through the decoder layer.\n\n        Args:\n            tgt: the sequence to the decoder layer (required).\n            memory: the sequence from the last layer of the encoder (required).\n            tgt_mask: the mask for the tgt sequence (optional).\n            memory_mask: the mask for the memory sequence (optional).\n            tgt_key_padding_mask: the mask for the tgt keys per batch (optional).\n            memory_key_padding_mask: the mask for the memory keys per batch (optional).\n\n        Shape:\n            see the docs in Transformer class.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "tgt": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "memory": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "tgt_mask": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "memory_mask": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "tgt_key_padding_mask": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "memory_key_padding_mask": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        }
                      }
                    }
                  }
                },
                "TransformerEncoder": {
                  "Doc": "TransformerEncoder is a stack of N encoder layers. Users can build the\n    BERT(https://arxiv.org/abs/1810.04805) model with corresponding parameters.\n\n    Args:\n        encoder_layer: an instance of the TransformerEncoderLayer() class (required).\n        num_layers: the number of sub-encoder-layers in the encoder (required).\n        norm: the layer normalization component (optional).\n        enable_nested_tensor: if True, input will automatically convert to nested tensor\n            (and convert back on output). This will improve the overall performance of\n            TransformerEncoder when padding rate is high. Default: ``True`` (enabled).\n\n    Examples::\n        >>> encoder_layer = nn.TransformerEncoderLayer(d_model=512, nhead=8)\n        >>> transformer_encoder = nn.TransformerEncoder(encoder_layer, num_layers=6)\n        >>> src = torch.rand(10, 32, 512)\n        >>> out = transformer_encoder(src)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "encoder_layer": {
                          "Type": null,
                          "Default": null
                        },
                        "num_layers": {
                          "Type": null,
                          "Default": null
                        },
                        "norm": {
                          "Type": null,
                          "Default": "None"
                        },
                        "enable_nested_tensor": {
                          "Type": null,
                          "Default": "True"
                        },
                        "mask_check": {
                          "Type": null,
                          "Default": "True"
                        }
                      }
                    },
                    "forward": {
                      "Doc": "Pass the input through the encoder layers in turn.\n\n        Args:\n            src: the sequence to the encoder (required).\n            mask: the mask for the src sequence (optional).\n            src_key_padding_mask: the mask for the src keys per batch (optional).\n\n        Shape:\n            see the docs in Transformer class.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "src": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "mask": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "src_key_padding_mask": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        }
                      }
                    }
                  }
                },
                "TransformerEncoderLayer": {
                  "Doc": "TransformerEncoderLayer is made up of self-attn and feedforward network.\n    This standard encoder layer is based on the paper \"Attention Is All You Need\".\n    Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez,\n    Lukasz Kaiser, and Illia Polosukhin. 2017. Attention is all you need. In Advances in\n    Neural Information Processing Systems, pages 6000-6010. Users may modify or implement\n    in a different way during application.\n\n    Args:\n        d_model: the number of expected features in the input (required).\n        nhead: the number of heads in the multiheadattention models (required).\n        dim_feedforward: the dimension of the feedforward network model (default=2048).\n        dropout: the dropout value (default=0.1).\n        activation: the activation function of the intermediate layer, can be a string\n            (\"relu\" or \"gelu\") or a unary callable. Default: relu\n        layer_norm_eps: the eps value in layer normalization components (default=1e-5).\n        batch_first: If ``True``, then the input and output tensors are provided\n            as (batch, seq, feature). Default: ``False`` (seq, batch, feature).\n        norm_first: if ``True``, layer norm is done prior to attention and feedforward\n            operations, respectively. Otherwise it's done after. Default: ``False`` (after).\n\n    Examples::\n        >>> encoder_layer = nn.TransformerEncoderLayer(d_model=512, nhead=8)\n        >>> src = torch.rand(10, 32, 512)\n        >>> out = encoder_layer(src)\n\n    Alternatively, when ``batch_first`` is ``True``:\n        >>> encoder_layer = nn.TransformerEncoderLayer(d_model=512, nhead=8, batch_first=True)\n        >>> src = torch.rand(32, 10, 512)\n        >>> out = encoder_layer(src)\n\n    Fast path:\n        forward() will use a special optimized implementation if all of the following\n        conditions are met:\n\n        - Either autograd is disabled (using ``torch.inference_mode`` or ``torch.no_grad``) or no tensor\n          argument ``requires_grad``\n        - training is disabled (using ``.eval()``)\n        - batch_first is ``True`` and the input is batched (i.e., ``src.dim() == 3``)\n        - activation is one of: ``\"relu\"``, ``\"gelu\"``, ``torch.functional.relu``, or ``torch.functional.gelu``\n        - at most one of ``src_mask`` and ``src_key_padding_mask`` is passed\n        - if src is a `NestedTensor <https://pytorch.org/docs/stable/nested.html>`_, neither ``src_mask``\n          nor ``src_key_padding_mask`` is passed\n        - the two ``LayerNorm`` instances have a consistent ``eps`` value (this will naturally be the case\n          unless the caller has manually modified one without modifying the other)\n\n        If the optimized implementation is in use, a\n        `NestedTensor <https://pytorch.org/docs/stable/nested.html>`_ can be\n        passed for ``src`` to represent padding more efficiently than using a padding\n        mask. In this case, a `NestedTensor <https://pytorch.org/docs/stable/nested.html>`_ will be\n        returned, and an additional speedup proportional to the fraction of the input that\n        is padding can be expected.\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "d_model": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "nhead": {
                          "Type": "<class 'int'>",
                          "Default": null
                        },
                        "dim_feedforward": {
                          "Type": "<class 'int'>",
                          "Default": "2048"
                        },
                        "dropout": {
                          "Type": "<class 'float'>",
                          "Default": "0.1"
                        },
                        "activation": {
                          "Type": "typing.Union[str, typing.Callable[[torch.Tensor], torch.Tensor]]",
                          "Default": "<function relu at 0x0000024A58A265E0>"
                        },
                        "layer_norm_eps": {
                          "Type": "<class 'float'>",
                          "Default": "1e-05"
                        },
                        "batch_first": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "norm_first": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        },
                        "device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dtype": {
                          "Type": null,
                          "Default": "None"
                        }
                      }
                    },
                    "forward": {
                      "Doc": "Pass the input through the encoder layer.\n\n        Args:\n            src: the sequence to the encoder layer (required).\n            src_mask: the mask for the src sequence (optional).\n            src_key_padding_mask: the mask for the src keys per batch (optional).\n\n        Shape:\n            see the docs in Transformer class.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "src": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        },
                        "src_mask": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        },
                        "src_key_padding_mask": {
                          "Type": "typing.Optional[torch.Tensor]",
                          "Default": "None"
                        }
                      }
                    }
                  }
                }
              }
            },
            "upsampling": {
              "Doc": null,
              "Classes": {
                "Upsample": {
                  "Doc": "Upsamples a given multi-channel 1D (temporal), 2D (spatial) or 3D (volumetric) data.\n\n    The input data is assumed to be of the form\n    `minibatch x channels x [optional depth] x [optional height] x width`.\n    Hence, for spatial inputs, we expect a 4D Tensor and for volumetric inputs, we expect a 5D Tensor.\n\n    The algorithms available for upsampling are nearest neighbor and linear,\n    bilinear, bicubic and trilinear for 3D, 4D and 5D input Tensor,\n    respectively.\n\n    One can either give a :attr:`scale_factor` or the target output :attr:`size` to\n    calculate the output size. (You cannot give both, as it is ambiguous)\n\n    Args:\n        size (int or Tuple[int] or Tuple[int, int] or Tuple[int, int, int], optional):\n            output spatial sizes\n        scale_factor (float or Tuple[float] or Tuple[float, float] or Tuple[float, float, float], optional):\n            multiplier for spatial size. Has to match input size if it is a tuple.\n        mode (str, optional): the upsampling algorithm: one of ``'nearest'``,\n            ``'linear'``, ``'bilinear'``, ``'bicubic'`` and ``'trilinear'``.\n            Default: ``'nearest'``\n        align_corners (bool, optional): if ``True``, the corner pixels of the input\n            and output tensors are aligned, and thus preserving the values at\n            those pixels. This only has effect when :attr:`mode` is\n            ``'linear'``, ``'bilinear'``, ``'bicubic'``, or ``'trilinear'``.\n            Default: ``False``\n        recompute_scale_factor (bool, optional): recompute the scale_factor for use in the\n            interpolation calculation. If `recompute_scale_factor` is ``True``, then\n            `scale_factor` must be passed in and `scale_factor` is used to compute the\n            output `size`. The computed output `size` will be used to infer new scales for\n            the interpolation. Note that when `scale_factor` is floating-point, it may differ\n            from the recomputed `scale_factor` due to rounding and precision issues.\n            If `recompute_scale_factor` is ``False``, then `size` or `scale_factor` will\n            be used directly for interpolation.\n\n    Shape:\n        - Input: :math:`(N, C, W_{in})`, :math:`(N, C, H_{in}, W_{in})` or :math:`(N, C, D_{in}, H_{in}, W_{in})`\n        - Output: :math:`(N, C, W_{out})`, :math:`(N, C, H_{out}, W_{out})`\n          or :math:`(N, C, D_{out}, H_{out}, W_{out})`, where\n\n    .. math::\n        D_{out} = \\left\\lfloor D_{in} \\times \\text{scale\\_factor} \\right\\rfloor\n\n    .. math::\n        H_{out} = \\left\\lfloor H_{in} \\times \\text{scale\\_factor} \\right\\rfloor\n\n    .. math::\n        W_{out} = \\left\\lfloor W_{in} \\times \\text{scale\\_factor} \\right\\rfloor\n\n    .. warning::\n        With ``align_corners = True``, the linearly interpolating modes\n        (`linear`, `bilinear`, `bicubic`, and `trilinear`) don't proportionally\n        align the output and input pixels, and thus the output values can depend\n        on the input size. This was the default behavior for these modes up to\n        version 0.3.1. Since then, the default behavior is\n        ``align_corners = False``. See below for concrete examples on how this\n        affects the outputs.\n\n    .. note::\n        If you want downsampling/general resizing, you should use :func:`~nn.functional.interpolate`.\n\n    Examples::\n\n        >>> input = torch.arange(1, 5, dtype=torch.float32).view(1, 1, 2, 2)\n        >>> input\n        tensor([[[[1., 2.],\n                  [3., 4.]]]])\n\n        >>> m = nn.Upsample(scale_factor=2, mode='nearest')\n        >>> m(input)\n        tensor([[[[1., 1., 2., 2.],\n                  [1., 1., 2., 2.],\n                  [3., 3., 4., 4.],\n                  [3., 3., 4., 4.]]]])\n\n        >>> # xdoctest: +IGNORE_WANT(\"other tests seem to modify printing styles\")\n        >>> m = nn.Upsample(scale_factor=2, mode='bilinear')  # align_corners=False\n        >>> m(input)\n        tensor([[[[1.0000, 1.2500, 1.7500, 2.0000],\n                  [1.5000, 1.7500, 2.2500, 2.5000],\n                  [2.5000, 2.7500, 3.2500, 3.5000],\n                  [3.0000, 3.2500, 3.7500, 4.0000]]]])\n\n        >>> m = nn.Upsample(scale_factor=2, mode='bilinear', align_corners=True)\n        >>> m(input)\n        tensor([[[[1.0000, 1.3333, 1.6667, 2.0000],\n                  [1.6667, 2.0000, 2.3333, 2.6667],\n                  [2.3333, 2.6667, 3.0000, 3.3333],\n                  [3.0000, 3.3333, 3.6667, 4.0000]]]])\n\n        >>> # Try scaling the same data in a larger tensor\n        >>> input_3x3 = torch.zeros(3, 3).view(1, 1, 3, 3)\n        >>> input_3x3[:, :, :2, :2].copy_(input)\n        tensor([[[[1., 2.],\n                  [3., 4.]]]])\n        >>> input_3x3\n        tensor([[[[1., 2., 0.],\n                  [3., 4., 0.],\n                  [0., 0., 0.]]]])\n\n        >>> # xdoctest: +IGNORE_WANT(\"seems to fail when other tests are run in the same session\")\n        >>> m = nn.Upsample(scale_factor=2, mode='bilinear')  # align_corners=False\n        >>> # Notice that values in top left corner are the same with the small input (except at boundary)\n        >>> m(input_3x3)\n        tensor([[[[1.0000, 1.2500, 1.7500, 1.5000, 0.5000, 0.0000],\n                  [1.5000, 1.7500, 2.2500, 1.8750, 0.6250, 0.0000],\n                  [2.5000, 2.7500, 3.2500, 2.6250, 0.8750, 0.0000],\n                  [2.2500, 2.4375, 2.8125, 2.2500, 0.7500, 0.0000],\n                  [0.7500, 0.8125, 0.9375, 0.7500, 0.2500, 0.0000],\n                  [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000]]]])\n\n        >>> m = nn.Upsample(scale_factor=2, mode='bilinear', align_corners=True)\n        >>> # Notice that values in top left corner are now changed\n        >>> m(input_3x3)\n        tensor([[[[1.0000, 1.4000, 1.8000, 1.6000, 0.8000, 0.0000],\n                  [1.8000, 2.2000, 2.6000, 2.2400, 1.1200, 0.0000],\n                  [2.6000, 3.0000, 3.4000, 2.8800, 1.4400, 0.0000],\n                  [2.4000, 2.7200, 3.0400, 2.5600, 1.2800, 0.0000],\n                  [1.2000, 1.3600, 1.5200, 1.2800, 0.6400, 0.0000],\n                  [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000]]]])\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "size": {
                          "Type": "typing.Union[int, typing.Tuple[int, ...], NoneType]",
                          "Default": "None"
                        },
                        "scale_factor": {
                          "Type": "typing.Union[float, typing.Tuple[float, ...], NoneType]",
                          "Default": "None"
                        },
                        "mode": {
                          "Type": "<class 'str'>",
                          "Default": "nearest"
                        },
                        "align_corners": {
                          "Type": "typing.Optional[bool]",
                          "Default": "None"
                        },
                        "recompute_scale_factor": {
                          "Type": "typing.Optional[bool]",
                          "Default": "None"
                        }
                      }
                    },
                    "extra_repr": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "input": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                },
                "UpsamplingBilinear2d": {
                  "Doc": "Applies a 2D bilinear upsampling to an input signal composed of several input\n    channels.\n\n    To specify the scale, it takes either the :attr:`size` or the :attr:`scale_factor`\n    as it's constructor argument.\n\n    When :attr:`size` is given, it is the output size of the image `(h, w)`.\n\n    Args:\n        size (int or Tuple[int, int], optional): output spatial sizes\n        scale_factor (float or Tuple[float, float], optional): multiplier for\n            spatial size.\n\n    .. warning::\n        This class is deprecated in favor of :func:`~nn.functional.interpolate`. It is\n        equivalent to ``nn.functional.interpolate(..., mode='bilinear', align_corners=True)``.\n\n    Shape:\n        - Input: :math:`(N, C, H_{in}, W_{in})`\n        - Output: :math:`(N, C, H_{out}, W_{out})` where\n\n    .. math::\n        H_{out} = \\left\\lfloor H_{in} \\times \\text{scale\\_factor} \\right\\rfloor\n\n    .. math::\n        W_{out} = \\left\\lfloor W_{in} \\times \\text{scale\\_factor} \\right\\rfloor\n\n    Examples::\n\n        >>> input = torch.arange(1, 5, dtype=torch.float32).view(1, 1, 2, 2)\n        >>> input\n        tensor([[[[1., 2.],\n                  [3., 4.]]]])\n\n        >>> # xdoctest: +IGNORE_WANT(\"do other tests modify the global state?\")\n        >>> m = nn.UpsamplingBilinear2d(scale_factor=2)\n        >>> m(input)\n        tensor([[[[1.0000, 1.3333, 1.6667, 2.0000],\n                  [1.6667, 2.0000, 2.3333, 2.6667],\n                  [2.3333, 2.6667, 3.0000, 3.3333],\n                  [3.0000, 3.3333, 3.6667, 4.0000]]]])\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "size": {
                          "Type": "typing.Union[int, typing.Tuple[int, int], NoneType]",
                          "Default": "None"
                        },
                        "scale_factor": {
                          "Type": "typing.Union[float, typing.Tuple[float, float], NoneType]",
                          "Default": "None"
                        }
                      }
                    }
                  }
                },
                "UpsamplingNearest2d": {
                  "Doc": "Applies a 2D nearest neighbor upsampling to an input signal composed of several input\n    channels.\n\n    To specify the scale, it takes either the :attr:`size` or the :attr:`scale_factor`\n    as it's constructor argument.\n\n    When :attr:`size` is given, it is the output size of the image `(h, w)`.\n\n    Args:\n        size (int or Tuple[int, int], optional): output spatial sizes\n        scale_factor (float or Tuple[float, float], optional): multiplier for\n            spatial size.\n\n    .. warning::\n        This class is deprecated in favor of :func:`~nn.functional.interpolate`.\n\n    Shape:\n        - Input: :math:`(N, C, H_{in}, W_{in})`\n        - Output: :math:`(N, C, H_{out}, W_{out})` where\n\n    .. math::\n          H_{out} = \\left\\lfloor H_{in} \\times \\text{scale\\_factor} \\right\\rfloor\n\n    .. math::\n          W_{out} = \\left\\lfloor W_{in} \\times \\text{scale\\_factor} \\right\\rfloor\n\n    Examples::\n\n        >>> input = torch.arange(1, 5, dtype=torch.float32).view(1, 1, 2, 2)\n        >>> input\n        tensor([[[[1., 2.],\n                  [3., 4.]]]])\n\n        >>> m = nn.UpsamplingNearest2d(scale_factor=2)\n        >>> m(input)\n        tensor([[[[1., 1., 2., 2.],\n                  [1., 1., 2., 2.],\n                  [3., 3., 4., 4.],\n                  [3., 3., 4., 4.]]]])\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "size": {
                          "Type": "typing.Union[int, typing.Tuple[int, int], NoneType]",
                          "Default": "None"
                        },
                        "scale_factor": {
                          "Type": "typing.Union[float, typing.Tuple[float, float], NoneType]",
                          "Default": "None"
                        }
                      }
                    }
                  }
                }
              }
            },
            "utils": {
              "Doc": null,
              "Functions": {
                "consume_prefix_in_state_dict_if_present": {
                  "Doc": "Strip the prefix in state_dict in place, if any.\n\n    ..note::\n        Given a `state_dict` from a DP/DDP model, a local model can load it by applying\n        `consume_prefix_in_state_dict_if_present(state_dict, \"module.\")` before calling\n        :meth:`torch.nn.Module.load_state_dict`.\n\n    Args:\n        state_dict (OrderedDict): a state-dict to be loaded to the model.\n        prefix (str): prefix.\n    ",
                  "Args": {
                    "state_dict": {
                      "Type": "typing.Dict[str, typing.Any]",
                      "Default": null
                    },
                    "prefix": {
                      "Type": "<class 'str'>",
                      "Default": null
                    }
                  }
                }
              }
            }
          }
        },
        "parallel": {
          "Doc": null,
          "Functions": {
            "DistributedDataParallelCPU": {
              "Doc": null,
              "Args": {
                "*args": {
                  "Type": null,
                  "Default": null
                },
                "**kwargs": {
                  "Type": null,
                  "Default": null
                }
              }
            },
            "data_parallel": {
              "Doc": "Evaluates module(input) in parallel across the GPUs given in device_ids.\n\n    This is the functional version of the DataParallel module.\n\n    Args:\n        module (Module): the module to evaluate in parallel\n        inputs (Tensor): inputs to the module\n        device_ids (list of int or torch.device): GPU ids on which to replicate module\n        output_device (list of int or torch.device): GPU location of the output  Use -1 to indicate the CPU.\n            (default: device_ids[0])\n    Returns:\n        a Tensor containing the result of module(input) located on\n        output_device\n    ",
              "Args": {
                "module": {
                  "Type": null,
                  "Default": null
                },
                "inputs": {
                  "Type": null,
                  "Default": null
                },
                "device_ids": {
                  "Type": null,
                  "Default": "None"
                },
                "output_device": {
                  "Type": null,
                  "Default": "None"
                },
                "dim": {
                  "Type": null,
                  "Default": "0"
                },
                "module_kwargs": {
                  "Type": null,
                  "Default": "None"
                }
              }
            },
            "gather": {
              "Doc": "\n    Gathers tensors from different GPUs on a specified device.\n    Use 'cpu' for CPU to avoid a deprecation warning.\n    ",
              "Args": {
                "outputs": {
                  "Type": null,
                  "Default": null
                },
                "target_device": {
                  "Type": null,
                  "Default": null
                },
                "dim": {
                  "Type": null,
                  "Default": "0"
                }
              }
            },
            "parallel_apply": {
              "Doc": "Applies each `module` in :attr:`modules` in parallel on arguments\n    contained in :attr:`inputs` (positional) and :attr:`kwargs_tup` (keyword)\n    on each of :attr:`devices`.\n\n    Args:\n        modules (Module): modules to be parallelized\n        inputs (tensor): inputs to the modules\n        devices (list of int or torch.device): CUDA devices\n\n    :attr:`modules`, :attr:`inputs`, :attr:`kwargs_tup` (if given), and\n    :attr:`devices` (if given) should all have same length. Moreover, each\n    element of :attr:`inputs` can either be a single object as the only argument\n    to a module, or a collection of positional arguments.\n    ",
              "Args": {
                "modules": {
                  "Type": null,
                  "Default": null
                },
                "inputs": {
                  "Type": null,
                  "Default": null
                },
                "kwargs_tup": {
                  "Type": null,
                  "Default": "None"
                },
                "devices": {
                  "Type": null,
                  "Default": "None"
                }
              }
            },
            "replicate": {
              "Doc": null,
              "Args": {
                "network": {
                  "Type": null,
                  "Default": null
                },
                "devices": {
                  "Type": null,
                  "Default": null
                },
                "detach": {
                  "Type": null,
                  "Default": "False"
                }
              }
            },
            "scatter": {
              "Doc": "\n    Slices tensors into approximately equal chunks and\n    distributes them across given GPUs. Duplicates\n    references to objects that are not tensors.\n    ",
              "Args": {
                "inputs": {
                  "Type": null,
                  "Default": null
                },
                "target_gpus": {
                  "Type": null,
                  "Default": null
                },
                "dim": {
                  "Type": null,
                  "Default": "0"
                }
              }
            }
          },
          "Modules": {
            "comm": {
              "Doc": null,
              "Functions": {
                "broadcast": {
                  "Doc": "Broadcasts a tensor to specified GPU devices.\n\n    Args:\n        tensor (Tensor): tensor to broadcast. Can be on CPU or GPU.\n        devices (Iterable[torch.device, str or int], optional): an iterable of\n          GPU devices, among which to broadcast.\n        out (Sequence[Tensor], optional, keyword-only): the GPU tensors to\n          store output results.\n\n    .. note::\n        Exactly one of :attr:`devices` and :attr:`out` must be specified.\n\n    Returns:\n        - If :attr:`devices` is specified,\n            a tuple containing copies of :attr:`tensor`, placed on\n            :attr:`devices`.\n        - If :attr:`out` is specified,\n            a tuple containing :attr:`out` tensors, each containing a copy of\n            :attr:`tensor`.\n    ",
                  "Args": {
                    "tensor": {
                      "Type": null,
                      "Default": null
                    },
                    "devices": {
                      "Type": null,
                      "Default": "None"
                    },
                    "out": {
                      "Type": null,
                      "Default": "None"
                    }
                  }
                },
                "broadcast_coalesced": {
                  "Doc": "Broadcasts a sequence tensors to the specified GPUs.\n    Small tensors are first coalesced into a buffer to reduce the number\n    of synchronizations.\n\n    Args:\n        tensors (sequence): tensors to broadcast. Must be on the same device,\n          either CPU or GPU.\n        devices (Iterable[torch.device, str or int]): an iterable of GPU\n          devices, among which to broadcast.\n        buffer_size (int): maximum size of the buffer used for coalescing\n\n    Returns:\n        A tuple containing copies of :attr:`tensor`, placed on :attr:`devices`.\n    ",
                  "Args": {
                    "tensors": {
                      "Type": null,
                      "Default": null
                    },
                    "devices": {
                      "Type": null,
                      "Default": null
                    },
                    "buffer_size": {
                      "Type": null,
                      "Default": "10485760"
                    }
                  }
                },
                "gather": {
                  "Doc": "Gathers tensors from multiple GPU devices.\n\n    Args:\n        tensors (Iterable[Tensor]): an iterable of tensors to gather.\n          Tensor sizes in all dimensions other than :attr:`dim` have to match.\n        dim (int, optional): a dimension along which the tensors will be\n          concatenated. Default: ``0``.\n        destination (torch.device, str, or int, optional): the output device.\n          Can be CPU or CUDA. Default: the current CUDA device.\n        out (Tensor, optional, keyword-only): the tensor to store gather result.\n          Its sizes must match those of :attr:`tensors`, except for :attr:`dim`,\n          where the size must equal ``sum(tensor.size(dim) for tensor in tensors)``.\n          Can be on CPU or CUDA.\n\n    .. note::\n        :attr:`destination` must not be specified when :attr:`out` is specified.\n\n    Returns:\n        - If :attr:`destination` is specified,\n            a tensor located on :attr:`destination` device, that is a result of\n            concatenating :attr:`tensors` along :attr:`dim`.\n        - If :attr:`out` is specified,\n            the :attr:`out` tensor, now containing results of concatenating\n            :attr:`tensors` along :attr:`dim`.\n    ",
                  "Args": {
                    "tensors": {
                      "Type": null,
                      "Default": null
                    },
                    "dim": {
                      "Type": null,
                      "Default": "0"
                    },
                    "destination": {
                      "Type": null,
                      "Default": "None"
                    },
                    "out": {
                      "Type": null,
                      "Default": "None"
                    }
                  }
                },
                "reduce_add": {
                  "Doc": "Sums tensors from multiple GPUs.\n\n    All inputs should have matching shapes, dtype, and layout. The output tensor\n    will be of the same shape, dtype, and layout.\n\n    Args:\n        inputs (Iterable[Tensor]): an iterable of tensors to add.\n        destination (int, optional): a device on which the output will be\n            placed (default: current device).\n\n    Returns:\n        A tensor containing an elementwise sum of all inputs, placed on the\n        :attr:`destination` device.\n    ",
                  "Args": {
                    "inputs": {
                      "Type": null,
                      "Default": null
                    },
                    "destination": {
                      "Type": null,
                      "Default": "None"
                    }
                  }
                },
                "reduce_add_coalesced": {
                  "Doc": "Sums tensors from multiple GPUs.\n\n    Small tensors are first coalesced into a buffer to reduce the number\n    of synchronizations.\n\n    Args:\n        inputs (Iterable[Iterable[Tensor]]): iterable of iterables that\n            contain tensors from a single device.\n        destination (int, optional): a device on which the output will be\n            placed (default: current device).\n        buffer_size (int): maximum size of the buffer used for coalescing\n\n    Returns:\n        A tuple of tensors containing an elementwise sum of each group of\n        inputs, placed on the ``destination`` device.\n    ",
                  "Args": {
                    "inputs": {
                      "Type": null,
                      "Default": null
                    },
                    "destination": {
                      "Type": null,
                      "Default": "None"
                    },
                    "buffer_size": {
                      "Type": null,
                      "Default": "10485760"
                    }
                  }
                },
                "scatter": {
                  "Doc": "Scatters tensor across multiple GPUs.\n\n    Args:\n        tensor (Tensor): tensor to scatter. Can be on CPU or GPU.\n        devices (Iterable[torch.device, str or int], optional): an iterable of\n          GPU devices, among which to scatter.\n        chunk_sizes (Iterable[int], optional): sizes of chunks to be placed on\n          each device. It should match :attr:`devices` in length and sums to\n          ``tensor.size(dim)``. If not specified, :attr:`tensor` will be divided\n          into equal chunks.\n        dim (int, optional): A dimension along which to chunk :attr:`tensor`.\n          Default: ``0``.\n        streams (Iterable[Stream], optional): an iterable of Streams, among\n          which to execute the scatter. If not specified, the default stream will\n          be utilized.\n        out (Sequence[Tensor], optional, keyword-only): the GPU tensors to\n          store output results. Sizes of these tensors must match that of\n          :attr:`tensor`, except for :attr:`dim`, where the total size must\n          sum to ``tensor.size(dim)``.\n\n    .. note::\n        Exactly one of :attr:`devices` and :attr:`out` must be specified. When\n        :attr:`out` is specified, :attr:`chunk_sizes` must not be specified and\n        will be inferred from sizes of :attr:`out`.\n\n    Returns:\n        - If :attr:`devices` is specified,\n            a tuple containing chunks of :attr:`tensor`, placed on\n            :attr:`devices`.\n        - If :attr:`out` is specified,\n            a tuple containing :attr:`out` tensors, each containing a chunk of\n            :attr:`tensor`.\n    ",
                  "Args": {
                    "tensor": {
                      "Type": null,
                      "Default": null
                    },
                    "devices": {
                      "Type": null,
                      "Default": "None"
                    },
                    "chunk_sizes": {
                      "Type": null,
                      "Default": "None"
                    },
                    "dim": {
                      "Type": null,
                      "Default": "0"
                    },
                    "streams": {
                      "Type": null,
                      "Default": "None"
                    },
                    "out": {
                      "Type": null,
                      "Default": "None"
                    }
                  }
                }
              }
            },
            "distributed": {
              "Doc": null,
              "Classes": {
                "DistributedDataParallel": {
                  "Doc": "Implements distributed data parallelism that is based on\n    ``torch.distributed`` package at the module level.\n\n    This container parallelizes the application of the given module by\n    splitting the input across the specified devices by chunking in the batch\n    dimension. The module is replicated on each machine and each device, and\n    each such replica handles a portion of the input. During the backwards\n    pass, gradients from each node are averaged.\n\n    The batch size should be larger than the number of GPUs used locally.\n\n    See also: :ref:`distributed-basics` and :ref:`cuda-nn-ddp-instead`.\n    The same constraints on input as in :class:`torch.nn.DataParallel` apply.\n\n    Creation of this class requires that ``torch.distributed`` to be already\n    initialized, by calling :func:`torch.distributed.init_process_group`.\n\n    ``DistributedDataParallel`` is proven to be significantly faster than\n    :class:`torch.nn.DataParallel` for single-node multi-GPU data\n    parallel training.\n\n    To use ``DistributedDataParallel`` on a host with N GPUs, you should spawn\n    up ``N`` processes, ensuring that each process exclusively works on a single\n    GPU from 0 to N-1. This can be done by either setting\n    ``CUDA_VISIBLE_DEVICES`` for every process or by calling:\n\n        >>> # xdoctest: +SKIP(\"undefined variables\")\n        >>> torch.cuda.set_device(i)\n\n    where i is from 0 to N-1. In each process, you should refer the following\n    to construct this module:\n\n        >>> # xdoctest: +SKIP(\"undefined variables\")\n        >>> torch.distributed.init_process_group(\n        >>>     backend='nccl', world_size=N, init_method='...'\n        >>> )\n        >>> model = DistributedDataParallel(model, device_ids=[i], output_device=i)\n\n    In order to spawn up multiple processes per node, you can use either\n    ``torch.distributed.launch`` or ``torch.multiprocessing.spawn``.\n\n    .. note::\n        Please refer to `PyTorch Distributed Overview <https://pytorch.org/tutorials/beginner/dist_overview.html>`__\n        for a brief introduction to all features related to distributed training.\n\n    .. note::\n        ``DistributedDataParallel`` can be used in conjunction with\n        :class:`torch.distributed.optim.ZeroRedundancyOptimizer` to reduce\n        per-rank optimizer states memory footprint. Please refer to\n        `ZeroRedundancyOptimizer recipe <https://pytorch.org/tutorials/recipes/zero_redundancy_optimizer.html>`__\n        for more details.\n\n    .. note:: ``nccl`` backend is currently the fastest and highly recommended\n        backend when using GPUs. This applies to both single-node and\n        multi-node distributed training.\n\n    .. note:: This module also supports mixed-precision distributed training.\n        This means that your model can have different types of parameters such\n        as mixed types of ``fp16`` and ``fp32``, the gradient reduction on these\n        mixed types of parameters will just work fine.\n\n    .. note:: If you use ``torch.save`` on one process to checkpoint the module,\n        and ``torch.load`` on some other processes to recover it, make sure that\n        ``map_location`` is configured properly for every process. Without\n        ``map_location``, ``torch.load`` would recover the module to devices\n        where the module was saved from.\n\n    .. note:: When a model is trained on ``M`` nodes with ``batch=N``, the\n        gradient will be ``M`` times smaller when compared to the same model\n        trained on a single node with ``batch=M*N`` if the loss is summed (NOT\n        averaged as usual) across instances in a batch (because the gradients\n        between different nodes are averaged). You should take this into\n        consideration when you want to obtain a mathematically equivalent\n        training process compared to the local training counterpart. But in most\n        cases, you can just treat a DistributedDataParallel wrapped model, a\n        DataParallel wrapped model and an ordinary model on a single GPU as the\n        same (E.g. using the same learning rate for equivalent batch size).\n\n    .. note::\n        Parameters are never broadcast between processes. The module performs\n        an all-reduce step on gradients and assumes that they will be modified\n        by the optimizer in all processes in the same way. Buffers\n        (e.g. BatchNorm stats) are broadcast from the module in process of rank\n        0, to all other replicas in the system in every iteration.\n\n    .. note::\n        If you are using DistributedDataParallel in conjunction with the\n        :ref:`distributed-rpc-framework`, you should always use\n        :meth:`torch.distributed.autograd.backward` to compute gradients and\n        :class:`torch.distributed.optim.DistributedOptimizer` for optimizing\n        parameters.\n\n    .. note::\n        DistributedDataParallel currently offers limited support for gradient\n        checkpointing with :meth:`torch.utils.checkpoint`. DDP will work as\n        expected when there are no unused parameters in the model and each layer\n        is checkpointed at most once (make sure you are not passing\n        `find_unused_parameters=True` to DDP). We currently do not support the\n        case where a layer is checkpointed multiple times, or when there unused\n        parameters in the checkpointed model.\n\n        Example::\n\n            >>> # xdoctest: +SKIP(\"undefined variables\")\n            >>> import torch.distributed.autograd as dist_autograd\n            >>> from torch.nn.parallel import DistributedDataParallel as DDP\n            >>> import torch\n            >>> from torch import optim\n            >>> from torch.distributed.optim import DistributedOptimizer\n            >>> import torch.distributed.rpc as rpc\n            >>> from torch.distributed.rpc import RRef\n            >>>\n            >>> t1 = torch.rand((3, 3), requires_grad=True)\n            >>> t2 = torch.rand((3, 3), requires_grad=True)\n            >>> rref = rpc.remote(\"worker1\", torch.add, args=(t1, t2))\n            >>> ddp_model = DDP(my_model)\n            >>>\n            >>> # Setup optimizer\n            >>> optimizer_params = [rref]\n            >>> for param in ddp_model.parameters():\n            >>>     optimizer_params.append(RRef(param))\n            >>>\n            >>> dist_optim = DistributedOptimizer(\n            >>>     optim.SGD,\n            >>>     optimizer_params,\n            >>>     lr=0.05,\n            >>> )\n            >>>\n            >>> with dist_autograd.context() as context_id:\n            >>>     pred = ddp_model(rref.to_here())\n            >>>     loss = loss_func(pred, target)\n            >>>     dist_autograd.backward(context_id, [loss])\n            >>>     dist_optim.step(context_id)\n\n    .. note::\n        To let a non-DDP model load a state dict from a DDP model,\n        :meth:`~torch.nn.modules.utils.consume_prefix_in_state_dict_if_present`\n        needs to be applied to strip the prefix \"module.\" in the DDP state dict before loading.\n\n    .. warning::\n        Constructor, forward method, and differentiation of the output (or a\n        function of the output of this module) are distributed synchronization\n        points. Take that into account in case different processes might be\n        executing different code.\n\n    .. warning::\n        This module assumes all parameters are registered in the model by the\n        time it is created. No parameters should be added nor removed later.\n        Same applies to buffers.\n\n    .. warning::\n        This module assumes all parameters are registered in the model of each\n        distributed processes are in the same order. The module itself will\n        conduct gradient ``allreduce`` following the reverse order of the\n        registered parameters of the model. In other words, it is users'\n        responsibility to ensure that each distributed process has the exact\n        same model and thus the exact same parameter registration order.\n\n    .. warning::\n        This module allows parameters with non-rowmajor-contiguous strides.\n        For example, your model may contain some parameters whose\n        :class:`torch.memory_format` is ``torch.contiguous_format``\n        and others whose format is ``torch.channels_last``.  However,\n        corresponding parameters in different processes must have the\n        same strides.\n\n    .. warning::\n        This module doesn't work with :func:`torch.autograd.grad` (i.e. it will\n        only work if gradients are to be accumulated in ``.grad`` attributes of\n        parameters).\n\n    .. warning::\n        If you plan on using this module with a ``nccl`` backend or a ``gloo``\n        backend (that uses Infiniband), together with a DataLoader that uses\n        multiple workers, please change the multiprocessing start method to\n        ``forkserver`` (Python 3 only) or ``spawn``. Unfortunately\n        Gloo (that uses Infiniband) and NCCL2 are not fork safe, and you will\n        likely experience deadlocks if you don't change this setting.\n\n    .. warning::\n        You should never try to change your model's parameters after wrapping\n        up your model with ``DistributedDataParallel``. Because, when\n        wrapping up your model with ``DistributedDataParallel``, the constructor\n        of ``DistributedDataParallel`` will register the additional gradient\n        reduction functions on all the parameters of the model itself at the\n        time of construction. If you change the model's parameters afterwards,\n        gradient redunction functions no longer match the correct set of\n        parameters.\n\n    .. warning::\n        Using ``DistributedDataParallel`` in conjunction with the\n        :ref:`distributed-rpc-framework` is experimental and subject to change.\n\n    Args:\n        module (Module): module to be parallelized\n        device_ids (list of int or torch.device): CUDA devices.\n                   1) For single-device modules, ``device_ids`` can\n                   contain exactly one device id, which represents the only\n                   CUDA device where the input module corresponding to this process resides.\n                   Alternatively, ``device_ids`` can also be ``None``.\n                   2) For multi-device modules and CPU modules,\n                   ``device_ids`` must be ``None``.\n\n                   When ``device_ids`` is ``None`` for both cases,\n                   both the input data for the forward pass and the actual module\n                   must be placed on the correct device.\n                   (default: ``None``)\n        output_device (int or torch.device): Device location of output for\n                      single-device CUDA modules. For multi-device modules and\n                      CPU modules, it must be ``None``, and the module itself\n                      dictates the output location. (default: ``device_ids[0]``\n                      for single-device modules)\n        broadcast_buffers (bool): Flag that enables syncing (broadcasting)\n                          buffers of the module at beginning of the ``forward``\n                          function. (default: ``True``)\n        process_group: The process group to be used for distributed data\n                       all-reduction. If ``None``, the default process group, which\n                       is created by :func:`torch.distributed.init_process_group`,\n                       will be used. (default: ``None``)\n        bucket_cap_mb: ``DistributedDataParallel`` will bucket parameters into\n                       multiple buckets so that gradient reduction of each\n                       bucket can potentially overlap with backward computation.\n                       :attr:`bucket_cap_mb` controls the bucket size in\n                       MegaBytes (MB). (default: 25)\n        find_unused_parameters (bool): Traverse the autograd graph from all\n                               tensors contained in the return value of the\n                               wrapped module's ``forward`` function. Parameters\n                               that don't receive gradients as part of this\n                               graph are preemptively marked as being ready to\n                               be reduced. In addition, parameters that may have\n                               been used in the wrapped module's ``forward``\n                               function but were not part of loss computation and\n                               thus would also not receive gradients are\n                               preemptively marked as ready to be reduced.\n                               (default: ``False``)\n        check_reduction: This argument is deprecated.\n        gradient_as_bucket_view (bool): When set to ``True``, gradients will be views\n                      pointing to different offsets of ``allreduce`` communication\n                      buckets. This can reduce peak memory usage, where the\n                      saved memory size will be equal to the total gradients\n                      size. Moreover, it avoids the overhead of copying between\n                      gradients and ``allreduce`` communication buckets. When\n                      gradients are views, ``detach_()`` cannot be called on the\n                      gradients. If hitting such errors, please fix it by\n                      referring to the :meth:`~torch.optim.Optimizer.zero_grad`\n                      function in ``torch/optim/optimizer.py`` as a solution.\n                      Note that gradients will be views after first iteration, so\n                      the peak memory saving should be checked after first iteration.\n        static_graph (bool): When set to ``True``, DDP knows the trained graph is\n                     static. Static graph means 1) The set of used and unused\n                     parameters will not change during the whole training loop; in\n                     this case, it does not matter whether users set\n                     ``find_unused_parameters = True`` or not. 2) How the graph is trained\n                     will not change during the whole training loop (meaning there is\n                     no control flow depending on iterations).\n                     When static_graph is set to be ``True``, DDP will support cases that\n                     can not be supported in the past:\n                     1) Reentrant backwards.\n                     2) Activation checkpointing multiple times.\n                     3) Activation checkpointing when model has unused parameters.\n                     4) There are model parameters that are outside of forward function.\n                     5) Potentially improve performance when there are unused parameters,\n                     as DDP will not search graph in each iteraton to detect unused\n                     parameters when static_graph is set to be ``True``.\n                     To check whether you can set static_graph to be ``True``, one way is to\n                     check ddp logging data at the end of your previous model training,\n                     if ``ddp_logging_data.get(\"can_set_static_graph\") == True``, mostly you\n                     can set ``static_graph = True`` as well.\n\n                     Example::\n                         >>> # xdoctest: +SKIP(\"undefined variables\")\n                         >>> model_DDP = torch.nn.parallel.DistributedDataParallel(model)\n                         >>> # Training loop\n                         >>> ...\n                         >>> ddp_logging_data = model_DDP._get_ddp_logging_data()\n                         >>> static_graph = ddp_logging_data.get(\"can_set_static_graph\")\n\n\n    Attributes:\n        module (Module): the module to be parallelized.\n\n    Example::\n\n        >>> # xdoctest: +SKIP(\"undefined variables\")\n        >>> torch.distributed.init_process_group(backend='nccl', world_size=4, init_method='...')\n        >>> net = torch.nn.parallel.DistributedDataParallel(model)\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "module": {
                          "Type": null,
                          "Default": null
                        },
                        "device_ids": {
                          "Type": null,
                          "Default": "None"
                        },
                        "output_device": {
                          "Type": null,
                          "Default": "None"
                        },
                        "dim": {
                          "Type": null,
                          "Default": "0"
                        },
                        "broadcast_buffers": {
                          "Type": null,
                          "Default": "True"
                        },
                        "process_group": {
                          "Type": null,
                          "Default": "None"
                        },
                        "bucket_cap_mb": {
                          "Type": null,
                          "Default": "25"
                        },
                        "find_unused_parameters": {
                          "Type": null,
                          "Default": "False"
                        },
                        "check_reduction": {
                          "Type": null,
                          "Default": "False"
                        },
                        "gradient_as_bucket_view": {
                          "Type": null,
                          "Default": "False"
                        },
                        "static_graph": {
                          "Type": null,
                          "Default": "False"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "*inputs": {
                          "Type": null,
                          "Default": null
                        },
                        "**kwargs": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "gather": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "outputs": {
                          "Type": null,
                          "Default": null
                        },
                        "output_device": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "join": {
                      "Doc": "\n        A context manager to be used in conjunction with an instance of\n        :class:`torch.nn.parallel.DistributedDataParallel` to be\n        able to train with uneven inputs across participating processes.\n\n        This context manager will keep track of already-joined DDP processes,\n        and \"shadow\" the forward and backward passes by inserting collective\n        communication operations to match with the ones created by non-joined\n        DDP processes. This will ensure each collective call has a corresponding\n        call by already-joined DDP processes, preventing hangs or errors that\n        would otherwise happen when training with uneven inputs across\n        processes. Alternatively, if the flag ``throw_on_early_termination`` is\n        specified to be ``True``, all trainers will throw an error once one rank\n        runs out of inputs, allowing these errors to be caught and handled\n        according to application logic.\n\n        Once all DDP processes have joined, the context manager will broadcast\n        the model corresponding to the last joined process to all processes to\n        ensure the model is the same across all processes\n        (which is guaranteed by DDP).\n\n        To use this to enable training with uneven inputs across processes,\n        simply wrap this context manager around your training loop. No further\n        modifications to the model or data loading is required.\n\n        .. warning::\n            If the model or training loop this context manager is wrapped around\n            has additional distributed collective operations, such as\n            ``SyncBatchNorm`` in the model's forward pass, then the flag\n            ``throw_on_early_termination`` must be enabled. This is because this\n            context manager is not aware of non-DDP collective communication.\n            This flag will cause all ranks to throw when any one rank\n            exhausts inputs, allowing these errors to be caught and recovered\n            from across all ranks.\n\n        Args:\n            divide_by_initial_world_size (bool): If ``True``, will divide\n                gradients by the initial ``world_size`` DDP training was launched\n                with. If ``False``, will compute the effective world size\n                (number of ranks that have not depleted their inputs yet) and\n                divide gradients by that during allreduce. Set\n                ``divide_by_initial_world_size=True`` to ensure every input\n                sample including the uneven inputs have equal weight in terms of\n                how much they contribute to the global gradient. This is\n                achieved by always dividing the gradient by the initial\n                ``world_size`` even when we encounter uneven inputs. If you set\n                this to ``False``, we divide the gradient by the remaining\n                number of nodes. This ensures parity with training on a smaller\n                ``world_size`` although it also means the uneven inputs would\n                contribute more towards the global gradient. Typically, you\n                would want to set this to ``True`` for cases where the last few\n                inputs of your training job are uneven. In extreme cases, where\n                there is a large discrepancy in the number of inputs, setting\n                this to ``False`` might provide better results.\n            enable (bool): Whether to enable uneven input detection or not. Pass\n                in ``enable=False`` to disable in cases where you know that\n                inputs are even across participating processes. Default is\n                ``True``.\n            throw_on_early_termination (bool): Whether to throw an error\n                or continue training when at least one rank has exhausted\n                inputs. If ``True``, will throw upon the first rank reaching end\n                of data. If ``False``, will continue training with a smaller\n                effective world size until all ranks are joined. Note that if\n                this flag is specified, then the flag\n                ``divide_by_initial_world_size`` would be ignored. Default\n                is ``False``.\n\n\n        Example::\n\n            >>> import torch\n            >>> import torch.distributed as dist\n            >>> import os\n            >>> import torch.multiprocessing as mp\n            >>> import torch.nn as nn\n            >>> # On each spawned worker\n            >>> def worker(rank):\n            >>>     dist.init_process_group(\"nccl\", rank=rank, world_size=2)\n            >>>     torch.cuda.set_device(rank)\n            >>>     model = nn.Linear(1, 1, bias=False).to(rank)\n            >>>     model = torch.nn.parallel.DistributedDataParallel(\n            >>>         model, device_ids=[rank], output_device=rank\n            >>>     )\n            >>>     # Rank 1 gets one more input than rank 0.\n            >>>     inputs = [torch.tensor([1]).float() for _ in range(10 + rank)]\n            >>>     with model.join():\n            >>>         for _ in range(5):\n            >>>             for inp in inputs:\n            >>>                 loss = model(inp).sum()\n            >>>                 loss.backward()\n            >>>     # Without the join() API, the below synchronization will hang\n            >>>     # blocking for rank 1's allreduce to complete.\n            >>>     torch.cuda.synchronize(device=rank)\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "divide_by_initial_world_size": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "enable": {
                          "Type": "<class 'bool'>",
                          "Default": "True"
                        },
                        "throw_on_early_termination": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        }
                      }
                    },
                    "join_hook": {
                      "Doc": "\n        Returns the DDP join hook, which enables training on uneven inputs by\n        shadowing the collective communications in the forward and backward\n        passes.\n\n        Arguments:\n            kwargs (dict): a :class:`dict` containing any keyword arguments\n                to modify the behavior of the join hook at run time; all\n                :class:`Joinable` instances sharing the same join context\n                manager are forwarded the same value for ``kwargs``.\n\n        The hook supports the following keyword arguments:\n            divide_by_initial_world_size (bool, optional):\n                If ``True``, then gradients are divided by the initial world\n                size that DDP was launched with.\n                If ``False``, then gradients are divided by the effective world\n                size (i.e. the number of non-joined processes), meaning that\n                the uneven inputs contribute more toward the global gradient.\n                Typically, this should be set to ``True`` if the degree of\n                unevenness is small but can be set to ``False`` in extreme\n                cases for possibly better results.\n                Default is ``True``.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "**kwargs": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "no_sync": {
                      "Doc": "\n        A context manager to disable gradient synchronizations across DDP\n        processes. Within this context, gradients will be accumulated on module\n        variables, which will later be synchronized in the first\n        forward-backward pass exiting the context.\n\n        Example::\n\n            >>> # xdoctest: +SKIP(\"undefined variables\")\n            >>> ddp = torch.nn.parallel.DistributedDataParallel(model, pg)\n            >>> with ddp.no_sync():\n            >>>   for input in inputs:\n            >>>     ddp(input).backward()  # no synchronization, accumulate grads\n            >>> ddp(another_input).backward()  # synchronize grads\n        ",
                      "Args": {
                        "*args": {
                          "Type": null,
                          "Default": null
                        },
                        "**kwds": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "register_comm_hook": {
                      "Doc": "\n        Registers a communication hook which is an enhancement that provides a\n        flexible hook to users where they can specify how DDP aggregates gradients\n        across multiple workers.\n\n        This hook would be very useful for researchers to try out new ideas. For\n        example, this hook can be used to implement several algorithms like GossipGrad\n        and gradient compression which involve different communication strategies for\n        parameter syncs while running Distributed DataParallel training.\n\n        Args:\n            state (object): Passed to the hook to maintain any state information during the training process.\n                            Examples include error feedback in gradient compression,\n                            peers to communicate with next in GossipGrad, etc.\n\n                            It is locally stored by each worker\n                            and shared by all the gradient tensors on the worker.\n            hook (Callable): Callable with the following signature:\n                             ``hook(state: object, bucket: dist.GradBucket) -> torch.futures.Future[torch.Tensor]``:\n\n                             This function is called once the bucket is ready. The\n                             hook can perform whatever processing is needed and return\n                             a Future indicating completion of any async work (ex: allreduce).\n                             If the hook doesn't perform any communication, it still\n                             must return a completed Future. The Future should hold the\n                             new value of grad bucket's tensors. Once a bucket is ready,\n                             c10d reducer would call this hook and use the tensors returned\n                             by the Future and copy grads to individual parameters.\n                             Note that the future's return type must be a single tensor.\n\n                             We also provide an API called ``get_future`` to retrieve a\n                             Future associated with the completion of ``c10d.ProcessGroup.Work``.\n                             ``get_future`` is currently supported for NCCL and also supported for most\n                             operations on GLOO and MPI, except for peer to peer operations (send/recv).\n\n        .. warning ::\n            Grad bucket's tensors will not be predivided by world_size. User is responsible\n            to divide by the world_size in case of operations like allreduce.\n\n        .. warning ::\n            DDP communication hook can only be registered once and should be registered\n            before calling backward.\n\n        .. warning ::\n            The Future object that hook returns should contain a single tensor\n            that has the same shape with the tensors inside grad bucket.\n\n        .. warning ::\n            ``get_future`` API supports NCCL, and partially GLOO and MPI backends (no support\n            for peer-to-peer operations like send/recv) and will return a ``torch.futures.Future``.\n\n        Example::\n            Below is an example of a noop hook that returns the same tensor.\n\n            >>> def noop(state: object, bucket: dist.GradBucket) -> torch.futures.Future[torch.Tensor]:\n            >>>     fut = torch.futures.Future()\n            >>>     fut.set_result(bucket.buffer())\n            >>>     return fut\n\n            >>> # xdoctest: +SKIP('undefined name')\n            >>> ddp.register_comm_hook(state=None, hook=noop)\n\n        Example::\n            Below is an example of a Parallel SGD algorithm where gradients are encoded before\n            allreduce, and then decoded after allreduce.\n\n            >>> def encode_and_decode(state: object, bucket: dist.GradBucket) -> torch.futures.Future[torch.Tensor]:\n            >>>     encoded_tensor = encode(bucket.buffer()) # encode gradients\n            >>>     fut = torch.distributed.all_reduce(encoded_tensor).get_future()\n            >>>     # Define the then callback to decode.\n            >>>     def decode(fut):\n            >>>         decoded_tensor = decode(fut.value()[0]) # decode gradients\n            >>>         return decoded_tensor\n            >>>     return fut.then(decode)\n\n            >>> # xdoctest: +SKIP('undefined name')\n            >>> ddp.register_comm_hook(state=None, hook=encode_and_decode)\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "state": {
                          "Type": "<class 'object'>",
                          "Default": null
                        },
                        "hook": {
                          "Type": "<built-in function callable>",
                          "Default": null
                        }
                      }
                    },
                    "scatter": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "inputs": {
                          "Type": null,
                          "Default": null
                        },
                        "kwargs": {
                          "Type": null,
                          "Default": null
                        },
                        "device_ids": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "to_kwargs": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "inputs": {
                          "Type": null,
                          "Default": null
                        },
                        "kwargs": {
                          "Type": null,
                          "Default": null
                        },
                        "device_id": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "train": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "mode": {
                          "Type": null,
                          "Default": "True"
                        }
                      }
                    },
                    "will_sync_module_buffers": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    }
                  }
                }
              },
              "Functions": {
                "contextmanager": {
                  "Doc": "@contextmanager decorator.\n\n    Typical usage:\n\n        @contextmanager\n        def some_generator(<arguments>):\n            <setup>\n            try:\n                yield <value>\n            finally:\n                <cleanup>\n\n    This makes this:\n\n        with some_generator(<arguments>) as <variable>:\n            <body>\n\n    equivalent to this:\n\n        <setup>\n        try:\n            <variable> = <value>\n            <body>\n        finally:\n            <cleanup>\n    ",
                  "Args": {
                    "func": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "dataclass": {
                  "Doc": "Returns the same class as was passed in, with dunder methods\n    added based on the fields defined in the class.\n\n    Examines PEP 526 __annotations__ to determine fields.\n\n    If init is true, an __init__() method is added to the class. If\n    repr is true, a __repr__() method is added. If order is true, rich\n    comparison dunder methods are added. If unsafe_hash is true, a\n    __hash__() method function is added. If frozen is true, fields may\n    not be assigned to after instance creation.\n    ",
                  "Args": {
                    "cls": {
                      "Type": null,
                      "Default": "None"
                    },
                    "init": {
                      "Type": null,
                      "Default": "True"
                    },
                    "repr": {
                      "Type": null,
                      "Default": "True"
                    },
                    "eq": {
                      "Type": null,
                      "Default": "True"
                    },
                    "order": {
                      "Type": null,
                      "Default": "False"
                    },
                    "unsafe_hash": {
                      "Type": null,
                      "Default": "False"
                    },
                    "frozen": {
                      "Type": null,
                      "Default": "False"
                    }
                  }
                },
                "gather": {
                  "Doc": "\n    Gathers tensors from different GPUs on a specified device.\n    Use 'cpu' for CPU to avoid a deprecation warning.\n    ",
                  "Args": {
                    "outputs": {
                      "Type": null,
                      "Default": null
                    },
                    "target_device": {
                      "Type": null,
                      "Default": null
                    },
                    "dim": {
                      "Type": null,
                      "Default": "0"
                    }
                  }
                },
                "is_namedtuple": {
                  "Doc": null,
                  "Args": {
                    "obj": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "scatter_kwargs": {
                  "Doc": "Scatter with support for kwargs dictionary",
                  "Args": {
                    "inputs": {
                      "Type": null,
                      "Default": null
                    },
                    "kwargs": {
                      "Type": null,
                      "Default": null
                    },
                    "target_gpus": {
                      "Type": null,
                      "Default": null
                    },
                    "dim": {
                      "Type": null,
                      "Default": "0"
                    }
                  }
                },
                "tree_flatten": {
                  "Doc": "Flattens a pytree into a list of values and a TreeSpec that can be used\n    to reconstruct the pytree.\n    ",
                  "Args": {
                    "pytree": {
                      "Type": "typing.Any",
                      "Default": null
                    }
                  }
                },
                "tree_unflatten": {
                  "Doc": "Given a list of values and a TreeSpec, builds a pytree.\n    This is the inverse operation of `tree_flatten`.\n    ",
                  "Args": {
                    "values": {
                      "Type": "typing.List[typing.Any]",
                      "Default": null
                    },
                    "spec": {
                      "Type": "<class 'torch.utils._pytree.TreeSpec'>",
                      "Default": null
                    }
                  }
                }
              }
            },
            "scatter_gather": {
              "Doc": null,
              "Functions": {
                "gather": {
                  "Doc": "\n    Gathers tensors from different GPUs on a specified device.\n    Use 'cpu' for CPU to avoid a deprecation warning.\n    ",
                  "Args": {
                    "outputs": {
                      "Type": null,
                      "Default": null
                    },
                    "target_device": {
                      "Type": null,
                      "Default": null
                    },
                    "dim": {
                      "Type": null,
                      "Default": "0"
                    }
                  }
                },
                "is_namedtuple": {
                  "Doc": null,
                  "Args": {
                    "obj": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "scatter": {
                  "Doc": "\n    Slices tensors into approximately equal chunks and\n    distributes them across given GPUs. Duplicates\n    references to objects that are not tensors.\n    ",
                  "Args": {
                    "inputs": {
                      "Type": null,
                      "Default": null
                    },
                    "target_gpus": {
                      "Type": null,
                      "Default": null
                    },
                    "dim": {
                      "Type": null,
                      "Default": "0"
                    }
                  }
                },
                "scatter_kwargs": {
                  "Doc": "Scatter with support for kwargs dictionary",
                  "Args": {
                    "inputs": {
                      "Type": null,
                      "Default": null
                    },
                    "kwargs": {
                      "Type": null,
                      "Default": null
                    },
                    "target_gpus": {
                      "Type": null,
                      "Default": null
                    },
                    "dim": {
                      "Type": null,
                      "Default": "0"
                    }
                  }
                }
              }
            }
          }
        },
        "parameter": {
          "Doc": null,
          "Classes": {
            "Parameter": {
              "Doc": "A kind of Tensor that is to be considered a module parameter.\n\n    Parameters are :class:`~torch.Tensor` subclasses, that have a\n    very special property when used with :class:`Module` s - when they're\n    assigned as Module attributes they are automatically added to the list of\n    its parameters, and will appear e.g. in :meth:`~Module.parameters` iterator.\n    Assigning a Tensor doesn't have such effect. This is because one might\n    want to cache some temporary state, like last hidden state of the RNN, in\n    the model. If there was no such class as :class:`Parameter`, these\n    temporaries would get registered too.\n\n    Args:\n        data (Tensor): parameter tensor.\n        requires_grad (bool, optional): if the parameter requires gradient. See\n            :ref:`locally-disable-grad-doc` for more details. Default: `True`\n    "
            },
            "UninitializedBuffer": {
              "Doc": "A buffer that is not initialized.\n\n    Unitialized Buffer is a a special case of :class:`torch.Tensor`\n    where the shape of the data is still unknown.\n\n    Unlike a :class:`torch.Tensor`, uninitialized parameters\n    hold no data and attempting to access some properties, like their shape,\n    will throw a runtime error. The only operations that can be performed on a uninitialized\n    parameter are changing its datatype, moving it to a different device and\n    converting it to a regular :class:`torch.Tensor`.\n\n    The default device or dtype to use when the buffer is materialized can be set\n    during construction using e.g. ``device='cuda'``.\n    "
            },
            "UninitializedParameter": {
              "Doc": "A parameter that is not initialized.\n\n    Unitialized Parameters are a a special case of :class:`torch.nn.Parameter`\n    where the shape of the data is still unknown.\n\n    Unlike a :class:`torch.nn.Parameter`, uninitialized parameters\n    hold no data and attempting to access some properties, like their shape,\n    will throw a runtime error. The only operations that can be performed on a uninitialized\n    parameter are changing its datatype, moving it to a different device and\n    converting it to a regular :class:`torch.nn.Parameter`.\n\n    The default device or dtype to use when the parameter is materialized can be set\n    during construction using e.g. ``device='cuda'``.\n    "
            },
            "UninitializedTensorMixin": {
              "Doc": null,
              "Functions": {
                "materialize": {
                  "Doc": "Create a Parameter or Tensor with the same properties of the uninitialized one.\n        Given a shape, it materializes a parameter in the same device\n        and with the same `dtype` as the current one or the specified ones in the\n        arguments.\n\n        Args:\n            shape : (tuple): the shape for the materialized tensor.\n            device (:class:`torch.device`): the desired device of the parameters\n                and buffers in this module. Optional.\n            dtype (:class:`torch.dtype`): the desired floating point type of\n                the floating point parameters and buffers in this module. Optional.\n        ",
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "shape": {
                      "Type": null,
                      "Default": null
                    },
                    "device": {
                      "Type": null,
                      "Default": "None"
                    },
                    "dtype": {
                      "Type": null,
                      "Default": "None"
                    }
                  }
                }
              }
            }
          },
          "Functions": {
            "is_lazy": {
              "Doc": null,
              "Args": {
                "param": {
                  "Type": null,
                  "Default": null
                }
              }
            }
          }
        },
        "qat": {
          "Doc": "QAT Dynamic Modules\n\nThis package is in the process of being deprecated.\nPlease, use `torch.ao.nn.qat.dynamic` instead.\n",
          "Modules": {
            "dynamic": {
              "Doc": "QAT Dynamic Modules\n\nThis package is in the process of being deprecated.\nPlease, use `torch.ao.nn.qat.dynamic` instead.\n",
              "Modules": {
                "modules": {
                  "Doc": null,
                  "Modules": {
                    "linear": {
                      "Doc": "QAT Modules\n\nThis file is in the process of migration to `torch/ao/nn/qat/dynamic`, and\nis kept here for compatibility while the migration process is ongoing.\nIf you are adding a new entry/functionality, please, add it to the\nappropriate file under the `torch/ao/nn/qat/dynamic/modules`,\nwhile adding an import statement here.\n"
                    }
                  }
                }
              }
            },
            "modules": {
              "Doc": "QAT Modules\n\nThis package is in the process of being deprecated.\nPlease, use `torch.ao.nn.qat.modules` instead.\n",
              "Modules": {
                "conv": {
                  "Doc": "QAT Modules\n\nThis file is in the process of migration to `torch/ao/nn/qat`, and\nis kept here for compatibility while the migration process is ongoing.\nIf you are adding a new entry/functionality, please, add it to the\nappropriate file under the `torch/ao/nn/qat/modules`,\nwhile adding an import statement here.\n"
                },
                "embedding_ops": {
                  "Doc": "QAT Modules\n\nThis file is in the process of migration to `torch/ao/nn/qat`, and\nis kept here for compatibility while the migration process is ongoing.\nIf you are adding a new entry/functionality, please, add it to the\nappropriate file under the `torch/ao/nn/qat/modules`,\nwhile adding an import statement here.\n"
                },
                "linear": {
                  "Doc": "QAT Modules\n\nThis file is in the process of migration to `torch/ao/nn/qat`, and\nis kept here for compatibility while the migration process is ongoing.\nIf you are adding a new entry/functionality, please, add it to the\nappropriate file under the `torch/ao/nn/qat/modules`,\nwhile adding an import statement here.\n"
                }
              }
            }
          }
        },
        "quantizable": {
          "Doc": null,
          "Modules": {
            "modules": {
              "Doc": null
            }
          }
        },
        "quantized": {
          "Doc": null,
          "Modules": {
            "dynamic": {
              "Doc": null
            },
            "functional": {
              "Doc": "nn.quantized.functional\n\nQuantized equivalents of the `nn.functional`.\n\nNote::\n    This location is in the process of being deprecated.\n    Please, use the `torch.ao.nn.quantized.functional` instead.\n",
              "Functions": {
                "adaptive_avg_pool2d": {
                  "Doc": "\n    Applies a 2D adaptive average pooling over a quantized input signal composed\n    of several quantized input planes.\n\n    .. note:: The input quantization parameters propagate to the output.\n\n    See :class:`~torch.ao.nn.quantized.AdaptiveAvgPool2d` for details and output shape.\n\n    Args:\n        output_size: the target output size (single integer or\n                     double-integer tuple)\n    ",
                  "Args": {
                    "input": {
                      "Type": "<class 'torch.Tensor'>",
                      "Default": null
                    },
                    "output_size": {
                      "Type": "None",
                      "Default": null
                    }
                  }
                },
                "adaptive_avg_pool3d": {
                  "Doc": "\n    Applies a 3D adaptive average pooling over a quantized input signal composed\n    of several quantized input planes.\n\n    .. note:: The input quantization parameters propagate to the output.\n\n    See :class:`~torch.ao.nn.quantized.AdaptiveAvgPool3d` for details and output shape.\n\n    Args:\n        output_size: the target output size (single integer or\n                     double-integer tuple)\n    ",
                  "Args": {
                    "input": {
                      "Type": "<class 'torch.Tensor'>",
                      "Default": null
                    },
                    "output_size": {
                      "Type": "None",
                      "Default": null
                    }
                  }
                },
                "avg_pool2d": {
                  "Doc": "\n    Applies 2D average-pooling operation in :math:`kH \\times kW` regions by step size\n    :math:`sH \\times sW` steps. The number of output features is equal to the number of\n    input planes.\n\n    .. note:: The input quantization parameters propagate to the output.\n\n    See :class:`~torch.ao.nn.quantized.AvgPool2d` for details and output shape.\n\n    Args:\n        input: quantized input tensor :math:`(\\text{minibatch} , \\text{in\\_channels} , iH , iW)`\n        kernel_size: size of the pooling region. Can be a single number or a\n          tuple `(kH, kW)`\n        stride: stride of the pooling operation. Can be a single number or a\n          tuple `(sH, sW)`. Default: :attr:`kernel_size`\n        padding: implicit zero paddings on both sides of the input. Can be a\n          single number or a tuple `(padH, padW)`. Default: 0\n        ceil_mode: when True, will use `ceil` instead of `floor` in the formula\n            to compute the output shape. Default: ``False``\n        count_include_pad: when True, will include the zero-padding in the\n            averaging calculation. Default: ``True``\n        divisor_override: if specified, it will be used as divisor, otherwise\n             size of the pooling region will be used. Default: None\n    ",
                  "Args": {
                    "input": {
                      "Type": null,
                      "Default": null
                    },
                    "kernel_size": {
                      "Type": null,
                      "Default": null
                    },
                    "stride": {
                      "Type": null,
                      "Default": "None"
                    },
                    "padding": {
                      "Type": null,
                      "Default": "0"
                    },
                    "ceil_mode": {
                      "Type": null,
                      "Default": "False"
                    },
                    "count_include_pad": {
                      "Type": null,
                      "Default": "True"
                    },
                    "divisor_override": {
                      "Type": null,
                      "Default": "None"
                    }
                  }
                },
                "avg_pool3d": {
                  "Doc": "\n    Applies 3D average-pooling operation in :math:`kD \\ times kH \\times kW` regions by step size\n    :math:`sD \\times sH \\times sW` steps. The number of output features is equal to the number of\n    input planes.\n\n    .. note:: The input quantization parameters propagate to the output.\n\n    Args:\n        input: quantized input tensor :math:`(\\text{minibatch} , \\text{in\\_channels} , iH , iW)`\n        kernel_size: size of the pooling region. Can be a single number or a\n          tuple `(kD, kH, kW)`\n        stride: stride of the pooling operation. Can be a single number or a\n          tuple `(sD, sH, sW)`. Default: :attr:`kernel_size`\n        padding: implicit zero paddings on both sides of the input. Can be a\n          single number or a tuple `(padD, padH, padW)`. Default: 0\n        ceil_mode: when True, will use `ceil` instead of `floor` in the formula\n            to compute the output shape. Default: ``False``\n        count_include_pad: when True, will include the zero-padding in the\n            averaging calculation. Default: ``True``\n        divisor_override: if specified, it will be used as divisor, otherwise\n             size of the pooling region will be used. Default: None\n    ",
                  "Args": {
                    "input": {
                      "Type": null,
                      "Default": null
                    },
                    "kernel_size": {
                      "Type": null,
                      "Default": null
                    },
                    "stride": {
                      "Type": null,
                      "Default": "None"
                    },
                    "padding": {
                      "Type": null,
                      "Default": "0"
                    },
                    "ceil_mode": {
                      "Type": null,
                      "Default": "False"
                    },
                    "count_include_pad": {
                      "Type": null,
                      "Default": "True"
                    },
                    "divisor_override": {
                      "Type": null,
                      "Default": "None"
                    }
                  }
                },
                "celu": {
                  "Doc": "celu(input, scale, zero_point, alpha=1.) -> Tensor\n\n    Applies the quantized CELU function element-wise.\n\n    .. math::\n        \\text{CELU}(x) = \\max(0,x) + \\min(0, \\alpha * (\\exp(x / \\alpha) - 1))\n\n    Args:\n        input: quantized input\n        alpha: the :math:`\\alpha` value for the CELU formulation. Default: 1.0\n    ",
                  "Args": {
                    "input": {
                      "Type": "<class 'torch.Tensor'>",
                      "Default": null
                    },
                    "scale": {
                      "Type": "<class 'float'>",
                      "Default": null
                    },
                    "zero_point": {
                      "Type": "<class 'int'>",
                      "Default": null
                    },
                    "alpha": {
                      "Type": "<class 'float'>",
                      "Default": "1.0"
                    }
                  }
                },
                "clamp": {
                  "Doc": "float(input, min\\_, max\\_) -> Tensor\n\n    Applies the clamp function element-wise.\n    See :class:`~torch.ao.nn.quantized.clamp` for more details.\n\n    Args:\n        input: quantized input\n        min_: minimum value for clamping\n        max_: maximum value for clamping\n    ",
                  "Args": {
                    "input": {
                      "Type": "<class 'torch.Tensor'>",
                      "Default": null
                    },
                    "min_": {
                      "Type": "<class 'float'>",
                      "Default": null
                    },
                    "max_": {
                      "Type": "<class 'float'>",
                      "Default": null
                    }
                  }
                },
                "conv1d": {
                  "Doc": "\n    Applies a 1D convolution over a quantized 1D input composed of several input\n    planes.\n\n    See :class:`~torch.ao.nn.quantized.Conv1d` for details and output shape.\n\n    Args:\n        input: quantized input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iW)`\n        weight: quantized filters of shape :math:`(\\text{out\\_channels} , \\frac{\\text{in\\_channels}}{\\text{groups}} , iW)`\n        bias: **non-quantized** bias tensor of shape :math:`(\\text{out\\_channels})`. The tensor type must be `torch.float`.\n        stride: the stride of the convolving kernel. Can be a single number or a\n          tuple `(sW,)`. Default: 1\n        padding: implicit paddings on both sides of the input. Can be a\n          single number or a tuple `(padW,)`. Default: 0\n        dilation: the spacing between kernel elements. Can be a single number or\n          a tuple `(dW,)`. Default: 1\n        groups: split input into groups, :math:`\\text{in\\_channels}` should be divisible by the\n          number of groups. Default: 1\n        padding_mode: the padding mode to use. Only \"zeros\" is supported for quantized convolution at the moment. Default: \"zeros\"\n        scale: quantization scale for the output. Default: 1.0\n        zero_point: quantization zero_point for the output. Default: 0\n        dtype: quantization data type to use. Default: ``torch.quint8``\n\n    Examples::\n\n        >>> from torch.ao.nn.quantized import functional as qF\n        >>> filters = torch.randn(33, 16, 3, dtype=torch.float)\n        >>> inputs = torch.randn(20, 16, 50, dtype=torch.float)\n        >>> bias = torch.randn(33, dtype=torch.float)\n        >>>\n        >>> scale, zero_point = 1.0, 0\n        >>> dtype_inputs = torch.quint8\n        >>> dtype_filters = torch.qint8\n        >>>\n        >>> q_filters = torch.quantize_per_tensor(filters, scale, zero_point, dtype_filters)\n        >>> q_inputs = torch.quantize_per_tensor(inputs, scale, zero_point, dtype_inputs)\n        >>> qF.conv1d(q_inputs, q_filters, bias, padding=1, scale=scale, zero_point=zero_point)\n    ",
                  "Args": {
                    "input": {
                      "Type": null,
                      "Default": null
                    },
                    "weight": {
                      "Type": null,
                      "Default": null
                    },
                    "bias": {
                      "Type": null,
                      "Default": null
                    },
                    "stride": {
                      "Type": null,
                      "Default": "1"
                    },
                    "padding": {
                      "Type": null,
                      "Default": "0"
                    },
                    "dilation": {
                      "Type": null,
                      "Default": "1"
                    },
                    "groups": {
                      "Type": null,
                      "Default": "1"
                    },
                    "padding_mode": {
                      "Type": null,
                      "Default": "zeros"
                    },
                    "scale": {
                      "Type": null,
                      "Default": "1.0"
                    },
                    "zero_point": {
                      "Type": null,
                      "Default": "0"
                    },
                    "dtype": {
                      "Type": null,
                      "Default": "torch.quint8"
                    }
                  }
                },
                "conv2d": {
                  "Doc": "\n    Applies a 2D convolution over a quantized 2D input composed of several input\n    planes.\n\n    See :class:`~torch.ao.nn.quantized.Conv2d` for details and output shape.\n\n    Args:\n        input: quantized input tensor of shape :math:`(\\text{minibatch} , \\text{in\\_channels} , iH , iW)`\n        weight: quantized filters of shape :math:`(\\text{out\\_channels} , \\frac{\\text{in\\_channels}}{\\text{groups}} , kH , kW)`\n        bias: **non-quantized** bias tensor of shape :math:`(\\text{out\\_channels})`. The tensor type must be `torch.float`.\n        stride: the stride of the convolving kernel. Can be a single number or a\n          tuple `(sH, sW)`. Default: 1\n        padding: implicit paddings on both sides of the input. Can be a\n          single number or a tuple `(padH, padW)`. Default: 0\n        dilation: the spacing between kernel elements. Can be a single number or\n          a tuple `(dH, dW)`. Default: 1\n        groups: split input into groups, :math:`\\text{in\\_channels}` should be divisible by the\n          number of groups. Default: 1\n        padding_mode: the padding mode to use. Only \"zeros\" is supported for quantized convolution at the moment. Default: \"zeros\"\n        scale: quantization scale for the output. Default: 1.0\n        zero_point: quantization zero_point for the output. Default: 0\n        dtype: quantization data type to use. Default: ``torch.quint8``\n\n    Examples::\n\n        >>> from torch.ao.nn.quantized import functional as qF\n        >>> filters = torch.randn(8, 4, 3, 3, dtype=torch.float)\n        >>> inputs = torch.randn(1, 4, 5, 5, dtype=torch.float)\n        >>> bias = torch.randn(8, dtype=torch.float)\n        >>>\n        >>> scale, zero_point = 1.0, 0\n        >>> dtype_inputs = torch.quint8\n        >>> dtype_filters = torch.qint8\n        >>>\n        >>> q_filters = torch.quantize_per_tensor(filters, scale, zero_point, dtype_filters)\n        >>> q_inputs = torch.quantize_per_tensor(inputs, scale, zero_point, dtype_inputs)\n        >>> qF.conv2d(q_inputs, q_filters, bias, padding=1, scale=scale, zero_point=zero_point)\n    ",
                  "Args": {
                    "input": {
                      "Type": null,
                      "Default": null
                    },
                    "weight": {
                      "Type": null,
                      "Default": null
                    },
                    "bias": {
                      "Type": null,
                      "Default": null
                    },
                    "stride": {
                      "Type": null,
                      "Default": "1"
                    },
                    "padding": {
                      "Type": null,
                      "Default": "0"
                    },
                    "dilation": {
                      "Type": null,
                      "Default": "1"
                    },
                    "groups": {
                      "Type": null,
                      "Default": "1"
                    },
                    "padding_mode": {
                      "Type": null,
                      "Default": "zeros"
                    },
                    "scale": {
                      "Type": null,
                      "Default": "1.0"
                    },
                    "zero_point": {
                      "Type": null,
                      "Default": "0"
                    },
                    "dtype": {
                      "Type": null,
                      "Default": "torch.quint8"
                    }
                  }
                },
                "conv3d": {
                  "Doc": "\n    Applies a 3D convolution over a quantized 3D input composed of several input\n    planes.\n\n    See :class:`~torch.ao.nn.quantized.Conv3d` for details and output shape.\n\n    Args:\n        input: quantized input tensor of shape\n          :math:`(\\text{minibatch} , \\text{in\\_channels} , iD , iH , iW)`\n        weight: quantized filters of shape\n          :math:`(\\text{out\\_channels} , \\frac{\\text{in\\_channels}}{\\text{groups}} , kD , kH , kW)`\n        bias: **non-quantized** bias tensor of shape\n          :math:`(\\text{out\\_channels})`. The tensor type must be `torch.float`.\n        stride: the stride of the convolving kernel. Can be a single number or a\n          tuple `(sD, sH, sW)`. Default: 1\n        padding: implicit paddings on both sides of the input. Can be a\n          single number or a tuple `(padD, padH, padW)`. Default: 0\n        dilation: the spacing between kernel elements. Can be a single number or\n          a tuple `(dD, dH, dW)`. Default: 1\n        groups: split input into groups, :math:`\\text{in\\_channels}` should be\n          divisible by the number of groups. Default: 1\n        padding_mode: the padding mode to use. Only \"zeros\" is supported for\n          quantized convolution at the moment. Default: \"zeros\"\n        scale: quantization scale for the output. Default: 1.0\n        zero_point: quantization zero_point for the output. Default: 0\n        dtype: quantization data type to use. Default: ``torch.quint8``\n\n    Examples::\n\n        >>> from torch.ao.nn.quantized import functional as qF\n        >>> filters = torch.randn(8, 4, 3, 3, 3, dtype=torch.float)\n        >>> inputs = torch.randn(1, 4, 5, 5, 5, dtype=torch.float)\n        >>> bias = torch.randn(8, dtype=torch.float)\n        >>>\n        >>> scale, zero_point = 1.0, 0\n        >>> dtype_inputs = torch.quint8\n        >>> dtype_filters = torch.qint8\n        >>>\n        >>> q_filters = torch.quantize_per_tensor(filters, scale, zero_point, dtype_filters)\n        >>> q_inputs = torch.quantize_per_tensor(inputs, scale, zero_point, dtype_inputs)\n        >>> qF.conv3d(q_inputs, q_filters, bias, padding=1, scale=scale, zero_point=zero_point)\n    ",
                  "Args": {
                    "input": {
                      "Type": null,
                      "Default": null
                    },
                    "weight": {
                      "Type": null,
                      "Default": null
                    },
                    "bias": {
                      "Type": null,
                      "Default": null
                    },
                    "stride": {
                      "Type": null,
                      "Default": "1"
                    },
                    "padding": {
                      "Type": null,
                      "Default": "0"
                    },
                    "dilation": {
                      "Type": null,
                      "Default": "1"
                    },
                    "groups": {
                      "Type": null,
                      "Default": "1"
                    },
                    "padding_mode": {
                      "Type": null,
                      "Default": "zeros"
                    },
                    "scale": {
                      "Type": null,
                      "Default": "1.0"
                    },
                    "zero_point": {
                      "Type": null,
                      "Default": "0"
                    },
                    "dtype": {
                      "Type": null,
                      "Default": "torch.quint8"
                    }
                  }
                },
                "elu": {
                  "Doc": "This is the quantized version of :func:`~torch.nn.functional.elu`.\n\n    Args:\n        input: quantized input\n        scale: quantization scale of the output tensor\n        zero_point: quantization zero point of the output tensor\n        alpha: the alpha constant\n    ",
                  "Args": {
                    "input": {
                      "Type": "<class 'torch.Tensor'>",
                      "Default": null
                    },
                    "scale": {
                      "Type": "<class 'float'>",
                      "Default": null
                    },
                    "zero_point": {
                      "Type": "<class 'int'>",
                      "Default": null
                    },
                    "alpha": {
                      "Type": "<class 'float'>",
                      "Default": "1.0"
                    }
                  }
                },
                "hardsigmoid": {
                  "Doc": "This is the quantized version of :func:`~torch.nn.functional.hardsigmoid`.\n    ",
                  "Args": {
                    "input": {
                      "Type": "<class 'torch.Tensor'>",
                      "Default": null
                    },
                    "inplace": {
                      "Type": "<class 'bool'>",
                      "Default": "False"
                    }
                  }
                },
                "hardswish": {
                  "Doc": "This is the quantized version of :func:`~torch.nn.functional.hardswish`.\n\n    Args:\n        input: quantized input\n        scale: quantization scale of the output tensor\n        zero_point: quantization zero point of the output tensor\n    ",
                  "Args": {
                    "input": {
                      "Type": "<class 'torch.Tensor'>",
                      "Default": null
                    },
                    "scale": {
                      "Type": "<class 'float'>",
                      "Default": null
                    },
                    "zero_point": {
                      "Type": "<class 'int'>",
                      "Default": null
                    }
                  }
                },
                "hardtanh": {
                  "Doc": "This is the quantized version of :func:`~torch.nn.functional.hardtanh`.\n    ",
                  "Args": {
                    "input": {
                      "Type": "<class 'torch.Tensor'>",
                      "Default": null
                    },
                    "min_val": {
                      "Type": "<class 'float'>",
                      "Default": "-1.0"
                    },
                    "max_val": {
                      "Type": "<class 'float'>",
                      "Default": "1.0"
                    },
                    "inplace": {
                      "Type": "<class 'bool'>",
                      "Default": "False"
                    }
                  }
                },
                "interpolate": {
                  "Doc": "Down/up samples the input to either the given :attr:`size` or the given\n    :attr:`scale_factor`\n\n    See :func:`torch.nn.functional.interpolate` for implementation details.\n\n    The input dimensions are interpreted in the form:\n    `mini-batch x channels x [optional depth] x [optional height] x width`.\n\n    .. note:: The input quantization parameters propagate to the output.\n\n    .. note:: Only 2D/3D input is supported for quantized inputs\n\n    .. note:: Only the following modes are supported for the quantized inputs:\n\n        - `bilinear`\n        - `nearest`\n\n    Args:\n        input (Tensor): the input tensor\n        size (int or Tuple[int] or Tuple[int, int] or Tuple[int, int, int]):\n            output spatial size.\n        scale_factor (float or Tuple[float]): multiplier for spatial size. Has to match input size if it is a tuple.\n        mode (str): algorithm used for upsampling:\n            ``'nearest'`` | ``'bilinear'``\n        align_corners (bool, optional): Geometrically, we consider the pixels of the\n            input and output as squares rather than points.\n            If set to ``True``, the input and output tensors are aligned by the\n            center points of their corner pixels, preserving the values at the corner pixels.\n            If set to ``False``, the input and output tensors are aligned by the corner\n            points of their corner pixels, and the interpolation uses edge value padding\n            for out-of-boundary values, making this operation *independent* of input size\n            when :attr:`scale_factor` is kept the same. This only has an effect when :attr:`mode`\n            is ``'bilinear'``.\n            Default: ``False``\n    ",
                  "Args": {
                    "input": {
                      "Type": null,
                      "Default": null
                    },
                    "size": {
                      "Type": null,
                      "Default": "None"
                    },
                    "scale_factor": {
                      "Type": null,
                      "Default": "None"
                    },
                    "mode": {
                      "Type": null,
                      "Default": "nearest"
                    },
                    "align_corners": {
                      "Type": null,
                      "Default": "None"
                    }
                  }
                },
                "leaky_relu": {
                  "Doc": "\n    Quantized version of the.\n    leaky_relu(input, negative_slope=0.01, inplace=False, scale, zero_point) -> Tensor\n\n    Applies element-wise,\n    :math:`\\text{LeakyReLU}(x) = \\max(0, x) + \\text{negative\\_slope} * \\min(0, x)`\n\n    Args:\n        input: Quaintized input\n        negative_slope: The slope of the negative input\n        inplace: Inplace modification of the input tensor\n        scale, zero_point: Scale and zero point of the output tensor.\n\n    See :class:`~torch.nn.LeakyReLU` for more details.\n    ",
                  "Args": {
                    "input": {
                      "Type": "<class 'torch.Tensor'>",
                      "Default": null
                    },
                    "negative_slope": {
                      "Type": "<class 'float'>",
                      "Default": "0.01"
                    },
                    "inplace": {
                      "Type": "<class 'bool'>",
                      "Default": "False"
                    },
                    "scale": {
                      "Type": "typing.Optional[float]",
                      "Default": "None"
                    },
                    "zero_point": {
                      "Type": "typing.Optional[int]",
                      "Default": "None"
                    }
                  }
                },
                "linear": {
                  "Doc": "\n    Applies a linear transformation to the incoming quantized data:\n    :math:`y = xA^T + b`.\n    See :class:`~torch.ao.nn.quantized.Linear`\n\n    .. note::\n\n      Current implementation packs weights on every call, which has penalty on performance.\n      If you want to avoid the overhead, use :class:`~torch.ao.nn.quantized.Linear`.\n\n    Args:\n      input (Tensor): Quantized input of type `torch.quint8`\n      weight (Tensor): Quantized weight of type `torch.qint8`\n      bias (Tensor): None or fp32 bias of type `torch.float`\n      scale (double): output scale. If None, derived from the input scale\n      zero_point (long): output zero point. If None, derived from the input zero_point\n\n    Shape:\n        - Input: :math:`(N, *, in\\_features)` where `*` means any number of\n          additional dimensions\n        - Weight: :math:`(out\\_features, in\\_features)`\n        - Bias: :math:`(out\\_features)`\n        - Output: :math:`(N, *, out\\_features)`\n    ",
                  "Args": {
                    "input": {
                      "Type": "<class 'torch.Tensor'>",
                      "Default": null
                    },
                    "weight": {
                      "Type": "<class 'torch.Tensor'>",
                      "Default": null
                    },
                    "bias": {
                      "Type": "typing.Optional[torch.Tensor]",
                      "Default": "None"
                    },
                    "scale": {
                      "Type": "typing.Optional[float]",
                      "Default": "None"
                    },
                    "zero_point": {
                      "Type": "typing.Optional[int]",
                      "Default": "None"
                    }
                  }
                },
                "max_pool1d": {
                  "Doc": "Applies a 1D max pooling over a quantized input signal composed of\n    several quantized input planes.\n\n    .. note:: The input quantization parameters are propagated to the output.\n\n    See :class:`~torch.ao.nn.quantized.MaxPool1d` for details.\n    ",
                  "Args": {
                    "input": {
                      "Type": null,
                      "Default": null
                    },
                    "kernel_size": {
                      "Type": null,
                      "Default": null
                    },
                    "stride": {
                      "Type": null,
                      "Default": "None"
                    },
                    "padding": {
                      "Type": null,
                      "Default": "0"
                    },
                    "dilation": {
                      "Type": null,
                      "Default": "1"
                    },
                    "ceil_mode": {
                      "Type": null,
                      "Default": "False"
                    },
                    "return_indices": {
                      "Type": null,
                      "Default": "False"
                    }
                  }
                },
                "max_pool2d": {
                  "Doc": "Applies a 2D max pooling over a quantized input signal composed of\n    several quantized input planes.\n\n    .. note:: The input quantization parameters are propagated to the output.\n\n    See :class:`~torch.ao.nn.quantized.MaxPool2d` for details.\n    ",
                  "Args": {
                    "input": {
                      "Type": null,
                      "Default": null
                    },
                    "kernel_size": {
                      "Type": null,
                      "Default": null
                    },
                    "stride": {
                      "Type": null,
                      "Default": "None"
                    },
                    "padding": {
                      "Type": null,
                      "Default": "0"
                    },
                    "dilation": {
                      "Type": null,
                      "Default": "1"
                    },
                    "ceil_mode": {
                      "Type": null,
                      "Default": "False"
                    },
                    "return_indices": {
                      "Type": null,
                      "Default": "False"
                    }
                  }
                },
                "threshold": {
                  "Doc": "Applies the quantized version of the threshold function element-wise:\n\n    .. math::\n        x = \\begin{cases}\n                x & \\text{if~} x > \\text{threshold} \\\\\n                \\text{value} & \\text{otherwise}\n            \\end{cases}\n\n    See :class:`~torch.nn.Threshold` for more details.\n    ",
                  "Args": {
                    "input": {
                      "Type": "<class 'torch.Tensor'>",
                      "Default": null
                    },
                    "threshold": {
                      "Type": "<class 'float'>",
                      "Default": null
                    },
                    "value": {
                      "Type": "<class 'float'>",
                      "Default": null
                    }
                  }
                },
                "upsample": {
                  "Doc": "Upsamples the input to either the given :attr:`size` or the given\n    :attr:`scale_factor`\n\n    .. warning::\n        This function is deprecated in favor of\n        :func:`torch.nn.quantized.functional.interpolate`.\n        This is equivalent with ``nn.quantized.functional.interpolate(...)``.\n\n    See :func:`torch.nn.functional.interpolate` for implementation details.\n\n    The input dimensions are interpreted in the form:\n    `mini-batch x channels x [optional depth] x [optional height] x width`.\n\n    .. note:: The input quantization parameters propagate to the output.\n\n    .. note:: Only 2D input is supported for quantized inputs\n\n    .. note:: Only the following modes are supported for the quantized inputs:\n\n        - `bilinear`\n        - `nearest`\n\n    Args:\n        input (Tensor): quantized input tensor\n        size (int or Tuple[int] or Tuple[int, int] or Tuple[int, int, int]):\n            output spatial size.\n        scale_factor (float or Tuple[float]): multiplier for spatial size. Has to be an integer.\n        mode (str): algorithm used for upsampling:\n            ``'nearest'`` | ``'bilinear'``\n        align_corners (bool, optional): Geometrically, we consider the pixels of the\n            input and output as squares rather than points.\n            If set to ``True``, the input and output tensors are aligned by the\n            center points of their corner pixels, preserving the values at the corner pixels.\n            If set to ``False``, the input and output tensors are aligned by the corner\n            points of their corner pixels, and the interpolation uses edge value padding\n            for out-of-boundary values, making this operation *independent* of input size\n            when :attr:`scale_factor` is kept the same. This only has an effect when :attr:`mode`\n            is ``'bilinear'``.\n            Default: ``False``\n\n    .. warning::\n        With ``align_corners = True``, the linearly interpolating modes\n        (`bilinear`) don't proportionally align the\n        output and input pixels, and thus the output values can depend on the\n        input size. This was the default behavior for these modes up to version\n        0.3.1. Since then, the default behavior is ``align_corners = False``.\n        See :class:`~torch.nn.Upsample` for concrete examples on how this\n        affects the outputs.\n    ",
                  "Args": {
                    "input": {
                      "Type": null,
                      "Default": null
                    },
                    "size": {
                      "Type": null,
                      "Default": "None"
                    },
                    "scale_factor": {
                      "Type": null,
                      "Default": "None"
                    },
                    "mode": {
                      "Type": null,
                      "Default": "nearest"
                    },
                    "align_corners": {
                      "Type": null,
                      "Default": "None"
                    }
                  }
                },
                "upsample_bilinear": {
                  "Doc": "Upsamples the input, using bilinear upsampling.\n\n    .. warning::\n        This function is deprecated in favor of\n        :func:`torch.nn.quantized.functional.interpolate`.\n        This is equivalent with\n        ``nn.quantized.functional.interpolate(..., mode='bilinear', align_corners=True)``.\n\n    .. note:: The input quantization parameters propagate to the output.\n\n    .. note:: Only 2D inputs are supported\n\n    Args:\n        input (Tensor): quantized input\n        size (int or Tuple[int, int]): output spatial size.\n        scale_factor (int or Tuple[int, int]): multiplier for spatial size\n    ",
                  "Args": {
                    "input": {
                      "Type": null,
                      "Default": null
                    },
                    "size": {
                      "Type": null,
                      "Default": "None"
                    },
                    "scale_factor": {
                      "Type": null,
                      "Default": "None"
                    }
                  }
                },
                "upsample_nearest": {
                  "Doc": "Upsamples the input, using nearest neighbours' pixel values.\n\n    .. warning::\n        This function is deprecated in favor of\n        :func:`torch.nn.quantized.functional.interpolate`.\n        This is equivalent with ``nn.quantized.functional.interpolate(..., mode='nearest')``.\n\n    .. note:: The input quantization parameters propagate to the output.\n\n    .. note:: Only 2D inputs are supported\n\n    Args:\n        input (Tensor): quantized input\n        size (int or Tuple[int, int] or Tuple[int, int, int]): output spatial\n            size.\n        scale_factor (int): multiplier for spatial size. Has to be an integer.\n    ",
                  "Args": {
                    "input": {
                      "Type": null,
                      "Default": null
                    },
                    "size": {
                      "Type": null,
                      "Default": "None"
                    },
                    "scale_factor": {
                      "Type": null,
                      "Default": "None"
                    }
                  }
                }
              }
            },
            "modules": {
              "Doc": "Quantized Modules\n\nNote::\n    The `torch.nn.quantized` namespace is in the process of being deprecated.\n    Please, use `torch.ao.nn.quantized` instead.\n"
            }
          }
        },
        "utils": {
          "Doc": null,
          "Modules": {
            "clip_grad": {
              "Doc": null,
              "Functions": {
                "clip_grad_norm": {
                  "Doc": "Clips gradient norm of an iterable of parameters.\n\n    .. warning::\n        This method is now deprecated in favor of\n        :func:`torch.nn.utils.clip_grad_norm_`.\n    ",
                  "Args": {
                    "parameters": {
                      "Type": "typing.Union[torch.Tensor, typing.Iterable[torch.Tensor]]",
                      "Default": null
                    },
                    "max_norm": {
                      "Type": "<class 'float'>",
                      "Default": null
                    },
                    "norm_type": {
                      "Type": "<class 'float'>",
                      "Default": "2.0"
                    },
                    "error_if_nonfinite": {
                      "Type": "<class 'bool'>",
                      "Default": "False"
                    }
                  }
                }
              }
            },
            "convert_parameters": {
              "Doc": null,
              "Functions": {
                "parameters_to_vector": {
                  "Doc": "Convert parameters to one vector\n\n    Args:\n        parameters (Iterable[Tensor]): an iterator of Tensors that are the\n            parameters of a model.\n\n    Returns:\n        The parameters represented by a single vector\n    ",
                  "Args": {
                    "parameters": {
                      "Type": "typing.Iterable[torch.Tensor]",
                      "Default": null
                    }
                  }
                },
                "vector_to_parameters": {
                  "Doc": "Convert one vector to the parameters\n\n    Args:\n        vec (Tensor): a single vector represents the parameters of a model.\n        parameters (Iterable[Tensor]): an iterator of Tensors that are the\n            parameters of a model.\n    ",
                  "Args": {
                    "vec": {
                      "Type": "<class 'torch.Tensor'>",
                      "Default": null
                    },
                    "parameters": {
                      "Type": "typing.Iterable[torch.Tensor]",
                      "Default": null
                    }
                  }
                }
              }
            },
            "fusion": {
              "Doc": null,
              "Functions": {
                "fuse_conv_bn_eval": {
                  "Doc": null,
                  "Args": {
                    "conv": {
                      "Type": null,
                      "Default": null
                    },
                    "bn": {
                      "Type": null,
                      "Default": null
                    },
                    "transpose": {
                      "Type": null,
                      "Default": "False"
                    }
                  }
                },
                "fuse_conv_bn_weights": {
                  "Doc": null,
                  "Args": {
                    "conv_w": {
                      "Type": null,
                      "Default": null
                    },
                    "conv_b": {
                      "Type": null,
                      "Default": null
                    },
                    "bn_rm": {
                      "Type": null,
                      "Default": null
                    },
                    "bn_rv": {
                      "Type": null,
                      "Default": null
                    },
                    "bn_eps": {
                      "Type": null,
                      "Default": null
                    },
                    "bn_w": {
                      "Type": null,
                      "Default": null
                    },
                    "bn_b": {
                      "Type": null,
                      "Default": null
                    },
                    "transpose": {
                      "Type": null,
                      "Default": "False"
                    }
                  }
                },
                "fuse_linear_bn_eval": {
                  "Doc": null,
                  "Args": {
                    "linear": {
                      "Type": null,
                      "Default": null
                    },
                    "bn": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "fuse_linear_bn_weights": {
                  "Doc": null,
                  "Args": {
                    "linear_w": {
                      "Type": null,
                      "Default": null
                    },
                    "linear_b": {
                      "Type": null,
                      "Default": null
                    },
                    "bn_rm": {
                      "Type": null,
                      "Default": null
                    },
                    "bn_rv": {
                      "Type": null,
                      "Default": null
                    },
                    "bn_eps": {
                      "Type": null,
                      "Default": null
                    },
                    "bn_w": {
                      "Type": null,
                      "Default": null
                    },
                    "bn_b": {
                      "Type": null,
                      "Default": null
                    }
                  }
                }
              }
            },
            "init": {
              "Doc": null,
              "Functions": {
                "skip_init": {
                  "Doc": "\n    Given a module class object and args / kwargs, instantiates the module without initializing\n    parameters / buffers.  This can be useful if initialization is slow or if custom initialization will\n    be performed, making the default initialization unnecessary. There are some caveats to this, due to\n    the way this function is implemented:\n\n    1. The module must accept a `device` arg in its constructor that is passed to any parameters\n    or buffers created during construction.\n\n    2. The module must not perform any computation on parameters in its constructor except\n    initialization (i.e. functions from :mod:`torch.nn.init`).\n\n    If these conditions are satisfied, the module can be instantiated with parameter / buffer values\n    uninitialized, as if having been created using :func:`torch.empty`.\n\n    Args:\n        module_cls: Class object; should be a subclass of :class:`torch.nn.Module`\n        args: args to pass to the module's constructor\n        kwargs: kwargs to pass to the module's constructor\n\n    Returns:\n        Instantiated module with uninitialized parameters / buffers\n\n    Example::\n\n        >>> import torch\n        >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\")\n        >>> m = torch.nn.utils.skip_init(torch.nn.Linear, 5, 1)\n        >>> m.weight\n        Parameter containing:\n        tensor([[0.0000e+00, 1.5846e+29, 7.8307e+00, 2.5250e-29, 1.1210e-44]],\n               requires_grad=True)\n        >>> m2 = torch.nn.utils.skip_init(torch.nn.Linear, in_features=6, out_features=1)\n        >>> m2.weight\n        Parameter containing:\n        tensor([[-1.4677e+24,  4.5915e-41,  1.4013e-45,  0.0000e+00, -1.4677e+24,\n                  4.5915e-41]], requires_grad=True)\n\n    ",
                  "Args": {
                    "module_cls": {
                      "Type": null,
                      "Default": null
                    },
                    "*args": {
                      "Type": null,
                      "Default": null
                    },
                    "**kwargs": {
                      "Type": null,
                      "Default": null
                    }
                  }
                }
              }
            },
            "memory_format": {
              "Doc": null,
              "Functions": {
                "convert_conv2d_weight_memory_format": {
                  "Doc": "Convert ``memory_format`` of ``nn.Conv2d.weight`` to ``memory_format``\n    The conversion recursively applies to nested ``nn.Module``, including ``module``.\n    Note that it only changes the memory_format, but not the semantics of each dimensions.\n    This function is used to facilitate the computation to adopt NHWC kernels, which\n    provides considerable speed up for fp16 data on CUDA devices with compute capability >= 7.0\n\n    .. note::\n        Calling ``model.to(memory_format=torch.channels_last)`` is more aggressive\n        than the utility function ``convert_conv2d_weight_memory_format``. Any\n        layer with 4d weight will be affected by ``model.to``, which does not\n        necessarily benefit from conversion to specified ``memory_format``.\n        One place we are confident in is that NHWC(channels_last) conversion for\n        convolution in cuDNN, As it is beneficial to run convolution in NHWC,\n        even in cases where we have to apply permutation to input tensors.\n\n        Hence our strategy here is to convert only the weight of convolution to\n        channels_last. This ensures that;\n        1. Fast convolution kernels will be used, the benefit of which could\n           outweigh overhead of permutation (if input is not in the same format)\n        2. No unnecessary permutations are applied on layers that do not benefit\n           from memory_format conversion.\n\n        The optimal case is that, layers between convolution layers are channels\n        last compatible. Input tensor would be permuted to channels last when it\n        encounters the first convolution layer and stay in that memory format.\n        Hence following convolutions will not need to permute its input tensor.\n\n        In case where a channels last incompatible layer is between convolution\n        layers, we need to permute the input tensor back to contiguous format\n        for that layer. The input tensor will go through the remaining layers in\n        contiguous format and be permuted to channels last when it encounters\n        another convolution layer. There's no point in propagating that\n        permutation to an earlier layer, as most layers are quite agnostic to\n        ``memory_format``.\n\n        This claim might change when PyTorch supports fusion of permutation, as\n        there might have been a better spot to fuse the permutation other than\n        immediately before a convolution.\n\n    Args:\n        module (nn.Module): ``nn.Conv2d`` & ``nn.ConvTranspose2d``  or container\n                            ``nn.Module``\n        format: user specified ``memory_format``,\n            e.g. ``torch.channels_last`` or ``torch.contiguous_format``\n\n    Returns:\n        The original module with updated ``nn.Conv2d``\n\n    Example:\n        >>> # xdoctest: +REQUIRES(env:CUBLAS_WORKSPACE_CONFIG)\n        >>> input = torch.randint(1, 10, (2, 8, 4, 4), dtype=torch.float16, device=\"cuda\")\n        >>> model = nn.Sequential(\n        >>>     nn.Conv2d(8, 4, 3)).cuda().half()\n        >>> # This is identical to:\n        >>> # nn.utils.convert_conv2d_weight_memory_format(model, torch.channels_last)\n        >>> model = nn.utils.convert_conv2d_weight_memory_format(model, torch.channels_last)\n        >>> out = model(input)\n    ",
                  "Args": {
                    "module": {
                      "Type": null,
                      "Default": null
                    },
                    "memory_format": {
                      "Type": null,
                      "Default": null
                    }
                  }
                }
              }
            },
            "parametrizations": {
              "Doc": null,
              "Functions": {
                "orthogonal": {
                  "Doc": "Applies an orthogonal or unitary parametrization to a matrix or a batch of matrices.\n\n    Letting :math:`\\mathbb{K}` be :math:`\\mathbb{R}` or :math:`\\mathbb{C}`, the parametrized\n    matrix :math:`Q \\in \\mathbb{K}^{m \\times n}` is **orthogonal** as\n\n    .. math::\n\n        \\begin{align*}\n            Q^{\\text{H}}Q &= \\mathrm{I}_n \\mathrlap{\\qquad \\text{if }m \\geq n}\\\\\n            QQ^{\\text{H}} &= \\mathrm{I}_m \\mathrlap{\\qquad \\text{if }m < n}\n        \\end{align*}\n\n    where :math:`Q^{\\text{H}}` is the conjugate transpose when :math:`Q` is complex\n    and the transpose when :math:`Q` is real-valued, and\n    :math:`\\mathrm{I}_n` is the `n`-dimensional identity matrix.\n    In plain words, :math:`Q` will have orthonormal columns whenever :math:`m \\geq n`\n    and orthonormal rows otherwise.\n\n    If the tensor has more than two dimensions, we consider it as a batch of matrices of shape `(..., m, n)`.\n\n    The matrix :math:`Q` may be parametrized via three different ``orthogonal_map`` in terms of the original tensor:\n\n    - ``\"matrix_exp\"``/``\"cayley\"``:\n      the :func:`~torch.matrix_exp` :math:`Q = \\exp(A)` and the `Cayley map`_\n      :math:`Q = (\\mathrm{I}_n + A/2)(\\mathrm{I}_n - A/2)^{-1}` are applied to a skew-symmetric\n      :math:`A` to give an orthogonal matrix.\n    - ``\"householder\"``: computes a product of Householder reflectors\n      (:func:`~torch.linalg.householder_product`).\n\n    ``\"matrix_exp\"``/``\"cayley\"`` often make the parametrized weight converge faster than\n    ``\"householder\"``, but they are slower to compute for very thin or very wide matrices.\n\n    If ``use_trivialization=True`` (default), the parametrization implements the \"Dynamic Trivialization Framework\",\n    where an extra matrix :math:`B \\in \\mathbb{K}^{n \\times n}` is stored under\n    ``module.parametrizations.weight[0].base``. This helps the\n    convergence of the parametrized layer at the expense of some extra memory use.\n    See `Trivializations for Gradient-Based Optimization on Manifolds`_ .\n\n    Initial value of :math:`Q`:\n    If the original tensor is not parametrized and ``use_trivialization=True`` (default), the initial value\n    of :math:`Q` is that of the original tensor if it is orthogonal (or unitary in the complex case)\n    and it is orthogonalized via the QR decomposition otherwise (see :func:`torch.linalg.qr`).\n    Same happens when it is not parametrized and ``orthogonal_map=\"householder\"`` even when ``use_trivialization=False``.\n    Otherwise, the initial value is the result of the composition of all the registered\n    parametrizations applied to the original tensor.\n\n    .. note::\n        This function is implemented using the parametrization functionality\n        in :func:`~torch.nn.utils.parametrize.register_parametrization`.\n\n\n    .. _`Cayley map`: https://en.wikipedia.org/wiki/Cayley_transform#Matrix_map\n    .. _`Trivializations for Gradient-Based Optimization on Manifolds`: https://arxiv.org/abs/1909.09501\n\n    Args:\n        module (nn.Module): module on which to register the parametrization.\n        name (str, optional): name of the tensor to make orthogonal. Default: ``\"weight\"``.\n        orthogonal_map (str, optional): One of the following: ``\"matrix_exp\"``, ``\"cayley\"``, ``\"householder\"``.\n            Default: ``\"matrix_exp\"`` if the matrix is square or complex, ``\"householder\"`` otherwise.\n        use_trivialization (bool, optional): whether to use the dynamic trivialization framework.\n            Default: ``True``.\n\n    Returns:\n        The original module with an orthogonal parametrization registered to the specified\n        weight\n\n    Example::\n\n        >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_LAPACK)\n        >>> orth_linear = orthogonal(nn.Linear(20, 40))\n        >>> orth_linear\n        ParametrizedLinear(\n        in_features=20, out_features=40, bias=True\n        (parametrizations): ModuleDict(\n            (weight): ParametrizationList(\n            (0): _Orthogonal()\n            )\n        )\n        )\n        >>> # xdoctest: +IGNORE_WANT\n        >>> Q = orth_linear.weight\n        >>> torch.dist(Q.T @ Q, torch.eye(20))\n        tensor(4.9332e-07)\n    ",
                  "Args": {
                    "module": {
                      "Type": "<class 'torch.nn.modules.module.Module'>",
                      "Default": null
                    },
                    "name": {
                      "Type": "<class 'str'>",
                      "Default": "weight"
                    },
                    "orthogonal_map": {
                      "Type": "typing.Optional[str]",
                      "Default": "None"
                    },
                    "use_trivialization": {
                      "Type": "<class 'bool'>",
                      "Default": "True"
                    }
                  }
                },
                "spectral_norm": {
                  "Doc": "Applies spectral normalization to a parameter in the given module.\n\n    .. math::\n        \\mathbf{W}_{SN} = \\dfrac{\\mathbf{W}}{\\sigma(\\mathbf{W})},\n        \\sigma(\\mathbf{W}) = \\max_{\\mathbf{h}: \\mathbf{h} \\ne 0} \\dfrac{\\|\\mathbf{W} \\mathbf{h}\\|_2}{\\|\\mathbf{h}\\|_2}\n\n    When applied on a vector, it simplifies to\n\n    .. math::\n        \\mathbf{x}_{SN} = \\dfrac{\\mathbf{x}}{\\|\\mathbf{x}\\|_2}\n\n    Spectral normalization stabilizes the training of discriminators (critics)\n    in Generative Adversarial Networks (GANs) by reducing the Lipschitz constant\n    of the model. :math:`\\sigma` is approximated performing one iteration of the\n    `power method`_ every time the weight is accessed. If the dimension of the\n    weight tensor is greater than 2, it is reshaped to 2D in power iteration\n    method to get spectral norm.\n\n\n    See `Spectral Normalization for Generative Adversarial Networks`_ .\n\n    .. _`power method`: https://en.wikipedia.org/wiki/Power_iteration\n    .. _`Spectral Normalization for Generative Adversarial Networks`: https://arxiv.org/abs/1802.05957\n\n    .. note::\n        This function is implemented using the parametrization functionality\n        in :func:`~torch.nn.utils.parametrize.register_parametrization`. It is a\n        reimplementation of :func:`torch.nn.utils.spectral_norm`.\n\n    .. note::\n        When this constraint is registered, the singular vectors associated to the largest\n        singular value are estimated rather than sampled at random. These are then updated\n        performing :attr:`n_power_iterations` of the `power method`_ whenever the tensor\n        is accessed with the module on `training` mode.\n\n    .. note::\n        If the `_SpectralNorm` module, i.e., `module.parametrization.weight[idx]`,\n        is in training mode on removal, it will perform another power iteration.\n        If you'd like to avoid this iteration, set the module to eval mode\n        before its removal.\n\n    Args:\n        module (nn.Module): containing module\n        name (str, optional): name of weight parameter. Default: ``\"weight\"``.\n        n_power_iterations (int, optional): number of power iterations to\n            calculate spectral norm. Default: ``1``.\n        eps (float, optional): epsilon for numerical stability in\n            calculating norms. Default: ``1e-12``.\n        dim (int, optional): dimension corresponding to number of outputs.\n            Default: ``0``, except for modules that are instances of\n            ConvTranspose{1,2,3}d, when it is ``1``\n\n    Returns:\n        The original module with a new parametrization registered to the specified\n        weight\n\n    Example::\n\n        >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_LAPACK)\n        >>> # xdoctest: +IGNORE_WANT(\"non-determenistic\")\n        >>> snm = spectral_norm(nn.Linear(20, 40))\n        >>> snm\n        ParametrizedLinear(\n          in_features=20, out_features=40, bias=True\n          (parametrizations): ModuleDict(\n            (weight): ParametrizationList(\n              (0): _SpectralNorm()\n            )\n          )\n        )\n        >>> torch.linalg.matrix_norm(snm.weight, 2)\n        tensor(1.0081, grad_fn=<AmaxBackward0>)\n    ",
                  "Args": {
                    "module": {
                      "Type": "<class 'torch.nn.modules.module.Module'>",
                      "Default": null
                    },
                    "name": {
                      "Type": "<class 'str'>",
                      "Default": "weight"
                    },
                    "n_power_iterations": {
                      "Type": "<class 'int'>",
                      "Default": "1"
                    },
                    "eps": {
                      "Type": "<class 'float'>",
                      "Default": "1e-12"
                    },
                    "dim": {
                      "Type": "typing.Optional[int]",
                      "Default": "None"
                    }
                  }
                }
              }
            },
            "parametrize": {
              "Doc": null,
              "Classes": {
                "ParametrizationList": {
                  "Doc": "A sequential container that holds and manages the ``original`` or ``original0``, ``original1``, ...\n    parameters or buffers of a parametrized :class:`torch.nn.Module`.\n\n    It is the type of ``module.parametrizations[tensor_name]`` when ``module[tensor_name]``\n    has been parametrized with :func:`register_parametrization`.\n\n    If the first registered parmetrization has a ``right_inverse`` that returns one tensor or\n    does not have a ``right_inverse`` (in which case we assume that ``right_inverse`` is the identity),\n    it will hold the tensor under the name ``original``.\n    If it has a ``right_inverse`` that returns more than one tensor, these will be registered as\n    ``original0``, ``original1``, ...\n\n    .. warning::\n        This class is used internally by :func:`register_parametrization`. It is documented\n        here for completeness. It shall not be instantiated by the user.\n\n    Args:\n        modules (sequence): sequence of modules representing the parametrizations\n        original (Parameter or Tensor): parameter or buffer that is parametrized\n        unsafe (bool): a boolean flag that denotes whether the parametrization\n            may change the dtype and shape of the tensor. Default: `False`\n            Warning: the parametrization is not checked for consistency upon registration.\n            Enable this flag at your own risk.\n    ",
                  "Functions": {
                    "__init__": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "modules": {
                          "Type": "typing.Sequence[torch.nn.modules.module.Module]",
                          "Default": null
                        },
                        "original": {
                          "Type": "typing.Union[torch.Tensor, torch.nn.parameter.Parameter]",
                          "Default": null
                        },
                        "unsafe": {
                          "Type": "<class 'bool'>",
                          "Default": "False"
                        }
                      }
                    },
                    "forward": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "right_inverse": {
                      "Doc": "Calls the methods ``right_inverse`` (see :func:`register_parametrization`)\n        of the parametrizations in the inverse order they were registered in.\n        Then, it stores the result in ``self.original`` if ``right_inverse`` outputs one tensor\n        or in ``self.original0``, ``self.original1``, ... if it outputs several.\n\n        Args:\n            value (Tensor): Value to which initialize the module\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "value": {
                          "Type": "<class 'torch.Tensor'>",
                          "Default": null
                        }
                      }
                    }
                  }
                }
              },
              "Functions": {
                "cached": {
                  "Doc": "Context manager that enables the caching system within parametrizations\n    registered with :func:`register_parametrization`.\n\n    The value of the parametrized objects is computed and cached the first time\n    they are required when this context manager is active. The cached values are\n    discarded when leaving the context manager.\n\n    This is useful when using a parametrized parameter more than once in the forward pass.\n    An example of this is when parametrizing the recurrent kernel of an RNN or when\n    sharing weights.\n\n    The simplest way to activate the cache is by wrapping the forward pass of the neural network\n\n    .. code-block:: python\n\n        import torch.nn.utils.parametrize as P\n        ...\n        with P.cached():\n            output = model(inputs)\n\n    in training and evaluation. One may also wrap the parts of the modules that use\n    several times the parametrized tensors. For example, the loop of an RNN with a\n    parametrized recurrent kernel:\n\n    .. code-block:: python\n\n        with P.cached():\n            for x in xs:\n                out_rnn = self.rnn_cell(x, out_rnn)\n    ",
                  "Args": {
                    "*args": {
                      "Type": null,
                      "Default": null
                    },
                    "**kwds": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "contextmanager": {
                  "Doc": "@contextmanager decorator.\n\n    Typical usage:\n\n        @contextmanager\n        def some_generator(<arguments>):\n            <setup>\n            try:\n                yield <value>\n            finally:\n                <cleanup>\n\n    This makes this:\n\n        with some_generator(<arguments>) as <variable>:\n            <body>\n\n    equivalent to this:\n\n        <setup>\n        try:\n            <variable> = <value>\n            <body>\n        finally:\n            <cleanup>\n    ",
                  "Args": {
                    "func": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "deepcopy": {
                  "Doc": "Deep copy operation on arbitrary Python objects.\n\n    See the module's __doc__ string for more info.\n    ",
                  "Args": {
                    "x": {
                      "Type": null,
                      "Default": null
                    },
                    "memo": {
                      "Type": null,
                      "Default": "None"
                    },
                    "_nil": {
                      "Type": null,
                      "Default": "[]"
                    }
                  }
                },
                "is_parametrized": {
                  "Doc": "Returns ``True`` if module has an active parametrization.\n\n    If the argument :attr:`tensor_name` is specified, returns ``True`` if\n    ``module[tensor_name]`` is parametrized.\n\n    Args:\n        module (nn.Module): module to query\n        name (str, optional): attribute in the module to query\n            Default: ``None``\n    ",
                  "Args": {
                    "module": {
                      "Type": "<class 'torch.nn.modules.module.Module'>",
                      "Default": null
                    },
                    "tensor_name": {
                      "Type": "typing.Optional[str]",
                      "Default": "None"
                    }
                  }
                },
                "register_parametrization": {
                  "Doc": "Adds a parametrization to a tensor in a module.\n\n    Assume that ``tensor_name=\"weight\"`` for simplicity. When accessing ``module.weight``,\n    the module will return the parametrized version ``parametrization(module.weight)``.\n    If the original tensor requires a gradient, the backward pass will differentiate\n    through :attr:`parametrization`, and the optimizer will update the tensor accordingly.\n\n    The first time that a module registers a parametrization, this function will add an attribute\n    ``parametrizations`` to the module of type :class:`~ParametrizationList`.\n\n    The list of parametrizations on the tensor ``weight`` will be accessible under\n    ``module.parametrizations.weight``.\n\n    The original tensor will be accessible under\n    ``module.parametrizations.weight.original``.\n\n    Parametrizations may be concatenated by registering several parametrizations\n    on the same attribute.\n\n    The training mode of a registered parametrization is updated on registration\n    to match the training mode of the host module\n\n    Parametrized parameters and buffers have an inbuilt caching system that can be activated\n    using the context manager :func:`cached`.\n\n    A :attr:`parametrization` may optionally implement a method with signature\n\n    .. code-block:: python\n\n        def right_inverse(self, X: Tensor) -> Union[Tensor, Sequence[Tensor]]\n\n    This method is called on the unparametrized tensor when the first parametrization\n    is registered to compute the initial value of the original tensor.\n    If this method is not implemented, the original tensor will be just the unparametrized tensor.\n\n    If all the parametrizations registered on a tensor implement `right_inverse` it is possible\n    to initialize a parametrized tensor by assigning to it, as shown in the example below.\n\n    It is possible for the first parametrization to depend on several inputs.\n    This may be implemented returning a tuple of tensors from ``right_inverse``\n    (see the example implementation of a ``RankOne`` parametrization below).\n\n    In this case, the unconstrained tensors are also located under ``module.parametrizations.weight``\n    with names ``original0``, ``original1``,...\n\n    .. note::\n\n        If unsafe=False (default) both the forward and right_inverse methods will be called\n        once to perform a number of consistency checks.\n        If unsafe=True, then right_inverse will be called if the tensor is not parametrized,\n        and nothing will be called otherwise.\n\n    .. note::\n\n        In most situations, ``right_inverse`` will be a function such that\n        ``forward(right_inverse(X)) == X`` (see\n        `right inverse <https://en.wikipedia.org/wiki/Inverse_function#Right_inverses>`_).\n        Sometimes, when the parametrization is not surjective, it may be reasonable\n        to relax this.\n\n    .. warning::\n\n        If a parametrization depends on several inputs, :func:`~register_parametrization`\n        will register a number of new parameters. If such parametrization is registered\n        after the optimizer is created, these new parameters will need to be added manually\n        to the optimizer. See :meth:`torch.Optimizer.add_param_group`.\n\n    Args:\n        module (nn.Module): module on which to register the parametrization\n        tensor_name (str): name of the parameter or buffer on which to register\n            the parametrization\n        parametrization (nn.Module): the parametrization to register\n    Keyword args:\n        unsafe (bool): a boolean flag that denotes whether the parametrization\n            may change the dtype and shape of the tensor. Default: `False`\n            Warning: the parametrization is not checked for consistency upon registration.\n            Enable this flag at your own risk.\n\n    Raises:\n        ValueError: if the module does not have a parameter or a buffer named :attr:`tensor_name`\n\n    Examples:\n        >>> # xdoctest: +REQUIRES(env:TORCH_DOCTEST_LAPACK)\n        >>> import torch\n        >>> import torch.nn as nn\n        >>> import torch.nn.utils.parametrize as P\n        >>>\n        >>> class Symmetric(nn.Module):\n        >>>     def forward(self, X):\n        >>>         return X.triu() + X.triu(1).T  # Return a symmetric matrix\n        >>>\n        >>>     def right_inverse(self, A):\n        >>>         return A.triu()\n        >>>\n        >>> m = nn.Linear(5, 5)\n        >>> P.register_parametrization(m, \"weight\", Symmetric())\n        >>> print(torch.allclose(m.weight, m.weight.T))  # m.weight is now symmetric\n        True\n        >>> A = torch.rand(5, 5)\n        >>> A = A + A.T   # A is now symmetric\n        >>> m.weight = A  # Initialize the weight to be the symmetric matrix A\n        >>> print(torch.allclose(m.weight, A))\n        True\n\n        >>> class RankOne(nn.Module):\n        >>>     def forward(self, x, y):\n        >>>         # Form a rank 1 matrix multiplying two vectors\n        >>>         return x.unsqueeze(-1) @ y.unsqueeze(-2)\n        >>>\n        >>>     def right_inverse(self, Z):\n        >>>         # Project Z onto the rank 1 matrices\n        >>>         U, S, Vh = torch.linalg.svd(Z, full_matrices=False)\n        >>>         # Return rescaled singular vectors\n        >>>         s0_sqrt = S[0].sqrt().unsqueeze(-1)\n        >>>         return U[..., :, 0] * s0_sqrt, Vh[..., 0, :] * s0_sqrt\n        >>>\n        >>> linear_rank_one = P.register_parametrization(nn.Linear(4, 4), \"weight\", RankOne())\n        >>> print(torch.linalg.matrix_rank(linear_rank_one.weight).item())\n        1\n\n    ",
                  "Args": {
                    "module": {
                      "Type": "<class 'torch.nn.modules.module.Module'>",
                      "Default": null
                    },
                    "tensor_name": {
                      "Type": "<class 'str'>",
                      "Default": null
                    },
                    "parametrization": {
                      "Type": "<class 'torch.nn.modules.module.Module'>",
                      "Default": null
                    },
                    "unsafe": {
                      "Type": "<class 'bool'>",
                      "Default": "False"
                    }
                  }
                },
                "remove_parametrizations": {
                  "Doc": "Removes the parametrizations on a tensor in a module.\n\n    - If ``leave_parametrized=True``, ``module[tensor_name]`` will be set to\n      its current output. In this case, the parametrization shall not change the ``dtype``\n      of the tensor.\n    - If ``leave_parametrized=False``, ``module[tensor_name]`` will be set to\n      the unparametrised tensor in ``module.parametrizations[tensor_name].original``.\n      This is only possible when the parametrization depends on just one tensor.\n\n    Args:\n        module (nn.Module): module from which remove the parametrization\n        tensor_name (str): name of the parametrization to be removed\n        leave_parametrized (bool, optional): leave the attribute :attr:`tensor_name` parametrized.\n            Default: ``True``\n\n    Returns:\n        Module: module\n\n    Raises:\n        ValueError: if ``module[tensor_name]`` is not parametrized\n        ValueError: if ``leave_parametrized=False`` and the parametrization depends on several tensors\n    ",
                  "Args": {
                    "module": {
                      "Type": "<class 'torch.nn.modules.module.Module'>",
                      "Default": null
                    },
                    "tensor_name": {
                      "Type": "<class 'str'>",
                      "Default": null
                    },
                    "leave_parametrized": {
                      "Type": "<class 'bool'>",
                      "Default": "True"
                    }
                  }
                },
                "transfer_parametrizations_and_params": {
                  "Doc": "Transfers parametrizations and the parameters they parametrize from from_module\n    to to_module. If tensor_name is specified, only transfers the specified parameter, otherwise\n    transfers all parametrized parameters. If those parameters do not exist in to_module, it will create them.\n    Does nothing if from_module is not parametrized.\n\n    Args:\n        from_module (nn.Module): module to transfer from\n        to_module (nn.Module): module to transfer to\n        tensor_name (str, optional): parameter to transfer\n\n    Returns:\n        Module: to_module\n    ",
                  "Args": {
                    "from_module": {
                      "Type": "<class 'torch.nn.modules.module.Module'>",
                      "Default": null
                    },
                    "to_module": {
                      "Type": "<class 'torch.nn.modules.module.Module'>",
                      "Default": null
                    },
                    "tensor_name": {
                      "Type": "typing.Optional[str]",
                      "Default": "None"
                    }
                  }
                },
                "type_before_parametrizations": {
                  "Doc": "Returns the module type before parametrizations were applied and if not,\n    then it returns the module type.\n\n    Args:\n        module (nn.Module): module to get type of\n    ",
                  "Args": {
                    "module": {
                      "Type": "<class 'torch.nn.modules.module.Module'>",
                      "Default": null
                    }
                  }
                }
              }
            },
            "rnn": {
              "Doc": null,
              "Classes": {
                "PackedSequence": {
                  "Doc": "Holds the data and list of :attr:`batch_sizes` of a packed sequence.\n\n    All RNN modules accept packed sequences as inputs.\n\n    Note:\n        Instances of this class should never be created manually. They are meant\n        to be instantiated by functions like :func:`pack_padded_sequence`.\n\n        Batch sizes represent the number elements at each sequence step in\n        the batch, not the varying sequence lengths passed to\n        :func:`pack_padded_sequence`.  For instance, given data ``abc`` and ``x``\n        the :class:`PackedSequence` would contain data ``axbc`` with\n        ``batch_sizes=[2,1,1]``.\n\n    Attributes:\n        data (Tensor): Tensor containing packed sequence\n        batch_sizes (Tensor): Tensor of integers holding\n            information about the batch size at each sequence step\n        sorted_indices (Tensor, optional): Tensor of integers holding how this\n            :class:`PackedSequence` is constructed from sequences.\n        unsorted_indices (Tensor, optional): Tensor of integers holding how this\n            to recover the original sequences with correct order.\n\n    .. note::\n        :attr:`data` can be on arbitrary device and of arbitrary dtype.\n        :attr:`sorted_indices` and :attr:`unsorted_indices` must be ``torch.int64``\n        tensors on the same device as :attr:`data`.\n\n        However, :attr:`batch_sizes` should always be a CPU ``torch.int64`` tensor.\n\n        This invariant is maintained throughout :class:`PackedSequence` class,\n        and all functions that construct a `:class:PackedSequence` in PyTorch\n        (i.e., they only pass in tensors conforming to this constraint).\n\n    ",
                  "Functions": {
                    "byte": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "char": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "cpu": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "*args": {
                          "Type": null,
                          "Default": null
                        },
                        "**kwargs": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "cuda": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "*args": {
                          "Type": null,
                          "Default": null
                        },
                        "**kwargs": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "double": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "float": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "half": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "int": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "is_pinned": {
                      "Doc": "Returns true if `self.data` stored on in pinned memory",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "long": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "pin_memory": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "short": {
                      "Doc": null,
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    },
                    "to": {
                      "Doc": "Performs dtype and/or device conversion on `self.data`.\n\n        It has similar signature as :meth:`torch.Tensor.to`, except optional\n        arguments like `non_blocking` and `copy` should be passed as kwargs,\n        not args, or they will not apply to the index tensors.\n\n        .. note::\n\n            If the ``self.data`` Tensor already has the correct :class:`torch.dtype`\n            and :class:`torch.device`, then ``self`` is returned.\n            Otherwise, returns a copy with the desired configuration.\n        ",
                      "Args": {
                        "self": {
                          "Type": null,
                          "Default": null
                        },
                        "*args": {
                          "Type": null,
                          "Default": null
                        },
                        "**kwargs": {
                          "Type": null,
                          "Default": null
                        }
                      }
                    }
                  }
                }
              },
              "Functions": {
                "bind": {
                  "Doc": null,
                  "Args": {
                    "optional": {
                      "Type": null,
                      "Default": null
                    },
                    "fn": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "invert_permutation": {
                  "Doc": null,
                  "Args": {
                    "permutation": {
                      "Type": "typing.Optional[torch.Tensor]",
                      "Default": null
                    }
                  }
                },
                "namedtuple": {
                  "Doc": "Returns a new subclass of tuple with named fields.\n\n    >>> Point = namedtuple('Point', ['x', 'y'])\n    >>> Point.__doc__                   # docstring for the new class\n    'Point(x, y)'\n    >>> p = Point(11, y=22)             # instantiate with positional args or keywords\n    >>> p[0] + p[1]                     # indexable like a plain tuple\n    33\n    >>> x, y = p                        # unpack like a regular tuple\n    >>> x, y\n    (11, 22)\n    >>> p.x + p.y                       # fields also accessible by name\n    33\n    >>> d = p._asdict()                 # convert to a dictionary\n    >>> d['x']\n    11\n    >>> Point(**d)                      # convert from a dictionary\n    Point(x=11, y=22)\n    >>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\n    Point(x=100, y=22)\n\n    ",
                  "Args": {
                    "typename": {
                      "Type": null,
                      "Default": null
                    },
                    "field_names": {
                      "Type": null,
                      "Default": null
                    },
                    "rename": {
                      "Type": null,
                      "Default": "False"
                    },
                    "defaults": {
                      "Type": null,
                      "Default": "None"
                    },
                    "module": {
                      "Type": null,
                      "Default": "None"
                    }
                  }
                },
                "pack_padded_sequence": {
                  "Doc": "Packs a Tensor containing padded sequences of variable length.\n\n    :attr:`input` can be of size ``T x B x *`` where `T` is the length of the\n    longest sequence (equal to ``lengths[0]``), ``B`` is the batch size, and\n    ``*`` is any number of dimensions (including 0). If ``batch_first`` is\n    ``True``, ``B x T x *`` :attr:`input` is expected.\n\n    For unsorted sequences, use `enforce_sorted = False`. If :attr:`enforce_sorted` is\n    ``True``, the sequences should be sorted by length in a decreasing order, i.e.\n    ``input[:,0]`` should be the longest sequence, and ``input[:,B-1]`` the shortest\n    one. `enforce_sorted = True` is only necessary for ONNX export.\n\n    Note:\n        This function accepts any input that has at least two dimensions. You\n        can apply it to pack the labels, and use the output of the RNN with\n        them to compute the loss directly. A Tensor can be retrieved from\n        a :class:`PackedSequence` object by accessing its ``.data`` attribute.\n\n    Args:\n        input (Tensor): padded batch of variable length sequences.\n        lengths (Tensor or list(int)): list of sequence lengths of each batch\n            element (must be on the CPU if provided as a tensor).\n        batch_first (bool, optional): if ``True``, the input is expected in ``B x T x *``\n            format.\n        enforce_sorted (bool, optional): if ``True``, the input is expected to\n            contain sequences sorted by length in a decreasing order. If\n            ``False``, the input will get sorted unconditionally. Default: ``True``.\n\n    Returns:\n        a :class:`PackedSequence` object\n    ",
                  "Args": {
                    "input": {
                      "Type": "<class 'torch.Tensor'>",
                      "Default": null
                    },
                    "lengths": {
                      "Type": "<class 'torch.Tensor'>",
                      "Default": null
                    },
                    "batch_first": {
                      "Type": "<class 'bool'>",
                      "Default": "False"
                    },
                    "enforce_sorted": {
                      "Type": "<class 'bool'>",
                      "Default": "True"
                    }
                  }
                },
                "pack_sequence": {
                  "Doc": "Packs a list of variable length Tensors\n\n    Consecutive call of the next functions: ``pad_sequence``, ``pack_padded_sequence``.\n\n    ``sequences`` should be a list of Tensors of size ``L x *``, where `L` is\n    the length of a sequence and `*` is any number of trailing dimensions,\n    including zero.\n\n    For unsorted sequences, use `enforce_sorted = False`. If ``enforce_sorted``\n    is ``True``, the sequences should be sorted in the order of decreasing length.\n    ``enforce_sorted = True`` is only necessary for ONNX export.\n\n\n    Example:\n        >>> from torch.nn.utils.rnn import pack_sequence\n        >>> a = torch.tensor([1,2,3])\n        >>> b = torch.tensor([4,5])\n        >>> c = torch.tensor([6])\n        >>> pack_sequence([a, b, c])\n        PackedSequence(data=tensor([1, 4, 6, 2, 5, 3]), batch_sizes=tensor([3, 2, 1]), sorted_indices=None, unsorted_indices=None)\n\n\n    Args:\n        sequences (list[Tensor]): A list of sequences of decreasing length.\n        enforce_sorted (bool, optional): if ``True``, checks that the input\n            contains sequences sorted by length in a decreasing order. If\n            ``False``, this condition is not checked. Default: ``True``.\n\n    Returns:\n        a :class:`PackedSequence` object\n    ",
                  "Args": {
                    "sequences": {
                      "Type": "typing.List[torch.Tensor]",
                      "Default": null
                    },
                    "enforce_sorted": {
                      "Type": "<class 'bool'>",
                      "Default": "True"
                    }
                  }
                },
                "pad_packed_sequence": {
                  "Doc": "Pads a packed batch of variable length sequences.\n\n    It is an inverse operation to :func:`pack_padded_sequence`.\n\n    The returned Tensor's data will be of size ``T x B x *``, where `T` is the length\n    of the longest sequence and `B` is the batch size. If ``batch_first`` is True,\n    the data will be transposed into ``B x T x *`` format.\n\n    Example:\n        >>> from torch.nn.utils.rnn import pack_padded_sequence, pad_packed_sequence\n        >>> seq = torch.tensor([[1,2,0], [3,0,0], [4,5,6]])\n        >>> lens = [2, 1, 3]\n        >>> packed = pack_padded_sequence(seq, lens, batch_first=True, enforce_sorted=False)\n        >>> packed\n        PackedSequence(data=tensor([4, 1, 3, 5, 2, 6]), batch_sizes=tensor([3, 2, 1]),\n                       sorted_indices=tensor([2, 0, 1]), unsorted_indices=tensor([1, 2, 0]))\n        >>> seq_unpacked, lens_unpacked = pad_packed_sequence(packed, batch_first=True)\n        >>> seq_unpacked\n        tensor([[1, 2, 0],\n                [3, 0, 0],\n                [4, 5, 6]])\n        >>> lens_unpacked\n        tensor([2, 1, 3])\n\n    .. note::\n        :attr:`total_length` is useful to implement the\n        ``pack sequence -> recurrent network -> unpack sequence`` pattern in a\n        :class:`~torch.nn.Module` wrapped in :class:`~torch.nn.DataParallel`.\n        See :ref:`this FAQ section <pack-rnn-unpack-with-data-parallelism>` for\n        details.\n\n    Args:\n        sequence (PackedSequence): batch to pad\n        batch_first (bool, optional): if ``True``, the output will be in ``B x T x *``\n            format.\n        padding_value (float, optional): values for padded elements.\n        total_length (int, optional): if not ``None``, the output will be padded to\n            have length :attr:`total_length`. This method will throw :class:`ValueError`\n            if :attr:`total_length` is less than the max sequence length in\n            :attr:`sequence`.\n\n    Returns:\n        Tuple of Tensor containing the padded sequence, and a Tensor\n        containing the list of lengths of each sequence in the batch.\n        Batch elements will be re-ordered as they were ordered originally when\n        the batch was passed to ``pack_padded_sequence`` or ``pack_sequence``.\n\n\n\n\n    ",
                  "Args": {
                    "sequence": {
                      "Type": "<class 'torch.nn.utils.rnn.PackedSequence'>",
                      "Default": null
                    },
                    "batch_first": {
                      "Type": "<class 'bool'>",
                      "Default": "False"
                    },
                    "padding_value": {
                      "Type": "<class 'float'>",
                      "Default": "0.0"
                    },
                    "total_length": {
                      "Type": "typing.Optional[int]",
                      "Default": "None"
                    }
                  }
                },
                "pad_sequence": {
                  "Doc": "Pad a list of variable length Tensors with ``padding_value``\n\n    ``pad_sequence`` stacks a list of Tensors along a new dimension,\n    and pads them to equal length. For example, if the input is list of\n    sequences with size ``L x *`` and if batch_first is False, and ``T x B x *``\n    otherwise.\n\n    `B` is batch size. It is equal to the number of elements in ``sequences``.\n    `T` is length of the longest sequence.\n    `L` is length of the sequence.\n    `*` is any number of trailing dimensions, including none.\n\n    Example:\n        >>> from torch.nn.utils.rnn import pad_sequence\n        >>> a = torch.ones(25, 300)\n        >>> b = torch.ones(22, 300)\n        >>> c = torch.ones(15, 300)\n        >>> pad_sequence([a, b, c]).size()\n        torch.Size([25, 3, 300])\n\n    Note:\n        This function returns a Tensor of size ``T x B x *`` or ``B x T x *``\n        where `T` is the length of the longest sequence. This function assumes\n        trailing dimensions and type of all the Tensors in sequences are same.\n\n    Args:\n        sequences (list[Tensor]): list of variable length sequences.\n        batch_first (bool, optional): output will be in ``B x T x *`` if True, or in\n            ``T x B x *`` otherwise. Default: False.\n        padding_value (float, optional): value for padded elements. Default: 0.\n\n    Returns:\n        Tensor of size ``T x B x *`` if :attr:`batch_first` is ``False``.\n        Tensor of size ``B x T x *`` otherwise\n    ",
                  "Args": {
                    "sequences": {
                      "Type": "typing.Union[torch.Tensor, typing.List[torch.Tensor]]",
                      "Default": null
                    },
                    "batch_first": {
                      "Type": "<class 'bool'>",
                      "Default": "False"
                    },
                    "padding_value": {
                      "Type": "<class 'float'>",
                      "Default": "0.0"
                    }
                  }
                },
                "unpack_sequence": {
                  "Doc": "Unpacks PackedSequence into a list of variable length Tensors\n\n    ``packed_sequences`` should be a PackedSequence object.\n\n\n    Example:\n        >>> from torch.nn.utils.rnn import pack_sequence, unpack_sequence\n        >>> a = torch.tensor([1,2,3])\n        >>> b = torch.tensor([4,5])\n        >>> c = torch.tensor([6])\n        >>> sequences = [a, b, c]\n        >>> print(sequences)\n        [tensor([1, 2, 3]), tensor([4, 5]), tensor([6])]\n        >>> packed_sequences = pack_sequence(sequences)\n        >>> print(packed_sequences)\n        PackedSequence(data=tensor([1, 4, 6, 2, 5, 3]), batch_sizes=tensor([3, 2, 1]), sorted_indices=None, unsorted_indices=None)\n        >>> unpacked_sequences = unpack_sequence(packed_sequences)\n        >>> print(unpacked_sequences)\n        [tensor([1, 2, 3]), tensor([4, 5]), tensor([6])]\n\n\n    Args:\n        packed_sequences (PackedSequence): A PackedSequence object.\n\n    Returns:\n        a list of :class:`Tensor` objects\n    ",
                  "Args": {
                    "packed_sequences": {
                      "Type": "<class 'torch.nn.utils.rnn.PackedSequence'>",
                      "Default": null
                    }
                  }
                },
                "unpad_sequence": {
                  "Doc": "Unpad padded Tensor into a list of variable length Tensors\n\n    ``unpad_sequence`` unstacks padded Tensor into a list of variable length Tensors.\n\n    Example:\n        >>> from torch.nn.utils.rnn import pad_sequence, unpad_sequence\n        >>> a = torch.ones(25, 300)\n        >>> b = torch.ones(22, 300)\n        >>> c = torch.ones(15, 300)\n        >>> sequences = [a, b, c]\n        >>> padded_sequences = pad_sequence(sequences)\n        >>> lengths = torch.as_tensor([v.size(0) for v in sequences])\n        >>> unpadded_sequences = unpad_sequence(padded_sequences, lengths)\n        >>> torch.allclose(sequences[0], unpadded_sequences[0])\n        True\n        >>> torch.allclose(sequences[1], unpadded_sequences[1])\n        True\n        >>> torch.allclose(sequences[2], unpadded_sequences[2])\n        True\n\n    Args:\n        padded_sequences (Tensor): padded sequences.\n        lengths (Tensor): length of original (unpadded) sequences.\n        batch_first (bool, optional): whether batch dimension first or not. Default: False.\n\n    Returns:\n        a list of :class:`Tensor` objects\n    ",
                  "Args": {
                    "padded_sequences": {
                      "Type": "<class 'torch.Tensor'>",
                      "Default": null
                    },
                    "lengths": {
                      "Type": "<class 'torch.Tensor'>",
                      "Default": null
                    },
                    "batch_first": {
                      "Type": "<class 'bool'>",
                      "Default": "False"
                    }
                  }
                }
              }
            },
            "stateless": {
              "Doc": null,
              "Functions": {
                "functional_call": {
                  "Doc": "Performs a functional call on the module by replacing the module parameters\n    and buffers with the provided ones.\n\n    .. note:: If the module has active parametrizations, passing a value in the\n        :attr:`parameters_and_buffers` argument with the name set to the regular parameter\n        name will completely disable the parametrization.\n        If you want to apply the parametrization function to the value passed\n        please set the key as ``{submodule_name}.parametrizations.{parameter_name}.original``.\n\n    .. note:: If the module performs in-place operations on parameters/buffers, these will be reflected\n        in the `parameters_and_buffers` input.\n\n        Example::\n\n            >>> a = {'foo': torch.zeros(())}\n            >>> # xdoctest: +SKIP\n            >>> mod = Foo()  # does self.foo = self.foo + 1\n            >>> print(mod.foo)  # tensor(0.)\n            >>> functional_call(mod, a, torch.ones(()))\n            >>> print(mod.foo)  # tensor(0.)\n            >>> print(a['foo'])  # tensor(1.)\n\n    Args:\n        module (torch.nn.Module): the module to call\n        parameters_and_buffers (dict of str and Tensor): the parameters that will be used in\n            the module call.\n        args (tuple): arguments to be passed to the module call\n        kwargs (dict): keyword arguments to be passed to the module call\n\n    Returns:\n        Any: the result of calling ``module``.\n    ",
                  "Args": {
                    "module": {
                      "Type": "torch.nn.Module",
                      "Default": null
                    },
                    "parameters_and_buffers": {
                      "Type": "typing.Dict[str, torch.Tensor]",
                      "Default": null
                    },
                    "args": {
                      "Type": "typing.Tuple",
                      "Default": null
                    },
                    "kwargs": {
                      "Type": "typing.Dict[str, typing.Any]",
                      "Default": "None"
                    }
                  }
                }
              }
            }
          },
          "Functions": {
            "clip_grad_norm": {
              "Doc": "Clips gradient norm of an iterable of parameters.\n\n    .. warning::\n        This method is now deprecated in favor of\n        :func:`torch.nn.utils.clip_grad_norm_`.\n    ",
              "Args": {
                "parameters": {
                  "Type": "typing.Union[torch.Tensor, typing.Iterable[torch.Tensor]]",
                  "Default": null
                },
                "max_norm": {
                  "Type": "<class 'float'>",
                  "Default": null
                },
                "norm_type": {
                  "Type": "<class 'float'>",
                  "Default": "2.0"
                },
                "error_if_nonfinite": {
                  "Type": "<class 'bool'>",
                  "Default": "False"
                }
              }
            },
            "convert_conv2d_weight_memory_format": {
              "Doc": "Convert ``memory_format`` of ``nn.Conv2d.weight`` to ``memory_format``\n    The conversion recursively applies to nested ``nn.Module``, including ``module``.\n    Note that it only changes the memory_format, but not the semantics of each dimensions.\n    This function is used to facilitate the computation to adopt NHWC kernels, which\n    provides considerable speed up for fp16 data on CUDA devices with compute capability >= 7.0\n\n    .. note::\n        Calling ``model.to(memory_format=torch.channels_last)`` is more aggressive\n        than the utility function ``convert_conv2d_weight_memory_format``. Any\n        layer with 4d weight will be affected by ``model.to``, which does not\n        necessarily benefit from conversion to specified ``memory_format``.\n        One place we are confident in is that NHWC(channels_last) conversion for\n        convolution in cuDNN, As it is beneficial to run convolution in NHWC,\n        even in cases where we have to apply permutation to input tensors.\n\n        Hence our strategy here is to convert only the weight of convolution to\n        channels_last. This ensures that;\n        1. Fast convolution kernels will be used, the benefit of which could\n           outweigh overhead of permutation (if input is not in the same format)\n        2. No unnecessary permutations are applied on layers that do not benefit\n           from memory_format conversion.\n\n        The optimal case is that, layers between convolution layers are channels\n        last compatible. Input tensor would be permuted to channels last when it\n        encounters the first convolution layer and stay in that memory format.\n        Hence following convolutions will not need to permute its input tensor.\n\n        In case where a channels last incompatible layer is between convolution\n        layers, we need to permute the input tensor back to contiguous format\n        for that layer. The input tensor will go through the remaining layers in\n        contiguous format and be permuted to channels last when it encounters\n        another convolution layer. There's no point in propagating that\n        permutation to an earlier layer, as most layers are quite agnostic to\n        ``memory_format``.\n\n        This claim might change when PyTorch supports fusion of permutation, as\n        there might have been a better spot to fuse the permutation other than\n        immediately before a convolution.\n\n    Args:\n        module (nn.Module): ``nn.Conv2d`` & ``nn.ConvTranspose2d``  or container\n                            ``nn.Module``\n        format: user specified ``memory_format``,\n            e.g. ``torch.channels_last`` or ``torch.contiguous_format``\n\n    Returns:\n        The original module with updated ``nn.Conv2d``\n\n    Example:\n        >>> # xdoctest: +REQUIRES(env:CUBLAS_WORKSPACE_CONFIG)\n        >>> input = torch.randint(1, 10, (2, 8, 4, 4), dtype=torch.float16, device=\"cuda\")\n        >>> model = nn.Sequential(\n        >>>     nn.Conv2d(8, 4, 3)).cuda().half()\n        >>> # This is identical to:\n        >>> # nn.utils.convert_conv2d_weight_memory_format(model, torch.channels_last)\n        >>> model = nn.utils.convert_conv2d_weight_memory_format(model, torch.channels_last)\n        >>> out = model(input)\n    ",
              "Args": {
                "module": {
                  "Type": null,
                  "Default": null
                },
                "memory_format": {
                  "Type": null,
                  "Default": null
                }
              }
            },
            "fuse_conv_bn_eval": {
              "Doc": null,
              "Args": {
                "conv": {
                  "Type": null,
                  "Default": null
                },
                "bn": {
                  "Type": null,
                  "Default": null
                },
                "transpose": {
                  "Type": null,
                  "Default": "False"
                }
              }
            },
            "fuse_conv_bn_weights": {
              "Doc": null,
              "Args": {
                "conv_w": {
                  "Type": null,
                  "Default": null
                },
                "conv_b": {
                  "Type": null,
                  "Default": null
                },
                "bn_rm": {
                  "Type": null,
                  "Default": null
                },
                "bn_rv": {
                  "Type": null,
                  "Default": null
                },
                "bn_eps": {
                  "Type": null,
                  "Default": null
                },
                "bn_w": {
                  "Type": null,
                  "Default": null
                },
                "bn_b": {
                  "Type": null,
                  "Default": null
                },
                "transpose": {
                  "Type": null,
                  "Default": "False"
                }
              }
            },
            "parameters_to_vector": {
              "Doc": "Convert parameters to one vector\n\n    Args:\n        parameters (Iterable[Tensor]): an iterator of Tensors that are the\n            parameters of a model.\n\n    Returns:\n        The parameters represented by a single vector\n    ",
              "Args": {
                "parameters": {
                  "Type": "typing.Iterable[torch.Tensor]",
                  "Default": null
                }
              }
            },
            "remove_spectral_norm": {
              "Doc": "Removes the spectral normalization reparameterization from a module.\n\n    Args:\n        module (Module): containing module\n        name (str, optional): name of weight parameter\n\n    Example:\n        >>> m = spectral_norm(nn.Linear(40, 10))\n        >>> remove_spectral_norm(m)\n    ",
              "Args": {
                "module": {
                  "Type": "~T_module",
                  "Default": null
                },
                "name": {
                  "Type": "<class 'str'>",
                  "Default": "weight"
                }
              }
            },
            "remove_weight_norm": {
              "Doc": "Removes the weight normalization reparameterization from a module.\n\n    Args:\n        module (Module): containing module\n        name (str, optional): name of weight parameter\n\n    Example:\n        >>> m = weight_norm(nn.Linear(20, 40))\n        >>> remove_weight_norm(m)\n    ",
              "Args": {
                "module": {
                  "Type": "~T_module",
                  "Default": null
                },
                "name": {
                  "Type": "<class 'str'>",
                  "Default": "weight"
                }
              }
            },
            "skip_init": {
              "Doc": "\n    Given a module class object and args / kwargs, instantiates the module without initializing\n    parameters / buffers.  This can be useful if initialization is slow or if custom initialization will\n    be performed, making the default initialization unnecessary. There are some caveats to this, due to\n    the way this function is implemented:\n\n    1. The module must accept a `device` arg in its constructor that is passed to any parameters\n    or buffers created during construction.\n\n    2. The module must not perform any computation on parameters in its constructor except\n    initialization (i.e. functions from :mod:`torch.nn.init`).\n\n    If these conditions are satisfied, the module can be instantiated with parameter / buffer values\n    uninitialized, as if having been created using :func:`torch.empty`.\n\n    Args:\n        module_cls: Class object; should be a subclass of :class:`torch.nn.Module`\n        args: args to pass to the module's constructor\n        kwargs: kwargs to pass to the module's constructor\n\n    Returns:\n        Instantiated module with uninitialized parameters / buffers\n\n    Example::\n\n        >>> import torch\n        >>> # xdoctest: +IGNORE_WANT(\"non-deterministic\")\n        >>> m = torch.nn.utils.skip_init(torch.nn.Linear, 5, 1)\n        >>> m.weight\n        Parameter containing:\n        tensor([[0.0000e+00, 1.5846e+29, 7.8307e+00, 2.5250e-29, 1.1210e-44]],\n               requires_grad=True)\n        >>> m2 = torch.nn.utils.skip_init(torch.nn.Linear, in_features=6, out_features=1)\n        >>> m2.weight\n        Parameter containing:\n        tensor([[-1.4677e+24,  4.5915e-41,  1.4013e-45,  0.0000e+00, -1.4677e+24,\n                  4.5915e-41]], requires_grad=True)\n\n    ",
              "Args": {
                "module_cls": {
                  "Type": null,
                  "Default": null
                },
                "*args": {
                  "Type": null,
                  "Default": null
                },
                "**kwargs": {
                  "Type": null,
                  "Default": null
                }
              }
            },
            "spectral_norm": {
              "Doc": "Applies spectral normalization to a parameter in the given module.\n\n    .. math::\n        \\mathbf{W}_{SN} = \\dfrac{\\mathbf{W}}{\\sigma(\\mathbf{W})},\n        \\sigma(\\mathbf{W}) = \\max_{\\mathbf{h}: \\mathbf{h} \\ne 0} \\dfrac{\\|\\mathbf{W} \\mathbf{h}\\|_2}{\\|\\mathbf{h}\\|_2}\n\n    Spectral normalization stabilizes the training of discriminators (critics)\n    in Generative Adversarial Networks (GANs) by rescaling the weight tensor\n    with spectral norm :math:`\\sigma` of the weight matrix calculated using\n    power iteration method. If the dimension of the weight tensor is greater\n    than 2, it is reshaped to 2D in power iteration method to get spectral\n    norm. This is implemented via a hook that calculates spectral norm and\n    rescales weight before every :meth:`~Module.forward` call.\n\n    See `Spectral Normalization for Generative Adversarial Networks`_ .\n\n    .. _`Spectral Normalization for Generative Adversarial Networks`: https://arxiv.org/abs/1802.05957\n\n    Args:\n        module (nn.Module): containing module\n        name (str, optional): name of weight parameter\n        n_power_iterations (int, optional): number of power iterations to\n            calculate spectral norm\n        eps (float, optional): epsilon for numerical stability in\n            calculating norms\n        dim (int, optional): dimension corresponding to number of outputs,\n            the default is ``0``, except for modules that are instances of\n            ConvTranspose{1,2,3}d, when it is ``1``\n\n    Returns:\n        The original module with the spectral norm hook\n\n    .. note::\n        This function has been reimplemented as\n        :func:`torch.nn.utils.parametrizations.spectral_norm` using the new\n        parametrization functionality in\n        :func:`torch.nn.utils.parametrize.register_parametrization`. Please use\n        the newer version. This function will be deprecated in a future version\n        of PyTorch.\n\n    Example::\n\n        >>> m = spectral_norm(nn.Linear(20, 40))\n        >>> m\n        Linear(in_features=20, out_features=40, bias=True)\n        >>> m.weight_u.size()\n        torch.Size([40])\n\n    ",
              "Args": {
                "module": {
                  "Type": "~T_module",
                  "Default": null
                },
                "name": {
                  "Type": "<class 'str'>",
                  "Default": "weight"
                },
                "n_power_iterations": {
                  "Type": "<class 'int'>",
                  "Default": "1"
                },
                "eps": {
                  "Type": "<class 'float'>",
                  "Default": "1e-12"
                },
                "dim": {
                  "Type": "typing.Optional[int]",
                  "Default": "None"
                }
              }
            },
            "vector_to_parameters": {
              "Doc": "Convert one vector to the parameters\n\n    Args:\n        vec (Tensor): a single vector represents the parameters of a model.\n        parameters (Iterable[Tensor]): an iterator of Tensors that are the\n            parameters of a model.\n    ",
              "Args": {
                "vec": {
                  "Type": "<class 'torch.Tensor'>",
                  "Default": null
                },
                "parameters": {
                  "Type": "typing.Iterable[torch.Tensor]",
                  "Default": null
                }
              }
            },
            "weight_norm": {
              "Doc": "Applies weight normalization to a parameter in the given module.\n\n    .. math::\n         \\mathbf{w} = g \\dfrac{\\mathbf{v}}{\\|\\mathbf{v}\\|}\n\n    Weight normalization is a reparameterization that decouples the magnitude\n    of a weight tensor from its direction. This replaces the parameter specified\n    by :attr:`name` (e.g. ``'weight'``) with two parameters: one specifying the magnitude\n    (e.g. ``'weight_g'``) and one specifying the direction (e.g. ``'weight_v'``).\n    Weight normalization is implemented via a hook that recomputes the weight\n    tensor from the magnitude and direction before every :meth:`~Module.forward`\n    call.\n\n    By default, with ``dim=0``, the norm is computed independently per output\n    channel/plane. To compute a norm over the entire weight tensor, use\n    ``dim=None``.\n\n    See https://arxiv.org/abs/1602.07868\n\n    Args:\n        module (Module): containing module\n        name (str, optional): name of weight parameter\n        dim (int, optional): dimension over which to compute the norm\n\n    Returns:\n        The original module with the weight norm hook\n\n    Example::\n\n        >>> m = weight_norm(nn.Linear(20, 40), name='weight')\n        >>> m\n        Linear(in_features=20, out_features=40, bias=True)\n        >>> m.weight_g.size()\n        torch.Size([40, 1])\n        >>> m.weight_v.size()\n        torch.Size([40, 20])\n\n    ",
              "Args": {
                "module": {
                  "Type": "~T_module",
                  "Default": null
                },
                "name": {
                  "Type": "<class 'str'>",
                  "Default": "weight"
                },
                "dim": {
                  "Type": "<class 'int'>",
                  "Default": "0"
                }
              }
            }
          }
        }
      },
      "Functions": {
        "factory_kwargs": {
          "Doc": "\n    Given kwargs, returns a canonicalized dict of factory kwargs that can be directly passed\n    to factory functions like torch.empty, or errors if unrecognized kwargs are present.\n\n    This function makes it simple to write code like this::\n\n        class MyModule(nn.Module):\n            def __init__(self, **kwargs):\n                factory_kwargs = torch.nn.factory_kwargs(kwargs)\n                self.weight = Parameter(torch.empty(10, **factory_kwargs))\n\n    Why should you use this function instead of just passing `kwargs` along directly?\n\n    1. This function does error validation, so if there are unexpected kwargs we will\n    immediately report an error, instead of deferring it to the factory call\n    2. This function supports a special `factory_kwargs` argument, which can be used to\n    explicitly specify a kwarg to be used for factory functions, in the event one of the\n    factory kwargs conflicts with an already existing argument in the signature (e.g.\n    in the signature ``def f(dtype, **kwargs)``, you can specify ``dtype`` for factory\n    functions, as distinct from the dtype argument, by saying\n    ``f(dtype1, factory_kwargs={\"dtype\": dtype2})``)\n    ",
          "Args": {
            "kwargs": {
              "Type": null,
              "Default": null
            }
          }
        }
      }
    },
    "optim": {
      "Doc": "\n:mod:`torch.optim` is a package implementing various optimization algorithms.\nMost commonly used methods are already supported, and the interface is general\nenough, so that more sophisticated ones can be also easily integrated in the\nfuture.\n",
      "Modules": {
        "lr_scheduler": {
          "Doc": null,
          "Classes": {
            "ChainedScheduler": {
              "Doc": "Chains list of learning rate schedulers. It takes a list of chainable learning\n    rate schedulers and performs consecutive step() functions belonging to them by just\n    one call.\n\n    Args:\n        schedulers (list): List of chained schedulers.\n\n    Example:\n        >>> # Assuming optimizer uses lr = 1. for all groups\n        >>> # lr = 0.09     if epoch == 0\n        >>> # lr = 0.081    if epoch == 1\n        >>> # lr = 0.729    if epoch == 2\n        >>> # lr = 0.6561   if epoch == 3\n        >>> # lr = 0.59049  if epoch >= 4\n        >>> # xdoctest: +SKIP\n        >>> scheduler1 = ConstantLR(self.opt, factor=0.1, total_iters=2)\n        >>> scheduler2 = ExponentialLR(self.opt, gamma=0.9)\n        >>> scheduler = ChainedScheduler([scheduler1, scheduler2])\n        >>> for epoch in range(100):\n        >>>     train(...)\n        >>>     validate(...)\n        >>>     scheduler.step()\n    ",
              "Functions": {
                "__init__": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "schedulers": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "load_state_dict": {
                  "Doc": "Loads the schedulers state.\n\n        Args:\n            state_dict (dict): scheduler state. Should be an object returned\n                from a call to :meth:`state_dict`.\n        ",
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "state_dict": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "state_dict": {
                  "Doc": "Returns the state of the scheduler as a :class:`dict`.\n\n        It contains an entry for every variable in self.__dict__ which\n        is not the optimizer.\n        The wrapped scheduler states will also be saved.\n        ",
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "step": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    }
                  }
                }
              }
            },
            "ConstantLR": {
              "Doc": "Decays the learning rate of each parameter group by a small constant factor until the\n    number of epoch reaches a pre-defined milestone: total_iters. Notice that such decay can\n    happen simultaneously with other changes to the learning rate from outside this scheduler.\n    When last_epoch=-1, sets initial lr as lr.\n\n    Args:\n        optimizer (Optimizer): Wrapped optimizer.\n        factor (float): The number we multiply learning rate until the milestone. Default: 1./3.\n        total_iters (int): The number of steps that the scheduler decays the learning rate.\n            Default: 5.\n        last_epoch (int): The index of the last epoch. Default: -1.\n        verbose (bool): If ``True``, prints a message to stdout for\n            each update. Default: ``False``.\n\n    Example:\n        >>> # Assuming optimizer uses lr = 0.05 for all groups\n        >>> # lr = 0.025   if epoch == 0\n        >>> # lr = 0.025   if epoch == 1\n        >>> # lr = 0.025   if epoch == 2\n        >>> # lr = 0.025   if epoch == 3\n        >>> # lr = 0.05    if epoch >= 4\n        >>> # xdoctest: +SKIP\n        >>> scheduler = ConstantLR(self.opt, factor=0.5, total_iters=4)\n        >>> for epoch in range(100):\n        >>>     train(...)\n        >>>     validate(...)\n        >>>     scheduler.step()\n    ",
              "Functions": {
                "__init__": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "optimizer": {
                      "Type": null,
                      "Default": null
                    },
                    "factor": {
                      "Type": null,
                      "Default": "0.3333333333333333"
                    },
                    "total_iters": {
                      "Type": null,
                      "Default": "5"
                    },
                    "last_epoch": {
                      "Type": null,
                      "Default": "-1"
                    },
                    "verbose": {
                      "Type": null,
                      "Default": "False"
                    }
                  }
                },
                "get_lr": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    }
                  }
                }
              }
            },
            "CosineAnnealingLR": {
              "Doc": "Set the learning rate of each parameter group using a cosine annealing\n    schedule, where :math:`\\eta_{max}` is set to the initial lr and\n    :math:`T_{cur}` is the number of epochs since the last restart in SGDR:\n\n    .. math::\n        \\begin{aligned}\n            \\eta_t & = \\eta_{min} + \\frac{1}{2}(\\eta_{max} - \\eta_{min})\\left(1\n            + \\cos\\left(\\frac{T_{cur}}{T_{max}}\\pi\\right)\\right),\n            & T_{cur} \\neq (2k+1)T_{max}; \\\\\n            \\eta_{t+1} & = \\eta_{t} + \\frac{1}{2}(\\eta_{max} - \\eta_{min})\n            \\left(1 - \\cos\\left(\\frac{1}{T_{max}}\\pi\\right)\\right),\n            & T_{cur} = (2k+1)T_{max}.\n        \\end{aligned}\n\n    When last_epoch=-1, sets initial lr as lr. Notice that because the schedule\n    is defined recursively, the learning rate can be simultaneously modified\n    outside this scheduler by other operators. If the learning rate is set\n    solely by this scheduler, the learning rate at each step becomes:\n\n    .. math::\n        \\eta_t = \\eta_{min} + \\frac{1}{2}(\\eta_{max} - \\eta_{min})\\left(1 +\n        \\cos\\left(\\frac{T_{cur}}{T_{max}}\\pi\\right)\\right)\n\n    It has been proposed in\n    `SGDR: Stochastic Gradient Descent with Warm Restarts`_. Note that this only\n    implements the cosine annealing part of SGDR, and not the restarts.\n\n    Args:\n        optimizer (Optimizer): Wrapped optimizer.\n        T_max (int): Maximum number of iterations.\n        eta_min (float): Minimum learning rate. Default: 0.\n        last_epoch (int): The index of last epoch. Default: -1.\n        verbose (bool): If ``True``, prints a message to stdout for\n            each update. Default: ``False``.\n\n    .. _SGDR\\: Stochastic Gradient Descent with Warm Restarts:\n        https://arxiv.org/abs/1608.03983\n    ",
              "Functions": {
                "__init__": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "optimizer": {
                      "Type": null,
                      "Default": null
                    },
                    "T_max": {
                      "Type": null,
                      "Default": null
                    },
                    "eta_min": {
                      "Type": null,
                      "Default": "0"
                    },
                    "last_epoch": {
                      "Type": null,
                      "Default": "-1"
                    },
                    "verbose": {
                      "Type": null,
                      "Default": "False"
                    }
                  }
                },
                "get_lr": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    }
                  }
                }
              }
            },
            "CosineAnnealingWarmRestarts": {
              "Doc": "Set the learning rate of each parameter group using a cosine annealing\n    schedule, where :math:`\\eta_{max}` is set to the initial lr, :math:`T_{cur}`\n    is the number of epochs since the last restart and :math:`T_{i}` is the number\n    of epochs between two warm restarts in SGDR:\n\n    .. math::\n        \\eta_t = \\eta_{min} + \\frac{1}{2}(\\eta_{max} - \\eta_{min})\\left(1 +\n        \\cos\\left(\\frac{T_{cur}}{T_{i}}\\pi\\right)\\right)\n\n    When :math:`T_{cur}=T_{i}`, set :math:`\\eta_t = \\eta_{min}`.\n    When :math:`T_{cur}=0` after restart, set :math:`\\eta_t=\\eta_{max}`.\n\n    It has been proposed in\n    `SGDR: Stochastic Gradient Descent with Warm Restarts`_.\n\n    Args:\n        optimizer (Optimizer): Wrapped optimizer.\n        T_0 (int): Number of iterations for the first restart.\n        T_mult (int, optional): A factor increases :math:`T_{i}` after a restart. Default: 1.\n        eta_min (float, optional): Minimum learning rate. Default: 0.\n        last_epoch (int, optional): The index of last epoch. Default: -1.\n        verbose (bool): If ``True``, prints a message to stdout for\n            each update. Default: ``False``.\n\n    .. _SGDR\\: Stochastic Gradient Descent with Warm Restarts:\n        https://arxiv.org/abs/1608.03983\n    ",
              "Functions": {
                "__init__": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "optimizer": {
                      "Type": null,
                      "Default": null
                    },
                    "T_0": {
                      "Type": null,
                      "Default": null
                    },
                    "T_mult": {
                      "Type": null,
                      "Default": "1"
                    },
                    "eta_min": {
                      "Type": null,
                      "Default": "0"
                    },
                    "last_epoch": {
                      "Type": null,
                      "Default": "-1"
                    },
                    "verbose": {
                      "Type": null,
                      "Default": "False"
                    }
                  }
                },
                "get_lr": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "step": {
                  "Doc": "Step could be called after every batch update\n\n        Example:\n            >>> # xdoctest: +SKIP(\"Undefined vars\")\n            >>> scheduler = CosineAnnealingWarmRestarts(optimizer, T_0, T_mult)\n            >>> iters = len(dataloader)\n            >>> for epoch in range(20):\n            >>>     for i, sample in enumerate(dataloader):\n            >>>         inputs, labels = sample['inputs'], sample['labels']\n            >>>         optimizer.zero_grad()\n            >>>         outputs = net(inputs)\n            >>>         loss = criterion(outputs, labels)\n            >>>         loss.backward()\n            >>>         optimizer.step()\n            >>>         scheduler.step(epoch + i / iters)\n\n        This function can be called in an interleaved way.\n\n        Example:\n            >>> # xdoctest: +SKIP(\"Undefined vars\")\n            >>> scheduler = CosineAnnealingWarmRestarts(optimizer, T_0, T_mult)\n            >>> for epoch in range(20):\n            >>>     scheduler.step()\n            >>> scheduler.step(26)\n            >>> scheduler.step() # scheduler.step(27), instead of scheduler(20)\n        ",
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "epoch": {
                      "Type": null,
                      "Default": "None"
                    }
                  }
                }
              }
            },
            "CyclicLR": {
              "Doc": "Sets the learning rate of each parameter group according to\n    cyclical learning rate policy (CLR). The policy cycles the learning\n    rate between two boundaries with a constant frequency, as detailed in\n    the paper `Cyclical Learning Rates for Training Neural Networks`_.\n    The distance between the two boundaries can be scaled on a per-iteration\n    or per-cycle basis.\n\n    Cyclical learning rate policy changes the learning rate after every batch.\n    `step` should be called after a batch has been used for training.\n\n    This class has three built-in policies, as put forth in the paper:\n\n    * \"triangular\": A basic triangular cycle without amplitude scaling.\n    * \"triangular2\": A basic triangular cycle that scales initial amplitude by half each cycle.\n    * \"exp_range\": A cycle that scales initial amplitude by :math:`\\text{gamma}^{\\text{cycle iterations}}`\n      at each cycle iteration.\n\n    This implementation was adapted from the github repo: `bckenstler/CLR`_\n\n    Args:\n        optimizer (Optimizer): Wrapped optimizer.\n        base_lr (float or list): Initial learning rate which is the\n            lower boundary in the cycle for each parameter group.\n        max_lr (float or list): Upper learning rate boundaries in the cycle\n            for each parameter group. Functionally,\n            it defines the cycle amplitude (max_lr - base_lr).\n            The lr at any cycle is the sum of base_lr\n            and some scaling of the amplitude; therefore\n            max_lr may not actually be reached depending on\n            scaling function.\n        step_size_up (int): Number of training iterations in the\n            increasing half of a cycle. Default: 2000\n        step_size_down (int): Number of training iterations in the\n            decreasing half of a cycle. If step_size_down is None,\n            it is set to step_size_up. Default: None\n        mode (str): One of {triangular, triangular2, exp_range}.\n            Values correspond to policies detailed above.\n            If scale_fn is not None, this argument is ignored.\n            Default: 'triangular'\n        gamma (float): Constant in 'exp_range' scaling function:\n            gamma**(cycle iterations)\n            Default: 1.0\n        scale_fn (function): Custom scaling policy defined by a single\n            argument lambda function, where\n            0 <= scale_fn(x) <= 1 for all x >= 0.\n            If specified, then 'mode' is ignored.\n            Default: None\n        scale_mode (str): {'cycle', 'iterations'}.\n            Defines whether scale_fn is evaluated on\n            cycle number or cycle iterations (training\n            iterations since start of cycle).\n            Default: 'cycle'\n        cycle_momentum (bool): If ``True``, momentum is cycled inversely\n            to learning rate between 'base_momentum' and 'max_momentum'.\n            Default: True\n        base_momentum (float or list): Lower momentum boundaries in the cycle\n            for each parameter group. Note that momentum is cycled inversely\n            to learning rate; at the peak of a cycle, momentum is\n            'base_momentum' and learning rate is 'max_lr'.\n            Default: 0.8\n        max_momentum (float or list): Upper momentum boundaries in the cycle\n            for each parameter group. Functionally,\n            it defines the cycle amplitude (max_momentum - base_momentum).\n            The momentum at any cycle is the difference of max_momentum\n            and some scaling of the amplitude; therefore\n            base_momentum may not actually be reached depending on\n            scaling function. Note that momentum is cycled inversely\n            to learning rate; at the start of a cycle, momentum is 'max_momentum'\n            and learning rate is 'base_lr'\n            Default: 0.9\n        last_epoch (int): The index of the last batch. This parameter is used when\n            resuming a training job. Since `step()` should be invoked after each\n            batch instead of after each epoch, this number represents the total\n            number of *batches* computed, not the total number of epochs computed.\n            When last_epoch=-1, the schedule is started from the beginning.\n            Default: -1\n        verbose (bool): If ``True``, prints a message to stdout for\n            each update. Default: ``False``.\n\n    Example:\n        >>> # xdoctest: +SKIP\n        >>> optimizer = torch.optim.SGD(model.parameters(), lr=0.1, momentum=0.9)\n        >>> scheduler = torch.optim.lr_scheduler.CyclicLR(optimizer, base_lr=0.01, max_lr=0.1)\n        >>> data_loader = torch.utils.data.DataLoader(...)\n        >>> for epoch in range(10):\n        >>>     for batch in data_loader:\n        >>>         train_batch(...)\n        >>>         scheduler.step()\n\n\n    .. _Cyclical Learning Rates for Training Neural Networks: https://arxiv.org/abs/1506.01186\n    .. _bckenstler/CLR: https://github.com/bckenstler/CLR\n    ",
              "Functions": {
                "__init__": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "optimizer": {
                      "Type": null,
                      "Default": null
                    },
                    "base_lr": {
                      "Type": null,
                      "Default": null
                    },
                    "max_lr": {
                      "Type": null,
                      "Default": null
                    },
                    "step_size_up": {
                      "Type": null,
                      "Default": "2000"
                    },
                    "step_size_down": {
                      "Type": null,
                      "Default": "None"
                    },
                    "mode": {
                      "Type": null,
                      "Default": "triangular"
                    },
                    "gamma": {
                      "Type": null,
                      "Default": "1.0"
                    },
                    "scale_fn": {
                      "Type": null,
                      "Default": "None"
                    },
                    "scale_mode": {
                      "Type": null,
                      "Default": "cycle"
                    },
                    "cycle_momentum": {
                      "Type": null,
                      "Default": "True"
                    },
                    "base_momentum": {
                      "Type": null,
                      "Default": "0.8"
                    },
                    "max_momentum": {
                      "Type": null,
                      "Default": "0.9"
                    },
                    "last_epoch": {
                      "Type": null,
                      "Default": "-1"
                    },
                    "verbose": {
                      "Type": null,
                      "Default": "False"
                    }
                  }
                },
                "get_lr": {
                  "Doc": "Calculates the learning rate at batch index. This function treats\n        `self.last_epoch` as the last batch index.\n\n        If `self.cycle_momentum` is ``True``, this function has a side effect of\n        updating the optimizer's momentum.\n        ",
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "scale_fn": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "x": {
                      "Type": null,
                      "Default": null
                    }
                  }
                }
              }
            },
            "ExponentialLR": {
              "Doc": "Decays the learning rate of each parameter group by gamma every epoch.\n    When last_epoch=-1, sets initial lr as lr.\n\n    Args:\n        optimizer (Optimizer): Wrapped optimizer.\n        gamma (float): Multiplicative factor of learning rate decay.\n        last_epoch (int): The index of last epoch. Default: -1.\n        verbose (bool): If ``True``, prints a message to stdout for\n            each update. Default: ``False``.\n    ",
              "Functions": {
                "__init__": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "optimizer": {
                      "Type": null,
                      "Default": null
                    },
                    "gamma": {
                      "Type": null,
                      "Default": null
                    },
                    "last_epoch": {
                      "Type": null,
                      "Default": "-1"
                    },
                    "verbose": {
                      "Type": null,
                      "Default": "False"
                    }
                  }
                },
                "get_lr": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    }
                  }
                }
              }
            },
            "LambdaLR": {
              "Doc": "Sets the learning rate of each parameter group to the initial lr\n    times a given function. When last_epoch=-1, sets initial lr as lr.\n\n    Args:\n        optimizer (Optimizer): Wrapped optimizer.\n        lr_lambda (function or list): A function which computes a multiplicative\n            factor given an integer parameter epoch, or a list of such\n            functions, one for each group in optimizer.param_groups.\n        last_epoch (int): The index of last epoch. Default: -1.\n        verbose (bool): If ``True``, prints a message to stdout for\n            each update. Default: ``False``.\n\n    Example:\n        >>> # Assuming optimizer has two groups.\n        >>> lambda1 = lambda epoch: epoch // 30\n        >>> lambda2 = lambda epoch: 0.95 ** epoch\n        >>> # xdoctest: +SKIP\n        >>> scheduler = LambdaLR(optimizer, lr_lambda=[lambda1, lambda2])\n        >>> for epoch in range(100):\n        >>>     train(...)\n        >>>     validate(...)\n        >>>     scheduler.step()\n    ",
              "Functions": {
                "__init__": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "optimizer": {
                      "Type": null,
                      "Default": null
                    },
                    "lr_lambda": {
                      "Type": null,
                      "Default": null
                    },
                    "last_epoch": {
                      "Type": null,
                      "Default": "-1"
                    },
                    "verbose": {
                      "Type": null,
                      "Default": "False"
                    }
                  }
                },
                "get_lr": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "load_state_dict": {
                  "Doc": "Loads the schedulers state.\n\n        When saving or loading the scheduler, please make sure to also save or load the state of the optimizer.\n\n        Args:\n            state_dict (dict): scheduler state. Should be an object returned\n                from a call to :meth:`state_dict`.\n        ",
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "state_dict": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "state_dict": {
                  "Doc": "Returns the state of the scheduler as a :class:`dict`.\n\n        It contains an entry for every variable in self.__dict__ which\n        is not the optimizer.\n        The learning rate lambda functions will only be saved if they are callable objects\n        and not if they are functions or lambdas.\n\n        When saving or loading the scheduler, please make sure to also save or load the state of the optimizer.\n        ",
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    }
                  }
                }
              }
            },
            "LinearLR": {
              "Doc": "Decays the learning rate of each parameter group by linearly changing small\n    multiplicative factor until the number of epoch reaches a pre-defined milestone: total_iters.\n    Notice that such decay can happen simultaneously with other changes to the learning rate\n    from outside this scheduler. When last_epoch=-1, sets initial lr as lr.\n\n    Args:\n        optimizer (Optimizer): Wrapped optimizer.\n        start_factor (float): The number we multiply learning rate in the first epoch.\n            The multiplication factor changes towards end_factor in the following epochs.\n            Default: 1./3.\n        end_factor (float): The number we multiply learning rate at the end of linear changing\n            process. Default: 1.0.\n        total_iters (int): The number of iterations that multiplicative factor reaches to 1.\n            Default: 5.\n        last_epoch (int): The index of the last epoch. Default: -1.\n        verbose (bool): If ``True``, prints a message to stdout for\n            each update. Default: ``False``.\n\n    Example:\n        >>> # Assuming optimizer uses lr = 0.05 for all groups\n        >>> # lr = 0.025    if epoch == 0\n        >>> # lr = 0.03125  if epoch == 1\n        >>> # lr = 0.0375   if epoch == 2\n        >>> # lr = 0.04375  if epoch == 3\n        >>> # lr = 0.05    if epoch >= 4\n        >>> # xdoctest: +SKIP\n        >>> scheduler = LinearLR(self.opt, start_factor=0.5, total_iters=4)\n        >>> for epoch in range(100):\n        >>>     train(...)\n        >>>     validate(...)\n        >>>     scheduler.step()\n    ",
              "Functions": {
                "__init__": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "optimizer": {
                      "Type": null,
                      "Default": null
                    },
                    "start_factor": {
                      "Type": null,
                      "Default": "0.3333333333333333"
                    },
                    "end_factor": {
                      "Type": null,
                      "Default": "1.0"
                    },
                    "total_iters": {
                      "Type": null,
                      "Default": "5"
                    },
                    "last_epoch": {
                      "Type": null,
                      "Default": "-1"
                    },
                    "verbose": {
                      "Type": null,
                      "Default": "False"
                    }
                  }
                },
                "get_lr": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    }
                  }
                }
              }
            },
            "MultiStepLR": {
              "Doc": "Decays the learning rate of each parameter group by gamma once the\n    number of epoch reaches one of the milestones. Notice that such decay can\n    happen simultaneously with other changes to the learning rate from outside\n    this scheduler. When last_epoch=-1, sets initial lr as lr.\n\n    Args:\n        optimizer (Optimizer): Wrapped optimizer.\n        milestones (list): List of epoch indices. Must be increasing.\n        gamma (float): Multiplicative factor of learning rate decay.\n            Default: 0.1.\n        last_epoch (int): The index of last epoch. Default: -1.\n        verbose (bool): If ``True``, prints a message to stdout for\n            each update. Default: ``False``.\n\n    Example:\n        >>> # Assuming optimizer uses lr = 0.05 for all groups\n        >>> # lr = 0.05     if epoch < 30\n        >>> # lr = 0.005    if 30 <= epoch < 80\n        >>> # lr = 0.0005   if epoch >= 80\n        >>> # xdoctest: +SKIP\n        >>> scheduler = MultiStepLR(optimizer, milestones=[30,80], gamma=0.1)\n        >>> for epoch in range(100):\n        >>>     train(...)\n        >>>     validate(...)\n        >>>     scheduler.step()\n    ",
              "Functions": {
                "__init__": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "optimizer": {
                      "Type": null,
                      "Default": null
                    },
                    "milestones": {
                      "Type": null,
                      "Default": null
                    },
                    "gamma": {
                      "Type": null,
                      "Default": "0.1"
                    },
                    "last_epoch": {
                      "Type": null,
                      "Default": "-1"
                    },
                    "verbose": {
                      "Type": null,
                      "Default": "False"
                    }
                  }
                },
                "get_lr": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    }
                  }
                }
              }
            },
            "MultiplicativeLR": {
              "Doc": "Multiply the learning rate of each parameter group by the factor given\n    in the specified function. When last_epoch=-1, sets initial lr as lr.\n\n    Args:\n        optimizer (Optimizer): Wrapped optimizer.\n        lr_lambda (function or list): A function which computes a multiplicative\n            factor given an integer parameter epoch, or a list of such\n            functions, one for each group in optimizer.param_groups.\n        last_epoch (int): The index of last epoch. Default: -1.\n        verbose (bool): If ``True``, prints a message to stdout for\n            each update. Default: ``False``.\n\n    Example:\n        >>> lmbda = lambda epoch: 0.95\n        >>> # xdoctest: +SKIP\n        >>> scheduler = MultiplicativeLR(optimizer, lr_lambda=lmbda)\n        >>> for epoch in range(100):\n        >>>     train(...)\n        >>>     validate(...)\n        >>>     scheduler.step()\n    ",
              "Functions": {
                "__init__": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "optimizer": {
                      "Type": null,
                      "Default": null
                    },
                    "lr_lambda": {
                      "Type": null,
                      "Default": null
                    },
                    "last_epoch": {
                      "Type": null,
                      "Default": "-1"
                    },
                    "verbose": {
                      "Type": null,
                      "Default": "False"
                    }
                  }
                },
                "get_lr": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "load_state_dict": {
                  "Doc": "Loads the schedulers state.\n\n        Args:\n            state_dict (dict): scheduler state. Should be an object returned\n                from a call to :meth:`state_dict`.\n        ",
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "state_dict": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "state_dict": {
                  "Doc": "Returns the state of the scheduler as a :class:`dict`.\n\n        It contains an entry for every variable in self.__dict__ which\n        is not the optimizer.\n        The learning rate lambda functions will only be saved if they are callable objects\n        and not if they are functions or lambdas.\n        ",
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    }
                  }
                }
              }
            },
            "OneCycleLR": {
              "Doc": "Sets the learning rate of each parameter group according to the\n    1cycle learning rate policy. The 1cycle policy anneals the learning\n    rate from an initial learning rate to some maximum learning rate and then\n    from that maximum learning rate to some minimum learning rate much lower\n    than the initial learning rate.\n    This policy was initially described in the paper `Super-Convergence:\n    Very Fast Training of Neural Networks Using Large Learning Rates`_.\n\n    The 1cycle learning rate policy changes the learning rate after every batch.\n    `step` should be called after a batch has been used for training.\n\n    This scheduler is not chainable.\n\n    Note also that the total number of steps in the cycle can be determined in one\n    of two ways (listed in order of precedence):\n\n    #. A value for total_steps is explicitly provided.\n    #. A number of epochs (epochs) and a number of steps per epoch\n       (steps_per_epoch) are provided.\n       In this case, the number of total steps is inferred by\n       total_steps = epochs * steps_per_epoch\n\n    You must either provide a value for total_steps or provide a value for both\n    epochs and steps_per_epoch.\n\n    The default behaviour of this scheduler follows the fastai implementation of 1cycle, which\n    claims that \"unpublished work has shown even better results by using only two phases\". To\n    mimic the behaviour of the original paper instead, set ``three_phase=True``.\n\n    Args:\n        optimizer (Optimizer): Wrapped optimizer.\n        max_lr (float or list): Upper learning rate boundaries in the cycle\n            for each parameter group.\n        total_steps (int): The total number of steps in the cycle. Note that\n            if a value is not provided here, then it must be inferred by providing\n            a value for epochs and steps_per_epoch.\n            Default: None\n        epochs (int): The number of epochs to train for. This is used along\n            with steps_per_epoch in order to infer the total number of steps in the cycle\n            if a value for total_steps is not provided.\n            Default: None\n        steps_per_epoch (int): The number of steps per epoch to train for. This is\n            used along with epochs in order to infer the total number of steps in the\n            cycle if a value for total_steps is not provided.\n            Default: None\n        pct_start (float): The percentage of the cycle (in number of steps) spent\n            increasing the learning rate.\n            Default: 0.3\n        anneal_strategy (str): {'cos', 'linear'}\n            Specifies the annealing strategy: \"cos\" for cosine annealing, \"linear\" for\n            linear annealing.\n            Default: 'cos'\n        cycle_momentum (bool): If ``True``, momentum is cycled inversely\n            to learning rate between 'base_momentum' and 'max_momentum'.\n            Default: True\n        base_momentum (float or list): Lower momentum boundaries in the cycle\n            for each parameter group. Note that momentum is cycled inversely\n            to learning rate; at the peak of a cycle, momentum is\n            'base_momentum' and learning rate is 'max_lr'.\n            Default: 0.85\n        max_momentum (float or list): Upper momentum boundaries in the cycle\n            for each parameter group. Functionally,\n            it defines the cycle amplitude (max_momentum - base_momentum).\n            Note that momentum is cycled inversely\n            to learning rate; at the start of a cycle, momentum is 'max_momentum'\n            and learning rate is 'base_lr'\n            Default: 0.95\n        div_factor (float): Determines the initial learning rate via\n            initial_lr = max_lr/div_factor\n            Default: 25\n        final_div_factor (float): Determines the minimum learning rate via\n            min_lr = initial_lr/final_div_factor\n            Default: 1e4\n        three_phase (bool): If ``True``, use a third phase of the schedule to annihilate the\n            learning rate according to 'final_div_factor' instead of modifying the second\n            phase (the first two phases will be symmetrical about the step indicated by\n            'pct_start').\n        last_epoch (int): The index of the last batch. This parameter is used when\n            resuming a training job. Since `step()` should be invoked after each\n            batch instead of after each epoch, this number represents the total\n            number of *batches* computed, not the total number of epochs computed.\n            When last_epoch=-1, the schedule is started from the beginning.\n            Default: -1\n        verbose (bool): If ``True``, prints a message to stdout for\n            each update. Default: ``False``.\n\n    Example:\n        >>> data_loader = torch.utils.data.DataLoader(...)\n        >>> # xdoctest: +SKIP\n        >>> optimizer = torch.optim.SGD(model.parameters(), lr=0.1, momentum=0.9)\n        >>> scheduler = torch.optim.lr_scheduler.OneCycleLR(optimizer, max_lr=0.01, steps_per_epoch=len(data_loader), epochs=10)\n        >>> for epoch in range(10):\n        >>>     for batch in data_loader:\n        >>>         train_batch(...)\n        >>>         scheduler.step()\n\n\n    .. _Super-Convergence\\: Very Fast Training of Neural Networks Using Large Learning Rates:\n        https://arxiv.org/abs/1708.07120\n    ",
              "Functions": {
                "__init__": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "optimizer": {
                      "Type": null,
                      "Default": null
                    },
                    "max_lr": {
                      "Type": null,
                      "Default": null
                    },
                    "total_steps": {
                      "Type": null,
                      "Default": "None"
                    },
                    "epochs": {
                      "Type": null,
                      "Default": "None"
                    },
                    "steps_per_epoch": {
                      "Type": null,
                      "Default": "None"
                    },
                    "pct_start": {
                      "Type": null,
                      "Default": "0.3"
                    },
                    "anneal_strategy": {
                      "Type": null,
                      "Default": "cos"
                    },
                    "cycle_momentum": {
                      "Type": null,
                      "Default": "True"
                    },
                    "base_momentum": {
                      "Type": null,
                      "Default": "0.85"
                    },
                    "max_momentum": {
                      "Type": null,
                      "Default": "0.95"
                    },
                    "div_factor": {
                      "Type": null,
                      "Default": "25.0"
                    },
                    "final_div_factor": {
                      "Type": null,
                      "Default": "10000.0"
                    },
                    "three_phase": {
                      "Type": null,
                      "Default": "False"
                    },
                    "last_epoch": {
                      "Type": null,
                      "Default": "-1"
                    },
                    "verbose": {
                      "Type": null,
                      "Default": "False"
                    }
                  }
                },
                "get_lr": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    }
                  }
                }
              }
            },
            "PolynomialLR": {
              "Doc": "Decays the learning rate of each parameter group using a polynomial function\n    in the given total_iters. When last_epoch=-1, sets initial lr as lr.\n\n    Args:\n        optimizer (Optimizer): Wrapped optimizer.\n        total_iters (int): The number of steps that the scheduler decays the learning rate. Default: 5.\n        power (int): The power of the polynomial. Default: 1.0.\n        verbose (bool): If ``True``, prints a message to stdout for\n            each update. Default: ``False``.\n\n    Example:\n        >>> # Assuming optimizer uses lr = 0.001 for all groups\n        >>> # lr = 0.001     if epoch == 0\n        >>> # lr = 0.00075   if epoch == 1\n        >>> # lr = 0.00050   if epoch == 2\n        >>> # lr = 0.00025   if epoch == 3\n        >>> # lr = 0.0       if epoch >= 4\n        >>> # xdoctest: +SKIP(\"undefined vars\")\n        >>> scheduler = PolynomialLR(self.opt, total_iters=4, power=1.0)\n        >>> for epoch in range(100):\n        >>>     train(...)\n        >>>     validate(...)\n        >>>     scheduler.step()\n    ",
              "Functions": {
                "__init__": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "optimizer": {
                      "Type": null,
                      "Default": null
                    },
                    "total_iters": {
                      "Type": null,
                      "Default": "5"
                    },
                    "power": {
                      "Type": null,
                      "Default": "1.0"
                    },
                    "last_epoch": {
                      "Type": null,
                      "Default": "-1"
                    },
                    "verbose": {
                      "Type": null,
                      "Default": "False"
                    }
                  }
                },
                "get_lr": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    }
                  }
                }
              }
            },
            "ReduceLROnPlateau": {
              "Doc": "Reduce learning rate when a metric has stopped improving.\n    Models often benefit from reducing the learning rate by a factor\n    of 2-10 once learning stagnates. This scheduler reads a metrics\n    quantity and if no improvement is seen for a 'patience' number\n    of epochs, the learning rate is reduced.\n\n    Args:\n        optimizer (Optimizer): Wrapped optimizer.\n        mode (str): One of `min`, `max`. In `min` mode, lr will\n            be reduced when the quantity monitored has stopped\n            decreasing; in `max` mode it will be reduced when the\n            quantity monitored has stopped increasing. Default: 'min'.\n        factor (float): Factor by which the learning rate will be\n            reduced. new_lr = lr * factor. Default: 0.1.\n        patience (int): Number of epochs with no improvement after\n            which learning rate will be reduced. For example, if\n            `patience = 2`, then we will ignore the first 2 epochs\n            with no improvement, and will only decrease the LR after the\n            3rd epoch if the loss still hasn't improved then.\n            Default: 10.\n        threshold (float): Threshold for measuring the new optimum,\n            to only focus on significant changes. Default: 1e-4.\n        threshold_mode (str): One of `rel`, `abs`. In `rel` mode,\n            dynamic_threshold = best * ( 1 + threshold ) in 'max'\n            mode or best * ( 1 - threshold ) in `min` mode.\n            In `abs` mode, dynamic_threshold = best + threshold in\n            `max` mode or best - threshold in `min` mode. Default: 'rel'.\n        cooldown (int): Number of epochs to wait before resuming\n            normal operation after lr has been reduced. Default: 0.\n        min_lr (float or list): A scalar or a list of scalars. A\n            lower bound on the learning rate of all param groups\n            or each group respectively. Default: 0.\n        eps (float): Minimal decay applied to lr. If the difference\n            between new and old lr is smaller than eps, the update is\n            ignored. Default: 1e-8.\n        verbose (bool): If ``True``, prints a message to stdout for\n            each update. Default: ``False``.\n\n    Example:\n        >>> # xdoctest: +SKIP\n        >>> optimizer = torch.optim.SGD(model.parameters(), lr=0.1, momentum=0.9)\n        >>> scheduler = ReduceLROnPlateau(optimizer, 'min')\n        >>> for epoch in range(10):\n        >>>     train(...)\n        >>>     val_loss = validate(...)\n        >>>     # Note that step should be called after validate()\n        >>>     scheduler.step(val_loss)\n    ",
              "Functions": {
                "__init__": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "optimizer": {
                      "Type": null,
                      "Default": null
                    },
                    "mode": {
                      "Type": null,
                      "Default": "min"
                    },
                    "factor": {
                      "Type": null,
                      "Default": "0.1"
                    },
                    "patience": {
                      "Type": null,
                      "Default": "10"
                    },
                    "threshold": {
                      "Type": null,
                      "Default": "0.0001"
                    },
                    "threshold_mode": {
                      "Type": null,
                      "Default": "rel"
                    },
                    "cooldown": {
                      "Type": null,
                      "Default": "0"
                    },
                    "min_lr": {
                      "Type": null,
                      "Default": "0"
                    },
                    "eps": {
                      "Type": null,
                      "Default": "1e-08"
                    },
                    "verbose": {
                      "Type": null,
                      "Default": "False"
                    }
                  }
                },
                "is_better": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "a": {
                      "Type": null,
                      "Default": null
                    },
                    "best": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "load_state_dict": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "state_dict": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "state_dict": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "step": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "metrics": {
                      "Type": null,
                      "Default": null
                    },
                    "epoch": {
                      "Type": null,
                      "Default": "None"
                    }
                  }
                }
              }
            },
            "SequentialLR": {
              "Doc": "Receives the list of schedulers that is expected to be called sequentially during\n    optimization process and milestone points that provides exact intervals to reflect\n    which scheduler is supposed to be called at a given epoch.\n\n    Args:\n        optimizer (Optimizer): Wrapped optimizer.\n        schedulers (list): List of chained schedulers.\n        milestones (list): List of integers that reflects milestone points.\n        last_epoch (int): The index of last epoch. Default: -1.\n        verbose (bool): Does nothing.\n\n    Example:\n        >>> # Assuming optimizer uses lr = 1. for all groups\n        >>> # lr = 0.1     if epoch == 0\n        >>> # lr = 0.1     if epoch == 1\n        >>> # lr = 0.9     if epoch == 2\n        >>> # lr = 0.81    if epoch == 3\n        >>> # lr = 0.729   if epoch == 4\n        >>> # xdoctest: +SKIP\n        >>> scheduler1 = ConstantLR(self.opt, factor=0.1, total_iters=2)\n        >>> scheduler2 = ExponentialLR(self.opt, gamma=0.9)\n        >>> scheduler = SequentialLR(self.opt, schedulers=[scheduler1, scheduler2], milestones=[2])\n        >>> for epoch in range(100):\n        >>>     train(...)\n        >>>     validate(...)\n        >>>     scheduler.step()\n    ",
              "Functions": {
                "__init__": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "optimizer": {
                      "Type": null,
                      "Default": null
                    },
                    "schedulers": {
                      "Type": null,
                      "Default": null
                    },
                    "milestones": {
                      "Type": null,
                      "Default": null
                    },
                    "last_epoch": {
                      "Type": null,
                      "Default": "-1"
                    },
                    "verbose": {
                      "Type": null,
                      "Default": "False"
                    }
                  }
                },
                "load_state_dict": {
                  "Doc": "Loads the schedulers state.\n\n        Args:\n            state_dict (dict): scheduler state. Should be an object returned\n                from a call to :meth:`state_dict`.\n        ",
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "state_dict": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "state_dict": {
                  "Doc": "Returns the state of the scheduler as a :class:`dict`.\n\n        It contains an entry for every variable in self.__dict__ which\n        is not the optimizer.\n        The wrapped scheduler states will also be saved.\n        ",
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "step": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    }
                  }
                }
              }
            },
            "StepLR": {
              "Doc": "Decays the learning rate of each parameter group by gamma every\n    step_size epochs. Notice that such decay can happen simultaneously with\n    other changes to the learning rate from outside this scheduler. When\n    last_epoch=-1, sets initial lr as lr.\n\n    Args:\n        optimizer (Optimizer): Wrapped optimizer.\n        step_size (int): Period of learning rate decay.\n        gamma (float): Multiplicative factor of learning rate decay.\n            Default: 0.1.\n        last_epoch (int): The index of last epoch. Default: -1.\n        verbose (bool): If ``True``, prints a message to stdout for\n            each update. Default: ``False``.\n\n    Example:\n        >>> # Assuming optimizer uses lr = 0.05 for all groups\n        >>> # lr = 0.05     if epoch < 30\n        >>> # lr = 0.005    if 30 <= epoch < 60\n        >>> # lr = 0.0005   if 60 <= epoch < 90\n        >>> # ...\n        >>> # xdoctest: +SKIP\n        >>> scheduler = StepLR(optimizer, step_size=30, gamma=0.1)\n        >>> for epoch in range(100):\n        >>>     train(...)\n        >>>     validate(...)\n        >>>     scheduler.step()\n    ",
              "Functions": {
                "__init__": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "optimizer": {
                      "Type": null,
                      "Default": null
                    },
                    "step_size": {
                      "Type": null,
                      "Default": null
                    },
                    "gamma": {
                      "Type": null,
                      "Default": "0.1"
                    },
                    "last_epoch": {
                      "Type": null,
                      "Default": "-1"
                    },
                    "verbose": {
                      "Type": null,
                      "Default": "False"
                    }
                  }
                },
                "get_lr": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    }
                  }
                }
              }
            }
          },
          "Functions": {
            "bisect_right": {
              "Doc": "Return the index where to insert item x in list a, assuming a is sorted.\n\nThe return value i is such that all e in a[:i] have e <= x, and all e in\na[i:] have e > x.  So if x already appears in the list, i points just\nbeyond the rightmost x already there\n\nOptional args lo (default 0) and hi (default len(a)) bound the\nslice of a to be searched.",
              "Args": {
                "default 0) and hi (default len(a)": {
                  "Type": null,
                  "Default": null
                }
              }
            },
            "wraps": {
              "Doc": "Decorator factory to apply update_wrapper() to a wrapper function\n\n       Returns a decorator that invokes update_wrapper() with the decorated\n       function as the wrapper argument and the arguments to wraps() as the\n       remaining arguments. Default arguments are as for update_wrapper().\n       This is a convenience function to simplify applying partial() to\n       update_wrapper().\n    ",
              "Args": {
                "wrapped": {
                  "Type": null,
                  "Default": null
                },
                "assigned": {
                  "Type": null,
                  "Default": "('__module__', '__name__', '__qualname__', '__doc__', '__annotations__')"
                },
                "updated": {
                  "Type": null,
                  "Default": "('__dict__',)"
                }
              }
            }
          }
        },
        "swa_utils": {
          "Doc": null,
          "Classes": {
            "AveragedModel": {
              "Doc": "Implements averaged model for Stochastic Weight Averaging (SWA).\n\n    Stochastic Weight Averaging was proposed in `Averaging Weights Leads to\n    Wider Optima and Better Generalization`_ by Pavel Izmailov, Dmitrii\n    Podoprikhin, Timur Garipov, Dmitry Vetrov and Andrew Gordon Wilson\n    (UAI 2018).\n\n    AveragedModel class creates a copy of the provided module :attr:`model`\n    on the device :attr:`device` and allows to compute running averages of the\n    parameters of the :attr:`model`.\n\n    Args:\n        model (torch.nn.Module): model to use with SWA\n        device (torch.device, optional): if provided, the averaged model will be\n            stored on the :attr:`device`\n        avg_fn (function, optional): the averaging function used to update\n            parameters; the function must take in the current value of the\n            :class:`AveragedModel` parameter, the current value of :attr:`model`\n            parameter and the number of models already averaged; if None,\n            equally weighted average is used (default: None)\n        use_buffers (bool): if ``True``, it will compute running averages for\n            both the parameters and the buffers of the model. (default: ``False``)\n\n    Example:\n        >>> # xdoctest: +SKIP(\"undefined variables\")\n        >>> loader, optimizer, model, loss_fn = ...\n        >>> swa_model = torch.optim.swa_utils.AveragedModel(model)\n        >>> scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(optimizer,\n        >>>                                     T_max=300)\n        >>> swa_start = 160\n        >>> swa_scheduler = SWALR(optimizer, swa_lr=0.05)\n        >>> for i in range(300):\n        >>>      for input, target in loader:\n        >>>          optimizer.zero_grad()\n        >>>          loss_fn(model(input), target).backward()\n        >>>          optimizer.step()\n        >>>      if i > swa_start:\n        >>>          swa_model.update_parameters(model)\n        >>>          swa_scheduler.step()\n        >>>      else:\n        >>>          scheduler.step()\n        >>>\n        >>> # Update bn statistics for the swa_model at the end\n        >>> torch.optim.swa_utils.update_bn(loader, swa_model)\n\n    You can also use custom averaging functions with `avg_fn` parameter.\n    If no averaging function is provided, the default is to compute\n    equally-weighted average of the weights.\n\n    Example:\n        >>> # xdoctest: +SKIP(\"undefined variables\")\n        >>> # Compute exponential moving averages of the weights and buffers\n        >>> ema_avg = lambda averaged_model_parameter, model_parameter, num_averaged: (\n        ...                 0.1 * averaged_model_parameter + 0.9 * model_parameter)\n        >>> swa_model = torch.optim.swa_utils.AveragedModel(model, avg_fn=ema_avg, use_buffers=True)\n\n    .. note::\n        When using SWA with models containing Batch Normalization you may\n        need to update the activation statistics for Batch Normalization.\n        This can be done either by using the :meth:`torch.optim.swa_utils.update_bn`\n        or by setting :attr:`use_buffers` to `True`. The first approach updates the\n        statistics in a post-training step by passing data through the model. The\n        second does it during the parameter update phase by averaging all buffers.\n        Empirical evidence has shown that updating the statistics in normalization\n        layers increases accuracy, but you may wish to empirically test which\n        approach yields the best results in your problem.\n\n    .. note::\n        :attr:`avg_fn` is not saved in the :meth:`state_dict` of the model.\n\n    .. note::\n        When :meth:`update_parameters` is called for the first time (i.e.\n        :attr:`n_averaged` is `0`) the parameters of `model` are copied\n        to the parameters of :class:`AveragedModel`. For every subsequent\n        call of :meth:`update_parameters` the function `avg_fn` is used\n        to update the parameters.\n\n    .. _Averaging Weights Leads to Wider Optima and Better Generalization:\n        https://arxiv.org/abs/1803.05407\n    .. _There Are Many Consistent Explanations of Unlabeled Data: Why You Should\n        Average:\n        https://arxiv.org/abs/1806.05594\n    .. _SWALP: Stochastic Weight Averaging in Low-Precision Training:\n        https://arxiv.org/abs/1904.11943\n    .. _Stochastic Weight Averaging in Parallel: Large-Batch Training That\n        Generalizes Well:\n        https://arxiv.org/abs/2001.02312\n    ",
              "Functions": {
                "__init__": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "model": {
                      "Type": null,
                      "Default": null
                    },
                    "device": {
                      "Type": null,
                      "Default": "None"
                    },
                    "avg_fn": {
                      "Type": null,
                      "Default": "None"
                    },
                    "use_buffers": {
                      "Type": null,
                      "Default": "False"
                    }
                  }
                },
                "forward": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "*args": {
                      "Type": null,
                      "Default": null
                    },
                    "**kwargs": {
                      "Type": null,
                      "Default": null
                    }
                  }
                },
                "update_parameters": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "model": {
                      "Type": null,
                      "Default": null
                    }
                  }
                }
              }
            },
            "SWALR": {
              "Doc": "Anneals the learning rate in each parameter group to a fixed value.\n\n    This learning rate scheduler is meant to be used with Stochastic Weight\n    Averaging (SWA) method (see `torch.optim.swa_utils.AveragedModel`).\n\n    Args:\n        optimizer (torch.optim.Optimizer): wrapped optimizer\n        swa_lrs (float or list): the learning rate value for all param groups\n            together or separately for each group.\n        annealing_epochs (int): number of epochs in the annealing phase\n            (default: 10)\n        annealing_strategy (str): \"cos\" or \"linear\"; specifies the annealing\n            strategy: \"cos\" for cosine annealing, \"linear\" for linear annealing\n            (default: \"cos\")\n        last_epoch (int): the index of the last epoch (default: -1)\n\n    The :class:`SWALR` scheduler can be used together with other\n    schedulers to switch to a constant learning rate late in the training\n    as in the example below.\n\n    Example:\n        >>> # xdoctest: +SKIP(\"Undefined variables\")\n        >>> loader, optimizer, model = ...\n        >>> lr_lambda = lambda epoch: 0.9\n        >>> scheduler = torch.optim.lr_scheduler.MultiplicativeLR(optimizer,\n        >>>        lr_lambda=lr_lambda)\n        >>> swa_scheduler = torch.optim.swa_utils.SWALR(optimizer,\n        >>>        anneal_strategy=\"linear\", anneal_epochs=20, swa_lr=0.05)\n        >>> swa_start = 160\n        >>> for i in range(300):\n        >>>      for input, target in loader:\n        >>>          optimizer.zero_grad()\n        >>>          loss_fn(model(input), target).backward()\n        >>>          optimizer.step()\n        >>>      if i > swa_start:\n        >>>          swa_scheduler.step()\n        >>>      else:\n        >>>          scheduler.step()\n\n    .. _Averaging Weights Leads to Wider Optima and Better Generalization:\n        https://arxiv.org/abs/1803.05407\n    ",
              "Functions": {
                "__init__": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    },
                    "optimizer": {
                      "Type": null,
                      "Default": null
                    },
                    "swa_lr": {
                      "Type": null,
                      "Default": null
                    },
                    "anneal_epochs": {
                      "Type": null,
                      "Default": "10"
                    },
                    "anneal_strategy": {
                      "Type": null,
                      "Default": "cos"
                    },
                    "last_epoch": {
                      "Type": null,
                      "Default": "-1"
                    }
                  }
                },
                "get_lr": {
                  "Doc": null,
                  "Args": {
                    "self": {
                      "Type": null,
                      "Default": null
                    }
                  }
                }
              }
            }
          },
          "Functions": {
            "deepcopy": {
              "Doc": "Deep copy operation on arbitrary Python objects.\n\n    See the module's __doc__ string for more info.\n    ",
              "Args": {
                "x": {
                  "Type": null,
                  "Default": null
                },
                "memo": {
                  "Type": null,
                  "Default": "None"
                },
                "_nil": {
                  "Type": null,
                  "Default": "[]"
                }
              }
            },
            "update_bn": {
              "Doc": "Updates BatchNorm running_mean, running_var buffers in the model.\n\n    It performs one pass over data in `loader` to estimate the activation\n    statistics for BatchNorm layers in the model.\n    Args:\n        loader (torch.utils.data.DataLoader): dataset loader to compute the\n            activation statistics on. Each data batch should be either a\n            tensor, or a list/tuple whose first element is a tensor\n            containing data.\n        model (torch.nn.Module): model for which we seek to update BatchNorm\n            statistics.\n        device (torch.device, optional): If set, data will be transferred to\n            :attr:`device` before being passed into :attr:`model`.\n\n    Example:\n        >>> # xdoctest: +SKIP(\"Undefined variables\")\n        >>> loader, model = ...\n        >>> torch.optim.swa_utils.update_bn(loader, model)\n\n    .. note::\n        The `update_bn` utility assumes that each data batch in :attr:`loader`\n        is either a tensor or a list or tuple of tensors; in the latter case it\n        is assumed that :meth:`model.forward()` should be called on the first\n        element of the list or tuple corresponding to the data batch.\n    ",
              "Args": {
                "*args": {
                  "Type": null,
                  "Default": null
                },
                "**kwargs": {
                  "Type": null,
                  "Default": null
                }
              }
            }
          }
        }
      }
    },
    "random": {
      "Doc": null,
      "Functions": {
        "fork_rng": {
          "Doc": "\n    Forks the RNG, so that when you return, the RNG is reset\n    to the state that it was previously in.\n\n    Args:\n        devices (iterable of CUDA IDs): CUDA devices for which to fork\n            the RNG.  CPU RNG state is always forked.  By default, :meth:`fork_rng` operates\n            on all devices, but will emit a warning if your machine has a lot\n            of devices, since this function will run very slowly in that case.\n            If you explicitly specify devices, this warning will be suppressed\n        enabled (bool): if ``False``, the RNG is not forked.  This is a convenience\n            argument for easily disabling the context manager without having\n            to delete it and unindent your Python code under it.\n    ",
          "Args": {
            "*args": {
              "Type": null,
              "Default": null
            },
            "**kwds": {
              "Type": null,
              "Default": null
            }
          }
        },
        "get_rng_state": {
          "Doc": "Returns the random number generator state as a `torch.ByteTensor`.",
          "Args": {}
        },
        "initial_seed": {
          "Doc": "Returns the initial seed for generating random numbers as a\n    Python `long`.\n    ",
          "Args": {}
        },
        "manual_seed": {
          "Doc": "Sets the seed for generating random numbers. Returns a\n    `torch.Generator` object.\n\n    Args:\n        seed (int): The desired seed. Value must be within the inclusive range\n            `[-0x8000_0000_0000_0000, 0xffff_ffff_ffff_ffff]`. Otherwise, a RuntimeError\n            is raised. Negative inputs are remapped to positive values with the formula\n            `0xffff_ffff_ffff_ffff + seed`.\n    ",
          "Args": {
            "seed": {
              "Type": null,
              "Default": null
            }
          }
        },
        "seed": {
          "Doc": "Sets the seed for generating random numbers to a non-deterministic\n    random number. Returns a 64 bit number used to seed the RNG.\n    ",
          "Args": {}
        },
        "set_rng_state": {
          "Doc": "Sets the random number generator state.\n\n    .. note: This function only works for CPU. For CUDA, please use\n             torch.manual_seed(seed), which works for both CPU and CUDA.\n\n    Args:\n        new_state (torch.ByteTensor): The desired state\n    ",
          "Args": {
            "new_state": {
              "Type": "<class 'torch.Tensor'>",
              "Default": null
            }
          }
        }
      }
    }
  }
}